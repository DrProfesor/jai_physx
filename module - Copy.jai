//
// This file was auto-generated using the following command:
//
// jai build.jai
//



NDEBUG :: 1;
_ALLOW_COMPILER_AND_STL_VERSION_MISMATCH :: 1;
PX_VC :: 15;

PX_CLANG :: 1;

PX_WIN64 :: 1;

PX_X64 :: 1;

PX_SSE2 :: 1;

PX_GCC :: 0;

PX_XBOXONE :: 0;

PX_WIN32 :: 0;

PX_ANDROID :: 0;

PX_LINUX :: 0;

PX_IOS :: 0;

PX_OSX :: 0;

PX_PS4 :: 0;

PX_SWITCH :: 0;

PX_UWP :: 0;

PX_X86 :: 0;

PX_A64 :: 0;

PX_ARM :: 0;

PX_PPC :: 0;

PX_NEON :: 0;

PX_VMX :: 0;

PX_DEBUG :: 0;

PX_CHECKED :: 0;

PX_PROFILE :: 0;

PX_DEBUG_CRT :: 0;

PX_NVTX :: 0;

PX_DOXYGEN :: 0;

PX_GCC_FAMILY :: PX_CLANG || PX_GCC;

PX_WINDOWS_FAMILY :: PX_WIN32 || PX_WIN64 || PX_UWP;
PX_MICROSOFT_FAMILY :: PX_XBOXONE || PX_WINDOWS_FAMILY;
PX_LINUX_FAMILY :: PX_LINUX || PX_ANDROID;
PX_APPLE_FAMILY :: PX_IOS || PX_OSX;
PX_UNIX_FAMILY :: PX_LINUX_FAMILY || PX_APPLE_FAMILY;

PX_EMSCRIPTEN :: 0;

PX_INTEL_FAMILY :: PX_X64 || PX_X86;
PX_ARM_FAMILY :: PX_ARM || PX_A64;
PX_P64_FAMILY :: PX_X64 || PX_A64;

PX_LIBCPP :: 1;

PX_WINDOWS :: PX_WINDOWS_FAMILY && !PX_ARM_FAMILY;

PX_ENABLE_ASSERTS :: 0;

PX_OFFSETOF_BASE :: 0x100;

PX_SUPPORT_GPU_PHYSX :: (PX_WINDOWS_FAMILY) || (PX_LINUX && PX_X64);

PX_SUPPORT_COMPUTE_PHYSX :: 0;

PX_SUPPORT_EXTERN_TEMPLATE :: (!PX_ANDROID) && (PX_VC != 11);

PX_PRIu64 :: "I64u";

PX_MAX_F32 :: 3.4028234663852885981170418348452e+38;

PX_MAX_REAL :: PX_MAX_F32;

PX_MAX_BOUNDS_EXTENTS :: PX_MAX_REAL * 0.25;

PX_SERIAL_ALIGN :: 16;

PX_SERIAL_FILE_ALIGN :: 128;

PX_SERIAL_OBJECT_ID_INVALID :: 0;

PX_SERIAL_REF_KIND_PTR_TYPE_BIT :: 1<<31;

PX_SERIAL_REF_KIND_PXBASE :: 0 | PX_SERIAL_REF_KIND_PTR_TYPE_BIT;

PX_SERIAL_REF_KIND_MATERIAL_IDX :: 1;

PX_SUPPORT_PXTASK_PROFILING :: 1;

PX_MESH_SCALE_MIN :: 1.0e-6;

PX_MESH_SCALE_MAX :: 1.0e6;

PX_MIN_HEIGHTFIELD_XZ_SCALE :: 1.0e-8;

PX_MAX_SWEEP_DISTANCE :: 1.0e8;

PX_ENABLE_DYNAMIC_MESH_RTREE :: 1;

PXC_CONTACT_NO_FACE_INDEX :: 0xffffffff;

PX_PHYSICS_VERSION_MAJOR :: 4;
PX_PHYSICS_VERSION_MINOR :: 1;
PX_PHYSICS_VERSION_BUGFIX :: 1;

PX_PHYSICS_VERSION :: (PX_PHYSICS_VERSION_MAJOR<<24) + (PX_PHYSICS_VERSION_MINOR<<16) + (PX_PHYSICS_VERSION_BUGFIX<<8) + 0;

INVALID_OBSTACLE_HANDLE :: 0xffffffff;

PX_BINARY_SERIAL_VERSION :: "F193874828914B3A8AC4EFE75AED0247";

PX_MAX_NB_WHEELS :: 20;

PX_DEBUG_VEHICLE_ON :: 1;

PxPackValidation :: struct {
    _: u8;
    a: s64;
}
#run {
    instance: PxPackValidation;
    assert(((cast(*void)(*instance._)) - cast(*void)(*instance)) == 0, "PxPackValidation._ has unexpected offset % instead of 0", ((cast(*void)(*instance._)) - cast(*void)(*instance)));
    assert(size_of(type_of(PxPackValidation._)) == 1, "PxPackValidation._ has unexpected size % instead of 1", size_of(type_of(PxPackValidation._)));
    assert(((cast(*void)(*instance.a)) - cast(*void)(*instance)) == 8, "PxPackValidation.a has unexpected offset % instead of 8", ((cast(*void)(*instance.a)) - cast(*void)(*instance)));
    assert(size_of(type_of(PxPackValidation.a)) == 8, "PxPackValidation.a has unexpected size % instead of 8", size_of(type_of(PxPackValidation.a)));
    assert(size_of(PxPackValidation) == 16, "PxPackValidation has size % instead of 16", size_of(PxPackValidation));
}

PxCompileTimeAssert_Dummy0 :: [1] u8;

physx :: struct {
    PxI64 :: s64;
    PxU64 :: u64;
    PxI32 :: s32;
    PxU32 :: u32;
    PxI16 :: s16;
    PxU16 :: u16;
    PxI8 :: s8;
    PxU8 :: u8;
    PxF32 :: float;
    PxF64 :: float64;
    PxReal :: float;

    /** enum for empty constructor tag*/
    PxEMPTY :: enum s32 {
        PxEmpty :: 0;
    }

    /** enum for zero constructor tag for vectors and matrices */
    PxZERO :: enum s32 {
        PxZero :: 0;
    }

    /** enum for identity constructor flag for quaternions, transforms, and matrices */
    PxIDENTITY :: enum s32 {
        PxIdentity :: 0;
    }

    /**
    \brief Abstract base class for an application defined memory allocator that can be used by the Nv library.

    \note The SDK state should not be modified from within any allocation/free function.

    <b>Threading:</b> All methods of this class should be thread safe as it can be called from the user thread
    or the physics processing thread(s).
    */
    PxAllocatorCallback :: struct {
        vtable: *PxAllocatorCallback_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.
        /**
        \brief destructor
        */
        virtual_Destructor :: (this: *PxAllocatorCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_lib "??1PxAllocatorCallback@physx@@UEAA@XZ";
    }
    PxAllocatorCallback_VTable :: struct #type_info_none {
        Destructor: (this: *PxAllocatorCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

        allocate: (this: *PxAllocatorCallback, size: size_t, typeName: *u8, filename: *u8, line: s32) -> *void #cpp_method;

        deallocate: (this: *PxAllocatorCallback, ptr: *void) -> void #cpp_method;
    }

    PxAllocatorCallback_Destructor :: inline (this: *PxAllocatorCallback, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    PxAllocatorCallback_allocate :: inline (this: *PxAllocatorCallback, size: size_t, typeName: *u8, filename: *u8, line: s32) -> *void { return this.vtable.allocate(this, size, typeName, filename, line); }

    PxAllocatorCallback_deallocate :: inline (this: *PxAllocatorCallback, ptr: *void) { this.vtable.deallocate(this, ptr); }

    vtable :: (obj: *PxAllocatorCallback) -> *PxAllocatorCallback_VTable { return obj.vtable; }

    #run {if true then return;
        assert(size_of(PxAllocatorCallback) == 8, "PxAllocatorCallback has size % instead of 8", size_of(PxAllocatorCallback));
    }

    /* Base class to handle assert failures */
    PxAssertHandler :: struct {
        vtable: *PxAssertHandler_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.
        virtual_Destructor :: (this: *PxAssertHandler, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_lib "??1PxAssertHandler@physx@@UEAA@XZ";
    }
    PxAssertHandler_VTable :: struct #type_info_none {
        Destructor: (this: *PxAssertHandler, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

        operator_parens: (this: *PxAssertHandler, exp: *u8, file: *u8, line: s32, ignore: *bool) -> void #cpp_method;
        // operator_parens :: (this: PxAssertHandler, exp: *u8, file: *u8, line: s32, ignore: *bool) #no_context {
        //     operator_parens(*this, exp, file, line, ignore);
        // }
    }

    PxAssertHandler_Destructor :: inline (this: *PxAssertHandler, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    PxAssertHandler_operator_parens :: inline (this: *PxAssertHandler, exp: *u8, file: *u8, line: s32, ignore: *bool) { this.vtable.operator_parens(this, exp, file, line, ignore); }

    vtable :: (obj: *PxAssertHandler) -> *PxAssertHandler_VTable { return obj.vtable; }

    #run {if true then return;
        assert(size_of(PxAssertHandler) == 8, "PxAssertHandler has size % instead of 8", size_of(PxAssertHandler));
    }

    PxBitAndDataT :: struct(storageType: Type, bitMask: storageType) {
        mData: storageType;
    }

    PxBitAndByte :: PxBitAndDataT(u8, 0x80);
    PxBitAndWord :: PxBitAndDataT(u16, 0x8000);
    PxBitAndDword :: PxBitAndDataT(u32, 0x80000000);

    intrinsics :: struct {
        //! \brief platform-specific absolute value
        abs :: (a: float) -> float #foreign physx_lib "?abs@intrinsics@physx@@YAMM@Z";

        //! \brief platform-specific sign
        sign :: (a: float) -> float #foreign physx_lib "?sign@intrinsics@physx@@YAMM@Z";

        //! \brief platform-specific square root
        sqrt :: (a: float) -> float #foreign physx_lib "?sqrt@intrinsics@physx@@YAMM@Z";

        //! \brief platform-specific reciprocal square root
        recipSqrt :: (a: float) -> float #foreign physx_lib "?recipSqrt@intrinsics@physx@@YAMM@Z";

        //! \brief platform-specific sine
        sin :: (a: float) -> float #foreign physx_lib "?sin@intrinsics@physx@@YAMM@Z";

        //! \brief platform-specific cosine
        cos :: (a: float) -> float #foreign physx_lib "?cos@intrinsics@physx@@YAMM@Z";

        //! \brief platform-specific minimum
        selectMin :: (a: float, b: float) -> float #foreign physx_lib "?selectMin@intrinsics@physx@@YAMMM@Z";

        //! \brief platform-specific maximum
        selectMax :: (a: float, b: float) -> float #foreign physx_lib "?selectMax@intrinsics@physx@@YAMMM@Z";

        //! \brief platform-specific finiteness check (not INF or NAN)
        isFinite :: (a: float) -> bool #foreign physx_lib "?isFinite@intrinsics@physx@@YA_NM@Z";

        //! \brief platform-specific finiteness check (not INF or NAN)
        isFinite :: (a: float64) -> bool #foreign physx_lib "?isFinite@intrinsics@physx@@YA_NN@Z";

        /*!
        Sets \c count bytes starting at \c dst to zero.
        */
        memZero :: (dest: *void, count: u32) -> *void #foreign physx_lib "?memZero@intrinsics@physx@@YAPEAXPEAXI@Z";

        /*!
        Sets \c count bytes starting at \c dst to \c c.
        */
        memSet :: (dest: *void, c: s32, count: u32) -> *void #foreign physx_lib "?memSet@intrinsics@physx@@YAPEAXPEAXHI@Z";

        /*!
        Copies \c count bytes from \c src to \c dst. User memMove if regions overlap.
        */
        memCopy :: (dest: *void, src: *void, count: u32) -> *void #foreign physx_lib "?memCopy@intrinsics@physx@@YAPEAXPEAXPEBXI@Z";

        /*!
        Copies \c count bytes from \c src to \c dst. Supports overlapping regions.
        */
        memMove :: (dest: *void, src: *void, count: u32) -> *void #foreign physx_lib "?memMove@intrinsics@physx@@YAPEAXPEAXPEBXI@Z";
    }

    // constants
    PxPi: float;
    PxHalfPi: float;
    PxTwoPi: float;
    PxInvPi: float;
    PxInvTwoPi: float;
    PxPiDivTwo: float;
    PxPiDivFour: float;

    //! overload for float to use fsel on xbox
    PxMax :: (a: float, b: float) -> float #foreign physx_lib "??$PxMax@M@physx@@YAMMM@Z";

    //! overload for float to use fsel on xbox
    PxMin :: (a: float, b: float) -> float #foreign physx_lib "??$PxMin@M@physx@@YAMMM@Z";

    /**
    \brief abs returns the absolute value of its argument.
    */
    PxAbs :: (a: float) -> float #foreign physx_lib "?PxAbs@physx@@YAMM@Z";

    PxEquals :: (a: float, b: float, eps: float) -> bool #foreign physx_lib "?PxEquals@physx@@YA_NMMM@Z";

    /**
    \brief abs returns the absolute value of its argument.
    */
    PxAbs :: (a: float64) -> float64 #foreign physx_lib "?PxAbs@physx@@YANN@Z";

    /**
    \brief abs returns the absolute value of its argument.
    */
    PxAbs :: (a: s32) -> s32 #foreign physx_lib "?PxAbs@physx@@YAHH@Z";

    //!	\brief Square root.
    PxSqrt :: (a: float) -> float #foreign physx_lib "?PxSqrt@physx@@YAMM@Z";

    //!	\brief Square root.
    PxSqrt :: (a: float64) -> float64 #foreign physx_lib "?PxSqrt@physx@@YANN@Z";

    //!	\brief reciprocal square root.
    PxRecipSqrt :: (a: float) -> float #foreign physx_lib "?PxRecipSqrt@physx@@YAMM@Z";

    //!	\brief reciprocal square root.
    PxRecipSqrt :: (a: float64) -> float64 #foreign physx_lib "?PxRecipSqrt@physx@@YANN@Z";

    //!	\brief Sine of an angle ( <b>Unit:</b> Radians )
    PxSin :: (a: float) -> float #foreign physx_lib "?PxSin@physx@@YAMM@Z";

    //!	\brief Sine of an angle ( <b>Unit:</b> Radians )
    PxSin :: (a: float64) -> float64 #foreign physx_lib "?PxSin@physx@@YANN@Z";

    //!	\brief Cosine of an angle (<b>Unit:</b> Radians)
    PxCos :: (a: float) -> float #foreign physx_lib "?PxCos@physx@@YAMM@Z";

    //!	\brief Cosine of an angle (<b>Unit:</b> Radians)
    PxCos :: (a: float64) -> float64 #foreign physx_lib "?PxCos@physx@@YANN@Z";

    /**
    \brief Tangent of an angle.
    <b>Unit:</b> Radians
    */
    PxTan :: (a: float) -> float #foreign physx_lib "?PxTan@physx@@YAMM@Z";

    /**
    \brief Tangent of an angle.
    <b>Unit:</b> Radians
    */
    PxTan :: (a: float64) -> float64 #foreign physx_lib "?PxTan@physx@@YANN@Z";

    /**
    \brief Arcsine.
    Returns angle between -PI/2 and PI/2 in radians
    <b>Unit:</b> Radians
    */
    PxAsin :: (f: float) -> float #foreign physx_lib "?PxAsin@physx@@YAMM@Z";

    /**
    \brief Arcsine.
    Returns angle between -PI/2 and PI/2 in radians
    <b>Unit:</b> Radians
    */
    PxAsin :: (f: float64) -> float64 #foreign physx_lib "?PxAsin@physx@@YANN@Z";

    /**
    \brief Arccosine.
    Returns angle between 0 and PI in radians
    <b>Unit:</b> Radians
    */
    PxAcos :: (f: float) -> float #foreign physx_lib "?PxAcos@physx@@YAMM@Z";

    /**
    \brief Arccosine.
    Returns angle between 0 and PI in radians
    <b>Unit:</b> Radians
    */
    PxAcos :: (f: float64) -> float64 #foreign physx_lib "?PxAcos@physx@@YANN@Z";

    /**
    \brief ArcTangent.
    Returns angle between -PI/2 and PI/2 in radians
    <b>Unit:</b> Radians
    */
    PxAtan :: (a: float) -> float #foreign physx_lib "?PxAtan@physx@@YAMM@Z";

    /**
    \brief ArcTangent.
    Returns angle between -PI/2 and PI/2 in radians
    <b>Unit:</b> Radians
    */
    PxAtan :: (a: float64) -> float64 #foreign physx_lib "?PxAtan@physx@@YANN@Z";

    /**
    \brief Arctangent of (x/y) with correct sign.
    Returns angle between -PI and PI in radians
    <b>Unit:</b> Radians
    */
    PxAtan2 :: (x: float, y: float) -> float #foreign physx_lib "?PxAtan2@physx@@YAMMM@Z";

    /**
    \brief Arctangent of (x/y) with correct sign.
    Returns angle between -PI and PI in radians
    <b>Unit:</b> Radians
    */
    PxAtan2 :: (x: float64, y: float64) -> float64 #foreign physx_lib "?PxAtan2@physx@@YANNN@Z";

    //!	\brief returns true if the passed number is a finite floating point number as opposed to INF, NAN, etc.
    PxIsFinite :: (f: float) -> bool #foreign physx_lib "?PxIsFinite@physx@@YA_NM@Z";

    //!	\brief returns true if the passed number is a finite floating point number as opposed to INF, NAN, etc.
    PxIsFinite :: (f: float64) -> bool #foreign physx_lib "?PxIsFinite@physx@@YA_NN@Z";

    PxFloor :: (a: float) -> float #foreign physx_lib "?PxFloor@physx@@YAMM@Z";

    PxExp :: (a: float) -> float #foreign physx_lib "?PxExp@physx@@YAMM@Z";

    PxCeil :: (a: float) -> float #foreign physx_lib "?PxCeil@physx@@YAMM@Z";

    PxSign :: (a: float) -> float #foreign physx_lib "?PxSign@physx@@YAMM@Z";

    PxPow :: (x: float, y: float) -> float #foreign physx_lib "?PxPow@physx@@YAMMM@Z";

    PxLog :: (x: float) -> float #foreign physx_lib "?PxLog@physx@@YAMM@Z";

    /**
    \brief 3 Element vector class.

    This is a 3-dimensional vector class with public data members.
    */
    PxVec3 :: struct {
        /**
        \brief default constructor leaves data uninitialized.
        */
        Constructor :: (this: *PxVec3) -> void #cpp_method #foreign physx_lib "??0PxVec3@physx@@QEAA@XZ";

        /**
        \brief zero constructor.
        */
        Constructor :: (this: *PxVec3, r: PxZERO) -> void #cpp_method #foreign physx_lib "??0PxVec3@physx@@QEAA@W4PxZERO@1@@Z";

        /**
        \brief Assigns scalar parameter to all elements.

        Useful to initialize to zero or one.

        \param[in] a Value to assign to elements.
        */
        Constructor :: (this: *PxVec3, a: float) -> void #cpp_method #foreign physx_lib "??0PxVec3@physx@@QEAA@M@Z";

        /**
        \brief Initializes from 3 scalar parameters.

        \param[in] nx Value to initialize X component.
        \param[in] ny Value to initialize Y component.
        \param[in] nz Value to initialize Z component.
        */
        Constructor :: (this: *PxVec3, nx: float, ny: float, nz: float) -> void #cpp_method #foreign physx_lib "??0PxVec3@physx@@QEAA@MMM@Z";

        /**
        \brief Copy ctor.
        */
        CopyConstructor :: (this: *PxVec3, v: *PxVec3) -> void #cpp_method #foreign physx_lib "??0PxVec3@physx@@QEAA@AEBV01@@Z";
        CopyConstructor :: (this: *PxVec3, v: PxVec3) #no_context {
            CopyConstructor(this, *v);
        }

        /**
        \brief tests for exact zero vector
        */
        isZero :: (this: *PxVec3) -> bool #cpp_method #foreign physx_lib "?isZero@PxVec3@physx@@QEBA_NXZ";

        /**
        \brief returns true if all 3 elems of the vector are finite (not NAN or INF, etc.)
        */
        isFinite :: (this: *PxVec3) -> bool #cpp_method #foreign physx_lib "?isFinite@PxVec3@physx@@QEBA_NXZ";

        /**
        \brief is normalized - used by API parameter validation
        */
        isNormalized :: (this: *PxVec3) -> bool #cpp_method #foreign physx_lib "?isNormalized@PxVec3@physx@@QEBA_NXZ";

        /**
        \brief returns the squared magnitude

        Avoids calling PxSqrt()!
        */
        magnitudeSquared :: (this: *PxVec3) -> float #cpp_method #foreign physx_lib "?magnitudeSquared@PxVec3@physx@@QEBAMXZ";

        /**
        \brief returns the magnitude
        */
        magnitude :: (this: *PxVec3) -> float #cpp_method #foreign physx_lib "?magnitude@PxVec3@physx@@QEBAMXZ";

        /**
        \brief returns the scalar product of this and other.
        */
        dot :: (this: *PxVec3, v: *PxVec3) -> float #cpp_method #foreign physx_lib "?dot@PxVec3@physx@@QEBAMAEBV12@@Z";
        dot :: (this: *PxVec3, v: PxVec3) -> float #no_context {
            return dot(this, *v);
        }

        /**
        \brief cross product
        */
        cross :: (this: *PxVec3, v: *PxVec3) -> PxVec3 #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "?cross@PxVec3@physx@@QEBA?AV12@AEBV12@@Z";
        cross :: (this: *PxVec3, v: PxVec3) -> PxVec3 #no_context {
            return cross(this, *v);
        }

        /** return a unit vector */
        getNormalized :: (this: *PxVec3) -> PxVec3 #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "?getNormalized@PxVec3@physx@@QEBA?AV12@XZ";

        /**
        \brief normalizes the vector in place
        */
        normalize :: (this: *PxVec3) -> float #cpp_method #foreign physx_lib "?normalize@PxVec3@physx@@QEAAMXZ";

        /**
        \brief normalizes the vector in place. Does nothing if vector magnitude is under PX_NORMALIZATION_EPSILON.
        Returns vector magnitude if >= PX_NORMALIZATION_EPSILON and 0.0f otherwise.
        */
        normalizeSafe :: (this: *PxVec3) -> float #cpp_method #foreign physx_lib "?normalizeSafe@PxVec3@physx@@QEAAMXZ";

        /**
        \brief normalizes the vector in place. Asserts if vector magnitude is under PX_NORMALIZATION_EPSILON.
        returns vector magnitude.
        */
        normalizeFast :: (this: *PxVec3) -> float #cpp_method #foreign physx_lib "?normalizeFast@PxVec3@physx@@QEAAMXZ";

        /**
        \brief a[i] * b[i], for all i.
        */
        multiply :: (this: *PxVec3, a: *PxVec3) -> PxVec3 #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "?multiply@PxVec3@physx@@QEBA?AV12@AEBV12@@Z";
        multiply :: (this: *PxVec3, a: PxVec3) -> PxVec3 #no_context {
            return multiply(this, *a);
        }

        /**
        \brief element-wise minimum
        */
        minimum :: (this: *PxVec3, v: *PxVec3) -> PxVec3 #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "?minimum@PxVec3@physx@@QEBA?AV12@AEBV12@@Z";
        minimum :: (this: *PxVec3, v: PxVec3) -> PxVec3 #no_context {
            return minimum(this, *v);
        }

        /**
        \brief returns MIN(x, y, z);
        */
        minElement :: (this: *PxVec3) -> float #cpp_method #foreign physx_lib "?minElement@PxVec3@physx@@QEBAMXZ";

        /**
        \brief element-wise maximum
        */
        maximum :: (this: *PxVec3, v: *PxVec3) -> PxVec3 #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "?maximum@PxVec3@physx@@QEBA?AV12@AEBV12@@Z";
        maximum :: (this: *PxVec3, v: PxVec3) -> PxVec3 #no_context {
            return maximum(this, *v);
        }

        /**
        \brief returns MAX(x, y, z);
        */
        maxElement :: (this: *PxVec3) -> float #cpp_method #foreign physx_lib "?maxElement@PxVec3@physx@@QEBAMXZ";

        /**
        \brief returns absolute values of components;
        */
        abs :: (this: *PxVec3) -> PxVec3 #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "?abs@PxVec3@physx@@QEBA?AV12@XZ";

        x: float;
        y: float;
        z: float;
    }

    /**
    \brief Assignment operator
    */
    operator_assign :: (this: *physx.PxVec3, p: *physx.PxVec3) -> *physx.PxVec3 #cpp_method #foreign physx_lib "??4PxVec3@physx@@QEAAAEAV01@AEBV01@@Z";
    operator_assign :: (this: *physx.PxVec3, p: physx.PxVec3) -> *physx.PxVec3 #no_context {
        return operator_assign(this, *p);
    }

    /**
    \brief element access
    */
    operator[] :: (this: *physx.PxVec3, index: u32) -> *float #cpp_method #foreign physx_lib "??APxVec3@physx@@QEAAAEAMI@Z";
    operator[] :: (this: physx.PxVec3, index: u32) -> *float #no_context {
        return operator[](*this, index);
    }

    /**
    \brief element access
    */
    operator_brackets_1 :: (this: /*const*/ *physx.PxVec3, index: u32) -> *float #cpp_method #foreign physx_lib "??APxVec3@physx@@QEBAAEBMI@Z";
    operator_brackets_1 :: (this: physx.PxVec3, index: u32) -> *float #no_context {
        return operator_brackets_1(*this, index);
    }

    /**
    \brief negation
    */
    operator- :: (this: *physx.PxVec3) -> physx.PxVec3 #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "??GPxVec3@physx@@QEBA?AV01@XZ";
    operator- :: (this: physx.PxVec3) -> physx.PxVec3 #no_context {
        return operator-(*this);
    }

    /**
    \brief vector addition
    */
    operator+ :: (this: *physx.PxVec3, v: *physx.PxVec3) -> physx.PxVec3 #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "??HPxVec3@physx@@QEBA?AV01@AEBV01@@Z";
    operator+ :: (this: physx.PxVec3, v: physx.PxVec3) -> physx.PxVec3 #no_context {
        return operator+(*this, *v);
    }

    /**
    \brief vector difference
    */
    operator- :: (this: *physx.PxVec3, v: *physx.PxVec3) -> physx.PxVec3 #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "??GPxVec3@physx@@QEBA?AV01@AEBV01@@Z";
    operator- :: (this: physx.PxVec3, v: physx.PxVec3) -> physx.PxVec3 #no_context {
        return operator-(*this, *v);
    }

    /**
    \brief scalar post-multiplication
    */
    operator* :: (this: *physx.PxVec3, f: float) -> physx.PxVec3 #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "??DPxVec3@physx@@QEBA?AV01@M@Z";
    operator* :: (this: physx.PxVec3, f: float) -> physx.PxVec3 #no_context {
        return operator*(*this, f);
    }

    /**
    \brief vector addition
    */
    operator+= :: (this: *physx.PxVec3, v: *physx.PxVec3) -> *physx.PxVec3 #cpp_method #foreign physx_lib "??YPxVec3@physx@@QEAAAEAV01@AEBV01@@Z";
    operator+= :: (this: *physx.PxVec3, v: physx.PxVec3) -> *physx.PxVec3 #no_context {
        return operator+=(this, *v);
    }

    /**
    \brief scalar multiplication
    */
    operator*= :: (this: *physx.PxVec3, f: float) -> *physx.PxVec3 #cpp_method #foreign physx_lib "??XPxVec3@physx@@QEAAAEAV01@M@Z";

    /**
    \brief scalar division
    */
    operator/= :: (this: *physx.PxVec3, f: float) -> *physx.PxVec3 #cpp_method #foreign physx_lib "??_0PxVec3@physx@@QEAAAEAV01@M@Z";
    #run {
        instance: PxVec3;
        assert(((cast(*void)(*instance.x)) - cast(*void)(*instance)) == 0, "PxVec3.x has unexpected offset % instead of 0", ((cast(*void)(*instance.x)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVec3.x)) == 4, "PxVec3.x has unexpected size % instead of 4", size_of(type_of(PxVec3.x)));
        assert(((cast(*void)(*instance.y)) - cast(*void)(*instance)) == 4, "PxVec3.y has unexpected offset % instead of 4", ((cast(*void)(*instance.y)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVec3.y)) == 4, "PxVec3.y has unexpected size % instead of 4", size_of(type_of(PxVec3.y)));
        assert(((cast(*void)(*instance.z)) - cast(*void)(*instance)) == 8, "PxVec3.z has unexpected offset % instead of 8", ((cast(*void)(*instance.z)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVec3.z)) == 4, "PxVec3.z has unexpected size % instead of 4", size_of(type_of(PxVec3.z)));
        assert(size_of(PxVec3) == 12, "PxVec3 has size % instead of 12", size_of(PxVec3));
    }

    /**
    \brief This is a quaternion class. For more information on quaternion mathematics
    consult a mathematics source on complex numbers.

    */
    PxQuat :: struct {
        /**
        \brief Default constructor, does not do any initialization.
        */
        Constructor :: (this: *PxQuat) -> void #cpp_method #foreign physx_lib "??0PxQuat@physx@@QEAA@XZ";

        //! identity constructor
        Constructor :: (this: *PxQuat, r: PxIDENTITY) -> void #cpp_method #foreign physx_lib "??0PxQuat@physx@@QEAA@W4PxIDENTITY@1@@Z";

        /**
        \brief Constructor from a scalar: sets the real part w to the scalar value, and the imaginary parts (x,y,z) to zero
        */
        Constructor :: (this: *PxQuat, r: float) -> void #cpp_method #foreign physx_lib "??0PxQuat@physx@@QEAA@M@Z";

        /**
        \brief Constructor.  Take note of the order of the elements!
        */
        Constructor :: (this: *PxQuat, nx: float, ny: float, nz: float, nw: float) -> void #cpp_method #foreign physx_lib "??0PxQuat@physx@@QEAA@MMMM@Z";

        /**
        \brief Creates from angle-axis representation.

        Axis must be normalized!

        Angle is in radians!

        <b>Unit:</b> Radians
        */
        Constructor :: (this: *PxQuat, angleRadians: float, unitAxis: *PxVec3) -> void #cpp_method #foreign physx_lib "??0PxQuat@physx@@QEAA@MAEBVPxVec3@1@@Z";
        Constructor :: (this: *PxQuat, angleRadians: float, unitAxis: PxVec3) #no_context {
            Constructor(this, angleRadians, *unitAxis);
        }

        /**
        \brief Copy ctor.
        */
        CopyConstructor :: (this: *PxQuat, v: *PxQuat) -> void #cpp_method #foreign physx_lib "??0PxQuat@physx@@QEAA@AEBV01@@Z";
        CopyConstructor :: (this: *PxQuat, v: PxQuat) #no_context {
            CopyConstructor(this, *v);
        }

        /**
        \brief Creates from orientation matrix.

        \param[in] m Rotation matrix to extract quaternion from.
        */
        Constructor :: (this: *PxQuat, m: *PxMat33) -> void #cpp_method #foreign physx_lib "??0PxQuat@physx@@QEAA@AEBVPxMat33@1@@Z";
        Constructor :: (this: *PxQuat, m: PxMat33) #no_context {
            Constructor(this, *m);
        }

        /**
        \brief returns true if quat is identity
        */
        isIdentity :: (this: *PxQuat) -> bool #cpp_method #foreign physx_lib "?isIdentity@PxQuat@physx@@QEBA_NXZ";

        /**
        \brief returns true if all elements are finite (not NAN or INF, etc.)
        */
        isFinite :: (this: *PxQuat) -> bool #cpp_method #foreign physx_lib "?isFinite@PxQuat@physx@@QEBA_NXZ";

        /**
        \brief returns true if finite and magnitude is close to unit
        */
        isUnit :: (this: *PxQuat) -> bool #cpp_method #foreign physx_lib "?isUnit@PxQuat@physx@@QEBA_NXZ";

        /**
        \brief returns true if finite and magnitude is reasonably close to unit to allow for some accumulation of error vs
        isValid
        */
        isSane :: (this: *PxQuat) -> bool #cpp_method #foreign physx_lib "?isSane@PxQuat@physx@@QEBA_NXZ";

        /**
        \brief converts this quaternion to angle-axis representation
        */
        toRadiansAndUnitAxis :: (this: *PxQuat, angle: *float, axis: *PxVec3) -> void #cpp_method #foreign physx_lib "?toRadiansAndUnitAxis@PxQuat@physx@@QEBAXAEAMAEAVPxVec3@2@@Z";

        /**
        \brief Gets the angle between this quat and the identity quaternion.

        <b>Unit:</b> Radians
        */
        getAngle :: (this: *PxQuat) -> float #cpp_method #foreign physx_lib "?getAngle@PxQuat@physx@@QEBAMXZ";

        /**
        \brief Gets the angle between this quat and the argument

        <b>Unit:</b> Radians
        */
        getAngle :: (this: *PxQuat, q: *PxQuat) -> float #cpp_method #foreign physx_lib "?getAngle@PxQuat@physx@@QEBAMAEBV12@@Z";
        getAngle :: (this: *PxQuat, q: PxQuat) -> float #no_context {
            return getAngle(this, *q);
        }

        /**
        \brief This is the squared 4D vector length, should be 1 for unit quaternions.
        */
        magnitudeSquared :: (this: *PxQuat) -> float #cpp_method #foreign physx_lib "?magnitudeSquared@PxQuat@physx@@QEBAMXZ";

        /**
        \brief returns the scalar product of this and other.
        */
        dot :: (this: *PxQuat, v: *PxQuat) -> float #cpp_method #foreign physx_lib "?dot@PxQuat@physx@@QEBAMAEBV12@@Z";
        dot :: (this: *PxQuat, v: PxQuat) -> float #no_context {
            return dot(this, *v);
        }

        getNormalized :: (this: *PxQuat) -> PxQuat #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "?getNormalized@PxQuat@physx@@QEBA?AV12@XZ";

        magnitude :: (this: *PxQuat) -> float #cpp_method #foreign physx_lib "?magnitude@PxQuat@physx@@QEBAMXZ";

        // modifiers:
        /**
        \brief maps to the closest unit quaternion.
        */
        normalize :: (this: *PxQuat) -> float #cpp_method #foreign physx_lib "?normalize@PxQuat@physx@@QEAAMXZ";

        /*
        \brief returns the conjugate.

        \note for unit quaternions, this is the inverse.
        */
        getConjugate :: (this: *PxQuat) -> PxQuat #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "?getConjugate@PxQuat@physx@@QEBA?AV12@XZ";

        /*
        \brief returns imaginary part.
        */
        getImaginaryPart :: (this: *PxQuat) -> PxVec3 #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "?getImaginaryPart@PxQuat@physx@@QEBA?AVPxVec3@2@XZ";

        /** brief computes rotation of x-axis */
        getBasisVector0 :: (this: *PxQuat) -> PxVec3 #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "?getBasisVector0@PxQuat@physx@@QEBA?AVPxVec3@2@XZ";

        /** brief computes rotation of y-axis */
        getBasisVector1 :: (this: *PxQuat) -> PxVec3 #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "?getBasisVector1@PxQuat@physx@@QEBA?AVPxVec3@2@XZ";

        /** brief computes rotation of z-axis */
        getBasisVector2 :: (this: *PxQuat) -> PxVec3 #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "?getBasisVector2@PxQuat@physx@@QEBA?AVPxVec3@2@XZ";

        /**
        rotates passed vec by this (assumed unitary)
        */
        rotate :: (this: *PxQuat, v: *PxVec3) -> PxVec3 #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "?rotate@PxQuat@physx@@QEBA?BVPxVec3@2@AEBV32@@Z";
        rotate :: (this: *PxQuat, v: PxVec3) -> PxVec3 #no_context {
            return rotate(this, *v);
        }

        /**
        inverse rotates passed vec by this (assumed unitary)
        */
        rotateInv :: (this: *PxQuat, v: *PxVec3) -> PxVec3 #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "?rotateInv@PxQuat@physx@@QEBA?BVPxVec3@2@AEBV32@@Z";
        rotateInv :: (this: *PxQuat, v: PxVec3) -> PxVec3 #no_context {
            return rotateInv(this, *v);
        }

        /** the quaternion elements */
        x: float;
        /** the quaternion elements */
        y: float;
        /** the quaternion elements */
        z: float;
        /** the quaternion elements */
        w: float;
    }

    /**
    \brief Assignment operator
    */
    operator_assign :: (this: *physx.PxQuat, p: *physx.PxQuat) -> *physx.PxQuat #cpp_method #foreign physx_lib "??4PxQuat@physx@@QEAAAEAV01@AEBV01@@Z";
    operator_assign :: (this: *physx.PxQuat, p: physx.PxQuat) -> *physx.PxQuat #no_context {
        return operator_assign(this, *p);
    }

    /** quaternion multiplication */
    operator* :: (this: *physx.PxQuat, q: *physx.PxQuat) -> physx.PxQuat #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "??DPxQuat@physx@@QEBA?AV01@AEBV01@@Z";
    operator* :: (this: physx.PxQuat, q: physx.PxQuat) -> physx.PxQuat #no_context {
        return operator*(*this, *q);
    }

    operator* :: (this: *physx.PxQuat, r: float) -> physx.PxQuat #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "??DPxQuat@physx@@QEBA?AV01@M@Z";
    operator* :: (this: physx.PxQuat, r: float) -> physx.PxQuat #no_context {
        return operator*(*this, r);
    }
    #run {
        instance: PxQuat;
        assert(((cast(*void)(*instance.x)) - cast(*void)(*instance)) == 0, "PxQuat.x has unexpected offset % instead of 0", ((cast(*void)(*instance.x)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxQuat.x)) == 4, "PxQuat.x has unexpected size % instead of 4", size_of(type_of(PxQuat.x)));
        assert(((cast(*void)(*instance.y)) - cast(*void)(*instance)) == 4, "PxQuat.y has unexpected offset % instead of 4", ((cast(*void)(*instance.y)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxQuat.y)) == 4, "PxQuat.y has unexpected size % instead of 4", size_of(type_of(PxQuat.y)));
        assert(((cast(*void)(*instance.z)) - cast(*void)(*instance)) == 8, "PxQuat.z has unexpected offset % instead of 8", ((cast(*void)(*instance.z)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxQuat.z)) == 4, "PxQuat.z has unexpected size % instead of 4", size_of(type_of(PxQuat.z)));
        assert(((cast(*void)(*instance.w)) - cast(*void)(*instance)) == 12, "PxQuat.w has unexpected offset % instead of 12", ((cast(*void)(*instance.w)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxQuat.w)) == 4, "PxQuat.w has unexpected size % instead of 4", size_of(type_of(PxQuat.w)));
        assert(size_of(PxQuat) == 16, "PxQuat has size % instead of 16", size_of(PxQuat));
    }

    /**
    \brief Representation of a plane.

    Plane equation used: n.dot(v) + d = 0
    */
    PxPlane :: struct {
        /**
        \brief Constructor
        */
        Constructor :: (this: *PxPlane) -> void #cpp_method #foreign physx_lib "??0PxPlane@physx@@QEAA@XZ";

        /**
        \brief Constructor from a normal and a distance
        */
        Constructor :: (this: *PxPlane, nx: float, ny: float, nz: float, distance: float) -> void #cpp_method #foreign physx_lib "??0PxPlane@physx@@QEAA@MMMM@Z";

        /**
        \brief Constructor from a normal and a distance
        */
        Constructor :: (this: *PxPlane, normal: *PxVec3, distance: float) -> void #cpp_method #foreign physx_lib "??0PxPlane@physx@@QEAA@AEBVPxVec3@1@M@Z";
        Constructor :: (this: *PxPlane, normal: PxVec3, distance: float) #no_context {
            Constructor(this, *normal, distance);
        }

        /**
        \brief Constructor from a point on the plane and a normal
        */
        Constructor :: (this: *PxPlane, point: *PxVec3, normal: *PxVec3) -> void #cpp_method #foreign physx_lib "??0PxPlane@physx@@QEAA@AEBVPxVec3@1@0@Z";
        Constructor :: (this: *PxPlane, point: PxVec3, normal: PxVec3) #no_context {
            Constructor(this, *point, *normal);
        }

        /**
        \brief Constructor from three points
        */
        Constructor :: (this: *PxPlane, p0: *PxVec3, p1: *PxVec3, p2: *PxVec3) -> void #cpp_method #foreign physx_lib "??0PxPlane@physx@@QEAA@AEBVPxVec3@1@00@Z";
        Constructor :: (this: *PxPlane, p0: PxVec3, p1: PxVec3, p2: PxVec3) #no_context {
            Constructor(this, *p0, *p1, *p2);
        }

        distance :: (this: *PxPlane, p: *PxVec3) -> float #cpp_method #foreign physx_lib "?distance@PxPlane@physx@@QEBAMAEBVPxVec3@2@@Z";
        distance :: (this: *PxPlane, p: PxVec3) -> float #no_context {
            return distance(this, *p);
        }

        contains :: (this: *PxPlane, p: *PxVec3) -> bool #cpp_method #foreign physx_lib "?contains@PxPlane@physx@@QEBA_NAEBVPxVec3@2@@Z";
        contains :: (this: *PxPlane, p: PxVec3) -> bool #no_context {
            return contains(this, *p);
        }

        /**
        \brief projects p into the plane
        */
        project :: (this: *PxPlane, p: *PxVec3) -> PxVec3 #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "?project@PxPlane@physx@@QEBA?AVPxVec3@2@AEBV32@@Z";
        project :: (this: *PxPlane, p: PxVec3) -> PxVec3 #no_context {
            return project(this, *p);
        }

        /**
        \brief find an arbitrary point in the plane
        */
        pointInPlane :: (this: *PxPlane) -> PxVec3 #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "?pointInPlane@PxPlane@physx@@QEBA?AVPxVec3@2@XZ";

        /**
        \brief equivalent plane with unit normal
        */
        normalize :: (this: *PxPlane) -> void #cpp_method #foreign physx_lib "?normalize@PxPlane@physx@@QEAAXXZ";

        n: PxVec3; //!< The normal to the plane
        d: float; //!< The distance from the origin
    }
    #run {
        instance: PxPlane;
        assert(((cast(*void)(*instance.n)) - cast(*void)(*instance)) == 0, "PxPlane.n has unexpected offset % instead of 0", ((cast(*void)(*instance.n)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxPlane.n)) == 12, "PxPlane.n has unexpected size % instead of 12", size_of(type_of(PxPlane.n)));
        assert(((cast(*void)(*instance.d)) - cast(*void)(*instance)) == 12, "PxPlane.d has unexpected offset % instead of 12", ((cast(*void)(*instance.d)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxPlane.d)) == 4, "PxPlane.d has unexpected size % instead of 4", size_of(type_of(PxPlane.d)));
        assert(size_of(PxPlane) == 16, "PxPlane has size % instead of 16", size_of(PxPlane));
    }

    /*!
    \brief class representing a rigid euclidean transform as a quaternion and a vector
    */
    PxTransform :: struct {
        q: PxQuat;
        p: PxVec3;

        Constructor :: (this: *PxTransform) -> void #cpp_method #foreign physx_lib "??0PxTransform@physx@@QEAA@XZ";

        Constructor :: (this: *PxTransform, position: *PxVec3) -> void #cpp_method #foreign physx_lib "??0PxTransform@physx@@QEAA@AEBVPxVec3@1@@Z";
        Constructor :: (this: *PxTransform, position: PxVec3) #no_context {
            Constructor(this, *position);
        }

        Constructor :: (this: *PxTransform, r: PxIDENTITY) -> void #cpp_method #foreign physx_lib "??0PxTransform@physx@@QEAA@W4PxIDENTITY@1@@Z";

        Constructor :: (this: *PxTransform, orientation: *PxQuat) -> void #cpp_method #foreign physx_lib "??0PxTransform@physx@@QEAA@AEBVPxQuat@1@@Z";
        Constructor :: (this: *PxTransform, orientation: PxQuat) #no_context {
            Constructor(this, *orientation);
        }

        Constructor :: (this: *PxTransform, x: float, y: float, z: float, aQ: PxQuat) -> void #cpp_method #foreign physx_lib "??0PxTransform@physx@@QEAA@MMMVPxQuat@1@@Z";

        Constructor :: (this: *PxTransform, p0: *PxVec3, q0: *PxQuat) -> void #cpp_method #foreign physx_lib "??0PxTransform@physx@@QEAA@AEBVPxVec3@1@AEBVPxQuat@1@@Z";
        Constructor :: (this: *PxTransform, p0: PxVec3, q0: PxQuat) #no_context {
            Constructor(this, *p0, *q0);
        }

        // implementation from PxTransform.h
        Constructor :: (this: *PxTransform, m: *PxMat44) -> void #cpp_method #foreign physx_lib "??0PxTransform@physx@@QEAA@AEBVPxMat44@1@@Z";
        Constructor :: (this: *PxTransform, m: PxMat44) #no_context {
            Constructor(this, *m);
        }

        getInverse :: (this: *PxTransform) -> PxTransform #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "?getInverse@PxTransform@physx@@QEBA?AV12@XZ";

        transform :: (this: *PxTransform, input: *PxVec3) -> PxVec3 #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "?transform@PxTransform@physx@@QEBA?AVPxVec3@2@AEBV32@@Z";
        transform :: (this: *PxTransform, input: PxVec3) -> PxVec3 #no_context {
            return transform(this, *input);
        }

        transformInv :: (this: *PxTransform, input: *PxVec3) -> PxVec3 #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "?transformInv@PxTransform@physx@@QEBA?AVPxVec3@2@AEBV32@@Z";
        transformInv :: (this: *PxTransform, input: PxVec3) -> PxVec3 #no_context {
            return transformInv(this, *input);
        }

        rotate :: (this: *PxTransform, input: *PxVec3) -> PxVec3 #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "?rotate@PxTransform@physx@@QEBA?AVPxVec3@2@AEBV32@@Z";
        rotate :: (this: *PxTransform, input: PxVec3) -> PxVec3 #no_context {
            return rotate(this, *input);
        }

        rotateInv :: (this: *PxTransform, input: *PxVec3) -> PxVec3 #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "?rotateInv@PxTransform@physx@@QEBA?AVPxVec3@2@AEBV32@@Z";
        rotateInv :: (this: *PxTransform, input: PxVec3) -> PxVec3 #no_context {
            return rotateInv(this, *input);
        }

        //! Transform transform to parent (returns compound transform: first src, then *this)
        transform :: (this: *PxTransform, src: *PxTransform) -> PxTransform #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "?transform@PxTransform@physx@@QEBA?AV12@AEBV12@@Z";
        transform :: (this: *PxTransform, src: PxTransform) -> PxTransform #no_context {
            return transform(this, *src);
        }

        /**
        \brief returns true if finite and q is a unit quaternion
        */
        isValid :: (this: *PxTransform) -> bool #cpp_method #foreign physx_lib "?isValid@PxTransform@physx@@QEBA_NXZ";

        /**
        \brief returns true if finite and quat magnitude is reasonably close to unit to allow for some accumulation of error
        vs isValid
        */
        isSane :: (this: *PxTransform) -> bool #cpp_method #foreign physx_lib "?isSane@PxTransform@physx@@QEBA_NXZ";

        /**
        \brief returns true if all elems are finite (not NAN or INF, etc.)
        */
        isFinite :: (this: *PxTransform) -> bool #cpp_method #foreign physx_lib "?isFinite@PxTransform@physx@@QEBA_NXZ";

        //! Transform transform from parent (returns compound transform: first src, then this->inverse)
        transformInv :: (this: *PxTransform, src: *PxTransform) -> PxTransform #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "?transformInv@PxTransform@physx@@QEBA?AV12@AEBV12@@Z";
        transformInv :: (this: *PxTransform, src: PxTransform) -> PxTransform #no_context {
            return transformInv(this, *src);
        }

        /**
        \brief transform plane
        */
        transform :: (this: *PxTransform, plane: *PxPlane) -> PxPlane #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "?transform@PxTransform@physx@@QEBA?AVPxPlane@2@AEBV32@@Z";
        transform :: (this: *PxTransform, plane: PxPlane) -> PxPlane #no_context {
            return transform(this, *plane);
        }

        /**
        \brief inverse-transform plane
        */
        inverseTransform :: (this: *PxTransform, plane: *PxPlane) -> PxPlane #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "?inverseTransform@PxTransform@physx@@QEBA?AVPxPlane@2@AEBV32@@Z";
        inverseTransform :: (this: *PxTransform, plane: PxPlane) -> PxPlane #no_context {
            return inverseTransform(this, *plane);
        }

        /**
        \brief return a normalized transform (i.e. one in which the quaternion has unit magnitude)
        */
        getNormalized :: (this: *PxTransform) -> PxTransform #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "?getNormalized@PxTransform@physx@@QEBA?AV12@XZ";
    }

    operator* :: (this: *physx.PxTransform, x: *physx.PxTransform) -> physx.PxTransform #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "??DPxTransform@physx@@QEBA?AV01@AEBV01@@Z";
    operator* :: (this: physx.PxTransform, x: physx.PxTransform) -> physx.PxTransform #no_context {
        return operator*(*this, *x);
    }
    #run {if true then return;
        instance: PxTransform;
        assert(((cast(*void)(*instance.q)) - cast(*void)(*instance)) == 0, "PxTransform.q has unexpected offset % instead of 0", ((cast(*void)(*instance.q)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTransform.q)) == 16, "PxTransform.q has unexpected size % instead of 16", size_of(type_of(PxTransform.q)));
        assert(((cast(*void)(*instance.p)) - cast(*void)(*instance)) == 16, "PxTransform.p has unexpected offset % instead of 16", ((cast(*void)(*instance.p)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTransform.p)) == 12, "PxTransform.p has unexpected size % instead of 12", size_of(type_of(PxTransform.p)));
        assert(size_of(PxTransform) == 28, "PxTransform has size % instead of 28", size_of(PxTransform));
    }

    /*!
    \brief 3x3 matrix class

    Some clarifications, as there have been much confusion about matrix formats etc in the past.

    Short:
    - Matrix have base vectors in columns (vectors are column matrices, 3x1 matrices).
    - Matrix is physically stored in column major format
    - Matrices are concaternated from left

    Long:
    Given three base vectors a, b and c the matrix is stored as

    |a.x b.x c.x|
    |a.y b.y c.y|
    |a.z b.z c.z|

    Vectors are treated as columns, so the vector v is

    |x|
    |y|
    |z|

    And matrices are applied _before_ the vector (pre-multiplication)
    v' = M*v

    |x'|   |a.x b.x c.x|   |x|   |a.x*x + b.x*y + c.x*z|
    |y'| = |a.y b.y c.y| * |y| = |a.y*x + b.y*y + c.y*z|
    |z'|   |a.z b.z c.z|   |z|   |a.z*x + b.z*y + c.z*z|


    Physical storage and indexing:
    To be compatible with popular 3d rendering APIs (read D3d and OpenGL)
    the physical indexing is

    |0 3 6|
    |1 4 7|
    |2 5 8|

    index = column*3 + row

    which in C++ translates to M[column][row]

    The mathematical indexing is M_row,column and this is what is used for _-notation
    so _12 is 1st row, second column and operator(row, column)!

    */
    PxMat33 :: struct {
        //! Default constructor
        Constructor :: (this: *PxMat33) -> void #cpp_method #foreign physx_lib "??0PxMat33@physx@@QEAA@XZ";

        //! identity constructor
        Constructor :: (this: *PxMat33, r: PxIDENTITY) -> void #cpp_method #foreign physx_lib "??0PxMat33@physx@@QEAA@W4PxIDENTITY@1@@Z";

        //! zero constructor
        Constructor :: (this: *PxMat33, r: PxZERO) -> void #cpp_method #foreign physx_lib "??0PxMat33@physx@@QEAA@W4PxZERO@1@@Z";

        //! Construct from three base vectors
        Constructor :: (this: *PxMat33, col0: *PxVec3, col1: *PxVec3, col2: *PxVec3) -> void #cpp_method #foreign physx_lib "??0PxMat33@physx@@QEAA@AEBVPxVec3@1@00@Z";
        Constructor :: (this: *PxMat33, col0: PxVec3, col1: PxVec3, col2: PxVec3) #no_context {
            Constructor(this, *col0, *col1, *col2);
        }

        //! constructor from a scalar, which generates a multiple of the identity matrix
        Constructor :: (this: *PxMat33, r: float) -> void #cpp_method #foreign physx_lib "??0PxMat33@physx@@QEAA@M@Z";

        //! Construct from float[9]
        Constructor :: (this: *PxMat33, values: *float) -> void #cpp_method #foreign physx_lib "??0PxMat33@physx@@QEAA@QEAM@Z";

        //! Construct from a quaternion
        Constructor :: (this: *PxMat33, q: *PxQuat) -> void #cpp_method #foreign physx_lib "??0PxMat33@physx@@QEAA@AEBVPxQuat@1@@Z";
        Constructor :: (this: *PxMat33, q: PxQuat) #no_context {
            Constructor(this, *q);
        }

        //! Copy constructor
        CopyConstructor :: (this: *PxMat33, other: *PxMat33) -> void #cpp_method #foreign physx_lib "??0PxMat33@physx@@QEAA@AEBV01@@Z";
        CopyConstructor :: (this: *PxMat33, other: PxMat33) #no_context {
            CopyConstructor(this, *other);
        }

        //! Construct from diagonal, off-diagonals are zero.
        createDiagonal :: (d: *PxVec3) -> PxMat33 #cpp_return_type_is_non_pod #foreign physx_lib "?createDiagonal@PxMat33@physx@@SA?BV12@AEBVPxVec3@2@@Z";
        createDiagonal :: (d: PxVec3) -> PxMat33 #no_context {
            return createDiagonal(*d);
        }

        //! Get transposed matrix
        getTranspose :: (this: *PxMat33) -> PxMat33 #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "?getTranspose@PxMat33@physx@@QEBA?BV12@XZ";

        //! Get the real inverse
        getInverse :: (this: *PxMat33) -> PxMat33 #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "?getInverse@PxMat33@physx@@QEBA?BV12@XZ";

        //! Get determinant
        getDeterminant :: (this: *PxMat33) -> float #cpp_method #foreign physx_lib "?getDeterminant@PxMat33@physx@@QEBAMXZ";

        //! Transform vector by matrix, equal to v' = M*v
        transform :: (this: *PxMat33, other: *PxVec3) -> PxVec3 #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "?transform@PxMat33@physx@@QEBA?BVPxVec3@2@AEBV32@@Z";
        transform :: (this: *PxMat33, other: PxVec3) -> PxVec3 #no_context {
            return transform(this, *other);
        }

        //! Transform vector by matrix transpose, v' = M^t*v
        transformTranspose :: (this: *PxMat33, other: *PxVec3) -> PxVec3 #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "?transformTranspose@PxMat33@physx@@QEBA?BVPxVec3@2@AEBV32@@Z";
        transformTranspose :: (this: *PxMat33, other: PxVec3) -> PxVec3 #no_context {
            return transformTranspose(this, *other);
        }

        front :: (this: *PxMat33) -> *float #cpp_method #foreign physx_lib "?front@PxMat33@physx@@QEBAPEBMXZ";

        column0: PxVec3; // the three base vectors
        column1: PxVec3; // the three base vectors
        column2: PxVec3; // the three base vectors
    }

    //! Assignment operator
    operator_assign :: (this: *physx.PxMat33, other: *physx.PxMat33) -> *physx.PxMat33 #cpp_method #foreign physx_lib "??4PxMat33@physx@@QEAAAEAV01@AEBV01@@Z";
    operator_assign :: (this: *physx.PxMat33, other: physx.PxMat33) -> *physx.PxMat33 #no_context {
        return operator_assign(this, *other);
    }

    //! Add
    operator+ :: (this: *physx.PxMat33, other: *physx.PxMat33) -> physx.PxMat33 #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "??HPxMat33@physx@@QEBA?BV01@AEBV01@@Z";
    operator+ :: (this: physx.PxMat33, other: physx.PxMat33) -> physx.PxMat33 #no_context {
        return operator+(*this, *other);
    }

    //! Scalar multiplication
    operator* :: (this: *physx.PxMat33, scalar: float) -> physx.PxMat33 #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "??DPxMat33@physx@@QEBA?BV01@M@Z";
    operator* :: (this: physx.PxMat33, scalar: float) -> physx.PxMat33 #no_context {
        return operator*(*this, scalar);
    }

    //! Matrix vector multiplication (returns 'this->transform(vec)')
    operator* :: (this: *physx.PxMat33, vec: *physx.PxVec3) -> physx.PxVec3 #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "??DPxMat33@physx@@QEBA?BVPxVec3@1@AEBV21@@Z";
    operator* :: (this: physx.PxMat33, vec: physx.PxVec3) -> physx.PxVec3 #no_context {
        return operator*(*this, *vec);
    }

    //! Matrix multiplication
    operator* :: (this: *physx.PxMat33, other: *physx.PxMat33) -> physx.PxMat33 #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "??DPxMat33@physx@@QEBA?BV01@AEBV01@@Z";
    operator* :: (this: physx.PxMat33, other: physx.PxMat33) -> physx.PxMat33 #no_context {
        return operator*(*this, *other);
    }

    //! Equals-add
    operator+= :: (this: *physx.PxMat33, other: *physx.PxMat33) -> *physx.PxMat33 #cpp_method #foreign physx_lib "??YPxMat33@physx@@QEAAAEAV01@AEBV01@@Z";
    operator+= :: (this: *physx.PxMat33, other: physx.PxMat33) -> *physx.PxMat33 #no_context {
        return operator+=(this, *other);
    }

    operator[] :: (this: *physx.PxMat33, num: u32) -> *physx.PxVec3 #cpp_method #foreign physx_lib "??APxMat33@physx@@QEAAAEAVPxVec3@1@I@Z";
    operator[] :: (this: physx.PxMat33, num: u32) -> *physx.PxVec3 #no_context {
        return operator[](*this, num);
    }
    #run {if true then return;
        instance: PxMat33;
        assert(((cast(*void)(*instance.column0)) - cast(*void)(*instance)) == 0, "PxMat33.column0 has unexpected offset % instead of 0", ((cast(*void)(*instance.column0)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxMat33.column0)) == 12, "PxMat33.column0 has unexpected size % instead of 12", size_of(type_of(PxMat33.column0)));
        assert(((cast(*void)(*instance.column1)) - cast(*void)(*instance)) == 12, "PxMat33.column1 has unexpected offset % instead of 12", ((cast(*void)(*instance.column1)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxMat33.column1)) == 12, "PxMat33.column1 has unexpected size % instead of 12", size_of(type_of(PxMat33.column1)));
        assert(((cast(*void)(*instance.column2)) - cast(*void)(*instance)) == 24, "PxMat33.column2 has unexpected offset % instead of 24", ((cast(*void)(*instance.column2)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxMat33.column2)) == 12, "PxMat33.column2 has unexpected size % instead of 12", size_of(type_of(PxMat33.column2)));
        assert(size_of(PxMat33) == 36, "PxMat33 has size % instead of 36", size_of(PxMat33));
    }

    /**
    \brief Class representing 3D range or axis aligned bounding box.

    Stored as minimum and maximum extent corners. Alternate representation
    would be center and dimensions.
    May be empty or nonempty. For nonempty bounds, minimum <= maximum has to hold for all axes.
    Empty bounds have to be represented as minimum = PX_MAX_BOUNDS_EXTENTS and maximum = -PX_MAX_BOUNDS_EXTENTS for all
    axes.
    All other representations are invalid and the behavior is undefined.
    */
    PxBounds3 :: struct {
        /**
        \brief Default constructor, not performing any initialization for performance reason.
        \remark Use empty() function below to construct empty bounds.
        */
        Constructor :: (this: *PxBounds3) -> void #cpp_method #foreign physx_lib "??0PxBounds3@physx@@QEAA@XZ";

        /**
        \brief Construct from two bounding points
        */
        Constructor :: (this: *PxBounds3, minimum: *PxVec3, maximum: *PxVec3) -> void #cpp_method #foreign physx_lib "??0PxBounds3@physx@@QEAA@AEBVPxVec3@1@0@Z";
        Constructor :: (this: *PxBounds3, minimum: PxVec3, maximum: PxVec3) #no_context {
            Constructor(this, *minimum, *maximum);
        }

        /**
        \brief Return empty bounds.
        */
        empty :: () -> PxBounds3 #cpp_return_type_is_non_pod #foreign physx_lib "?empty@PxBounds3@physx@@SA?AV12@XZ";

        /**
        \brief returns the AABB containing v0 and v1.
        \param v0 first point included in the AABB.
        \param v1 second point included in the AABB.
        */
        boundsOfPoints :: (v0: *PxVec3, v1: *PxVec3) -> PxBounds3 #cpp_return_type_is_non_pod #foreign physx_lib "?boundsOfPoints@PxBounds3@physx@@SA?AV12@AEBVPxVec3@2@0@Z";
        boundsOfPoints :: (v0: PxVec3, v1: PxVec3) -> PxBounds3 #no_context {
            return boundsOfPoints(*v0, *v1);
        }

        /**
        \brief returns the AABB from center and extents vectors.
        \param center Center vector
        \param extent Extents vector
        */
        centerExtents :: (center: *PxVec3, extent: *PxVec3) -> PxBounds3 #cpp_return_type_is_non_pod #foreign physx_lib "?centerExtents@PxBounds3@physx@@SA?AV12@AEBVPxVec3@2@0@Z";
        centerExtents :: (center: PxVec3, extent: PxVec3) -> PxBounds3 #no_context {
            return centerExtents(*center, *extent);
        }

        /**
        \brief Construct from center, extent, and (not necessarily orthogonal) basis
        */
        basisExtent :: (center: *PxVec3, basis: *PxMat33, extent: *PxVec3) -> PxBounds3 #cpp_return_type_is_non_pod #foreign physx_lib "?basisExtent@PxBounds3@physx@@SA?AV12@AEBVPxVec3@2@AEBVPxMat33@2@0@Z";
        basisExtent :: (center: PxVec3, basis: PxMat33, extent: PxVec3) -> PxBounds3 #no_context {
            return basisExtent(*center, *basis, *extent);
        }

        /**
        \brief Construct from pose and extent
        */
        poseExtent :: (pose: *PxTransform, extent: *PxVec3) -> PxBounds3 #cpp_return_type_is_non_pod #foreign physx_lib "?poseExtent@PxBounds3@physx@@SA?AV12@AEBVPxTransform@2@AEBVPxVec3@2@@Z";
        poseExtent :: (pose: PxTransform, extent: PxVec3) -> PxBounds3 #no_context {
            return poseExtent(*pose, *extent);
        }

        /**
        \brief gets the transformed bounds of the passed AABB (resulting in a bigger AABB).

        This version is safe to call for empty bounds.

        \param[in] matrix Transform to apply, can contain scaling as well
        \param[in] bounds The bounds to transform.
        */
        transformSafe :: (matrix: *PxMat33, bounds: *PxBounds3) -> PxBounds3 #cpp_return_type_is_non_pod #foreign physx_lib "?transformSafe@PxBounds3@physx@@SA?AV12@AEBVPxMat33@2@AEBV12@@Z";
        transformSafe :: (matrix: PxMat33, bounds: PxBounds3) -> PxBounds3 #no_context {
            return transformSafe(*matrix, *bounds);
        }

        /**
        \brief gets the transformed bounds of the passed AABB (resulting in a bigger AABB).

        Calling this method for empty bounds leads to undefined behavior. Use #transformSafe() instead.

        \param[in] matrix Transform to apply, can contain scaling as well
        \param[in] bounds The bounds to transform.
        */
        transformFast :: (matrix: *PxMat33, bounds: *PxBounds3) -> PxBounds3 #cpp_return_type_is_non_pod #foreign physx_lib "?transformFast@PxBounds3@physx@@SA?AV12@AEBVPxMat33@2@AEBV12@@Z";
        transformFast :: (matrix: PxMat33, bounds: PxBounds3) -> PxBounds3 #no_context {
            return transformFast(*matrix, *bounds);
        }

        /**
        \brief gets the transformed bounds of the passed AABB (resulting in a bigger AABB).

        This version is safe to call for empty bounds.

        \param[in] transform Transform to apply, can contain scaling as well
        \param[in] bounds The bounds to transform.
        */
        transformSafe :: (transform: *PxTransform, bounds: *PxBounds3) -> PxBounds3 #cpp_return_type_is_non_pod #foreign physx_lib "?transformSafe@PxBounds3@physx@@SA?AV12@AEBVPxTransform@2@AEBV12@@Z";
        transformSafe :: (transform: PxTransform, bounds: PxBounds3) -> PxBounds3 #no_context {
            return transformSafe(*transform, *bounds);
        }

        /**
        \brief gets the transformed bounds of the passed AABB (resulting in a bigger AABB).

        Calling this method for empty bounds leads to undefined behavior. Use #transformSafe() instead.

        \param[in] transform Transform to apply, can contain scaling as well
        \param[in] bounds The bounds to transform.
        */
        transformFast :: (transform: *PxTransform, bounds: *PxBounds3) -> PxBounds3 #cpp_return_type_is_non_pod #foreign physx_lib "?transformFast@PxBounds3@physx@@SA?AV12@AEBVPxTransform@2@AEBV12@@Z";
        transformFast :: (transform: PxTransform, bounds: PxBounds3) -> PxBounds3 #no_context {
            return transformFast(*transform, *bounds);
        }

        /**
        \brief Sets empty to true
        */
        setEmpty :: (this: *PxBounds3) -> void #cpp_method #foreign physx_lib "?setEmpty@PxBounds3@physx@@QEAAXXZ";

        /**
        \brief Sets the bounds to maximum size [-PX_MAX_BOUNDS_EXTENTS, PX_MAX_BOUNDS_EXTENTS].
        */
        setMaximal :: (this: *PxBounds3) -> void #cpp_method #foreign physx_lib "?setMaximal@PxBounds3@physx@@QEAAXXZ";

        /**
        \brief expands the volume to include v
        \param v Point to expand to.
        */
        include :: (this: *PxBounds3, v: *PxVec3) -> void #cpp_method #foreign physx_lib "?include@PxBounds3@physx@@QEAAXAEBVPxVec3@2@@Z";
        include :: (this: *PxBounds3, v: PxVec3) #no_context {
            include(this, *v);
        }

        /**
        \brief expands the volume to include b.
        \param b Bounds to perform union with.
        */
        include :: (this: *PxBounds3, b: *PxBounds3) -> void #cpp_method #foreign physx_lib "?include@PxBounds3@physx@@QEAAXAEBV12@@Z";
        include :: (this: *PxBounds3, b: PxBounds3) #no_context {
            include(this, *b);
        }

        isEmpty :: (this: *PxBounds3) -> bool #cpp_method #foreign physx_lib "?isEmpty@PxBounds3@physx@@QEBA_NXZ";

        /**
        \brief indicates whether the intersection of this and b is empty or not.
        \param b Bounds to test for intersection.
        */
        intersects :: (this: *PxBounds3, b: *PxBounds3) -> bool #cpp_method #foreign physx_lib "?intersects@PxBounds3@physx@@QEBA_NAEBV12@@Z";
        intersects :: (this: *PxBounds3, b: PxBounds3) -> bool #no_context {
            return intersects(this, *b);
        }

        /**
        \brief computes the 1D-intersection between two AABBs, on a given axis.
        \param	a		the other AABB
        \param	axis	the axis (0, 1, 2)
        */
        intersects1D :: (this: *PxBounds3, a: *PxBounds3, axis: u32) -> bool #cpp_method #foreign physx_lib "?intersects1D@PxBounds3@physx@@QEBA_NAEBV12@I@Z";
        intersects1D :: (this: *PxBounds3, a: PxBounds3, axis: u32) -> bool #no_context {
            return intersects1D(this, *a, axis);
        }

        /**
        \brief indicates if these bounds contain v.
        \param v Point to test against bounds.
        */
        contains :: (this: *PxBounds3, v: *PxVec3) -> bool #cpp_method #foreign physx_lib "?contains@PxBounds3@physx@@QEBA_NAEBVPxVec3@2@@Z";
        contains :: (this: *PxBounds3, v: PxVec3) -> bool #no_context {
            return contains(this, *v);
        }

        /**
        \brief	checks a box is inside another box.
        \param	box		the other AABB
        */
        isInside :: (this: *PxBounds3, box: *PxBounds3) -> bool #cpp_method #foreign physx_lib "?isInside@PxBounds3@physx@@QEBA_NAEBV12@@Z";
        isInside :: (this: *PxBounds3, box: PxBounds3) -> bool #no_context {
            return isInside(this, *box);
        }

        /**
        \brief returns the center of this axis aligned box.
        */
        getCenter :: (this: *PxBounds3) -> PxVec3 #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "?getCenter@PxBounds3@physx@@QEBA?AVPxVec3@2@XZ";

        /**
        \brief get component of the box's center along a given axis
        */
        getCenter :: (this: *PxBounds3, axis: u32) -> float #cpp_method #foreign physx_lib "?getCenter@PxBounds3@physx@@QEBAMI@Z";

        /**
        \brief get component of the box's extents along a given axis
        */
        getExtents :: (this: *PxBounds3, axis: u32) -> float #cpp_method #foreign physx_lib "?getExtents@PxBounds3@physx@@QEBAMI@Z";

        /**
        \brief returns the dimensions (width/height/depth) of this axis aligned box.
        */
        getDimensions :: (this: *PxBounds3) -> PxVec3 #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "?getDimensions@PxBounds3@physx@@QEBA?AVPxVec3@2@XZ";

        /**
        \brief returns the extents, which are half of the width/height/depth.
        */
        getExtents :: (this: *PxBounds3) -> PxVec3 #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "?getExtents@PxBounds3@physx@@QEBA?AVPxVec3@2@XZ";

        /**
        \brief scales the AABB.

        This version is safe to call for empty bounds.

        \param scale Factor to scale AABB by.
        */
        scaleSafe :: (this: *PxBounds3, scale: float) -> void #cpp_method #foreign physx_lib "?scaleSafe@PxBounds3@physx@@QEAAXM@Z";

        /**
        \brief scales the AABB.

        Calling this method for empty bounds leads to undefined behavior. Use #scaleSafe() instead.

        \param scale Factor to scale AABB by.
        */
        scaleFast :: (this: *PxBounds3, scale: float) -> void #cpp_method #foreign physx_lib "?scaleFast@PxBounds3@physx@@QEAAXM@Z";

        /**
        fattens the AABB in all 3 dimensions by the given distance.

        This version is safe to call for empty bounds.
        */
        fattenSafe :: (this: *PxBounds3, distance: float) -> void #cpp_method #foreign physx_lib "?fattenSafe@PxBounds3@physx@@QEAAXM@Z";

        /**
        fattens the AABB in all 3 dimensions by the given distance.

        Calling this method for empty bounds leads to undefined behavior. Use #fattenSafe() instead.
        */
        fattenFast :: (this: *PxBounds3, distance: float) -> void #cpp_method #foreign physx_lib "?fattenFast@PxBounds3@physx@@QEAAXM@Z";

        /**
        checks that the AABB values are not NaN
        */
        isFinite :: (this: *PxBounds3) -> bool #cpp_method #foreign physx_lib "?isFinite@PxBounds3@physx@@QEBA_NXZ";

        /**
        checks that the AABB values describe a valid configuration.
        */
        isValid :: (this: *PxBounds3) -> bool #cpp_method #foreign physx_lib "?isValid@PxBounds3@physx@@QEBA_NXZ";

        minimum: PxVec3;
        maximum: PxVec3;
    }
    #run {if true then return;
        instance: PxBounds3;
        assert(((cast(*void)(*instance.minimum)) - cast(*void)(*instance)) == 0, "PxBounds3.minimum has unexpected offset % instead of 0", ((cast(*void)(*instance.minimum)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxBounds3.minimum)) == 12, "PxBounds3.minimum has unexpected size % instead of 12", size_of(type_of(PxBounds3.minimum)));
        assert(((cast(*void)(*instance.maximum)) - cast(*void)(*instance)) == 12, "PxBounds3.maximum has unexpected offset % instead of 12", ((cast(*void)(*instance.maximum)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxBounds3.maximum)) == 12, "PxBounds3.maximum has unexpected size % instead of 12", size_of(type_of(PxBounds3.maximum)));
        assert(size_of(PxBounds3) == 24, "PxBounds3 has size % instead of 24", size_of(PxBounds3));
    }

    /**
    \brief Error codes

    These error codes are passed to #PxErrorCallback

    @see PxErrorCallback
    */
    PxErrorCode :: struct {
        Enum :: enum s32 {
            NO_ERROR          :: 0;

            DEBUG_INFO        :: 1;

            DEBUG_WARNING     :: 2;

            INVALID_PARAMETER :: 4;

            INVALID_OPERATION :: 8;

            OUT_OF_MEMORY     :: 16;

            INTERNAL_ERROR    :: 32;

            ABORT             :: 64;

            PERF_WARNING      :: 128;

            MASK_ALL          :: -1;

            eNO_ERROR          :: NO_ERROR;

            eDEBUG_INFO        :: DEBUG_INFO;

            eDEBUG_WARNING     :: DEBUG_WARNING;

            eINVALID_PARAMETER :: INVALID_PARAMETER;

            eINVALID_OPERATION :: INVALID_OPERATION;

            eOUT_OF_MEMORY     :: OUT_OF_MEMORY;

            eINTERNAL_ERROR    :: INTERNAL_ERROR;

            eABORT             :: ABORT;

            ePERF_WARNING      :: PERF_WARNING;

            eMASK_ALL          :: MASK_ALL;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxErrorCode) == 1, "PxErrorCode has size % instead of 1", size_of(PxErrorCode));
    }

    /**
    \brief User defined interface class.  Used by the library to emit debug information.

    \note The SDK state should not be modified from within any error reporting functions.

    <b>Threading:</b> The SDK sequences its calls to the output stream using a mutex, so the class need not
    be implemented in a thread-safe manner if the SDK is the only client.
    */
    PxErrorCallback :: struct {
        vtable: *PxErrorCallback_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.
        virtual_Destructor :: (this: *PxErrorCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_lib "??1PxErrorCallback@physx@@UEAA@XZ";
    }
    PxErrorCallback_VTable :: struct #type_info_none {
        Destructor: (this: *PxErrorCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

        reportError: (this: *PxErrorCallback, code: PxErrorCode.Enum, message: *u8, file: *u8, line: s32) -> void #cpp_method;
    }

    PxErrorCallback_Destructor :: inline (this: *PxErrorCallback, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    PxErrorCallback_reportError :: inline (this: *PxErrorCallback, code: PxErrorCode.Enum, message: *u8, file: *u8, line: s32) { this.vtable.reportError(this, code, message, file, line); }

    vtable :: (obj: *PxErrorCallback) -> *PxErrorCallback_VTable { return obj.vtable; }

    #run {if true then return;
        assert(size_of(PxErrorCallback) == 8, "PxErrorCallback has size % instead of 8", size_of(PxErrorCallback));
    }

    /**
    \brief Container for bitfield flag variables associated with a specific enum type.

    This allows for type safe manipulation for bitfields.

    <h3>Example</h3>
    // enum that defines each bit...
    struct MyEnum
    {
    enum Enum
    {
    eMAN  = 1,
    eBEAR = 2,
    ePIG  = 4,
    };
    };

    // implements some convenient global operators.
    PX_FLAGS_OPERATORS(MyEnum::Enum, uint8_t);

    PxFlags<MyEnum::Enum, uint8_t> myFlags;
    myFlags |= MyEnum::eMAN;
    myFlags |= MyEnum::eBEAR | MyEnum::ePIG;
    if(myFlags & MyEnum::eBEAR)
    {
    doSomething();
    }
    */
    PxFlags :: struct(enumtype: Type, storagetype: Type) {
        InternalType :: storagetype;

        mBits:        storagetype;
    }

    /**
    \brief Input stream class for I/O.

    The user needs to supply a PxInputStream implementation to a number of methods to allow the SDK to read data.
    */
    PxInputStream :: struct {
        vtable: *PxInputStream_VTable;
    }
    PxInputStream_VTable :: struct #type_info_none {
        read: (this: *PxInputStream, dest: *void, count: u32) -> u32 #cpp_method;

        Destructor: (this: *PxInputStream, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxInputStream_read :: inline (this: *PxInputStream, dest: *void, count: u32) -> u32 { return this.vtable.read(this, dest, count); }

    PxInputStream_Destructor :: inline (this: *PxInputStream, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxInputStream) -> *PxInputStream_VTable { return obj.vtable; }

    #run {if true then return;
        assert(size_of(PxInputStream) == 8, "PxInputStream has size % instead of 8", size_of(PxInputStream));
    }

    /**
    \brief Input data class for I/O which provides random read access.

    The user needs to supply a PxInputData implementation to a number of methods to allow the SDK to read data.
    */
    PxInputData :: struct {
        #as using pxinputstream: PxInputStream;
        #place pxinputstream; pxinputdata_vtable: *PxInputData_VTable;
    }
    PxInputData_VTable :: struct #type_info_none {
        using pxinputstream: PxInputStream_VTable;
        getLength: (this: *PxInputData) -> u32 #cpp_method;

        seek: (this: *PxInputData, offset: u32) -> void #cpp_method;

        tell: (this: *PxInputData) -> u32 #cpp_method;
    }

    PxInputData_getLength :: inline (this: *PxInputData) -> u32 { return this.pxinputdata_vtable.getLength(this); }

    PxInputData_seek :: inline (this: *PxInputData, offset: u32) { this.pxinputdata_vtable.seek(this, offset); }

    PxInputData_tell :: inline (this: *PxInputData) -> u32 { return this.pxinputdata_vtable.tell(this); }

    vtable :: (obj: *PxInputData) -> *PxInputData_VTable { return obj.pxinputdata_vtable; }

    #run {if true then return;
        assert(size_of(type_of(PxInputData.pxinputstream)) == 8, "PxInputData.pxinputstream has unexpected size % instead of 8", size_of(type_of(PxInputData.pxinputstream)));
        assert(size_of(PxInputData) == 8, "PxInputData has size % instead of 8", size_of(PxInputData));
    }

    /**
    \brief Output stream class for I/O.

    The user needs to supply a PxOutputStream implementation to a number of methods to allow the SDK to write data.
    */
    PxOutputStream :: struct {
        vtable: *PxOutputStream_VTable;
    }
    PxOutputStream_VTable :: struct #type_info_none {
        write: (this: *PxOutputStream, src: *void, count: u32) -> u32 #cpp_method;

        Destructor: (this: *PxOutputStream, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxOutputStream_write :: inline (this: *PxOutputStream, src: *void, count: u32) -> u32 { return this.vtable.write(this, src, count); }

    PxOutputStream_Destructor :: inline (this: *PxOutputStream, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxOutputStream) -> *PxOutputStream_VTable { return obj.vtable; }

    #run {if true then return;
        assert(size_of(PxOutputStream) == 8, "PxOutputStream has size % instead of 8", size_of(PxOutputStream));
    }

    PxVec4 :: struct {
        /**
        \brief default constructor leaves data uninitialized.
        */
        Constructor :: (this: *PxVec4) -> void #cpp_method #foreign physx_lib "??0PxVec4@physx@@QEAA@XZ";

        /**
        \brief zero constructor.
        */
        Constructor :: (this: *PxVec4, r: PxZERO) -> void #cpp_method #foreign physx_lib "??0PxVec4@physx@@QEAA@W4PxZERO@1@@Z";

        /**
        \brief Assigns scalar parameter to all elements.

        Useful to initialize to zero or one.

        \param[in] a Value to assign to elements.
        */
        Constructor :: (this: *PxVec4, a: float) -> void #cpp_method #foreign physx_lib "??0PxVec4@physx@@QEAA@M@Z";

        /**
        \brief Initializes from 3 scalar parameters.

        \param[in] nx Value to initialize X component.
        \param[in] ny Value to initialize Y component.
        \param[in] nz Value to initialize Z component.
        \param[in] nw Value to initialize W component.
        */
        Constructor :: (this: *PxVec4, nx: float, ny: float, nz: float, nw: float) -> void #cpp_method #foreign physx_lib "??0PxVec4@physx@@QEAA@MMMM@Z";

        /**
        \brief Initializes from 3 scalar parameters.

        \param[in] v Value to initialize the X, Y, and Z components.
        \param[in] nw Value to initialize W component.
        */
        Constructor :: (this: *PxVec4, v: *PxVec3, nw: float) -> void #cpp_method #foreign physx_lib "??0PxVec4@physx@@QEAA@AEBVPxVec3@1@M@Z";
        Constructor :: (this: *PxVec4, v: PxVec3, nw: float) #no_context {
            Constructor(this, *v, nw);
        }

        /**
        \brief Initializes from an array of scalar parameters.

        \param[in] v Value to initialize with.
        */
        Constructor :: (this: *PxVec4, v: *float) -> void #cpp_method #foreign physx_lib "??0PxVec4@physx@@QEAA@QEBM@Z";

        /**
        \brief Copy ctor.
        */
        CopyConstructor :: (this: *PxVec4, v: *PxVec4) -> void #cpp_method #foreign physx_lib "??0PxVec4@physx@@QEAA@AEBV01@@Z";
        CopyConstructor :: (this: *PxVec4, v: PxVec4) #no_context {
            CopyConstructor(this, *v);
        }

        /**
        \brief tests for exact zero vector
        */
        isZero :: (this: *PxVec4) -> bool #cpp_method #foreign physx_lib "?isZero@PxVec4@physx@@QEBA_NXZ";

        /**
        \brief returns true if all 3 elems of the vector are finite (not NAN or INF, etc.)
        */
        isFinite :: (this: *PxVec4) -> bool #cpp_method #foreign physx_lib "?isFinite@PxVec4@physx@@QEBA_NXZ";

        /**
        \brief is normalized - used by API parameter validation
        */
        isNormalized :: (this: *PxVec4) -> bool #cpp_method #foreign physx_lib "?isNormalized@PxVec4@physx@@QEBA_NXZ";

        /**
        \brief returns the squared magnitude

        Avoids calling PxSqrt()!
        */
        magnitudeSquared :: (this: *PxVec4) -> float #cpp_method #foreign physx_lib "?magnitudeSquared@PxVec4@physx@@QEBAMXZ";

        /**
        \brief returns the magnitude
        */
        magnitude :: (this: *PxVec4) -> float #cpp_method #foreign physx_lib "?magnitude@PxVec4@physx@@QEBAMXZ";

        /**
        \brief returns the scalar product of this and other.
        */
        dot :: (this: *PxVec4, v: *PxVec4) -> float #cpp_method #foreign physx_lib "?dot@PxVec4@physx@@QEBAMAEBV12@@Z";
        dot :: (this: *PxVec4, v: PxVec4) -> float #no_context {
            return dot(this, *v);
        }

        /** return a unit vector */
        getNormalized :: (this: *PxVec4) -> PxVec4 #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "?getNormalized@PxVec4@physx@@QEBA?AV12@XZ";

        /**
        \brief normalizes the vector in place
        */
        normalize :: (this: *PxVec4) -> float #cpp_method #foreign physx_lib "?normalize@PxVec4@physx@@QEAAMXZ";

        /**
        \brief a[i] * b[i], for all i.
        */
        multiply :: (this: *PxVec4, a: *PxVec4) -> PxVec4 #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "?multiply@PxVec4@physx@@QEBA?AV12@AEBV12@@Z";
        multiply :: (this: *PxVec4, a: PxVec4) -> PxVec4 #no_context {
            return multiply(this, *a);
        }

        /**
        \brief element-wise minimum
        */
        minimum :: (this: *PxVec4, v: *PxVec4) -> PxVec4 #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "?minimum@PxVec4@physx@@QEBA?AV12@AEBV12@@Z";
        minimum :: (this: *PxVec4, v: PxVec4) -> PxVec4 #no_context {
            return minimum(this, *v);
        }

        /**
        \brief element-wise maximum
        */
        maximum :: (this: *PxVec4, v: *PxVec4) -> PxVec4 #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "?maximum@PxVec4@physx@@QEBA?AV12@AEBV12@@Z";
        maximum :: (this: *PxVec4, v: PxVec4) -> PxVec4 #no_context {
            return maximum(this, *v);
        }

        getXYZ :: (this: *PxVec4) -> PxVec3 #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "?getXYZ@PxVec4@physx@@QEBA?AVPxVec3@2@XZ";

        /**
        \brief set vector elements to zero
        */
        setZero :: (this: *PxVec4) -> void #cpp_method #foreign physx_lib "?setZero@PxVec4@physx@@QEAAXXZ";

        x: float;
        y: float;
        z: float;
        w: float;
    }

    /**
    \brief Assignment operator
    */
    operator_assign :: (this: *physx.PxVec4, p: *physx.PxVec4) -> *physx.PxVec4 #cpp_method #foreign physx_lib "??4PxVec4@physx@@QEAAAEAV01@AEBV01@@Z";
    operator_assign :: (this: *physx.PxVec4, p: physx.PxVec4) -> *physx.PxVec4 #no_context {
        return operator_assign(this, *p);
    }

    /**
    \brief vector addition
    */
    operator+ :: (this: *physx.PxVec4, v: *physx.PxVec4) -> physx.PxVec4 #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "??HPxVec4@physx@@QEBA?AV01@AEBV01@@Z";
    operator+ :: (this: physx.PxVec4, v: physx.PxVec4) -> physx.PxVec4 #no_context {
        return operator+(*this, *v);
    }

    /**
    \brief scalar post-multiplication
    */
    operator* :: (this: *physx.PxVec4, f: float) -> physx.PxVec4 #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "??DPxVec4@physx@@QEBA?AV01@M@Z";
    operator* :: (this: physx.PxVec4, f: float) -> physx.PxVec4 #no_context {
        return operator*(*this, f);
    }

    /**
    \brief scalar multiplication
    */
    operator*= :: (this: *physx.PxVec4, f: float) -> *physx.PxVec4 #cpp_method #foreign physx_lib "??XPxVec4@physx@@QEAAAEAV01@M@Z";

    /**
    \brief scalar division
    */
    operator/= :: (this: *physx.PxVec4, f: float) -> *physx.PxVec4 #cpp_method #foreign physx_lib "??_0PxVec4@physx@@QEAAAEAV01@M@Z";
    #run {if true then return;
        instance: PxVec4;
        assert(((cast(*void)(*instance.x)) - cast(*void)(*instance)) == 0, "PxVec4.x has unexpected offset % instead of 0", ((cast(*void)(*instance.x)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVec4.x)) == 4, "PxVec4.x has unexpected size % instead of 4", size_of(type_of(PxVec4.x)));
        assert(((cast(*void)(*instance.y)) - cast(*void)(*instance)) == 4, "PxVec4.y has unexpected offset % instead of 4", ((cast(*void)(*instance.y)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVec4.y)) == 4, "PxVec4.y has unexpected size % instead of 4", size_of(type_of(PxVec4.y)));
        assert(((cast(*void)(*instance.z)) - cast(*void)(*instance)) == 8, "PxVec4.z has unexpected offset % instead of 8", ((cast(*void)(*instance.z)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVec4.z)) == 4, "PxVec4.z has unexpected size % instead of 4", size_of(type_of(PxVec4.z)));
        assert(((cast(*void)(*instance.w)) - cast(*void)(*instance)) == 12, "PxVec4.w has unexpected offset % instead of 12", ((cast(*void)(*instance.w)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVec4.w)) == 4, "PxVec4.w has unexpected size % instead of 4", size_of(type_of(PxVec4.w)));
        assert(size_of(PxVec4) == 16, "PxVec4 has size % instead of 16", size_of(PxVec4));
    }

    /*!
    \brief 4x4 matrix class

    This class is layout-compatible with D3D and OpenGL matrices. More notes on layout are given in the PxMat33

    @see PxMat33 PxTransform
    */
    PxMat44 :: struct {
        //! Default constructor
        Constructor :: (this: *PxMat44) -> void #cpp_method #foreign physx_lib "??0PxMat44@physx@@QEAA@XZ";

        //! identity constructor
        Constructor :: (this: *PxMat44, r: PxIDENTITY) -> void #cpp_method #foreign physx_lib "??0PxMat44@physx@@QEAA@W4PxIDENTITY@1@@Z";

        //! zero constructor
        Constructor :: (this: *PxMat44, r: PxZERO) -> void #cpp_method #foreign physx_lib "??0PxMat44@physx@@QEAA@W4PxZERO@1@@Z";

        //! Construct from four 4-vectors
        Constructor :: (this: *PxMat44, col0: *PxVec4, col1: *PxVec4, col2: *PxVec4, col3: *PxVec4) -> void #cpp_method #foreign physx_lib "??0PxMat44@physx@@QEAA@AEBVPxVec4@1@000@Z";
        Constructor :: (this: *PxMat44, col0: PxVec4, col1: PxVec4, col2: PxVec4, col3: PxVec4) #no_context {
            Constructor(this, *col0, *col1, *col2, *col3);
        }

        //! constructor that generates a multiple of the identity matrix
        Constructor :: (this: *PxMat44, r: float) -> void #cpp_method #foreign physx_lib "??0PxMat44@physx@@QEAA@M@Z";

        //! Construct from three base vectors and a translation
        Constructor :: (this: *PxMat44, col0: *PxVec3, col1: *PxVec3, col2: *PxVec3, col3: *PxVec3) -> void #cpp_method #foreign physx_lib "??0PxMat44@physx@@QEAA@AEBVPxVec3@1@000@Z";
        Constructor :: (this: *PxMat44, col0: PxVec3, col1: PxVec3, col2: PxVec3, col3: PxVec3) #no_context {
            Constructor(this, *col0, *col1, *col2, *col3);
        }

        //! Construct from float[16]
        Constructor :: (this: *PxMat44, values: *float) -> void #cpp_method #foreign physx_lib "??0PxMat44@physx@@QEAA@QEAM@Z";

        //! Construct from a quaternion
        Constructor :: (this: *PxMat44, q: *PxQuat) -> void #cpp_method #foreign physx_lib "??0PxMat44@physx@@QEAA@AEBVPxQuat@1@@Z";
        Constructor :: (this: *PxMat44, q: PxQuat) #no_context {
            Constructor(this, *q);
        }

        //! Construct from a diagonal vector
        Constructor :: (this: *PxMat44, diagonal: *PxVec4) -> void #cpp_method #foreign physx_lib "??0PxMat44@physx@@QEAA@AEBVPxVec4@1@@Z";
        Constructor :: (this: *PxMat44, diagonal: PxVec4) #no_context {
            Constructor(this, *diagonal);
        }

        //! Construct from Mat33 and a translation
        Constructor :: (this: *PxMat44, axes: *PxMat33, position: *PxVec3) -> void #cpp_method #foreign physx_lib "??0PxMat44@physx@@QEAA@AEBVPxMat33@1@AEBVPxVec3@1@@Z";
        Constructor :: (this: *PxMat44, axes: PxMat33, position: PxVec3) #no_context {
            Constructor(this, *axes, *position);
        }

        Constructor :: (this: *PxMat44, t: *PxTransform) -> void #cpp_method #foreign physx_lib "??0PxMat44@physx@@QEAA@AEBVPxTransform@1@@Z";
        Constructor :: (this: *PxMat44, t: PxTransform) #no_context {
            Constructor(this, *t);
        }

        //! Get transposed matrix
        getTranspose :: (this: *PxMat44) -> PxMat44 #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "?getTranspose@PxMat44@physx@@QEBA?BV12@XZ";

        //! Transform vector by matrix, equal to v' = M*v
        transform :: (this: *PxMat44, other: *PxVec4) -> PxVec4 #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "?transform@PxMat44@physx@@QEBA?BVPxVec4@2@AEBV32@@Z";
        transform :: (this: *PxMat44, other: PxVec4) -> PxVec4 #no_context {
            return transform(this, *other);
        }

        //! Transform vector by matrix, equal to v' = M*v
        transform :: (this: *PxMat44, other: *PxVec3) -> PxVec3 #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "?transform@PxMat44@physx@@QEBA?BVPxVec3@2@AEBV32@@Z";
        transform :: (this: *PxMat44, other: PxVec3) -> PxVec3 #no_context {
            return transform(this, *other);
        }

        //! Rotate vector by matrix, equal to v' = M*v
        rotate :: (this: *PxMat44, other: *PxVec4) -> PxVec4 #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "?rotate@PxMat44@physx@@QEBA?BVPxVec4@2@AEBV32@@Z";
        rotate :: (this: *PxMat44, other: PxVec4) -> PxVec4 #no_context {
            return rotate(this, *other);
        }

        //! Rotate vector by matrix, equal to v' = M*v
        rotate :: (this: *PxMat44, other: *PxVec3) -> PxVec3 #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "?rotate@PxMat44@physx@@QEBA?BVPxVec3@2@AEBV32@@Z";
        rotate :: (this: *PxMat44, other: PxVec3) -> PxVec3 #no_context {
            return rotate(this, *other);
        }

        getBasis :: (this: *PxMat44, num: s32) -> PxVec3 #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "?getBasis@PxMat44@physx@@QEBA?BVPxVec3@2@H@Z";

        getPosition :: (this: *PxMat44) -> PxVec3 #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "?getPosition@PxMat44@physx@@QEBA?BVPxVec3@2@XZ";

        setPosition :: (this: *PxMat44, position: *PxVec3) -> void #cpp_method #foreign physx_lib "?setPosition@PxMat44@physx@@QEAAXAEBVPxVec3@2@@Z";
        setPosition :: (this: *PxMat44, position: PxVec3) #no_context {
            setPosition(this, *position);
        }

        front :: (this: *PxMat44) -> *float #cpp_method #foreign physx_lib "?front@PxMat44@physx@@QEBAPEBMXZ";

        scale :: (this: *PxMat44, p: *PxVec4) -> void #cpp_method #foreign physx_lib "?scale@PxMat44@physx@@QEAAXAEBVPxVec4@2@@Z";
        scale :: (this: *PxMat44, p: PxVec4) #no_context {
            scale(this, *p);
        }

        inverseRT :: (this: *PxMat44) -> PxMat44 #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "?inverseRT@PxMat44@physx@@QEBA?BV12@XZ";

        isFinite :: (this: *PxMat44) -> bool #cpp_method #foreign physx_lib "?isFinite@PxMat44@physx@@QEBA_NXZ";

        column0: PxVec4; // the four base vectors
        column1: PxVec4; // the four base vectors
        column2: PxVec4; // the four base vectors
        column3: PxVec4; // the four base vectors
    }

    //! Assignment operator
    operator_assign :: (this: *physx.PxMat44, other: *physx.PxMat44) -> *physx.PxMat44 #cpp_method #foreign physx_lib "??4PxMat44@physx@@QEAAAEAV01@AEBV01@@Z";
    operator_assign :: (this: *physx.PxMat44, other: physx.PxMat44) -> *physx.PxMat44 #no_context {
        return operator_assign(this, *other);
    }
    #run {if true then return;
        instance: PxMat44;
        assert(((cast(*void)(*instance.column0)) - cast(*void)(*instance)) == 0, "PxMat44.column0 has unexpected offset % instead of 0", ((cast(*void)(*instance.column0)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxMat44.column0)) == 16, "PxMat44.column0 has unexpected size % instead of 16", size_of(type_of(PxMat44.column0)));
        assert(((cast(*void)(*instance.column1)) - cast(*void)(*instance)) == 16, "PxMat44.column1 has unexpected offset % instead of 16", ((cast(*void)(*instance.column1)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxMat44.column1)) == 16, "PxMat44.column1 has unexpected size % instead of 16", size_of(type_of(PxMat44.column1)));
        assert(((cast(*void)(*instance.column2)) - cast(*void)(*instance)) == 32, "PxMat44.column2 has unexpected offset % instead of 32", ((cast(*void)(*instance.column2)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxMat44.column2)) == 16, "PxMat44.column2 has unexpected size % instead of 16", size_of(type_of(PxMat44.column2)));
        assert(((cast(*void)(*instance.column3)) - cast(*void)(*instance)) == 48, "PxMat44.column3 has unexpected offset % instead of 48", ((cast(*void)(*instance.column3)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxMat44.column3)) == 16, "PxMat44.column3 has unexpected size % instead of 16", size_of(type_of(PxMat44.column3)));
        assert(size_of(PxMat44) == 64, "PxMat44 has size % instead of 64", size_of(PxMat44));
    }

    /**
    \brief Iterator class for iterating over arrays of data that may be interleaved with other data.

    This class is used for iterating over arrays of elements that may have a larger element to element
    offset, called the stride, than the size of the element itself (non-contiguous).

    The template parameter T denotes the type of the element accessed. The stride itself
    is stored as a member field so multiple instances of a PxStrideIterator class can have
    different strides. This is useful for cases were the stride depends on runtime configuration.

    The stride iterator can be used for index based access, e.g.:
    \code
    PxStrideIterator<PxVec3> strideArray(...);
    for (unsigned i = 0; i < 10; ++i)
    {
    PxVec3& vec = strideArray[i];
    ...
    }
    \endcode
    or iteration by increment, e.g.:
    \code
    PxStrideIterator<PxVec3> strideBegin(...);
    PxStrideIterator<PxVec3> strideEnd(strideBegin + 10);
    for (PxStrideIterator<PxVec3> it = strideBegin; it < strideEnd; ++it)
    {
    PxVec3& vec = *it;
    ...
    }
    \endcode

    Two special cases:
    - A stride of sizeof(T) represents a regular c array of type T.
    - A stride of 0 can be used to describe re-occurrence of the same element multiple times.

    */
    PxStrideIterator :: struct(T: Type) {
        StripConst :: struct(X: Type) {
            Type :: X;
        }

        mPtr:    *T;
        mStride: PxU32;
    }

    /**
    \brief 2 Element vector class.

    This is a 2-dimensional vector class with public data members.
    */
    PxVec2 :: struct {
        /**
        \brief default constructor leaves data uninitialized.
        */
        Constructor :: (this: *PxVec2) -> void #cpp_method #foreign physx_lib "??0PxVec2@physx@@QEAA@XZ";

        /**
        \brief zero constructor.
        */
        Constructor :: (this: *PxVec2, r: PxZERO) -> void #cpp_method #foreign physx_lib "??0PxVec2@physx@@QEAA@W4PxZERO@1@@Z";

        /**
        \brief Assigns scalar parameter to all elements.

        Useful to initialize to zero or one.

        \param[in] a Value to assign to elements.
        */
        Constructor :: (this: *PxVec2, a: float) -> void #cpp_method #foreign physx_lib "??0PxVec2@physx@@QEAA@M@Z";

        /**
        \brief Initializes from 2 scalar parameters.

        \param[in] nx Value to initialize X component.
        \param[in] ny Value to initialize Y component.
        */
        Constructor :: (this: *PxVec2, nx: float, ny: float) -> void #cpp_method #foreign physx_lib "??0PxVec2@physx@@QEAA@MM@Z";

        /**
        \brief Copy ctor.
        */
        CopyConstructor :: (this: *PxVec2, v: *PxVec2) -> void #cpp_method #foreign physx_lib "??0PxVec2@physx@@QEAA@AEBV01@@Z";
        CopyConstructor :: (this: *PxVec2, v: PxVec2) #no_context {
            CopyConstructor(this, *v);
        }

        /**
        \brief tests for exact zero vector
        */
        isZero :: (this: *PxVec2) -> bool #cpp_method #foreign physx_lib "?isZero@PxVec2@physx@@QEBA_NXZ";

        /**
        \brief returns true if all 2 elems of the vector are finite (not NAN or INF, etc.)
        */
        isFinite :: (this: *PxVec2) -> bool #cpp_method #foreign physx_lib "?isFinite@PxVec2@physx@@QEBA_NXZ";

        /**
        \brief is normalized - used by API parameter validation
        */
        isNormalized :: (this: *PxVec2) -> bool #cpp_method #foreign physx_lib "?isNormalized@PxVec2@physx@@QEBA_NXZ";

        /**
        \brief returns the squared magnitude

        Avoids calling PxSqrt()!
        */
        magnitudeSquared :: (this: *PxVec2) -> float #cpp_method #foreign physx_lib "?magnitudeSquared@PxVec2@physx@@QEBAMXZ";

        /**
        \brief returns the magnitude
        */
        magnitude :: (this: *PxVec2) -> float #cpp_method #foreign physx_lib "?magnitude@PxVec2@physx@@QEBAMXZ";

        /**
        \brief returns the scalar product of this and other.
        */
        dot :: (this: *PxVec2, v: *PxVec2) -> float #cpp_method #foreign physx_lib "?dot@PxVec2@physx@@QEBAMAEBV12@@Z";
        dot :: (this: *PxVec2, v: PxVec2) -> float #no_context {
            return dot(this, *v);
        }

        /** return a unit vector */
        getNormalized :: (this: *PxVec2) -> PxVec2 #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "?getNormalized@PxVec2@physx@@QEBA?AV12@XZ";

        /**
        \brief normalizes the vector in place
        */
        normalize :: (this: *PxVec2) -> float #cpp_method #foreign physx_lib "?normalize@PxVec2@physx@@QEAAMXZ";

        /**
        \brief a[i] * b[i], for all i.
        */
        multiply :: (this: *PxVec2, a: *PxVec2) -> PxVec2 #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "?multiply@PxVec2@physx@@QEBA?AV12@AEBV12@@Z";
        multiply :: (this: *PxVec2, a: PxVec2) -> PxVec2 #no_context {
            return multiply(this, *a);
        }

        /**
        \brief element-wise minimum
        */
        minimum :: (this: *PxVec2, v: *PxVec2) -> PxVec2 #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "?minimum@PxVec2@physx@@QEBA?AV12@AEBV12@@Z";
        minimum :: (this: *PxVec2, v: PxVec2) -> PxVec2 #no_context {
            return minimum(this, *v);
        }

        /**
        \brief returns MIN(x, y);
        */
        minElement :: (this: *PxVec2) -> float #cpp_method #foreign physx_lib "?minElement@PxVec2@physx@@QEBAMXZ";

        /**
        \brief element-wise maximum
        */
        maximum :: (this: *PxVec2, v: *PxVec2) -> PxVec2 #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "?maximum@PxVec2@physx@@QEBA?AV12@AEBV12@@Z";
        maximum :: (this: *PxVec2, v: PxVec2) -> PxVec2 #no_context {
            return maximum(this, *v);
        }

        /**
        \brief returns MAX(x, y);
        */
        maxElement :: (this: *PxVec2) -> float #cpp_method #foreign physx_lib "?maxElement@PxVec2@physx@@QEBAMXZ";

        x: float;
        y: float;
    }

    /**
    \brief scalar post-multiplication
    */
    operator* :: (this: *physx.PxVec2, f: float) -> physx.PxVec2 #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "??DPxVec2@physx@@QEBA?AV01@M@Z";
    operator* :: (this: physx.PxVec2, f: float) -> physx.PxVec2 #no_context {
        return operator*(*this, f);
    }

    /**
    \brief scalar division
    */
    operator/= :: (this: *physx.PxVec2, f: float) -> *physx.PxVec2 #cpp_method #foreign physx_lib "??_0PxVec2@physx@@QEAAAEAV01@M@Z";
    #run {if true then return;
        instance: PxVec2;
        assert(((cast(*void)(*instance.x)) - cast(*void)(*instance)) == 0, "PxVec2.x has unexpected offset % instead of 0", ((cast(*void)(*instance.x)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVec2.x)) == 4, "PxVec2.x has unexpected size % instead of 4", size_of(type_of(PxVec2.x)));
        assert(((cast(*void)(*instance.y)) - cast(*void)(*instance)) == 4, "PxVec2.y has unexpected offset % instead of 4", ((cast(*void)(*instance.y)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVec2.y)) == 4, "PxVec2.y has unexpected size % instead of 4", size_of(type_of(PxVec2.y)));
        assert(size_of(PxVec2) == 8, "PxVec2 has size % instead of 8", size_of(PxVec2));
    }

    /**
    \brief Sets the bytes of the provided buffer to zero.

    \param dest Pointer to block of memory to set zero.
    \param count Number of bytes to set to zero.

    \return Pointer to memory block (same as input)
    */
    PxMemZero :: (dest: *void, count: PxU32) -> *void #foreign physx_lib "?PxMemZero@physx@@YAPEAXPEAXI@Z";

    /**
    \brief Sets the bytes of the provided buffer to the specified value.

    \param dest Pointer to block of memory to set to the specified value.
    \param c Value to set the bytes of the block of memory to.
    \param count Number of bytes to set to the specified value.

    \return Pointer to memory block (same as input)
    */
    PxMemSet :: (dest: *void, c: PxI32, count: PxU32) -> *void #foreign physx_lib "?PxMemSet@physx@@YAPEAXPEAXHI@Z";

    /**
    \brief Copies the bytes of one memory block to another. The memory blocks must not overlap.

    \note Use #PxMemMove if memory blocks overlap.

    \param dest Pointer to block of memory to copy to.
    \param src Pointer to block of memory to copy from.
    \param count Number of bytes to copy.

    \return Pointer to destination memory block
    */
    PxMemCopy :: (dest: *void, src: *void, count: PxU32) -> *void #foreign physx_lib "?PxMemCopy@physx@@YAPEAXPEAXPEBXI@Z";

    /**
    \brief Copies the bytes of one memory block to another. The memory blocks can overlap.

    \note Use #PxMemCopy if memory blocks do not overlap.

    \param dest Pointer to block of memory to copy to.
    \param src Pointer to block of memory to copy from.
    \param count Number of bytes to copy.

    \return Pointer to destination memory block
    */
    PxMemMove :: (dest: *void, src: *void, count: PxU32) -> *void #foreign physx_lib "?PxMemMove@physx@@YAPEAXPEAXPEBXI@Z";

    PxStridedData :: struct {
        /**
        \brief The offset in bytes between consecutive samples in the data.

        <b>Default:</b> 0
        */
        stride: PxU32;
        data:   *void;

        Constructor :: (this: *PxStridedData) -> void #cpp_method #foreign physx_lib "??0PxStridedData@physx@@QEAA@XZ";
    }
    #run {if true then return;
        instance: PxStridedData;
        assert(((cast(*void)(*instance.stride)) - cast(*void)(*instance)) == 0, "PxStridedData.stride has unexpected offset % instead of 0", ((cast(*void)(*instance.stride)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxStridedData.stride)) == 4, "PxStridedData.stride has unexpected size % instead of 4", size_of(type_of(PxStridedData.stride)));
        assert(((cast(*void)(*instance.data)) - cast(*void)(*instance)) == 8, "PxStridedData.data has unexpected offset % instead of 8", ((cast(*void)(*instance.data)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxStridedData.data)) == 8, "PxStridedData.data has unexpected size % instead of 8", size_of(type_of(PxStridedData.data)));
        assert(size_of(PxStridedData) == 16, "PxStridedData has size % instead of 16", size_of(PxStridedData));
    }

    PxTypedStridedData :: struct(TDataType: Type) {
        stride: PxU32;
        data:   *TDataType;
    }

    PxBoundedData :: struct {
        #as using pxstrideddata: PxStridedData;

        count: PxU32;
        Constructor :: (this: *PxBoundedData) -> void #cpp_method #foreign physx_lib "??0PxBoundedData@physx@@QEAA@XZ";
    }
    #run {if true then return;
        assert(size_of(type_of(PxBoundedData.pxstrideddata)) == 16, "PxBoundedData.pxstrideddata has unexpected size % instead of 16", size_of(type_of(PxBoundedData.pxstrideddata)));
        instance: PxBoundedData;
        assert(((cast(*void)(*instance.count)) - cast(*void)(*instance)) == 16, "PxBoundedData.count has unexpected offset % instead of 16", ((cast(*void)(*instance.count)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxBoundedData.count)) == 4, "PxBoundedData.count has unexpected size % instead of 4", size_of(type_of(PxBoundedData.count)));
        assert(size_of(PxBoundedData) == 24, "PxBoundedData has size % instead of 24", size_of(PxBoundedData));
    }

    PxPadding :: struct(TNumBytes: PxU8) {
        mPadding: [TNumBytes] PxU8;
    }

    PxFixedSizeLookupTable :: struct(NB_ELEMENTS: PxU32) {
        mDataPairs:   [NB_ELEMENTS] PxReal;
        mNbDataPairs: PxU32;
        mPad:         [3] PxU32;
    }

    PxTriangleID :: PxU32;
    PxMaterialTableIndex :: PxU16;

    /**
    \brief Default color values used for debug rendering.
    */
    PxDebugColor :: struct {
        Enum :: enum s32 {
            BLACK     :: -16777216;
            RED       :: -65536;
            GREEN     :: -16711936;
            BLUE      :: -16776961;
            YELLOW    :: -256;
            MAGENTA   :: -65281;
            CYAN      :: -16711681;
            WHITE     :: -1;
            GREY      :: -8355712;
            DARKRED   :: -2004353024;
            DARKGREEN :: -2013231104;
            DARKBLUE  :: -2013265784;

            eARGB_BLACK     :: BLACK;
            eARGB_RED       :: RED;
            eARGB_GREEN     :: GREEN;
            eARGB_BLUE      :: BLUE;
            eARGB_YELLOW    :: YELLOW;
            eARGB_MAGENTA   :: MAGENTA;
            eARGB_CYAN      :: CYAN;
            eARGB_WHITE     :: WHITE;
            eARGB_GREY      :: GREY;
            eARGB_DARKRED   :: DARKRED;
            eARGB_DARKGREEN :: DARKGREEN;
            eARGB_DARKBLUE  :: DARKBLUE;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxDebugColor) == 1, "PxDebugColor has size % instead of 1", size_of(PxDebugColor));
    }

    /**
    \brief Used to store a single point and colour for debug rendering.
    */
    PxDebugPoint :: struct {
        Constructor :: (this: *PxDebugPoint, p: *PxVec3, c: *PxU32) -> void #cpp_method #foreign physx_lib "??0PxDebugPoint@physx@@QEAA@AEBVPxVec3@1@AEBI@Z";
        Constructor :: (this: *PxDebugPoint, p: PxVec3, c: PxU32) #no_context {
            Constructor(this, *p, *c);
        }

        pos:   PxVec3;
        color: PxU32;
    }
    #run {if true then return;
        instance: PxDebugPoint;
        assert(((cast(*void)(*instance.pos)) - cast(*void)(*instance)) == 0, "PxDebugPoint.pos has unexpected offset % instead of 0", ((cast(*void)(*instance.pos)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxDebugPoint.pos)) == 12, "PxDebugPoint.pos has unexpected size % instead of 12", size_of(type_of(PxDebugPoint.pos)));
        assert(((cast(*void)(*instance.color)) - cast(*void)(*instance)) == 12, "PxDebugPoint.color has unexpected offset % instead of 12", ((cast(*void)(*instance.color)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxDebugPoint.color)) == 4, "PxDebugPoint.color has unexpected size % instead of 4", size_of(type_of(PxDebugPoint.color)));
        assert(size_of(PxDebugPoint) == 16, "PxDebugPoint has size % instead of 16", size_of(PxDebugPoint));
    }

    /**
    \brief Used to store a single line and colour for debug rendering.
    */
    PxDebugLine :: struct {
        Constructor :: (this: *PxDebugLine, p0: *PxVec3, p1: *PxVec3, c: *PxU32) -> void #cpp_method #foreign physx_lib "??0PxDebugLine@physx@@QEAA@AEBVPxVec3@1@0AEBI@Z";
        Constructor :: (this: *PxDebugLine, p0: PxVec3, p1: PxVec3, c: PxU32) #no_context {
            Constructor(this, *p0, *p1, *c);
        }

        pos0:   PxVec3;
        color0: PxU32;
        pos1:   PxVec3;
        color1: PxU32;
    }
    #run {if true then return;
        instance: PxDebugLine;
        assert(((cast(*void)(*instance.pos0)) - cast(*void)(*instance)) == 0, "PxDebugLine.pos0 has unexpected offset % instead of 0", ((cast(*void)(*instance.pos0)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxDebugLine.pos0)) == 12, "PxDebugLine.pos0 has unexpected size % instead of 12", size_of(type_of(PxDebugLine.pos0)));
        assert(((cast(*void)(*instance.color0)) - cast(*void)(*instance)) == 12, "PxDebugLine.color0 has unexpected offset % instead of 12", ((cast(*void)(*instance.color0)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxDebugLine.color0)) == 4, "PxDebugLine.color0 has unexpected size % instead of 4", size_of(type_of(PxDebugLine.color0)));
        assert(((cast(*void)(*instance.pos1)) - cast(*void)(*instance)) == 16, "PxDebugLine.pos1 has unexpected offset % instead of 16", ((cast(*void)(*instance.pos1)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxDebugLine.pos1)) == 12, "PxDebugLine.pos1 has unexpected size % instead of 12", size_of(type_of(PxDebugLine.pos1)));
        assert(((cast(*void)(*instance.color1)) - cast(*void)(*instance)) == 28, "PxDebugLine.color1 has unexpected offset % instead of 28", ((cast(*void)(*instance.color1)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxDebugLine.color1)) == 4, "PxDebugLine.color1 has unexpected size % instead of 4", size_of(type_of(PxDebugLine.color1)));
        assert(size_of(PxDebugLine) == 32, "PxDebugLine has size % instead of 32", size_of(PxDebugLine));
    }

    /**
    \brief Used to store a single triangle and colour for debug rendering.
    */
    PxDebugTriangle :: struct {
        Constructor :: (this: *PxDebugTriangle, p0: *PxVec3, p1: *PxVec3, p2: *PxVec3, c: *PxU32) -> void #cpp_method #foreign physx_lib "??0PxDebugTriangle@physx@@QEAA@AEBVPxVec3@1@00AEBI@Z";
        Constructor :: (this: *PxDebugTriangle, p0: PxVec3, p1: PxVec3, p2: PxVec3, c: PxU32) #no_context {
            Constructor(this, *p0, *p1, *p2, *c);
        }

        pos0:   PxVec3;
        color0: PxU32;
        pos1:   PxVec3;
        color1: PxU32;
        pos2:   PxVec3;
        color2: PxU32;
    }
    #run {if true then return;
        instance: PxDebugTriangle;
        assert(((cast(*void)(*instance.pos0)) - cast(*void)(*instance)) == 0, "PxDebugTriangle.pos0 has unexpected offset % instead of 0", ((cast(*void)(*instance.pos0)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxDebugTriangle.pos0)) == 12, "PxDebugTriangle.pos0 has unexpected size % instead of 12", size_of(type_of(PxDebugTriangle.pos0)));
        assert(((cast(*void)(*instance.color0)) - cast(*void)(*instance)) == 12, "PxDebugTriangle.color0 has unexpected offset % instead of 12", ((cast(*void)(*instance.color0)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxDebugTriangle.color0)) == 4, "PxDebugTriangle.color0 has unexpected size % instead of 4", size_of(type_of(PxDebugTriangle.color0)));
        assert(((cast(*void)(*instance.pos1)) - cast(*void)(*instance)) == 16, "PxDebugTriangle.pos1 has unexpected offset % instead of 16", ((cast(*void)(*instance.pos1)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxDebugTriangle.pos1)) == 12, "PxDebugTriangle.pos1 has unexpected size % instead of 12", size_of(type_of(PxDebugTriangle.pos1)));
        assert(((cast(*void)(*instance.color1)) - cast(*void)(*instance)) == 28, "PxDebugTriangle.color1 has unexpected offset % instead of 28", ((cast(*void)(*instance.color1)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxDebugTriangle.color1)) == 4, "PxDebugTriangle.color1 has unexpected size % instead of 4", size_of(type_of(PxDebugTriangle.color1)));
        assert(((cast(*void)(*instance.pos2)) - cast(*void)(*instance)) == 32, "PxDebugTriangle.pos2 has unexpected offset % instead of 32", ((cast(*void)(*instance.pos2)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxDebugTriangle.pos2)) == 12, "PxDebugTriangle.pos2 has unexpected size % instead of 12", size_of(type_of(PxDebugTriangle.pos2)));
        assert(((cast(*void)(*instance.color2)) - cast(*void)(*instance)) == 44, "PxDebugTriangle.color2 has unexpected offset % instead of 44", ((cast(*void)(*instance.color2)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxDebugTriangle.color2)) == 4, "PxDebugTriangle.color2 has unexpected size % instead of 4", size_of(type_of(PxDebugTriangle.color2)));
        assert(size_of(PxDebugTriangle) == 48, "PxDebugTriangle has size % instead of 48", size_of(PxDebugTriangle));
    }

    /**
    \brief Used to store a text for debug rendering. Doesn't own 'string' array.
    */
    PxDebugText :: struct {
        Constructor :: (this: *PxDebugText) -> void #cpp_method #foreign physx_lib "??0PxDebugText@physx@@QEAA@XZ";

        Constructor :: (this: *PxDebugText, p: *PxVec3, s: *PxReal, c: *PxU32, str: *u8) -> void #cpp_method #foreign physx_lib "??0PxDebugText@physx@@QEAA@AEBVPxVec3@1@AEBMAEBIPEBD@Z";
        Constructor :: (this: *PxDebugText, p: PxVec3, s: PxReal, c: PxU32, str: *u8) #no_context {
            Constructor(this, *p, *s, *c, str);
        }

        position: PxVec3;
        size:     PxReal;
        color:    PxU32;
        _string:  *u8;
    }
    #run {if true then return;
        instance: PxDebugText;
        assert(((cast(*void)(*instance.position)) - cast(*void)(*instance)) == 0, "PxDebugText.position has unexpected offset % instead of 0", ((cast(*void)(*instance.position)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxDebugText.position)) == 12, "PxDebugText.position has unexpected size % instead of 12", size_of(type_of(PxDebugText.position)));
        assert(((cast(*void)(*instance.size)) - cast(*void)(*instance)) == 12, "PxDebugText.size has unexpected offset % instead of 12", ((cast(*void)(*instance.size)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxDebugText.size)) == 4, "PxDebugText.size has unexpected size % instead of 4", size_of(type_of(PxDebugText.size)));
        assert(((cast(*void)(*instance.color)) - cast(*void)(*instance)) == 16, "PxDebugText.color has unexpected offset % instead of 16", ((cast(*void)(*instance.color)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxDebugText.color)) == 4, "PxDebugText.color has unexpected size % instead of 4", size_of(type_of(PxDebugText.color)));
        assert(((cast(*void)(*instance._string)) - cast(*void)(*instance)) == 24, "PxDebugText._string has unexpected offset % instead of 24", ((cast(*void)(*instance._string)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxDebugText._string)) == 8, "PxDebugText._string has unexpected size % instead of 8", size_of(type_of(PxDebugText._string)));
        assert(size_of(PxDebugText) == 32, "PxDebugText has size % instead of 32", size_of(PxDebugText));
    }

    /**
    \brief Interface for points, lines, triangles, and text buffer.
    */
    PxRenderBuffer :: struct {
        vtable: *PxRenderBuffer_VTable;
    }
    PxRenderBuffer_VTable :: struct #type_info_none {
        Destructor: (this: *PxRenderBuffer, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

        getNbPoints: (this: *PxRenderBuffer) -> PxU32 #cpp_method;
        getPoints: (this: *PxRenderBuffer) -> *PxDebugPoint #cpp_method;

        getNbLines: (this: *PxRenderBuffer) -> PxU32 #cpp_method;
        getLines: (this: *PxRenderBuffer) -> *PxDebugLine #cpp_method;

        getNbTriangles: (this: *PxRenderBuffer) -> PxU32 #cpp_method;
        getTriangles: (this: *PxRenderBuffer) -> *PxDebugTriangle #cpp_method;

        getNbTexts: (this: *PxRenderBuffer) -> PxU32 #cpp_method;
        getTexts: (this: *PxRenderBuffer) -> *PxDebugText #cpp_method;

        append: (this: *PxRenderBuffer, other: *PxRenderBuffer) -> void #cpp_method;
        clear: (this: *PxRenderBuffer) -> void #cpp_method;
    }

    PxRenderBuffer_Destructor :: inline (this: *PxRenderBuffer, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    PxRenderBuffer_getNbPoints :: inline (this: *PxRenderBuffer) -> PxU32 { return this.vtable.getNbPoints(this); }
    PxRenderBuffer_getPoints :: inline (this: *PxRenderBuffer) -> *PxDebugPoint { return this.vtable.getPoints(this); }

    PxRenderBuffer_getNbLines :: inline (this: *PxRenderBuffer) -> PxU32 { return this.vtable.getNbLines(this); }
    PxRenderBuffer_getLines :: inline (this: *PxRenderBuffer) -> *PxDebugLine { return this.vtable.getLines(this); }

    PxRenderBuffer_getNbTriangles :: inline (this: *PxRenderBuffer) -> PxU32 { return this.vtable.getNbTriangles(this); }
    PxRenderBuffer_getTriangles :: inline (this: *PxRenderBuffer) -> *PxDebugTriangle { return this.vtable.getTriangles(this); }

    PxRenderBuffer_getNbTexts :: inline (this: *PxRenderBuffer) -> PxU32 { return this.vtable.getNbTexts(this); }
    PxRenderBuffer_getTexts :: inline (this: *PxRenderBuffer) -> *PxDebugText { return this.vtable.getTexts(this); }

    PxRenderBuffer_append :: inline (this: *PxRenderBuffer, other: *PxRenderBuffer) { this.vtable.append(this, other); }
    PxRenderBuffer_clear :: inline (this: *PxRenderBuffer) { this.vtable.clear(this); }

    vtable :: (obj: *PxRenderBuffer) -> *PxRenderBuffer_VTable { return obj.vtable; }

    #run {if true then return;
        assert(size_of(PxRenderBuffer) == 8, "PxRenderBuffer has size % instead of 8", size_of(PxRenderBuffer));
    }

    PxType :: PxU16;

    //! ID type for PxBase objects in a PxCollection
    PxSerialObjectId :: PxU64;

    /**
    \brief Callback class used to process PxBase objects.

    @see PxSerializer::requires
    */
    PxProcessPxBaseCallback :: struct {
        vtable: *PxProcessPxBaseCallback_VTable;
    }
    PxProcessPxBaseCallback_VTable :: struct #type_info_none {
        Destructor: (this: *PxProcessPxBaseCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
        process: (this: *PxProcessPxBaseCallback, unknown0: *PxBase) -> void #cpp_method;
    }

    PxProcessPxBaseCallback_Destructor :: inline (this: *PxProcessPxBaseCallback, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }
    PxProcessPxBaseCallback_process :: inline (this: *PxProcessPxBaseCallback, unknown0: *PxBase) { this.vtable.process(this, unknown0); }

    vtable :: (obj: *PxProcessPxBaseCallback) -> *PxProcessPxBaseCallback_VTable { return obj.vtable; }

    #run {if true then return;
        assert(size_of(PxProcessPxBaseCallback) == 8, "PxProcessPxBaseCallback has size % instead of 8", size_of(PxProcessPxBaseCallback));
    }

    /**
    \brief Binary serialization context class.

    This class is used to register reference values and write object
    and object extra data during serialization.
    It is mainly used by the serialization framework. Except for custom
    serializable types, users should not have to worry about it.

    @see PxDeserializationContext
    */
    PxSerializationContext :: struct {
        vtable: *PxSerializationContext_VTable;
    }
    PxSerializationContext_VTable :: struct #type_info_none {
        registerReference: (this: *PxSerializationContext, base: *PxBase, kind: PxU32, reference: size_t) -> void #cpp_method;

        getCollection: (this: *PxSerializationContext) -> *PxCollection #cpp_method;

        writeData: (this: *PxSerializationContext, data: *void, size: PxU32) -> void #cpp_method;

        alignData: (this: *PxSerializationContext, alignment: PxU32 = 16) -> void #cpp_method;

        writeName: (this: *PxSerializationContext, name: *u8) -> void #cpp_method;

        Destructor: (this: *PxSerializationContext, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxSerializationContext_registerReference :: inline (this: *PxSerializationContext, base: *PxBase, kind: PxU32, reference: size_t) { this.vtable.registerReference(this, base, kind, reference); }

    PxSerializationContext_getCollection :: inline (this: *PxSerializationContext) -> *PxCollection { return this.vtable.getCollection(this); }

    PxSerializationContext_writeData :: inline (this: *PxSerializationContext, data: *void, size: PxU32) { this.vtable.writeData(this, data, size); }

    PxSerializationContext_alignData :: inline (this: *PxSerializationContext, alignment: PxU32 = 16) { this.vtable.alignData(this, alignment); }

    PxSerializationContext_writeName :: inline (this: *PxSerializationContext, name: *u8) { this.vtable.writeName(this, name); }

    PxSerializationContext_Destructor :: inline (this: *PxSerializationContext, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxSerializationContext) -> *PxSerializationContext_VTable { return obj.vtable; }

    #run {if true then return;
        assert(size_of(PxSerializationContext) == 8, "PxSerializationContext has size % instead of 8", size_of(PxSerializationContext));
    }

    /**
    \brief Binary deserialization context class.

    This class is used to resolve references and access extra data during deserialization.
    It is mainly used by the serialization framework. Except for custom
    serializable types, users should not have to worry about it.

    @see PxSerializationContext
    */
    PxDeserializationContext :: struct {
        vtable: *PxDeserializationContext_VTable;
        /**
        \brief Helper function to read a name from the extra data during deserialization.

        This function is assumed to be called within the implementation of PxSerializer::createObject.

        @see PxSerializationContext::writeName
        */
        readName :: (this: *PxDeserializationContext, name: **u8) -> void #cpp_method #foreign physx_lib "?readName@PxDeserializationContext@physx@@QEAAXAEAPEBD@Z";

        /**
        \brief Function to align the extra data stream to a power of 2 alignment

        This function is assumed to be called within the implementation of PxSerializer::createObject.

        @see PxSerializationContext::alignData, PxSerializer::createObject
        */
        alignExtraData :: (this: *PxDeserializationContext, alignment: PxU32 = 16) -> void #cpp_method #foreign physx_lib "?alignExtraData@PxDeserializationContext@physx@@QEAAXI@Z";

        mExtraDataAddress: *PxU8;
    }
    PxDeserializationContext_VTable :: struct #type_info_none {
        resolveReference: (this: *PxDeserializationContext, kind: PxU32, reference: size_t) -> *PxBase #cpp_method;

        Destructor: (this: *PxDeserializationContext, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxDeserializationContext_resolveReference :: inline (this: *PxDeserializationContext, kind: PxU32, reference: size_t) -> *PxBase { return this.vtable.resolveReference(this, kind, reference); }

    PxDeserializationContext_Destructor :: inline (this: *PxDeserializationContext, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxDeserializationContext) -> *PxDeserializationContext_VTable { return obj.vtable; }

    #run {if true then return;
        instance: PxDeserializationContext;
        assert(((cast(*void)(*instance.mExtraDataAddress)) - cast(*void)(*instance)) == 8, "PxDeserializationContext.mExtraDataAddress has unexpected offset % instead of 8", ((cast(*void)(*instance.mExtraDataAddress)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxDeserializationContext.mExtraDataAddress)) == 8, "PxDeserializationContext.mExtraDataAddress has unexpected size % instead of 8", size_of(type_of(PxDeserializationContext.mExtraDataAddress)));
        assert(size_of(PxDeserializationContext) == 16, "PxDeserializationContext has size % instead of 16", size_of(PxDeserializationContext));
    }

    /**
    \brief Callback type for exporting binary meta data for a serializable type.
    @see PxSerializationRegistry::registerBinaryMetaDataCallback

    \param stream	Stream to store binary meta data.
    */
    PxBinaryMetaDataCallback :: #type (stream: *PxOutputStream) -> void #c_call;

    /**
    \brief Class serving as a registry for XML (RepX) and binary serializable types.

    In order to serialize and deserialize objects the application needs
    to maintain an instance of this class. It can be created with
    PxSerialization::createSerializationRegistry() and released with
    PxSerializationRegistry::release().

    @see PxSerialization::createSerializationRegistry
    */
    PxSerializationRegistry :: struct {
        vtable: *PxSerializationRegistry_VTable;
    }
    PxSerializationRegistry_VTable :: struct #type_info_none {
        registerSerializer: (this: *PxSerializationRegistry, type: PxType, serializer: *PxSerializer) -> void #cpp_method;

        unregisterSerializer: (this: *PxSerializationRegistry, type: PxType) -> *PxSerializer #cpp_method;

        registerBinaryMetaDataCallback: (this: *PxSerializationRegistry, callback: PxBinaryMetaDataCallback) -> void #cpp_method;

        getSerializer: (this: *PxSerializationRegistry, type: PxType) -> *PxSerializer #cpp_method;

        registerRepXSerializer: (this: *PxSerializationRegistry, type: PxType, serializer: *PxRepXSerializer) -> void #cpp_method;

        unregisterRepXSerializer: (this: *PxSerializationRegistry, type: PxType) -> *PxRepXSerializer #cpp_method;

        getRepXSerializer: (this: *PxSerializationRegistry, typeName: *u8) -> *PxRepXSerializer #cpp_method;

        release: (this: *PxSerializationRegistry) -> void #cpp_method;

        Destructor: (this: *PxSerializationRegistry, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxSerializationRegistry_registerSerializer :: inline (this: *PxSerializationRegistry, type: PxType, serializer: *PxSerializer) { this.vtable.registerSerializer(this, type, serializer); }

    PxSerializationRegistry_unregisterSerializer :: inline (this: *PxSerializationRegistry, type: PxType) -> *PxSerializer { return this.vtable.unregisterSerializer(this, type); }

    PxSerializationRegistry_registerBinaryMetaDataCallback :: inline (this: *PxSerializationRegistry, callback: PxBinaryMetaDataCallback) { this.vtable.registerBinaryMetaDataCallback(this, callback); }

    PxSerializationRegistry_getSerializer :: inline (this: *PxSerializationRegistry, type: PxType) -> *PxSerializer { return this.vtable.getSerializer(this, type); }

    PxSerializationRegistry_registerRepXSerializer :: inline (this: *PxSerializationRegistry, type: PxType, serializer: *PxRepXSerializer) { this.vtable.registerRepXSerializer(this, type, serializer); }

    PxSerializationRegistry_unregisterRepXSerializer :: inline (this: *PxSerializationRegistry, type: PxType) -> *PxRepXSerializer { return this.vtable.unregisterRepXSerializer(this, type); }

    PxSerializationRegistry_getRepXSerializer :: inline (this: *PxSerializationRegistry, typeName: *u8) -> *PxRepXSerializer { return this.vtable.getRepXSerializer(this, typeName); }

    PxSerializationRegistry_release :: inline (this: *PxSerializationRegistry) { this.vtable.release(this); }

    PxSerializationRegistry_Destructor :: inline (this: *PxSerializationRegistry, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxSerializationRegistry) -> *PxSerializationRegistry_VTable { return obj.vtable; }

    #run {if true then return;
        assert(size_of(PxSerializationRegistry) == 8, "PxSerializationRegistry has size % instead of 8", size_of(PxSerializationRegistry));
    }

    /**
    \brief Collection class for serialization.

    A collection is a set of PxBase objects. PxBase objects can be added to the collection
    regardless of other objects they depend on. Objects may be named using PxSerialObjectId values in order
    to resolve dependencies between objects of different collections.

    Serialization and deserialization only work through collections.

    A scene is typically serialized using the following steps:

    -# create a serialization registry
    -# create a collection for scene objects
    -# complete the scene objects (adds all dependent objects, e.g. meshes)
    -# serialize collection
    -# release collection
    -# release serialization registry

    For example the code may look like this:

    \code
    PxPhysics* physics; // The physics
    PxScene* scene;		// The physics scene
    SerialStream s;		// The user-defined stream doing the actual write to disk

    PxSerializationRegistry* registry = PxSerialization::createSerializationRegistry(*physics);	// step 1)
    PxCollection* collection = PxSerialization::createCollection(*scene);						// step 2)
    PxSerialization::complete(*collection, *registry);											// step 3)
    PxSerialization::serializeCollectionToBinary(s, *collection, *registry);					// step 4)
    collection->release();																		// step 5)
    registry->release();																		// step 6)
    \endcode

    A scene is typically deserialized using the following steps:

    -# load a serialized collection into memory
    -# create a serialization registry
    -# create a collection by passing the serialized memory block
    -# add collected objects to scene
    -# release collection
    -# release serialization registry

    For example the code may look like this:

    \code
    PxPhysics* physics; // The physics
    PxScene* scene;		// The physics scene
    void* memory128;	// a 128-byte aligned buffer previously loaded from disk by the user	- step 1)

    PxSerializationRegistry* registry = PxSerialization::createSerializationRegistry(*physics);		// step 2)
    PxCollection* collection = PxSerialization::createCollectionFromBinary(memory128, *registry);	// step 3)
    scene->addCollection(*collection);																// step 4)
    collection->release();																			// step 5)
    registry->release();																			// step 6)
    \endcode

    @see PxBase, PxCreateCollection()
    */
    PxCollection :: struct {
        vtable: *PxCollection_VTable;
    }
    PxCollection_VTable :: struct #type_info_none {
        add: (this: *PxCollection, collection: *PxCollection) -> void #cpp_method;

        add_1: (this: *PxCollection, object: /*reference*/ *PxBase, id: PxSerialObjectId = 0) -> void #cpp_method;

        _remove: (this: *PxCollection, collection: *PxCollection) -> void #cpp_method;

        _remove_1: (this: *PxCollection, object: /*reference*/ *PxBase) -> void #cpp_method;

        contains: (this: *PxCollection, object: *PxBase) -> bool #cpp_method;

        addId: (this: *PxCollection, object: *PxBase, id: PxSerialObjectId) -> void #cpp_method;

        removeId: (this: *PxCollection, id: PxSerialObjectId) -> void #cpp_method;

        getNbObjects: (this: *PxCollection) -> PxU32 #cpp_method;

        getObject: (this: *PxCollection, index: PxU32) -> *PxBase #cpp_method;

        getObjects: (this: *PxCollection, userBuffer: **PxBase, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        find: (this: *PxCollection, id: PxSerialObjectId) -> *PxBase #cpp_method;

        getNbIds: (this: *PxCollection) -> PxU32 #cpp_method;

        getIds: (this: *PxCollection, userBuffer: *PxSerialObjectId, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        getId: (this: *PxCollection, object: *PxBase) -> PxSerialObjectId #cpp_method;

        release: (this: *PxCollection) -> void #cpp_method;

        Destructor: (this: *PxCollection, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxCollection_add :: inline (this: *PxCollection, collection: /*reference*/ *PxCollection) { this.vtable.add(this, collection); }

    PxCollection_add_1 :: inline (this: *PxCollection, object: /*reference*/ *PxBase, id: PxSerialObjectId = 0) { this.vtable.add_1(this, object, id); }

    PxCollection__remove :: inline (this: *PxCollection, collection: /*reference*/ *PxCollection) { this.vtable._remove(this, collection); }

    PxCollection__remove_1 :: inline (this: *PxCollection, object: /*reference*/ *PxBase) { this.vtable._remove_1(this, object); }

    PxCollection_contains :: inline (this: *PxCollection, object: *PxBase) -> bool { return this.vtable.contains(this, object); }

    PxCollection_addId :: inline (this: *PxCollection, object: *PxBase, id: PxSerialObjectId) { this.vtable.addId(this, object, id); }

    PxCollection_removeId :: inline (this: *PxCollection, id: PxSerialObjectId) { this.vtable.removeId(this, id); }

    PxCollection_getNbObjects :: inline (this: *PxCollection) -> PxU32 { return this.vtable.getNbObjects(this); }

    PxCollection_getObject :: inline (this: *PxCollection, index: PxU32) -> *PxBase { return this.vtable.getObject(this, index); }

    PxCollection_getObjects :: inline (this: *PxCollection, userBuffer: **PxBase, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.vtable.getObjects(this, userBuffer, bufferSize, startIndex); }

    PxCollection_find :: inline (this: *PxCollection, id: PxSerialObjectId) -> *PxBase { return this.vtable.find(this, id); }

    PxCollection_getNbIds :: inline (this: *PxCollection) -> PxU32 { return this.vtable.getNbIds(this); }

    PxCollection_getIds :: inline (this: *PxCollection, userBuffer: *PxSerialObjectId, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.vtable.getIds(this, userBuffer, bufferSize, startIndex); }

    PxCollection_getId :: inline (this: *PxCollection, object: *PxBase) -> PxSerialObjectId { return this.vtable.getId(this, object); }

    PxCollection_release :: inline (this: *PxCollection) { this.vtable.release(this); }

    PxCollection_Destructor :: inline (this: *PxCollection, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxCollection) -> *PxCollection_VTable { return obj.vtable; }

    #run {if true then return;
        assert(size_of(PxCollection) == 8, "PxCollection has size % instead of 8", size_of(PxCollection));
    }

    /**
    \brief an enumeration of concrete classes inheriting from PxBase

    Enumeration space is reserved for future PhysX core types, PhysXExtensions,
    PhysXVehicle and Custom application types.

    @see PxBase, PxTypeInfo
    */
    PxConcreteType :: struct {
        Enum :: enum s32 {
            UNDEFINED                             :: 0;

            HEIGHTFIELD                           :: 1;
            CONVEX_MESH                           :: 2;
            TRIANGLE_MESH_BVH33                   :: 3;
            TRIANGLE_MESH_BVH34                   :: 4;

            RIGID_DYNAMIC                         :: 5;
            RIGID_STATIC                          :: 6;
            SHAPE                                 :: 7;
            MATERIAL                              :: 8;
            CONSTRAINT                            :: 9;
            AGGREGATE                             :: 10;
            ARTICULATION                          :: 11;
            ARTICULATION_REDUCED_COORDINATE       :: 12;
            ARTICULATION_LINK                     :: 13;
            ARTICULATION_JOINT                    :: 14;
            ARTICULATION_JOINT_REDUCED_COORDINATE :: 15;
            PRUNING_STRUCTURE                     :: 16;
            BVH_STRUCTURE                         :: 17;

            PHYSX_CORE_COUNT                      :: 18;
            FIRST_PHYSX_EXTENSION                 :: 256;
            FIRST_VEHICLE_EXTENSION               :: 512;
            FIRST_USER_EXTENSION                  :: 1024;

            eUNDEFINED                             :: UNDEFINED;

            eHEIGHTFIELD                           :: HEIGHTFIELD;
            eCONVEX_MESH                           :: CONVEX_MESH;
            eTRIANGLE_MESH_BVH33                   :: TRIANGLE_MESH_BVH33;
            eTRIANGLE_MESH_BVH34                   :: TRIANGLE_MESH_BVH34;

            eRIGID_DYNAMIC                         :: RIGID_DYNAMIC;
            eRIGID_STATIC                          :: RIGID_STATIC;
            eSHAPE                                 :: SHAPE;
            eMATERIAL                              :: MATERIAL;
            eCONSTRAINT                            :: CONSTRAINT;
            eAGGREGATE                             :: AGGREGATE;
            eARTICULATION                          :: ARTICULATION;
            eARTICULATION_REDUCED_COORDINATE       :: ARTICULATION_REDUCED_COORDINATE;
            eARTICULATION_LINK                     :: ARTICULATION_LINK;
            eARTICULATION_JOINT                    :: ARTICULATION_JOINT;
            eARTICULATION_JOINT_REDUCED_COORDINATE :: ARTICULATION_JOINT_REDUCED_COORDINATE;
            ePRUNING_STRUCTURE                     :: PRUNING_STRUCTURE;
            eBVH_STRUCTURE                         :: BVH_STRUCTURE;

            ePHYSX_CORE_COUNT                      :: PHYSX_CORE_COUNT;
            eFIRST_PHYSX_EXTENSION                 :: FIRST_PHYSX_EXTENSION;
            eFIRST_VEHICLE_EXTENSION               :: FIRST_VEHICLE_EXTENSION;
            eFIRST_USER_EXTENSION                  :: FIRST_USER_EXTENSION;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxConcreteType) == 1, "PxConcreteType has size % instead of 1", size_of(PxConcreteType));
    }

    /**
    \brief a structure containing per-type information for types inheriting from PxBase

    @see PxBase, PxConcreteType
    */
    PxTypeInfo :: struct(T: Type) {}

    /**
    \brief Flags for PxBase.
    */
    PxBaseFlag :: struct {
        Enum :: enum s32 {
            OWNS_MEMORY   :: 1;
            IS_RELEASABLE :: 2;

            eOWNS_MEMORY   :: OWNS_MEMORY;
            eIS_RELEASABLE :: IS_RELEASABLE;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxBaseFlag) == 1, "PxBaseFlag has size % instead of 1", size_of(PxBaseFlag));
    }

    PxBaseFlags :: PxFlags(PxBaseFlag.Enum, PxU16);
    // operator~ :: (a: PxBaseFlag.Enum) -> PxFlags(PxBaseFlag.Enum, PxU16) #foreign physx_lib "??Sphysx@@YA?AV?$PxFlags@W4Enum@PxBaseFlag@physx@@G@0@W4Enum@PxBaseFlag@0@@Z";

    /**
    \brief Base class for objects that can be members of a PxCollection.

    All PxBase sub-classes can be serialized.

    @see PxCollection
    */
    PxBase :: struct {
        vtable: *PxBase_VTable;
        /**
        \brief	Returns concrete type of object.
        \return	PxConcreteType::Enum of serialized object

        @see PxConcreteType
        */
        getConcreteType :: (this: *PxBase) -> PxType #cpp_method #foreign physx_lib "?getConcreteType@PxBase@physx@@QEBAGXZ";

        /**
        \brief Set PxBaseFlag

        \param[in] flag The flag to be set
        \param[in] value The flags new value
        */
        setBaseFlag :: (this: *PxBase, flag: PxBaseFlag.Enum, value: bool) -> void #cpp_method #foreign physx_lib "?setBaseFlag@PxBase@physx@@QEAAXW4Enum@PxBaseFlag@2@_N@Z";

        /**
        \brief Set PxBaseFlags

        \param[in] inFlags The flags to be set

        @see PxBaseFlags
        */
        setBaseFlags :: (this: *PxBase, inFlags: PxBaseFlags) -> void #cpp_method #foreign physx_lib "?setBaseFlags@PxBase@physx@@QEAAXV?$PxFlags@W4Enum@PxBaseFlag@physx@@G@2@@Z";

        /**
        \brief Returns PxBaseFlags

        \return	PxBaseFlags

        @see PxBaseFlags
        */
        getBaseFlags :: (this: *PxBase) -> PxBaseFlags #cpp_method #foreign physx_lib "?getBaseFlags@PxBase@physx@@QEBA?AV?$PxFlags@W4Enum@PxBaseFlag@physx@@G@2@XZ";

        /**
        \brief Constructor setting concrete type and base flags.
        */
        Constructor :: (this: *PxBase, concreteType: PxType, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_lib "??0PxBase@physx@@IEAA@GV?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";

        /**
        \brief Deserialization constructor setting base flags.
        */
        Constructor :: (this: *PxBase, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_lib "??0PxBase@physx@@IEAA@V?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";

        mConcreteType: PxType; // concrete type identifier - see PxConcreteType.
        mBaseFlags:    PxBaseFlags; // internal flags

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.

        /**
        \brief Whether the object is subordinate.

        A class is subordinate, if it can only be instantiated in the context of another class.

        \return	Whether the class is subordinate

        @see PxSerialization::isSerializable
        */
        virtual_isReleasable :: (this: *PxBase) -> bool #cpp_method #foreign physx_lib "?isReleasable@PxBase@physx@@UEBA_NXZ";

        /**
        \brief Destructor.
        */
        virtual_Destructor :: (this: *PxBase, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_lib "??1PxBase@physx@@MEAA@XZ";

        /**
        \brief Returns whether a given type name matches with the type of this instance
        */
        virtual_isKindOf :: (this: *PxBase, superClass: *u8) -> bool #cpp_method #foreign physx_lib "?isKindOf@PxBase@physx@@MEBA_NPEBD@Z";
    }
    PxBase_VTable :: struct #type_info_none {
        release: (this: *PxBase) -> void #cpp_method;

        getConcreteTypeName: (this: *PxBase) -> *u8 #cpp_method;

        isReleasable: (this: *PxBase) -> bool #cpp_method;

        Destructor: (this: *PxBase, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

        isKindOf: (this: *PxBase, superClass: *u8) -> bool #cpp_method;
    }

    PxBase_release :: inline (this: *PxBase) { this.vtable.release(this); }

    PxBase_getConcreteTypeName :: inline (this: *PxBase) -> *u8 { return this.vtable.getConcreteTypeName(this); }

    PxBase_isReleasable :: inline (this: *PxBase) -> bool { return this.vtable.isReleasable(this); }

    PxBase_Destructor :: inline (this: *PxBase, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    PxBase_isKindOf :: inline (this: *PxBase, superClass: *u8) -> bool { return this.vtable.isKindOf(this, superClass); }

    vtable :: (obj: *PxBase) -> *PxBase_VTable { return obj.vtable; }

    #run {if true then return;
        instance: PxBase;
        assert(((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)) == 8, "PxBase.mConcreteType has unexpected offset % instead of 8", ((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxBase.mConcreteType)) == 2, "PxBase.mConcreteType has unexpected size % instead of 2", size_of(type_of(PxBase.mConcreteType)));
        assert(((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)) == 10, "PxBase.mBaseFlags has unexpected offset % instead of 10", ((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxBase.mBaseFlags)) == 2, "PxBase.mBaseFlags has unexpected size % instead of 2", size_of(type_of(PxBase.mBaseFlags)));
        assert(size_of(PxBase) == 16, "PxBase has size % instead of 16", size_of(PxBase));
    }

    /**
    \brief Class to define the scale at which simulation runs. Most simulation tolerances are
    calculated in terms of the values here.

    \note if you change the simulation scale, you will probablly also wish to change the scene's
    default value of gravity, and stable simulation will probably require changes to the scene's
    bounceThreshold also.
    */
    PxTolerancesScale :: struct {
        /** brief
        The approximate size of objects in the simulation.

        For simulating roughly human-sized in metric units, 1 is a good choice.
        If simulation is done in centimetres, use 100 instead. This is used to
        estimate certain length-related tolerances.
        */
        length: PxReal;

        /** brief
        The typical magnitude of velocities of objects in simulation. This is used to estimate
        whether a contact should be treated as bouncing or resting based on its impact velocity,
        and a kinetic energy threshold below which the simulation may put objects to sleep.

        For normal physical environments, a good choice is the approximate speed of an object falling
        under gravity for one second.
        */
        speed:  PxReal;

        /**
        \brief constructor sets to default
        */
        Constructor :: (this: *PxTolerancesScale) -> void #cpp_method #foreign physx_lib "??0PxTolerancesScale@physx@@QEAA@XZ";

        /**
        \brief Returns true if the descriptor is valid.
        \return true if the current settings are valid (returns always true).
        */
        isValid :: (this: *PxTolerancesScale) -> bool #cpp_method #foreign physx_lib "?isValid@PxTolerancesScale@physx@@QEBA_NXZ";
    }
    #run {if true then return;
        instance: PxTolerancesScale;
        assert(((cast(*void)(*instance.length)) - cast(*void)(*instance)) == 0, "PxTolerancesScale.length has unexpected offset % instead of 0", ((cast(*void)(*instance.length)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTolerancesScale.length)) == 4, "PxTolerancesScale.length has unexpected size % instead of 4", size_of(type_of(PxTolerancesScale.length)));
        assert(((cast(*void)(*instance.speed)) - cast(*void)(*instance)) == 4, "PxTolerancesScale.speed has unexpected offset % instead of 4", ((cast(*void)(*instance.speed)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTolerancesScale.speed)) == 4, "PxTolerancesScale.speed has unexpected size % instead of 4", size_of(type_of(PxTolerancesScale.speed)));
        assert(size_of(PxTolerancesScale) == 8, "PxTolerancesScale has size % instead of 8", size_of(PxTolerancesScale));
    }

    /**
    *	\brief a table to manage strings.  Strings allocated through this object are expected to be owned by this object.
    */
    PxStringTable :: struct {
        vtable: *PxStringTable_VTable;
    }
    PxStringTable_VTable :: struct #type_info_none {
        Destructor: (this: *PxStringTable, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

        allocateStr: (this: *PxStringTable, inSrc: *u8) -> *u8 #cpp_method;

        release: (this: *PxStringTable) -> void #cpp_method;
    }

    PxStringTable_Destructor :: inline (this: *PxStringTable, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    PxStringTable_allocateStr :: inline (this: *PxStringTable, inSrc: *u8) -> *u8 { return this.vtable.allocateStr(this, inSrc); }

    PxStringTable_release :: inline (this: *PxStringTable) { this.vtable.release(this); }

    vtable :: (obj: *PxStringTable) -> *PxStringTable_VTable { return obj.vtable; }

    #run {if true then return;
        assert(size_of(PxStringTable) == 8, "PxStringTable has size % instead of 8", size_of(PxStringTable));
    }

    /**
    \brief Foundation SDK singleton class.

    You need to have an instance of this class to instance the higher level SDKs.
    */
    PxFoundation :: struct {
        vtable: *PxFoundation_VTable;
    }
    PxFoundation_VTable :: struct #type_info_none {
        release: (this: *PxFoundation) -> void #cpp_method;

        getErrorCallback: (this: *PxFoundation) -> *PxErrorCallback #cpp_method;

        setErrorLevel: (this: *PxFoundation, mask: PxErrorCode.Enum = .MASK_ALL) -> void #cpp_method;

        getErrorLevel: (this: *PxFoundation) -> PxErrorCode.Enum #cpp_method;

        getAllocatorCallback: (this: *PxFoundation) -> *PxAllocatorCallback #cpp_method;

        getReportAllocationNames: (this: *PxFoundation) -> bool #cpp_method;

        setReportAllocationNames: (this: *PxFoundation, value: bool) -> void #cpp_method;

        Destructor: (this: *PxFoundation, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxFoundation_release :: inline (this: *PxFoundation) { this.vtable.release(this); }

    PxFoundation_getErrorCallback :: inline (this: *PxFoundation) -> *PxErrorCallback { return this.vtable.getErrorCallback(this); }

    PxFoundation_setErrorLevel :: inline (this: *PxFoundation, mask: PxErrorCode.Enum = .MASK_ALL) { this.vtable.setErrorLevel(this, mask); }

    PxFoundation_getErrorLevel :: inline (this: *PxFoundation) -> PxErrorCode.Enum { return this.vtable.getErrorLevel(this); }

    PxFoundation_getAllocatorCallback :: inline (this: *PxFoundation) -> *PxAllocatorCallback { return this.vtable.getAllocatorCallback(this); }

    PxFoundation_getReportAllocationNames :: inline (this: *PxFoundation) -> bool { return this.vtable.getReportAllocationNames(this); }

    PxFoundation_setReportAllocationNames :: inline (this: *PxFoundation, value: bool) { this.vtable.setReportAllocationNames(this, value); }

    PxFoundation_Destructor :: inline (this: *PxFoundation, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxFoundation) -> *PxFoundation_VTable { return obj.vtable; }

    #run {if true then return;
        assert(size_of(PxFoundation) == 8, "PxFoundation has size % instead of 8", size_of(PxFoundation));
    }

    /**
    \brief Serialization interface class.

    PxSerializer is used to extend serializable PxBase classes with serialization functionality. The
    interface is structured such that per-class adapter instances can be used as opposed to per-object
    adapter instances, avoiding per object allocations. Hence the methods take a reference to PxBase as a parameter.

    The PxSerializer interface needs to be implemented for binary or RepX serialization to work on custom
    types. If only RepX serialization is needed, some methods can be left empty, as they are only needed
    for binary serialization.

    A default implementation is available as a template adapter (PxSerializerDefaultAdapter).

    @see PxSerializerDefaultAdapter, PX_NEW_SERIALIZER_ADAPTER, PxSerializationRegistry::registerSerializer
    */
    PxSerializer :: struct {
        vtable: *PxSerializer_VTable;
    }
    PxSerializer_VTable :: struct #type_info_none {
        getConcreteTypeName: (this: *PxSerializer) -> *u8 #cpp_method;

        requiresObjects: (this: *PxSerializer, unknown0: *PxBase, unknown1: *PxProcessPxBaseCallback) -> void #cpp_method;

        isSubordinate: (this: *PxSerializer) -> bool #cpp_method;

        exportExtraData: (this: *PxSerializer, unknown0: *PxBase, unknown1: *PxSerializationContext) -> void #cpp_method;

        exportData: (this: *PxSerializer, unknown0: *PxBase, unknown1: *PxSerializationContext) -> void #cpp_method;

        registerReferences: (this: *PxSerializer, obj: *PxBase, s: *PxSerializationContext) -> void #cpp_method;

        getClassSize: (this: *PxSerializer) -> size_t #cpp_method;

        createObject: (this: *PxSerializer, address: **PxU8, _context: *PxDeserializationContext) -> *PxBase #cpp_method;

        Destructor: (this: *PxSerializer, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxSerializer_getConcreteTypeName :: inline (this: *PxSerializer) -> *u8 { return this.vtable.getConcreteTypeName(this); }

    PxSerializer_requiresObjects :: inline (this: *PxSerializer, unknown0: *PxBase, unknown1: *PxProcessPxBaseCallback) { this.vtable.requiresObjects(this, unknown0, unknown1); }

    PxSerializer_isSubordinate :: inline (this: *PxSerializer) -> bool { return this.vtable.isSubordinate(this); }

    PxSerializer_exportExtraData :: inline (this: *PxSerializer, unknown0: *PxBase, unknown1: *PxSerializationContext) { this.vtable.exportExtraData(this, unknown0, unknown1); }

    PxSerializer_exportData :: inline (this: *PxSerializer, unknown0: *PxBase, unknown1: *PxSerializationContext) { this.vtable.exportData(this, unknown0, unknown1); }

    PxSerializer_registerReferences :: inline (this: *PxSerializer, obj: *PxBase, s: *PxSerializationContext) { this.vtable.registerReferences(this, obj, s); }

    PxSerializer_getClassSize :: inline (this: *PxSerializer) -> size_t { return this.vtable.getClassSize(this); }

    PxSerializer_createObject :: inline (this: *PxSerializer, address: **PxU8, _context: *PxDeserializationContext) -> *PxBase { return this.vtable.createObject(this, address, _context); }

    PxSerializer_Destructor :: inline (this: *PxSerializer, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxSerializer) -> *PxSerializer_VTable { return obj.vtable; }

    #run {if true then return;
        assert(size_of(PxSerializer) == 8, "PxSerializer has size % instead of 8", size_of(PxSerializer));
    }

    /**
    \brief Default PxSerializer implementation.
    */
    PxSerializerDefaultAdapter :: struct(T: Type) {
        #as pxserializer: PxSerializer; // jai: no "using" to avoid name-clashes

        //@}
        /************************************************************************************************/
        mTypeName: *u8;
    }

    /**
    \brief Flags used to configure binary meta data entries, typically set through PX_DEF_BIN_METADATA defines.

    @see PxMetaDataEntry
    */
    PxMetaDataFlag :: struct {
        Enum :: enum s32 {
            CLASS              :: 1;
            VIRTUAL            :: 2;
            TYPEDEF            :: 4;
            PTR                :: 8;
            HANDLE             :: 16;
            EXTRA_DATA         :: 32;
            EXTRA_ITEM         :: 64;
            EXTRA_ITEMS        :: 128;
            EXTRA_NAME         :: 256;
            UNION              :: 512;
            PADDING            :: 1024;
            ALIGNMENT          :: 2048;
            COUNT_MASK_MSB     :: 4096;
            COUNT_SKIP_IF_ONE  :: 8192;
            CONTROL_FLIP       :: 16384;
            CONTROL_MASK       :: 32768;
            CONTROL_MASK_RANGE :: 255;
            FORCE_DWORD        :: 2147483647;

            eCLASS              :: CLASS;
            eVIRTUAL            :: VIRTUAL;
            eTYPEDEF            :: TYPEDEF;
            ePTR                :: PTR;
            eHANDLE             :: HANDLE;
            eEXTRA_DATA         :: EXTRA_DATA;
            eEXTRA_ITEM         :: EXTRA_ITEM;
            eEXTRA_ITEMS        :: EXTRA_ITEMS;
            eEXTRA_NAME         :: EXTRA_NAME;
            eUNION              :: UNION;
            ePADDING            :: PADDING;
            eALIGNMENT          :: ALIGNMENT;
            eCOUNT_MASK_MSB     :: COUNT_MASK_MSB;
            eCOUNT_SKIP_IF_ONE  :: COUNT_SKIP_IF_ONE;
            eCONTROL_FLIP       :: CONTROL_FLIP;
            eCONTROL_MASK       :: CONTROL_MASK;
            eCONTROL_MASK_RANGE :: CONTROL_MASK_RANGE;
            eFORCE_DWORD        :: FORCE_DWORD;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxMetaDataFlag) == 1, "PxMetaDataFlag has size % instead of 1", size_of(PxMetaDataFlag));
    }

    /**
    \brief Struct to store meta data definitions.

    Note: The individual fields have different meaning depending on the meta data entry configuration.
    */
    PxMetaDataEntry :: struct {
        type:       *u8; //!< Field type (bool, byte, quaternion, etc)
        name:       *u8; //!< Field name (appears exactly as in the source file)
        offset:     PxU32; //!< Offset from the start of the class (ie from "this", field is located at "this"+Offset)
        size:       PxU32; //!< sizeof(Type)
        count:      PxU32; //!< Number of items of type Type (0 for dynamic sizes)
        offsetSize: PxU32; //!< Offset of dynamic size param, for dynamic arrays
        flags:      PxU32; //!< Field parameters
        alignment:  PxU32; //!< Explicit alignment
    }
    #run {if true then return;
        instance: PxMetaDataEntry;
        assert(((cast(*void)(*instance.type)) - cast(*void)(*instance)) == 0, "PxMetaDataEntry.type has unexpected offset % instead of 0", ((cast(*void)(*instance.type)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxMetaDataEntry.type)) == 8, "PxMetaDataEntry.type has unexpected size % instead of 8", size_of(type_of(PxMetaDataEntry.type)));
        assert(((cast(*void)(*instance.name)) - cast(*void)(*instance)) == 8, "PxMetaDataEntry.name has unexpected offset % instead of 8", ((cast(*void)(*instance.name)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxMetaDataEntry.name)) == 8, "PxMetaDataEntry.name has unexpected size % instead of 8", size_of(type_of(PxMetaDataEntry.name)));
        assert(((cast(*void)(*instance.offset)) - cast(*void)(*instance)) == 16, "PxMetaDataEntry.offset has unexpected offset % instead of 16", ((cast(*void)(*instance.offset)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxMetaDataEntry.offset)) == 4, "PxMetaDataEntry.offset has unexpected size % instead of 4", size_of(type_of(PxMetaDataEntry.offset)));
        assert(((cast(*void)(*instance.size)) - cast(*void)(*instance)) == 20, "PxMetaDataEntry.size has unexpected offset % instead of 20", ((cast(*void)(*instance.size)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxMetaDataEntry.size)) == 4, "PxMetaDataEntry.size has unexpected size % instead of 4", size_of(type_of(PxMetaDataEntry.size)));
        assert(((cast(*void)(*instance.count)) - cast(*void)(*instance)) == 24, "PxMetaDataEntry.count has unexpected offset % instead of 24", ((cast(*void)(*instance.count)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxMetaDataEntry.count)) == 4, "PxMetaDataEntry.count has unexpected size % instead of 4", size_of(type_of(PxMetaDataEntry.count)));
        assert(((cast(*void)(*instance.offsetSize)) - cast(*void)(*instance)) == 28, "PxMetaDataEntry.offsetSize has unexpected offset % instead of 28", ((cast(*void)(*instance.offsetSize)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxMetaDataEntry.offsetSize)) == 4, "PxMetaDataEntry.offsetSize has unexpected size % instead of 4", size_of(type_of(PxMetaDataEntry.offsetSize)));
        assert(((cast(*void)(*instance.flags)) - cast(*void)(*instance)) == 32, "PxMetaDataEntry.flags has unexpected offset % instead of 32", ((cast(*void)(*instance.flags)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxMetaDataEntry.flags)) == 4, "PxMetaDataEntry.flags has unexpected size % instead of 4", size_of(type_of(PxMetaDataEntry.flags)));
        assert(((cast(*void)(*instance.alignment)) - cast(*void)(*instance)) == 36, "PxMetaDataEntry.alignment has unexpected offset % instead of 36", ((cast(*void)(*instance.alignment)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxMetaDataEntry.alignment)) == 4, "PxMetaDataEntry.alignment has unexpected size % instead of 4", size_of(type_of(PxMetaDataEntry.alignment)));
        assert(size_of(PxMetaDataEntry) == 40, "PxMetaDataEntry has size % instead of 40", size_of(PxMetaDataEntry));
    }

    /**

    \brief Callback interface that permits PxCooking to insert a
    TriangleMesh, HeightfieldMesh or ConvexMesh directly into PxPhysics without the need to store
    the cooking results into a stream.


    Using this is advised only if real-time cooking is required; using "offline" cooking and
    streams is otherwise preferred.

    The default PxPhysicsInsertionCallback implementation must be used. The PxPhysics
    default callback can be obtained using the PxPhysics::getPhysicsInsertionCallback().

    @see PxCooking PxPhysics
    */
    PxPhysicsInsertionCallback :: struct {
        vtable: *PxPhysicsInsertionCallback_VTable;
    }
    PxPhysicsInsertionCallback_VTable :: struct #type_info_none {
        buildObjectFromData: (this: *PxPhysicsInsertionCallback, type: PxConcreteType.Enum, data: *void) -> *PxBase #cpp_method;

        Destructor: (this: *PxPhysicsInsertionCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxPhysicsInsertionCallback_buildObjectFromData :: inline (this: *PxPhysicsInsertionCallback, type: PxConcreteType.Enum, data: *void) -> *PxBase { return this.vtable.buildObjectFromData(this, type, data); }

    PxPhysicsInsertionCallback_Destructor :: inline (this: *PxPhysicsInsertionCallback, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxPhysicsInsertionCallback) -> *PxPhysicsInsertionCallback_VTable { return obj.vtable; }

    #run {if true then return;
        assert(size_of(PxPhysicsInsertionCallback) == 8, "PxPhysicsInsertionCallback has size % instead of 8", size_of(PxPhysicsInsertionCallback));
    }

    PxTaskID :: u32;

    /**
    \brief Identifies the type of each heavyweight PxTask object

    \note This enum type is only used by PxTask and GpuTask objects, LightCpuTasks do not use this enum.

    @see PxTask
    @see PxLightCpuTask
    */
    PxTaskType :: struct {
        /**
        * \brief Identifies the type of each heavyweight PxTask object
        */
        Enum :: enum s32 {
            CPU         :: 0;
            NOT_PRESENT :: 1;
            COMPLETED   :: 2;

            TT_CPU         :: CPU;
            TT_NOT_PRESENT :: NOT_PRESENT;
            TT_COMPLETED   :: COMPLETED;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxTaskType) == 1, "PxTaskType has size % instead of 1", size_of(PxTaskType));
    }

    /**
    \brief The PxTaskManager interface

    A PxTaskManager instance holds references to user-provided dispatcher objects, when tasks are
    submitted the PxTaskManager routes them to the appropriate dispatcher and handles task profiling if enabled.
    Users should not implement the PxTaskManager interface, the SDK creates its own concrete PxTaskManager object
    per-scene which users can configure by passing dispatcher objects into the PxSceneDesc.

    @see CpuDispatcher

    */
    PxTaskManager :: struct {
        vtable: *PxTaskManager_VTable;
    }
    PxTaskManager_VTable :: struct #type_info_none {
        setCpuDispatcher: (this: *PxTaskManager, ref: *PxCpuDispatcher) -> void #cpp_method;

        getCpuDispatcher: (this: *PxTaskManager) -> *PxCpuDispatcher #cpp_method;

        resetDependencies: (this: *PxTaskManager) -> void #cpp_method;

        startSimulation: (this: *PxTaskManager) -> void #cpp_method;

        stopSimulation: (this: *PxTaskManager) -> void #cpp_method;

        taskCompleted: (this: *PxTaskManager, task: *PxTask) -> void #cpp_method;

        getNamedTask: (this: *PxTaskManager, name: *u8) -> PxTaskID #cpp_method;

        submitNamedTask: (this: *PxTaskManager, task: *PxTask, name: *u8, type: PxTaskType.Enum = .CPU) -> PxTaskID #cpp_method;

        submitUnnamedTask: (this: *PxTaskManager, task: *PxTask, type: PxTaskType.Enum = .CPU) -> PxTaskID #cpp_method;

        getTaskFromID: (this: *PxTaskManager, id: PxTaskID) -> *PxTask #cpp_method;

        release: (this: *PxTaskManager) -> void #cpp_method;

        Destructor: (this: *PxTaskManager, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

        finishBefore: (this: *PxTaskManager, task: *PxTask, taskID: PxTaskID) -> void #cpp_method;
        startAfter: (this: *PxTaskManager, task: *PxTask, taskID: PxTaskID) -> void #cpp_method;

        addReference: (this: *PxTaskManager, unknown0: *PxLightCpuTask) -> void #cpp_method;

        addReference_1: (this: *PxTaskManager, taskID: PxTaskID) -> void #cpp_method;

        decrReference: (this: *PxTaskManager, unknown0: *PxLightCpuTask) -> void #cpp_method;

        decrReference_1: (this: *PxTaskManager, taskID: PxTaskID) -> void #cpp_method;
        getReference: (this: *PxTaskManager, taskID: PxTaskID) -> s32 #cpp_method;
    }

    PxTaskManager_setCpuDispatcher :: inline (this: *PxTaskManager, ref: *PxCpuDispatcher) { this.vtable.setCpuDispatcher(this, ref); }

    PxTaskManager_getCpuDispatcher :: inline (this: *PxTaskManager) -> *PxCpuDispatcher { return this.vtable.getCpuDispatcher(this); }

    PxTaskManager_resetDependencies :: inline (this: *PxTaskManager) { this.vtable.resetDependencies(this); }

    PxTaskManager_startSimulation :: inline (this: *PxTaskManager) { this.vtable.startSimulation(this); }

    PxTaskManager_stopSimulation :: inline (this: *PxTaskManager) { this.vtable.stopSimulation(this); }

    PxTaskManager_taskCompleted :: inline (this: *PxTaskManager, task: *PxTask) { this.vtable.taskCompleted(this, task); }

    PxTaskManager_getNamedTask :: inline (this: *PxTaskManager, name: *u8) -> PxTaskID { return this.vtable.getNamedTask(this, name); }

    PxTaskManager_submitNamedTask :: inline (this: *PxTaskManager, task: *PxTask, name: *u8, type: PxTaskType.Enum = .CPU) -> PxTaskID { return this.vtable.submitNamedTask(this, task, name, type); }

    PxTaskManager_submitUnnamedTask :: inline (this: *PxTaskManager, task: *PxTask, type: PxTaskType.Enum = .CPU) -> PxTaskID { return this.vtable.submitUnnamedTask(this, task, type); }

    PxTaskManager_getTaskFromID :: inline (this: *PxTaskManager, id: PxTaskID) -> *PxTask { return this.vtable.getTaskFromID(this, id); }

    PxTaskManager_release :: inline (this: *PxTaskManager) { this.vtable.release(this); }

    PxTaskManager_Destructor :: inline (this: *PxTaskManager, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    PxTaskManager_finishBefore :: inline (this: *PxTaskManager, task: *PxTask, taskID: PxTaskID) { this.vtable.finishBefore(this, task, taskID); }
    PxTaskManager_startAfter :: inline (this: *PxTaskManager, task: *PxTask, taskID: PxTaskID) { this.vtable.startAfter(this, task, taskID); }

    PxTaskManager_addReference :: inline (this: *PxTaskManager, unknown0: /*reference*/ *PxLightCpuTask) { this.vtable.addReference(this, unknown0); }

    PxTaskManager_addReference_1 :: inline (this: *PxTaskManager, taskID: PxTaskID) { this.vtable.addReference_1(this, taskID); }

    PxTaskManager_decrReference :: inline (this: *PxTaskManager, unknown0: /*reference*/ *PxLightCpuTask) { this.vtable.decrReference(this, unknown0); }

    PxTaskManager_decrReference_1 :: inline (this: *PxTaskManager, taskID: PxTaskID) { this.vtable.decrReference_1(this, taskID); }
    PxTaskManager_getReference :: inline (this: *PxTaskManager, taskID: PxTaskID) -> s32 { return this.vtable.getReference(this, taskID); }

    vtable :: (obj: *PxTaskManager) -> *PxTaskManager_VTable { return obj.vtable; }

    #run {if true then return;
        assert(size_of(PxTaskManager) == 8, "PxTaskManager has size % instead of 8", size_of(PxTaskManager));
    }

    /**
    \brief A CpuDispatcher is responsible for scheduling the execution of tasks passed to it by the SDK.

    A typical implementation would for example use a thread pool with the dispatcher
    pushing tasks onto worker thread queues or a global queue.

    @see PxBaseTask
    @see PxTask
    @see PxTaskManager
    */
    PxCpuDispatcher :: struct {
        vtable: *PxCpuDispatcher_VTable;
    }
    PxCpuDispatcher_VTable :: struct #type_info_none {
        submitTask: (this: *PxCpuDispatcher, task: *PxBaseTask) -> void #cpp_method;

        getWorkerCount: (this: *PxCpuDispatcher) -> u32 #cpp_method;

        Destructor: (this: *PxCpuDispatcher, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxCpuDispatcher_submitTask :: inline (this: *PxCpuDispatcher, task: *PxBaseTask) { this.vtable.submitTask(this, task); }

    PxCpuDispatcher_getWorkerCount :: inline (this: *PxCpuDispatcher) -> u32 { return this.vtable.getWorkerCount(this); }

    PxCpuDispatcher_Destructor :: inline (this: *PxCpuDispatcher, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxCpuDispatcher) -> *PxCpuDispatcher_VTable { return obj.vtable; }

    #run {if true then return;
        assert(size_of(PxCpuDispatcher) == 8, "PxCpuDispatcher has size % instead of 8", size_of(PxCpuDispatcher));
    }

    /**
    * \brief Base class of all task types
    *
    * PxBaseTask defines a runnable reference counted task with built-in profiling.
    */
    PxBaseTask :: struct {
        vtable: *PxBaseTask_VTable;
        /**
        * \brief Return PxTaskManager to which this task was submitted
        *
        * Note, can return NULL if task was not submitted, or has been
        * completed.
        */
        getTaskManager :: (this: *PxBaseTask) -> *PxTaskManager #cpp_method #foreign physx_lib "?getTaskManager@PxBaseTask@physx@@QEBAPEAVPxTaskManager@2@XZ";

        setContextId :: (this: *PxBaseTask, id: PxU64) -> void #cpp_method #foreign physx_lib "?setContextId@PxBaseTask@physx@@QEAAX_K@Z";
        getContextId :: (this: *PxBaseTask) -> PxU64 #cpp_method #foreign physx_lib "?getContextId@PxBaseTask@physx@@QEBA_KXZ";

        mContextID: PxU64; //!< Context ID for profiler interface
        mTm:        *PxTaskManager; //!< Owning PxTaskManager instance
    }
    PxBaseTask_VTable :: struct #type_info_none {
        Destructor: (this: *PxBaseTask, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

        run: (this: *PxBaseTask) -> void #cpp_method;

        getName: (this: *PxBaseTask) -> *u8 #cpp_method;

        addReference: (this: *PxBaseTask) -> void #cpp_method;

        removeReference: (this: *PxBaseTask) -> void #cpp_method;

        getReference: (this: *PxBaseTask) -> s32 #cpp_method;

        release: (this: *PxBaseTask) -> void #cpp_method;
    }

    PxBaseTask_Destructor :: inline (this: *PxBaseTask, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    PxBaseTask_run :: inline (this: *PxBaseTask) { this.vtable.run(this); }

    PxBaseTask_getName :: inline (this: *PxBaseTask) -> *u8 { return this.vtable.getName(this); }

    PxBaseTask_addReference :: inline (this: *PxBaseTask) { this.vtable.addReference(this); }

    PxBaseTask_removeReference :: inline (this: *PxBaseTask) { this.vtable.removeReference(this); }

    PxBaseTask_getReference :: inline (this: *PxBaseTask) -> s32 { return this.vtable.getReference(this); }

    PxBaseTask_release :: inline (this: *PxBaseTask) { this.vtable.release(this); }

    vtable :: (obj: *PxBaseTask) -> *PxBaseTask_VTable { return obj.vtable; }

    #run {if true then return;
        instance: PxBaseTask;
        assert(((cast(*void)(*instance.mContextID)) - cast(*void)(*instance)) == 8, "PxBaseTask.mContextID has unexpected offset % instead of 8", ((cast(*void)(*instance.mContextID)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxBaseTask.mContextID)) == 8, "PxBaseTask.mContextID has unexpected size % instead of 8", size_of(type_of(PxBaseTask.mContextID)));
        assert(((cast(*void)(*instance.mTm)) - cast(*void)(*instance)) == 16, "PxBaseTask.mTm has unexpected offset % instead of 16", ((cast(*void)(*instance.mTm)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxBaseTask.mTm)) == 8, "PxBaseTask.mTm has unexpected size % instead of 8", size_of(type_of(PxBaseTask.mTm)));
        assert(size_of(PxBaseTask) == 24, "PxBaseTask has size % instead of 24", size_of(PxBaseTask));
    }

    /**
    * \brief A PxBaseTask implementation with deferred execution and full dependencies
    *
    * A PxTask must be submitted to a PxTaskManager to to be executed, Tasks may
    * optionally be named when they are submitted.
    */
    PxTask :: struct {
        #as using pxbasetask: PxBaseTask;

        //! \brief Inform the PxTaskManager this task must finish before the given
        //         task is allowed to start.
        finishBefore :: (this: *PxTask, taskID: PxTaskID) -> void #cpp_method #foreign physx_lib "?finishBefore@PxTask@physx@@QEAAXI@Z";

        //! \brief Inform the PxTaskManager this task cannot start until the given
        //         task has completed.
        startAfter :: (this: *PxTask, taskID: PxTaskID) -> void #cpp_method #foreign physx_lib "?startAfter@PxTask@physx@@QEAAXI@Z";

        /**
        * \brief Return the unique ID for this task
        */
        getTaskID :: (this: *PxTask) -> PxTaskID #cpp_method #foreign physx_lib "?getTaskID@PxTask@physx@@QEBAIXZ";

        mTaskID: PxTaskID; //!< ID assigned at submission
        #place pxbasetask; pxtask_vtable: *PxTask_VTable;
    }
    PxTask_VTable :: struct #type_info_none {
        using pxbasetask: PxBaseTask_VTable;
        submitted: (this: *PxTask) -> void #cpp_method;
    }
    PxTask_submitted :: inline (this: *PxTask) { this.pxtask_vtable.submitted(this); }

    vtable :: (obj: *PxTask) -> *PxTask_VTable { return obj.pxtask_vtable; }

    #run {if true then return;
        assert(size_of(type_of(PxTask.pxbasetask)) == 24, "PxTask.pxbasetask has unexpected size % instead of 24", size_of(type_of(PxTask.pxbasetask)));
        instance: PxTask;
        assert(((cast(*void)(*instance.mTaskID)) - cast(*void)(*instance)) == 24, "PxTask.mTaskID has unexpected offset % instead of 24", ((cast(*void)(*instance.mTaskID)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTask.mTaskID)) == 4, "PxTask.mTaskID has unexpected size % instead of 4", size_of(type_of(PxTask.mTaskID)));
        assert(size_of(PxTask) == 32, "PxTask has size % instead of 32", size_of(PxTask));
    }

    /**
    * \brief A PxBaseTask implementation with immediate execution and simple dependencies
    *
    * A PxLightCpuTask bypasses the PxTaskManager launch dependencies and will be
    * submitted directly to your scene's CpuDispatcher.  When the run() function
    * completes, it will decrement the reference count of the specified
    * continuation task.
    *
    * You must use a full-blown PxTask if you want your task to be resolved
    * by another PxTask, or you need more than a single dependency to be
    * resolved when your task completes, or your task will not run on the
    * CpuDispatcher.
    */
    PxLightCpuTask :: struct {
        #as using pxbasetask: PxBaseTask;

        /**
        * \brief Initialize this task and specify the task that will have its ref count decremented on completion.
        *
        * Submission is deferred until the task's mRefCount is decremented to zero.
        * Note that we only use the PxTaskManager to query the appropriate dispatcher.
        *
        * \param[in] tm The PxTaskManager this task is managed by
        * \param[in] c The task to be executed when this task has finished running
        */
        setContinuation :: (this: *PxLightCpuTask, tm: *PxTaskManager, c: *PxBaseTask) -> void #cpp_method #foreign physx_lib "?setContinuation@PxLightCpuTask@physx@@QEAAXAEAVPxTaskManager@2@PEAVPxBaseTask@2@@Z";

        /**
        * \brief Initialize this task and specify the task that will have its ref count decremented on completion.
        *
        * This overload of setContinuation() queries the PxTaskManager from the continuation
        * task, which cannot be NULL.
        * \param[in] c The task to be executed after this task has finished running
        */
        setContinuation :: (this: *PxLightCpuTask, c: *PxBaseTask) -> void #cpp_method #foreign physx_lib "?setContinuation@PxLightCpuTask@physx@@QEAAXPEAVPxBaseTask@2@@Z";

        /**
        * \brief Retrieves continuation task
        */
        getContinuation :: (this: *PxLightCpuTask) -> *PxBaseTask #cpp_method #foreign physx_lib "?getContinuation@PxLightCpuTask@physx@@QEBAPEAVPxBaseTask@2@XZ";

        mCont:     *PxBaseTask; //!< Continuation task, can be NULL
        mRefCount: s32; //!< PxTask is dispatched when reaches 0
    }
    #run {if true then return;
        assert(size_of(type_of(PxLightCpuTask.pxbasetask)) == 24, "PxLightCpuTask.pxbasetask has unexpected size % instead of 24", size_of(type_of(PxLightCpuTask.pxbasetask)));
        instance: PxLightCpuTask;
        assert(((cast(*void)(*instance.mCont)) - cast(*void)(*instance)) == 24, "PxLightCpuTask.mCont has unexpected offset % instead of 24", ((cast(*void)(*instance.mCont)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxLightCpuTask.mCont)) == 8, "PxLightCpuTask.mCont has unexpected size % instead of 8", size_of(type_of(PxLightCpuTask.mCont)));
        assert(((cast(*void)(*instance.mRefCount)) - cast(*void)(*instance)) == 32, "PxLightCpuTask.mRefCount has unexpected offset % instead of 32", ((cast(*void)(*instance.mRefCount)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxLightCpuTask.mRefCount)) == 4, "PxLightCpuTask.mRefCount has unexpected size % instead of 4", size_of(type_of(PxLightCpuTask.mRefCount)));
        assert(size_of(PxLightCpuTask) == 40, "PxLightCpuTask has size % instead of 40", size_of(PxLightCpuTask));
    }

    PxConstraintDesc :: struct {}

    /** \brief ID of the Feature which owns/allocated memory from the heap
    *
    * Maximum of 64k IDs allowed.
    */
    PxAllocId :: struct {
        /**
        * \brief ID of the Feature which owns/allocated memory from the heap
        */
        Enum :: enum s32 {
            UNASSIGNED :: 0;
            APEX       :: 1;
            PARTICLES  :: 2;
            GPU_UTIL   :: 3;
            CLOTH      :: 4;
            NUM_IDS    :: 5;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxAllocId) == 1, "PxAllocId has size % instead of 1", size_of(PxAllocId));
    }

    /// \brief memory type managed by a heap
    PxCudaBufferMemorySpace :: struct {
        /**
        * \brief memory type managed by a heap
        */
        Enum :: enum s32 {
            T_GPU            :: 0;
            T_PINNED_HOST    :: 1;
            T_WRITE_COMBINED :: 2;
            T_HOST           :: 3;
            COUNT            :: 4;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxCudaBufferMemorySpace) == 1, "PxCudaBufferMemorySpace has size % instead of 1", size_of(PxCudaBufferMemorySpace));
    }

    /// \brief class to track allocation statistics, see PxgMirrored
    PxAllocInfo :: struct {
        mFileName:  *u8;
        mLine:      s32;
        mAllocName: *u8;
        mAllocId:   PxAllocId.Enum;
    }
    #run {if true then return;
        instance: PxAllocInfo;
        assert(((cast(*void)(*instance.mFileName)) - cast(*void)(*instance)) == 0, "PxAllocInfo.mFileName has unexpected offset % instead of 0", ((cast(*void)(*instance.mFileName)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxAllocInfo.mFileName)) == 8, "PxAllocInfo.mFileName has unexpected size % instead of 8", size_of(type_of(PxAllocInfo.mFileName)));
        assert(((cast(*void)(*instance.mLine)) - cast(*void)(*instance)) == 8, "PxAllocInfo.mLine has unexpected offset % instead of 8", ((cast(*void)(*instance.mLine)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxAllocInfo.mLine)) == 4, "PxAllocInfo.mLine has unexpected size % instead of 4", size_of(type_of(PxAllocInfo.mLine)));
        assert(((cast(*void)(*instance.mAllocName)) - cast(*void)(*instance)) == 16, "PxAllocInfo.mAllocName has unexpected offset % instead of 16", ((cast(*void)(*instance.mAllocName)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxAllocInfo.mAllocName)) == 8, "PxAllocInfo.mAllocName has unexpected size % instead of 8", size_of(type_of(PxAllocInfo.mAllocName)));
        assert(((cast(*void)(*instance.mAllocId)) - cast(*void)(*instance)) == 24, "PxAllocInfo.mAllocId has unexpected offset % instead of 24", ((cast(*void)(*instance.mAllocId)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxAllocInfo.mAllocId)) == 4, "PxAllocInfo.mAllocId has unexpected size % instead of 4", size_of(type_of(PxAllocInfo.mAllocId)));
        assert(size_of(PxAllocInfo) == 32, "PxAllocInfo has size % instead of 32", size_of(PxAllocInfo));
    }

    /// \brief statistics collected per AllocationId by HeapManager.
    PxAllocIdStats :: struct {
        size:        size_t; //!< currently allocated memory by this ID
        maxSize:     size_t; //!< max allocated memory by this ID
        elements:    size_t; //!< number of current allocations by this ID
        maxElements: size_t; //!< max number of allocations by this ID
    }
    #run {if true then return;
        instance: PxAllocIdStats;
        assert(((cast(*void)(*instance.size)) - cast(*void)(*instance)) == 0, "PxAllocIdStats.size has unexpected offset % instead of 0", ((cast(*void)(*instance.size)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxAllocIdStats.size)) == 8, "PxAllocIdStats.size has unexpected size % instead of 8", size_of(type_of(PxAllocIdStats.size)));
        assert(((cast(*void)(*instance.maxSize)) - cast(*void)(*instance)) == 8, "PxAllocIdStats.maxSize has unexpected offset % instead of 8", ((cast(*void)(*instance.maxSize)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxAllocIdStats.maxSize)) == 8, "PxAllocIdStats.maxSize has unexpected size % instead of 8", size_of(type_of(PxAllocIdStats.maxSize)));
        assert(((cast(*void)(*instance.elements)) - cast(*void)(*instance)) == 16, "PxAllocIdStats.elements has unexpected offset % instead of 16", ((cast(*void)(*instance.elements)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxAllocIdStats.elements)) == 8, "PxAllocIdStats.elements has unexpected size % instead of 8", size_of(type_of(PxAllocIdStats.elements)));
        assert(((cast(*void)(*instance.maxElements)) - cast(*void)(*instance)) == 24, "PxAllocIdStats.maxElements has unexpected offset % instead of 24", ((cast(*void)(*instance.maxElements)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxAllocIdStats.maxElements)) == 8, "PxAllocIdStats.maxElements has unexpected size % instead of 8", size_of(type_of(PxAllocIdStats.maxElements)));
        assert(size_of(PxAllocIdStats) == 32, "PxAllocIdStats has size % instead of 32", size_of(PxAllocIdStats));
    }

    PxCudaBufferPtr :: size_t;

    /// \brief Hint flag to tell how the buffer will be used
    PxCudaBufferFlags :: struct {
        /// \brief Enumerations for the hint flag to tell how the buffer will be used
        Enum :: enum s32 {
            READ       :: 1;
            WRITE      :: 2;
            READ_WRITE :: 3;

            F_READ       :: READ;
            F_WRITE      :: WRITE;
            F_READ_WRITE :: READ_WRITE;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxCudaBufferFlags) == 1, "PxCudaBufferFlags has size % instead of 1", size_of(PxCudaBufferFlags));
    }

    /// \brief Memory statistics struct returned by CudaMemMgr::getStats()
    PxCudaMemoryManagerStats :: struct {
        heapSize:       size_t; //!< Size of all pages allocated for this memory type (allocated + free).
        totalAllocated: size_t; //!< Size occupied by the current allocations.
        maxAllocated:   size_t; //!< High water mark of allocations since the SDK was created.
        allocIdStats:   [5] PxAllocIdStats; //!< Stats for each allocation ID, see PxAllocIdStats
    }
    #run {if true then return;
        instance: PxCudaMemoryManagerStats;
        assert(((cast(*void)(*instance.heapSize)) - cast(*void)(*instance)) == 0, "PxCudaMemoryManagerStats.heapSize has unexpected offset % instead of 0", ((cast(*void)(*instance.heapSize)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxCudaMemoryManagerStats.heapSize)) == 8, "PxCudaMemoryManagerStats.heapSize has unexpected size % instead of 8", size_of(type_of(PxCudaMemoryManagerStats.heapSize)));
        assert(((cast(*void)(*instance.totalAllocated)) - cast(*void)(*instance)) == 8, "PxCudaMemoryManagerStats.totalAllocated has unexpected offset % instead of 8", ((cast(*void)(*instance.totalAllocated)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxCudaMemoryManagerStats.totalAllocated)) == 8, "PxCudaMemoryManagerStats.totalAllocated has unexpected size % instead of 8", size_of(type_of(PxCudaMemoryManagerStats.totalAllocated)));
        assert(((cast(*void)(*instance.maxAllocated)) - cast(*void)(*instance)) == 16, "PxCudaMemoryManagerStats.maxAllocated has unexpected offset % instead of 16", ((cast(*void)(*instance.maxAllocated)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxCudaMemoryManagerStats.maxAllocated)) == 8, "PxCudaMemoryManagerStats.maxAllocated has unexpected size % instead of 8", size_of(type_of(PxCudaMemoryManagerStats.maxAllocated)));
        assert(((cast(*void)(*instance.allocIdStats)) - cast(*void)(*instance)) == 24, "PxCudaMemoryManagerStats.allocIdStats has unexpected offset % instead of 24", ((cast(*void)(*instance.allocIdStats)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxCudaMemoryManagerStats.allocIdStats)) == 160, "PxCudaMemoryManagerStats.allocIdStats has unexpected size % instead of 160", size_of(type_of(PxCudaMemoryManagerStats.allocIdStats)));
        assert(size_of(PxCudaMemoryManagerStats) == 184, "PxCudaMemoryManagerStats has size % instead of 184", size_of(PxCudaMemoryManagerStats));
    }

    /// \brief Buffer type: made of hint flags and the memory space (Device Memory, Pinned Host Memory, ...)
    PxCudaBufferType :: struct {
        memorySpace: PxCudaBufferMemorySpace.Enum; //!< specifies which memory space for the buffer
        flags:       PxCudaBufferFlags.Enum; //!< specifies the usage flags for the buffer
    }
    #run {if true then return;
        instance: PxCudaBufferType;
        assert(((cast(*void)(*instance.memorySpace)) - cast(*void)(*instance)) == 0, "PxCudaBufferType.memorySpace has unexpected offset % instead of 0", ((cast(*void)(*instance.memorySpace)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxCudaBufferType.memorySpace)) == 4, "PxCudaBufferType.memorySpace has unexpected size % instead of 4", size_of(type_of(PxCudaBufferType.memorySpace)));
        assert(((cast(*void)(*instance.flags)) - cast(*void)(*instance)) == 4, "PxCudaBufferType.flags has unexpected offset % instead of 4", ((cast(*void)(*instance.flags)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxCudaBufferType.flags)) == 4, "PxCudaBufferType.flags has unexpected size % instead of 4", size_of(type_of(PxCudaBufferType.flags)));
        assert(size_of(PxCudaBufferType) == 8, "PxCudaBufferType has size % instead of 8", size_of(PxCudaBufferType));
    }

    /// \brief Buffer which keeps informations about allocated piece of memory.
    PxCudaBuffer :: struct {
        vtable: *PxCudaBuffer_VTable;
    }
    PxCudaBuffer_VTable :: struct #type_info_none {
        getCudaMemoryManager: (this: *PxCudaBuffer) -> *PxCudaMemoryManager #cpp_method;

        free: (this: *PxCudaBuffer) -> bool #cpp_method;

        realloc: (this: *PxCudaBuffer, size: size_t, file: *u8 = null, line: s32 = 0, allocName: *u8 = null, allocId: PxAllocId.Enum = .UNASSIGNED) -> bool #cpp_method;

        getType: (this: *PxCudaBuffer) -> *PxCudaBufferType #cpp_method;

        getPtr: (this: *PxCudaBuffer) -> PxCudaBufferPtr #cpp_method;

        getSize: (this: *PxCudaBuffer) -> size_t #cpp_method;

        Destructor: (this: *PxCudaBuffer, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxCudaBuffer_getCudaMemoryManager :: inline (this: *PxCudaBuffer) -> *PxCudaMemoryManager { return this.vtable.getCudaMemoryManager(this); }

    PxCudaBuffer_free :: inline (this: *PxCudaBuffer) -> bool { return this.vtable.free(this); }

    PxCudaBuffer_realloc :: inline (this: *PxCudaBuffer, size: size_t, file: *u8 = null, line: s32 = 0, allocName: *u8 = null, allocId: PxAllocId.Enum = .UNASSIGNED) -> bool { return this.vtable.realloc(this, size, file, line, allocName, allocId); }

    PxCudaBuffer_getType :: inline (this: *PxCudaBuffer) -> *PxCudaBufferType { return this.vtable.getType(this); }

    PxCudaBuffer_getPtr :: inline (this: *PxCudaBuffer) -> PxCudaBufferPtr { return this.vtable.getPtr(this); }

    PxCudaBuffer_getSize :: inline (this: *PxCudaBuffer) -> size_t { return this.vtable.getSize(this); }

    PxCudaBuffer_Destructor :: inline (this: *PxCudaBuffer, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxCudaBuffer) -> *PxCudaBuffer_VTable { return obj.vtable; }

    #run {if true then return;
        assert(size_of(PxCudaBuffer) == 8, "PxCudaBuffer has size % instead of 8", size_of(PxCudaBuffer));
    }

    /// \brief Allocator class for different kinds of CUDA related memory.
    PxCudaMemoryManager :: struct {
        vtable: *PxCudaMemoryManager_VTable;
    }
    PxCudaMemoryManager_VTable :: struct #type_info_none {
        alloc: (this: *PxCudaMemoryManager, memorySpace: PxCudaBufferMemorySpace.Enum, size: size_t, file: *u8 = null, line: s32 = 0, allocName: *u8 = null, allocId: PxAllocId.Enum = .UNASSIGNED) -> PxCudaBufferPtr #cpp_method;

        alloc_1: (this: *PxCudaMemoryManager, type: /*const reference*/ *PxCudaBufferType, size: size_t, file: /*const*/ *u8 = null, line: s32 = 0, allocName: /*const*/ *u8 = null, allocId: PxAllocId.Enum = .UNASSIGNED) -> *PxCudaBuffer #cpp_method;

        free: (this: *PxCudaMemoryManager, memorySpace: PxCudaBufferMemorySpace.Enum, addr: PxCudaBufferPtr) -> bool #cpp_method;

        realloc: (this: *PxCudaMemoryManager, memorySpace: PxCudaBufferMemorySpace.Enum, addr: PxCudaBufferPtr, size: size_t, file: *u8 = null, line: s32 = 0, allocName: *u8 = null, allocId: PxAllocId.Enum = .UNASSIGNED) -> bool #cpp_method;

        getStats: (this: *PxCudaMemoryManager, type: *PxCudaBufferType, outStats: *PxCudaMemoryManagerStats) -> void #cpp_method;

        reserve: (this: *PxCudaMemoryManager, type: *PxCudaBufferType, size: size_t) -> bool #cpp_method;

        setPageSize: (this: *PxCudaMemoryManager, type: *PxCudaBufferType, size: size_t) -> bool #cpp_method;

        setMaxMemorySize: (this: *PxCudaMemoryManager, type: *PxCudaBufferType, size: size_t) -> bool #cpp_method;

        getBaseSize: (this: *PxCudaMemoryManager, type: *PxCudaBufferType) -> size_t #cpp_method;

        getPageSize: (this: *PxCudaMemoryManager, type: *PxCudaBufferType) -> size_t #cpp_method;

        getMaxMemorySize: (this: *PxCudaMemoryManager, type: *PxCudaBufferType) -> size_t #cpp_method;

        getMappedPinnedPtr: (this: *PxCudaMemoryManager, hostPtr: PxCudaBufferPtr) -> PxCudaBufferPtr #cpp_method;

        Destructor: (this: *PxCudaMemoryManager, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxCudaMemoryManager_alloc :: inline (this: *PxCudaMemoryManager, memorySpace: PxCudaBufferMemorySpace.Enum, size: size_t, file: /*const*/ *u8 = null, line: s32 = 0, allocName: /*const*/ *u8 = null, allocId: PxAllocId.Enum = .UNASSIGNED) -> PxCudaBufferPtr { return this.vtable.alloc(this, memorySpace, size, file, line, allocName, allocId); }

    PxCudaMemoryManager_alloc_1 :: inline (this: *PxCudaMemoryManager, type: /*const reference*/ *PxCudaBufferType, size: size_t, file: /*const*/ *u8 = null, line: s32 = 0, allocName: /*const*/ *u8 = null, allocId: PxAllocId.Enum = .UNASSIGNED) -> *PxCudaBuffer { return this.vtable.alloc_1(this, type, size, file, line, allocName, allocId); }

    PxCudaMemoryManager_free :: inline (this: *PxCudaMemoryManager, memorySpace: PxCudaBufferMemorySpace.Enum, addr: PxCudaBufferPtr) -> bool { return this.vtable.free(this, memorySpace, addr); }

    PxCudaMemoryManager_realloc :: inline (this: *PxCudaMemoryManager, memorySpace: PxCudaBufferMemorySpace.Enum, addr: PxCudaBufferPtr, size: size_t, file: *u8 = null, line: s32 = 0, allocName: *u8 = null, allocId: PxAllocId.Enum = .UNASSIGNED) -> bool { return this.vtable.realloc(this, memorySpace, addr, size, file, line, allocName, allocId); }

    PxCudaMemoryManager_getStats :: inline (this: *PxCudaMemoryManager, type: *PxCudaBufferType, outStats: *PxCudaMemoryManagerStats) { this.vtable.getStats(this, type, outStats); }

    PxCudaMemoryManager_reserve :: inline (this: *PxCudaMemoryManager, type: *PxCudaBufferType, size: size_t) -> bool { return this.vtable.reserve(this, type, size); }

    PxCudaMemoryManager_setPageSize :: inline (this: *PxCudaMemoryManager, type: *PxCudaBufferType, size: size_t) -> bool { return this.vtable.setPageSize(this, type, size); }

    PxCudaMemoryManager_setMaxMemorySize :: inline (this: *PxCudaMemoryManager, type: *PxCudaBufferType, size: size_t) -> bool { return this.vtable.setMaxMemorySize(this, type, size); }

    PxCudaMemoryManager_getBaseSize :: inline (this: *PxCudaMemoryManager, type: *PxCudaBufferType) -> size_t { return this.vtable.getBaseSize(this, type); }

    PxCudaMemoryManager_getPageSize :: inline (this: *PxCudaMemoryManager, type: *PxCudaBufferType) -> size_t { return this.vtable.getPageSize(this, type); }

    PxCudaMemoryManager_getMaxMemorySize :: inline (this: *PxCudaMemoryManager, type: *PxCudaBufferType) -> size_t { return this.vtable.getMaxMemorySize(this, type); }

    PxCudaMemoryManager_getMappedPinnedPtr :: inline (this: *PxCudaMemoryManager, hostPtr: PxCudaBufferPtr) -> PxCudaBufferPtr { return this.vtable.getMappedPinnedPtr(this, hostPtr); }

    PxCudaMemoryManager_Destructor :: inline (this: *PxCudaMemoryManager, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxCudaMemoryManager) -> *PxCudaMemoryManager_VTable { return obj.vtable; }

    #run {if true then return;
        assert(size_of(PxCudaMemoryManager) == 8, "PxCudaMemoryManager has size % instead of 8", size_of(PxCudaMemoryManager));
    }

    /** \brief Possible graphic/CUDA interoperability modes for context */
    PxCudaInteropMode :: struct {
        /**
        * \brief Possible graphic/CUDA interoperability modes for context
        */
        Enum :: enum s32 {
            NO_INTEROP    :: 0;
            D3D10_INTEROP :: 1;
            D3D11_INTEROP :: 2;
            OGL_INTEROP   :: 3;

            COUNT         :: 4;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxCudaInteropMode) == 1, "PxCudaInteropMode has size % instead of 1", size_of(PxCudaInteropMode));
    }

    PxCudaInteropRegisterFlag :: struct {
        Enum :: enum s32 {
            NONE           :: 0;
            READ_ONLY      :: 1;
            WRITE_DISCARD  :: 2;
            SURFACE_LDST   :: 4;
            TEXTURE_GATHER :: 8;

            eNONE           :: NONE;
            eREAD_ONLY      :: READ_ONLY;
            eWRITE_DISCARD  :: WRITE_DISCARD;
            eSURFACE_LDST   :: SURFACE_LDST;
            eTEXTURE_GATHER :: TEXTURE_GATHER;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxCudaInteropRegisterFlag) == 1, "PxCudaInteropRegisterFlag has size % instead of 1", size_of(PxCudaInteropRegisterFlag));
    }

    /**
    \brief collection of set bits defined in NxCudaInteropRegisterFlag.

    @see NxCudaInteropRegisterFlag
    */
    PxCudaInteropRegisterFlags :: PxFlags(PxCudaInteropRegisterFlag.Enum, u32);

    //! \brief Descriptor used to create a PxCudaContextManager
    PxCudaContextManagerDesc :: struct {
        /**
        * \brief The CUDA context to manage
        *
        * If left NULL, the PxCudaContextManager will create a new context.  If
        * graphicsDevice is also not NULL, this new CUDA context will be bound to
        * that graphics device, enabling the use of CUDA/Graphics interop features.
        *
        * If ctx is not NULL, the specified context must be applied to the thread
        * that is allocating the PxCudaContextManager at creation time (aka, it
        * cannot be popped).  The PxCudaContextManager will take ownership of the
        * context until the manager is released.  All access to the context must be
        * gated by lock acquisition.
        *
        * If the user provides a context for the PxCudaContextManager, the context
        * _must_ have either been created on the GPU ordinal returned by
        * PxGetSuggestedCudaDeviceOrdinal() or on your graphics device.
        *
        * It is perfectly acceptable to allocate device or host pinned memory from
        * the context outside the scope of the PxCudaMemoryManager, so long as you
        * manage its eventual cleanup.
        */
        ctx:            *CUcontext;

        /**
        * \brief D3D device pointer or OpenGl context handle
        *
        * Only applicable when ctx is NULL, thus forcing a new context to be
        * created.  In that case, the created context will be bound to this
        * graphics device.
        */
        graphicsDevice: *void;

        /**
        * \brief Application-specific GUID
        *
        * If your application employs PhysX modules that use CUDA you need to use a GUID
        * so that patches for new architectures can be released for your game.You can obtain a GUID for your
        * application from Nvidia.
        */
        appGUID:        *u8;

        /**
        * \brief The CUDA/Graphics interop mode of this context
        *
        * If ctx is NULL, this value describes the nature of the graphicsDevice
        * pointer provided by the user.  Else it describes the nature of the
        * context provided by the user.
        */
        interopMode:    PxCudaInteropMode.Enum;

        /**
        * \brief Size of persistent memory
        *
        * This memory is allocated up front and stays allocated until the
        * PxCudaContextManager is released.  Size is in bytes, has to be power of two
        * and bigger than the page size.  Set to 0 to only use dynamic pages.
        *
        * Note: On Vista O/S and above, there is a per-memory allocation overhead
        * to every CUDA work submission, so we recommend that you carefully tune
        * this initial base memory size to closely approximate the amount of
        * memory your application will consume.

        Note: This is currently not used by PxSceneFlag::eENABLE_GPU_DYNAMICS. Memory allocation properties are configured
        for GPU rigid bodies using PxSceneDesc::gpuDynamicsConfig.
        */
        memoryBaseSize: [4] u32;

        /**
        * \brief Size of memory pages
        *
        * The memory manager will dynamically grow and shrink in blocks multiple of
        * this page size. Size has to be power of two and bigger than 0.

        Note: This is currently not used by PxSceneFlag::eENABLE_GPU_DYNAMICS. Memory allocation properties are configured
        for GPU rigid bodies using PxSceneDesc::gpuDynamicsConfig.
        */
        memoryPageSize: [4] u32;

        /**
        * \brief Maximum size of memory that the memory manager will allocate

        Note: This is currently not used by PxSceneFlag::eENABLE_GPU_DYNAMICS. Memory allocation properties are configured
        for GPU rigid bodies using PxSceneDesc::gpuDynamicsConfig.
        */
        maxMemorySize:  [4] u32;
    }
    #run {if true then return;
        instance: PxCudaContextManagerDesc;
        assert(((cast(*void)(*instance.ctx)) - cast(*void)(*instance)) == 0, "PxCudaContextManagerDesc.ctx has unexpected offset % instead of 0", ((cast(*void)(*instance.ctx)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxCudaContextManagerDesc.ctx)) == 8, "PxCudaContextManagerDesc.ctx has unexpected size % instead of 8", size_of(type_of(PxCudaContextManagerDesc.ctx)));
        assert(((cast(*void)(*instance.graphicsDevice)) - cast(*void)(*instance)) == 8, "PxCudaContextManagerDesc.graphicsDevice has unexpected offset % instead of 8", ((cast(*void)(*instance.graphicsDevice)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxCudaContextManagerDesc.graphicsDevice)) == 8, "PxCudaContextManagerDesc.graphicsDevice has unexpected size % instead of 8", size_of(type_of(PxCudaContextManagerDesc.graphicsDevice)));
        assert(((cast(*void)(*instance.appGUID)) - cast(*void)(*instance)) == 16, "PxCudaContextManagerDesc.appGUID has unexpected offset % instead of 16", ((cast(*void)(*instance.appGUID)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxCudaContextManagerDesc.appGUID)) == 8, "PxCudaContextManagerDesc.appGUID has unexpected size % instead of 8", size_of(type_of(PxCudaContextManagerDesc.appGUID)));
        assert(((cast(*void)(*instance.interopMode)) - cast(*void)(*instance)) == 24, "PxCudaContextManagerDesc.interopMode has unexpected offset % instead of 24", ((cast(*void)(*instance.interopMode)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxCudaContextManagerDesc.interopMode)) == 4, "PxCudaContextManagerDesc.interopMode has unexpected size % instead of 4", size_of(type_of(PxCudaContextManagerDesc.interopMode)));
        assert(((cast(*void)(*instance.memoryBaseSize)) - cast(*void)(*instance)) == 28, "PxCudaContextManagerDesc.memoryBaseSize has unexpected offset % instead of 28", ((cast(*void)(*instance.memoryBaseSize)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxCudaContextManagerDesc.memoryBaseSize)) == 16, "PxCudaContextManagerDesc.memoryBaseSize has unexpected size % instead of 16", size_of(type_of(PxCudaContextManagerDesc.memoryBaseSize)));
        assert(((cast(*void)(*instance.memoryPageSize)) - cast(*void)(*instance)) == 44, "PxCudaContextManagerDesc.memoryPageSize has unexpected offset % instead of 44", ((cast(*void)(*instance.memoryPageSize)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxCudaContextManagerDesc.memoryPageSize)) == 16, "PxCudaContextManagerDesc.memoryPageSize has unexpected size % instead of 16", size_of(type_of(PxCudaContextManagerDesc.memoryPageSize)));
        assert(((cast(*void)(*instance.maxMemorySize)) - cast(*void)(*instance)) == 60, "PxCudaContextManagerDesc.maxMemorySize has unexpected offset % instead of 60", ((cast(*void)(*instance.maxMemorySize)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxCudaContextManagerDesc.maxMemorySize)) == 16, "PxCudaContextManagerDesc.maxMemorySize has unexpected size % instead of 16", size_of(type_of(PxCudaContextManagerDesc.maxMemorySize)));
        assert(size_of(PxCudaContextManagerDesc) == 80, "PxCudaContextManagerDesc has size % instead of 80", size_of(PxCudaContextManagerDesc));
    }

    /**
    * \brief Manages memory, thread locks, and task scheduling for a CUDA context
    *
    * A PxCudaContextManager manages access to a single CUDA context, allowing it to
    * be shared between multiple scenes.   Memory allocations are dynamic: starting
    * with an initial heap size and growing on demand by a configurable page size.
    * The context must be acquired from the manager before using any CUDA APIs.
    *
    * The PxCudaContextManager is based on the CUDA driver API and explictly does not
    * support the CUDA runtime API (aka, CUDART).
    */
    PxCudaContextManager :: struct {
        vtable: *PxCudaContextManager_VTable;
    }
    PxCudaContextManager_VTable :: struct #type_info_none {
        acquireContext: (this: *PxCudaContextManager) -> void #cpp_method;

        releaseContext: (this: *PxCudaContextManager) -> void #cpp_method;

        getContext: (this: *PxCudaContextManager) -> CUcontext #cpp_method;

        getMemoryManager: (this: *PxCudaContextManager) -> *PxCudaMemoryManager #cpp_method;

        contextIsValid: (this: *PxCudaContextManager) -> bool #cpp_method;

        supportsArchSM10: (this: *PxCudaContextManager) -> bool #cpp_method;
        supportsArchSM11: (this: *PxCudaContextManager) -> bool #cpp_method;
        supportsArchSM12: (this: *PxCudaContextManager) -> bool #cpp_method;
        supportsArchSM13: (this: *PxCudaContextManager) -> bool #cpp_method;
        supportsArchSM20: (this: *PxCudaContextManager) -> bool #cpp_method;
        supportsArchSM30: (this: *PxCudaContextManager) -> bool #cpp_method;
        supportsArchSM35: (this: *PxCudaContextManager) -> bool #cpp_method;
        supportsArchSM50: (this: *PxCudaContextManager) -> bool #cpp_method;
        supportsArchSM52: (this: *PxCudaContextManager) -> bool #cpp_method;
        supportsArchSM60: (this: *PxCudaContextManager) -> bool #cpp_method;
        isIntegrated: (this: *PxCudaContextManager) -> bool #cpp_method;
        canMapHostMemory: (this: *PxCudaContextManager) -> bool #cpp_method;
        getDriverVersion: (this: *PxCudaContextManager) -> s32 #cpp_method;
        getDeviceTotalMemBytes: (this: *PxCudaContextManager) -> size_t #cpp_method;
        getMultiprocessorCount: (this: *PxCudaContextManager) -> s32 #cpp_method;
        getClockRate: (this: *PxCudaContextManager) -> u32 #cpp_method;
        getSharedMemPerBlock: (this: *PxCudaContextManager) -> s32 #cpp_method;
        getSharedMemPerMultiprocessor: (this: *PxCudaContextManager) -> s32 #cpp_method;
        getMaxThreadsPerBlock: (this: *PxCudaContextManager) -> u32 #cpp_method;
        getDeviceName: (this: *PxCudaContextManager) -> *u8 #cpp_method;
        getDevice: (this: *PxCudaContextManager) -> CUdevice #cpp_method;
        getInteropMode: (this: *PxCudaContextManager) -> PxCudaInteropMode.Enum #cpp_method;

        setUsingConcurrentStreams: (this: *PxCudaContextManager, unknown0: bool) -> void #cpp_method;
        getUsingConcurrentStreams: (this: *PxCudaContextManager) -> bool #cpp_method;

        registerResourceInCudaGL: (this: *PxCudaContextManager, resource: *CUgraphicsResource, buffer: u32, flags: PxCudaInteropRegisterFlags = .{}) -> bool #cpp_method;

        registerResourceInCudaD3D: (this: *PxCudaContextManager, resource: *CUgraphicsResource, resourcePointer: *void, flags: PxCudaInteropRegisterFlags = .{}) -> bool #cpp_method;

        unregisterResourceInCuda: (this: *PxCudaContextManager, resource: CUgraphicsResource) -> bool #cpp_method;

        usingDedicatedGPU: (this: *PxCudaContextManager) -> s32 #cpp_method;

        release: (this: *PxCudaContextManager) -> void #cpp_method;

        Destructor: (this: *PxCudaContextManager, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxCudaContextManager_acquireContext :: inline (this: *PxCudaContextManager) { this.vtable.acquireContext(this); }

    PxCudaContextManager_releaseContext :: inline (this: *PxCudaContextManager) { this.vtable.releaseContext(this); }

    PxCudaContextManager_getContext :: inline (this: *PxCudaContextManager) -> CUcontext { return this.vtable.getContext(this); }

    PxCudaContextManager_getMemoryManager :: inline (this: *PxCudaContextManager) -> *PxCudaMemoryManager { return this.vtable.getMemoryManager(this); }

    PxCudaContextManager_contextIsValid :: inline (this: *PxCudaContextManager) -> bool { return this.vtable.contextIsValid(this); }

    PxCudaContextManager_supportsArchSM10 :: inline (this: *PxCudaContextManager) -> bool { return this.vtable.supportsArchSM10(this); }
    PxCudaContextManager_supportsArchSM11 :: inline (this: *PxCudaContextManager) -> bool { return this.vtable.supportsArchSM11(this); }
    PxCudaContextManager_supportsArchSM12 :: inline (this: *PxCudaContextManager) -> bool { return this.vtable.supportsArchSM12(this); }
    PxCudaContextManager_supportsArchSM13 :: inline (this: *PxCudaContextManager) -> bool { return this.vtable.supportsArchSM13(this); }
    PxCudaContextManager_supportsArchSM20 :: inline (this: *PxCudaContextManager) -> bool { return this.vtable.supportsArchSM20(this); }
    PxCudaContextManager_supportsArchSM30 :: inline (this: *PxCudaContextManager) -> bool { return this.vtable.supportsArchSM30(this); }
    PxCudaContextManager_supportsArchSM35 :: inline (this: *PxCudaContextManager) -> bool { return this.vtable.supportsArchSM35(this); }
    PxCudaContextManager_supportsArchSM50 :: inline (this: *PxCudaContextManager) -> bool { return this.vtable.supportsArchSM50(this); }
    PxCudaContextManager_supportsArchSM52 :: inline (this: *PxCudaContextManager) -> bool { return this.vtable.supportsArchSM52(this); }
    PxCudaContextManager_supportsArchSM60 :: inline (this: *PxCudaContextManager) -> bool { return this.vtable.supportsArchSM60(this); }
    PxCudaContextManager_isIntegrated :: inline (this: *PxCudaContextManager) -> bool { return this.vtable.isIntegrated(this); }
    PxCudaContextManager_canMapHostMemory :: inline (this: *PxCudaContextManager) -> bool { return this.vtable.canMapHostMemory(this); }
    PxCudaContextManager_getDriverVersion :: inline (this: *PxCudaContextManager) -> s32 { return this.vtable.getDriverVersion(this); }
    PxCudaContextManager_getDeviceTotalMemBytes :: inline (this: *PxCudaContextManager) -> size_t { return this.vtable.getDeviceTotalMemBytes(this); }
    PxCudaContextManager_getMultiprocessorCount :: inline (this: *PxCudaContextManager) -> s32 { return this.vtable.getMultiprocessorCount(this); }
    PxCudaContextManager_getClockRate :: inline (this: *PxCudaContextManager) -> u32 { return this.vtable.getClockRate(this); }
    PxCudaContextManager_getSharedMemPerBlock :: inline (this: *PxCudaContextManager) -> s32 { return this.vtable.getSharedMemPerBlock(this); }
    PxCudaContextManager_getSharedMemPerMultiprocessor :: inline (this: *PxCudaContextManager) -> s32 { return this.vtable.getSharedMemPerMultiprocessor(this); }
    PxCudaContextManager_getMaxThreadsPerBlock :: inline (this: *PxCudaContextManager) -> u32 { return this.vtable.getMaxThreadsPerBlock(this); }
    PxCudaContextManager_getDeviceName :: inline (this: *PxCudaContextManager) -> *u8 { return this.vtable.getDeviceName(this); }
    PxCudaContextManager_getDevice :: inline (this: *PxCudaContextManager) -> CUdevice { return this.vtable.getDevice(this); }
    PxCudaContextManager_getInteropMode :: inline (this: *PxCudaContextManager) -> PxCudaInteropMode.Enum { return this.vtable.getInteropMode(this); }

    PxCudaContextManager_setUsingConcurrentStreams :: inline (this: *PxCudaContextManager, unknown0: bool) { this.vtable.setUsingConcurrentStreams(this, unknown0); }
    PxCudaContextManager_getUsingConcurrentStreams :: inline (this: *PxCudaContextManager) -> bool { return this.vtable.getUsingConcurrentStreams(this); }

    PxCudaContextManager_registerResourceInCudaGL :: inline (this: *PxCudaContextManager, resource: *CUgraphicsResource, buffer: u32, flags: PxCudaInteropRegisterFlags = .{}) -> bool { return this.vtable.registerResourceInCudaGL(this, resource, buffer, flags); }

    PxCudaContextManager_registerResourceInCudaD3D :: inline (this: *PxCudaContextManager, resource: *CUgraphicsResource, resourcePointer: *void, flags: PxCudaInteropRegisterFlags = .{}) -> bool { return this.vtable.registerResourceInCudaD3D(this, resource, resourcePointer, flags); }

    PxCudaContextManager_unregisterResourceInCuda :: inline (this: *PxCudaContextManager, resource: CUgraphicsResource) -> bool { return this.vtable.unregisterResourceInCuda(this, resource); }

    PxCudaContextManager_usingDedicatedGPU :: inline (this: *PxCudaContextManager) -> s32 { return this.vtable.usingDedicatedGPU(this); }

    PxCudaContextManager_release :: inline (this: *PxCudaContextManager) { this.vtable.release(this); }

    PxCudaContextManager_Destructor :: inline (this: *PxCudaContextManager, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxCudaContextManager) -> *PxCudaContextManager_VTable { return obj.vtable; }

    #run {if true then return;
        assert(size_of(PxCudaContextManager) == 8, "PxCudaContextManager has size % instead of 8", size_of(PxCudaContextManager));
    }

    /**
    * \brief Convenience class for holding CUDA lock within a scope
    */
    PxScopedCudaLock :: struct {
        /**
        * \brief CUDA context manager pointer (initialized in the constructor)
        */
        mCtx: *PxCudaContextManager;
    }
    #run {if true then return;
        instance: PxScopedCudaLock;
        assert(((cast(*void)(*instance.mCtx)) - cast(*void)(*instance)) == 0, "PxScopedCudaLock.mCtx has unexpected offset % instead of 0", ((cast(*void)(*instance.mCtx)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxScopedCudaLock.mCtx)) == 8, "PxScopedCudaLock.mCtx has unexpected size % instead of 8", size_of(type_of(PxScopedCudaLock.mCtx)));
        assert(size_of(PxScopedCudaLock) == 8, "PxScopedCudaLock has size % instead of 8", size_of(PxScopedCudaLock));
    }

    /**
    \brief A geometry type.

    Used to distinguish the type of a ::PxGeometry object.
    */
    PxGeometryType :: struct {
        Enum :: enum s32 {
            SPHERE         :: 0;
            PLANE          :: 1;
            CAPSULE        :: 2;
            BOX            :: 3;
            CONVEXMESH     :: 4;
            TRIANGLEMESH   :: 5;
            HEIGHTFIELD    :: 6;
            GEOMETRY_COUNT :: 7;
            INVALID        :: -1;

            eSPHERE         :: SPHERE;
            ePLANE          :: PLANE;
            eCAPSULE        :: CAPSULE;
            eBOX            :: BOX;
            eCONVEXMESH     :: CONVEXMESH;
            eTRIANGLEMESH   :: TRIANGLEMESH;
            eHEIGHTFIELD    :: HEIGHTFIELD;
            eGEOMETRY_COUNT :: GEOMETRY_COUNT;
            eINVALID        :: INVALID;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxGeometryType) == 1, "PxGeometryType has size % instead of 1", size_of(PxGeometryType));
    }

    /**
    \brief A geometry object.

    A geometry object defines the characteristics of a spatial object, but without any information
    about its placement in the world.

    \note This is an abstract class.  You cannot create instances directly.  Create an instance of one of the derived classes instead.
    */
    PxGeometry :: struct {
        /**
        \brief Returns the type of the geometry.
        \return The type of the object.
        */
        getType :: (this: *PxGeometry) -> PxGeometryType.Enum #cpp_method #foreign physx_lib "?getType@PxGeometry@physx@@QEBA?AW4Enum@PxGeometryType@2@XZ";

        Constructor :: (this: *PxGeometry, type: PxGeometryType.Enum) -> void #cpp_method #foreign physx_lib "??0PxGeometry@physx@@IEAA@W4Enum@PxGeometryType@1@@Z";
        mType: PxGeometryType.Enum;
    }
    #run {if true then return;
        instance: PxGeometry;
        assert(((cast(*void)(*instance.mType)) - cast(*void)(*instance)) == 0, "PxGeometry.mType has unexpected offset % instead of 0", ((cast(*void)(*instance.mType)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxGeometry.mType)) == 4, "PxGeometry.mType has unexpected size % instead of 4", size_of(type_of(PxGeometry.mType)));
        assert(size_of(PxGeometry) == 4, "PxGeometry has size % instead of 4", size_of(PxGeometry));
    }

    /**
    \brief Class representing the geometry of a box.

    The geometry of a box can be fully specified by its half extents.  This is the half of its width, height, and depth.
    \note The scaling of the box is expected to be baked into these values, there is no additional scaling parameter.
    */
    PxBoxGeometry :: struct {
        #as using pxgeometry: PxGeometry;

        /**
        \brief Default constructor, initializes to a box with zero dimensions.
        */
        Constructor :: (this: *PxBoxGeometry) -> void #cpp_method #foreign physx_lib "??0PxBoxGeometry@physx@@QEAA@XZ";

        /**
        \brief Constructor to initialize half extents from scalar parameters.
        \param hx Initial half extents' x component.
        \param hy Initial half extents' y component.
        \param hz Initial half extents' z component.
        */
        Constructor :: (this: *PxBoxGeometry, hx: PxReal, hy: PxReal, hz: PxReal) -> void #cpp_method #foreign physx_lib "??0PxBoxGeometry@physx@@QEAA@MMM@Z";

        /**
        \brief Constructor to initialize half extents from vector parameter.
        \param halfExtents_ Initial half extents.
        */
        Constructor :: (this: *PxBoxGeometry, halfExtents_: PxVec3) -> void #cpp_method #foreign physx_lib "??0PxBoxGeometry@physx@@QEAA@VPxVec3@1@@Z";

        /**
        \brief Returns true if the geometry is valid.

        \return True if the current settings are valid

        \note A valid box has a positive extent in each direction (halfExtents.x > 0, halfExtents.y > 0, halfExtents.z > 0).
        It is illegal to call PxRigidActor::createShape and PxPhysics::createShape with a box that has zero extent in any direction.

        @see PxRigidActor::createShape, PxPhysics::createShape
        */
        isValid :: (this: *PxBoxGeometry) -> bool #cpp_method #foreign physx_lib "?isValid@PxBoxGeometry@physx@@QEBA_NXZ";

        /**
        \brief Half of the width, height, and depth of the box.
        */
        halfExtents: PxVec3;
    }
    #run {if true then return;
        assert(size_of(type_of(PxBoxGeometry.pxgeometry)) == 4, "PxBoxGeometry.pxgeometry has unexpected size % instead of 4", size_of(type_of(PxBoxGeometry.pxgeometry)));
        instance: PxBoxGeometry;
        assert(((cast(*void)(*instance.halfExtents)) - cast(*void)(*instance)) == 4, "PxBoxGeometry.halfExtents has unexpected offset % instead of 4", ((cast(*void)(*instance.halfExtents)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxBoxGeometry.halfExtents)) == 12, "PxBoxGeometry.halfExtents has unexpected size % instead of 12", size_of(type_of(PxBoxGeometry.halfExtents)));
        assert(size_of(PxBoxGeometry) == 16, "PxBoxGeometry has size % instead of 16", size_of(PxBoxGeometry));
    }

    /**
    \brief Class representing the bounding volume hierarchy structure.

    PxBVHStructure can be  provided to PxScene::addActor. In this case the scene query
    pruning structure inside PhysX SDK will store/update one bound per actor.
    The scene queries against such an actor will query actor bounds and then
    make a local space query against the provided BVH structure, which is in
    actor's local space.

    @see PxScene::addActor
    */
    PxBVHStructure :: struct {
        #as using pxbase: PxBase;
        #place pxbase; pxbvhstructure_vtable: *PxBVHStructure_VTable;
    }
    PxBVHStructure_VTable :: struct #type_info_none {
        using pxbase: PxBase_VTable;
        raycast: (this: *PxBVHStructure, origin: *PxVec3, unitDir: *PxVec3, maxDist: PxReal, maxHits: PxU32, rayHits: *PxU32) -> PxU32 #cpp_method;

        sweep: (this: *PxBVHStructure, aabb: *PxBounds3, unitDir: *PxVec3, maxDist: PxReal, maxHits: PxU32, sweepHits: *PxU32) -> PxU32 #cpp_method;

        overlap: (this: *PxBVHStructure, aabb: *PxBounds3, maxHits: PxU32, overlapHits: *PxU32) -> PxU32 #cpp_method;

        getBounds: (this: *PxBVHStructure) -> *PxBounds3 #cpp_method;

        getNbBounds: (this: *PxBVHStructure) -> PxU32 #cpp_method;
    }

    PxBVHStructure_raycast :: inline (this: *PxBVHStructure, origin: *PxVec3, unitDir: *PxVec3, maxDist: PxReal, maxHits: PxU32, rayHits: *PxU32) -> PxU32 { return this.pxbvhstructure_vtable.raycast(this, origin, unitDir, maxDist, maxHits, rayHits); }

    PxBVHStructure_sweep :: inline (this: *PxBVHStructure, aabb: *PxBounds3, unitDir: *PxVec3, maxDist: PxReal, maxHits: PxU32, sweepHits: *PxU32) -> PxU32 { return this.pxbvhstructure_vtable.sweep(this, aabb, unitDir, maxDist, maxHits, sweepHits); }

    PxBVHStructure_overlap :: inline (this: *PxBVHStructure, aabb: *PxBounds3, maxHits: PxU32, overlapHits: *PxU32) -> PxU32 { return this.pxbvhstructure_vtable.overlap(this, aabb, maxHits, overlapHits); }

    PxBVHStructure_getBounds :: inline (this: *PxBVHStructure) -> *PxBounds3 { return this.pxbvhstructure_vtable.getBounds(this); }

    PxBVHStructure_getNbBounds :: inline (this: *PxBVHStructure) -> PxU32 { return this.pxbvhstructure_vtable.getNbBounds(this); }

    vtable :: (obj: *PxBVHStructure) -> *PxBVHStructure_VTable { return obj.pxbvhstructure_vtable; }

    #run {if true then return;
        assert(size_of(type_of(PxBVHStructure.pxbase)) == 16, "PxBVHStructure.pxbase has unexpected size % instead of 16", size_of(type_of(PxBVHStructure.pxbase)));
        assert(size_of(PxBVHStructure) == 16, "PxBVHStructure has size % instead of 16", size_of(PxBVHStructure));
    }

    /**
    \brief Class representing the geometry of a capsule.

    Capsules are shaped as the union of a cylinder of length 2 * halfHeight and with the
    given radius centered at the origin and extending along the x axis, and two hemispherical ends.
    \note The scaling of the capsule is expected to be baked into these values, there is no additional scaling parameter.

    The function PxTransformFromSegment is a helper for generating an appropriate transform for the capsule from the capsule's interior line segment.

    @see PxTransformFromSegment
    */
    PxCapsuleGeometry :: struct {
        #as using pxgeometry: PxGeometry;

        /**
        \brief Default constructor, initializes to a capsule with zero height and radius.
        */
        Constructor :: (this: *PxCapsuleGeometry) -> void #cpp_method #foreign physx_lib "??0PxCapsuleGeometry@physx@@QEAA@XZ";

        /**
        \brief Constructor, initializes to a capsule with passed radius and half height.
        */
        Constructor :: (this: *PxCapsuleGeometry, radius_: PxReal, halfHeight_: PxReal) -> void #cpp_method #foreign physx_lib "??0PxCapsuleGeometry@physx@@QEAA@MM@Z";

        /**
        \brief Returns true if the geometry is valid.

        \return True if the current settings are valid.

        \note A valid capsule has radius > 0, halfHeight > 0.
        It is illegal to call PxRigidActor::createShape and PxPhysics::createShape with a capsule that has zero radius or height.

        @see PxRigidActor::createShape, PxPhysics::createShape
        */
        isValid :: (this: *PxCapsuleGeometry) -> bool #cpp_method #foreign physx_lib "?isValid@PxCapsuleGeometry@physx@@QEBA_NXZ";

        /**
        \brief The radius of the capsule.
        */
        radius:     PxReal;

        /**
        \brief half of the capsule's height, measured between the centers of the hemispherical ends.
        */
        halfHeight: PxReal;
    }
    #run {if true then return;
        assert(size_of(type_of(PxCapsuleGeometry.pxgeometry)) == 4, "PxCapsuleGeometry.pxgeometry has unexpected size % instead of 4", size_of(type_of(PxCapsuleGeometry.pxgeometry)));
        instance: PxCapsuleGeometry;
        assert(((cast(*void)(*instance.radius)) - cast(*void)(*instance)) == 4, "PxCapsuleGeometry.radius has unexpected offset % instead of 4", ((cast(*void)(*instance.radius)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxCapsuleGeometry.radius)) == 4, "PxCapsuleGeometry.radius has unexpected size % instead of 4", size_of(type_of(PxCapsuleGeometry.radius)));
        assert(((cast(*void)(*instance.halfHeight)) - cast(*void)(*instance)) == 8, "PxCapsuleGeometry.halfHeight has unexpected offset % instead of 8", ((cast(*void)(*instance.halfHeight)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxCapsuleGeometry.halfHeight)) == 4, "PxCapsuleGeometry.halfHeight has unexpected size % instead of 4", size_of(type_of(PxCapsuleGeometry.halfHeight)));
        assert(size_of(PxCapsuleGeometry) == 12, "PxCapsuleGeometry has size % instead of 12", size_of(PxCapsuleGeometry));
    }

    /**
    \brief Polygon data

    Plane format: (mPlane[0],mPlane[1],mPlane[2]).dot(x) + mPlane[3] = 0
    With the normal outward-facing from the hull.
    */
    PxHullPolygon :: struct {
        mPlane:     [4] PxReal; //!< Plane equation for this polygon
        mNbVerts:   PxU16; //!< Number of vertices/edges in the polygon
        mIndexBase: PxU16; //!< Offset in index buffer
    }
    #run {if true then return;
        instance: PxHullPolygon;
        assert(((cast(*void)(*instance.mPlane)) - cast(*void)(*instance)) == 0, "PxHullPolygon.mPlane has unexpected offset % instead of 0", ((cast(*void)(*instance.mPlane)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxHullPolygon.mPlane)) == 16, "PxHullPolygon.mPlane has unexpected size % instead of 16", size_of(type_of(PxHullPolygon.mPlane)));
        assert(((cast(*void)(*instance.mNbVerts)) - cast(*void)(*instance)) == 16, "PxHullPolygon.mNbVerts has unexpected offset % instead of 16", ((cast(*void)(*instance.mNbVerts)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxHullPolygon.mNbVerts)) == 2, "PxHullPolygon.mNbVerts has unexpected size % instead of 2", size_of(type_of(PxHullPolygon.mNbVerts)));
        assert(((cast(*void)(*instance.mIndexBase)) - cast(*void)(*instance)) == 18, "PxHullPolygon.mIndexBase has unexpected offset % instead of 18", ((cast(*void)(*instance.mIndexBase)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxHullPolygon.mIndexBase)) == 2, "PxHullPolygon.mIndexBase has unexpected size % instead of 2", size_of(type_of(PxHullPolygon.mIndexBase)));
        assert(size_of(PxHullPolygon) == 20, "PxHullPolygon has size % instead of 20", size_of(PxHullPolygon));
    }

    /**
    \brief A convex mesh.

    Internally represented as a list of convex polygons. The number
    of polygons is limited to 256.

    To avoid duplicating data when you have several instances of a particular
    mesh positioned differently, you do not use this class to represent a
    convex object directly. Instead, you create an instance of this mesh via
    the PxConvexMeshGeometry and PxShape classes.

    <h3>Creation</h3>

    To create an instance of this class call PxPhysics::createConvexMesh(),
    and PxConvexMesh::release() to delete it. This is only possible
    once you have released all of its #PxShape instances.

    <h3>Visualizations:</h3>
    \li #PxVisualizationParameter::eCOLLISION_AABBS
    \li #PxVisualizationParameter::eCOLLISION_SHAPES
    \li #PxVisualizationParameter::eCOLLISION_AXES
    \li #PxVisualizationParameter::eCOLLISION_FNORMALS
    \li #PxVisualizationParameter::eCOLLISION_EDGES

    @see PxConvexMeshDesc PxPhysics.createConvexMesh()
    */
    PxConvexMesh :: struct {
        #as using pxbase: PxBase;
        #place pxbase; pxconvexmesh_vtable: *PxConvexMesh_VTable;
    }
    PxConvexMesh_VTable :: struct #type_info_none {
        using pxbase: PxBase_VTable;
        getNbVertices: (this: *PxConvexMesh) -> PxU32 #cpp_method;

        getVertices: (this: *PxConvexMesh) -> *PxVec3 #cpp_method;

        getIndexBuffer: (this: *PxConvexMesh) -> *PxU8 #cpp_method;

        getNbPolygons: (this: *PxConvexMesh) -> PxU32 #cpp_method;

        getPolygonData: (this: *PxConvexMesh, index: PxU32, data: *PxHullPolygon) -> bool #cpp_method;

        getReferenceCount: (this: *PxConvexMesh) -> PxU32 #cpp_method;

        acquireReference: (this: *PxConvexMesh) -> void #cpp_method;

        getMassInformation: (this: *PxConvexMesh, mass: *PxReal, localInertia: *PxMat33, localCenterOfMass: *PxVec3) -> void #cpp_method;

        getLocalBounds: (this: *PxConvexMesh) -> PxBounds3 #cpp_method #cpp_return_type_is_non_pod;

        isGpuCompatible: (this: *PxConvexMesh) -> bool #cpp_method;
    }

    PxConvexMesh_getNbVertices :: inline (this: *PxConvexMesh) -> PxU32 { return this.pxconvexmesh_vtable.getNbVertices(this); }

    PxConvexMesh_getVertices :: inline (this: *PxConvexMesh) -> *PxVec3 { return this.pxconvexmesh_vtable.getVertices(this); }

    PxConvexMesh_getIndexBuffer :: inline (this: *PxConvexMesh) -> *PxU8 { return this.pxconvexmesh_vtable.getIndexBuffer(this); }

    PxConvexMesh_getNbPolygons :: inline (this: *PxConvexMesh) -> PxU32 { return this.pxconvexmesh_vtable.getNbPolygons(this); }

    PxConvexMesh_getPolygonData :: inline (this: *PxConvexMesh, index: PxU32, data: *PxHullPolygon) -> bool { return this.pxconvexmesh_vtable.getPolygonData(this, index, data); }

    PxConvexMesh_getReferenceCount :: inline (this: *PxConvexMesh) -> PxU32 { return this.pxconvexmesh_vtable.getReferenceCount(this); }

    PxConvexMesh_acquireReference :: inline (this: *PxConvexMesh) { this.pxconvexmesh_vtable.acquireReference(this); }

    PxConvexMesh_getMassInformation :: inline (this: *PxConvexMesh, mass: *PxReal, localInertia: *PxMat33, localCenterOfMass: *PxVec3) { this.pxconvexmesh_vtable.getMassInformation(this, mass, localInertia, localCenterOfMass); }

    PxConvexMesh_getLocalBounds :: inline (this: *PxConvexMesh) -> PxBounds3 { return this.pxconvexmesh_vtable.getLocalBounds(this); }

    PxConvexMesh_isGpuCompatible :: inline (this: *PxConvexMesh) -> bool { return this.pxconvexmesh_vtable.isGpuCompatible(this); }

    vtable :: (obj: *PxConvexMesh) -> *PxConvexMesh_VTable { return obj.pxconvexmesh_vtable; }

    #run {if true then return;
        assert(size_of(type_of(PxConvexMesh.pxbase)) == 16, "PxConvexMesh.pxbase has unexpected size % instead of 16", size_of(type_of(PxConvexMesh.pxbase)));
        assert(size_of(PxConvexMesh) == 16, "PxConvexMesh has size % instead of 16", size_of(PxConvexMesh));
    }

    /**
    \brief A class expressing a nonuniform scaling transformation.

    The scaling is along arbitrary axes that are specified by PxMeshScale::rotation.

    \note	Negative scale values are supported for PxTriangleMeshGeometry
    with absolute values for each component within [PX_MIN_ABS_MESH_SCALE, PX_MAX_ABS_MESH_SCALE] range.
    Negative scale causes a reflection around the specified axis, in addition PhysX will flip the normals
    for mesh triangles when scale.x*scale.y*scale.z < 0.
    \note	Only positive scale values are supported for PxConvexMeshGeometry
    with values for each component within [PX_MIN_ABS_MESH_SCALE, PX_MAX_ABS_MESH_SCALE] range).

    @see PxConvexMeshGeometry PxTriangleMeshGeometry
    */
    PxMeshScale :: struct {
        /**
        \brief Constructor initializes to identity scale.
        */
        Constructor :: (this: *PxMeshScale) -> void #cpp_method #foreign physx_lib "??0PxMeshScale@physx@@QEAA@XZ";

        /**
        \brief Constructor from scalar.
        */
        Constructor :: (this: *PxMeshScale, r: PxReal) -> void #cpp_method #foreign physx_lib "??0PxMeshScale@physx@@QEAA@M@Z";

        /**
        \brief Constructor to initialize to arbitrary scale and identity scale rotation.
        */
        Constructor :: (this: *PxMeshScale, s: *PxVec3) -> void #cpp_method #foreign physx_lib "??0PxMeshScale@physx@@QEAA@AEBVPxVec3@1@@Z";
        Constructor :: (this: *PxMeshScale, s: PxVec3) #no_context {
            Constructor(this, *s);
        }

        /**
        \brief Constructor to initialize to arbitrary scaling.
        */
        Constructor :: (this: *PxMeshScale, s: *PxVec3, r: *PxQuat) -> void #cpp_method #foreign physx_lib "??0PxMeshScale@physx@@QEAA@AEBVPxVec3@1@AEBVPxQuat@1@@Z";
        Constructor :: (this: *PxMeshScale, s: PxVec3, r: PxQuat) #no_context {
            Constructor(this, *s, *r);
        }

        /**
        \brief Returns true if the scaling is an identity transformation.
        */
        isIdentity :: (this: *PxMeshScale) -> bool #cpp_method #foreign physx_lib "?isIdentity@PxMeshScale@physx@@QEBA_NXZ";

        /**
        \brief Returns the inverse of this scaling transformation.
        */
        getInverse :: (this: *PxMeshScale) -> PxMeshScale #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "?getInverse@PxMeshScale@physx@@QEBA?AV12@XZ";

        /**
        \brief Converts this transformation to a 3x3 matrix representation.
        */
        toMat33 :: (this: *PxMeshScale) -> PxMat33 #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "?toMat33@PxMeshScale@physx@@QEBA?AVPxMat33@2@XZ";

        /**
        \brief Returns true if combination of negative scale components will cause the triangle normal to flip. The SDK will flip the normals internally.
        */
        hasNegativeDeterminant :: (this: *PxMeshScale) -> bool #cpp_method #foreign physx_lib "?hasNegativeDeterminant@PxMeshScale@physx@@QEBA_NXZ";

        transform :: (this: *PxMeshScale, v: *PxVec3) -> PxVec3 #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "?transform@PxMeshScale@physx@@QEBA?AVPxVec3@2@AEBV32@@Z";
        transform :: (this: *PxMeshScale, v: PxVec3) -> PxVec3 #no_context {
            return transform(this, *v);
        }

        isValidForTriangleMesh :: (this: *PxMeshScale) -> bool #cpp_method #foreign physx_lib "?isValidForTriangleMesh@PxMeshScale@physx@@QEBA_NXZ";

        isValidForConvexMesh :: (this: *PxMeshScale) -> bool #cpp_method #foreign physx_lib "?isValidForConvexMesh@PxMeshScale@physx@@QEBA_NXZ";

        scale:    PxVec3; //!< A nonuniform scaling
        rotation: PxQuat; //!< The orientation of the scaling axes
    }
    #run {if true then return;
        instance: PxMeshScale;
        assert(((cast(*void)(*instance.scale)) - cast(*void)(*instance)) == 0, "PxMeshScale.scale has unexpected offset % instead of 0", ((cast(*void)(*instance.scale)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxMeshScale.scale)) == 12, "PxMeshScale.scale has unexpected size % instead of 12", size_of(type_of(PxMeshScale.scale)));
        assert(((cast(*void)(*instance.rotation)) - cast(*void)(*instance)) == 12, "PxMeshScale.rotation has unexpected offset % instead of 12", ((cast(*void)(*instance.rotation)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxMeshScale.rotation)) == 16, "PxMeshScale.rotation has unexpected size % instead of 16", size_of(type_of(PxMeshScale.rotation)));
        assert(size_of(PxMeshScale) == 28, "PxMeshScale has size % instead of 28", size_of(PxMeshScale));
    }

    /**
    \brief Flags controlling the simulated behavior of the convex mesh geometry.

    Used in ::PxConvexMeshGeometryFlags.
    */
    PxConvexMeshGeometryFlag :: struct {
        Enum :: enum s32 {
            eTIGHT_BOUNDS :: 1;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxConvexMeshGeometryFlag) == 1, "PxConvexMeshGeometryFlag has size % instead of 1", size_of(PxConvexMeshGeometryFlag));
    }

    /**
    \brief collection of set bits defined in PxConvexMeshGeometryFlag.

    @see PxConvexMeshGeometryFlag
    */
    PxConvexMeshGeometryFlags :: PxFlags(PxConvexMeshGeometryFlag.Enum, PxU8);

    /**
    \brief Convex mesh geometry class.

    This class unifies a convex mesh object with a scaling transform, and
    lets the combined object be used anywhere a PxGeometry is needed.

    The scaling is a transform along arbitrary axes contained in the scale object.
    The vertices of the mesh in geometry (or shape) space is the
    PxMeshScale::toMat33() transform, multiplied by the vertex space vertices
    in the PxConvexMesh object.
    */
    PxConvexMeshGeometry :: struct {
        #as using pxgeometry: PxGeometry;

        /**
        \brief Default constructor.

        Creates an empty object with a NULL mesh and identity scale.
        */
        Constructor :: (this: *PxConvexMeshGeometry) -> void #cpp_method #foreign physx_lib "??0PxConvexMeshGeometry@physx@@QEAA@XZ";

        /**
        \brief Constructor.
        \param[in] mesh		Mesh pointer. May be NULL, though this will not make the object valid for shape construction.
        \param[in] scaling	Scale factor.
        \param[in] flags	Mesh flags.
        \
        */
        Constructor :: (this: *PxConvexMeshGeometry, mesh: *PxConvexMesh, scaling: *PxMeshScale, flags: PxConvexMeshGeometryFlags) -> void #cpp_method #foreign physx_lib "??0PxConvexMeshGeometry@physx@@QEAA@PEAVPxConvexMesh@1@AEBVPxMeshScale@1@V?$PxFlags@W4Enum@PxConvexMeshGeometryFlag@physx@@E@1@@Z";
        Constructor :: (this: *PxConvexMeshGeometry, mesh: *PxConvexMesh, scaling: PxMeshScale = PxMeshScale.{}, flags: PxConvexMeshGeometryFlags) #no_context {
            Constructor(this, mesh, *scaling, flags);
        }

        /**
        \brief Returns true if the geometry is valid.

        \return True if the current settings are valid for shape creation.

        \note A valid convex mesh has a positive scale value in each direction (scale.x > 0, scale.y > 0, scale.z > 0).
        It is illegal to call PxRigidActor::createShape and PxPhysics::createShape with a convex that has zero extent in any direction.

        @see PxRigidActor::createShape, PxPhysics::createShape
        */
        isValid :: (this: *PxConvexMeshGeometry) -> bool #cpp_method #foreign physx_lib "?isValid@PxConvexMeshGeometry@physx@@QEBA_NXZ";

        scale:            PxMeshScale; //!< The scaling transformation (from vertex space to shape space).
        convexMesh:       *PxConvexMesh; //!< A reference to the convex mesh object.
        meshFlags:        PxConvexMeshGeometryFlags; //!< Mesh flags.
        paddingFromFlags: PxPadding(3); //!< padding for mesh flags
    }
    #run {if true then return;
        assert(size_of(type_of(PxConvexMeshGeometry.pxgeometry)) == 4, "PxConvexMeshGeometry.pxgeometry has unexpected size % instead of 4", size_of(type_of(PxConvexMeshGeometry.pxgeometry)));
        instance: PxConvexMeshGeometry;
        assert(((cast(*void)(*instance.scale)) - cast(*void)(*instance)) == 4, "PxConvexMeshGeometry.scale has unexpected offset % instead of 4", ((cast(*void)(*instance.scale)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxConvexMeshGeometry.scale)) == 28, "PxConvexMeshGeometry.scale has unexpected size % instead of 28", size_of(type_of(PxConvexMeshGeometry.scale)));
        assert(((cast(*void)(*instance.convexMesh)) - cast(*void)(*instance)) == 32, "PxConvexMeshGeometry.convexMesh has unexpected offset % instead of 32", ((cast(*void)(*instance.convexMesh)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxConvexMeshGeometry.convexMesh)) == 8, "PxConvexMeshGeometry.convexMesh has unexpected size % instead of 8", size_of(type_of(PxConvexMeshGeometry.convexMesh)));
        assert(((cast(*void)(*instance.meshFlags)) - cast(*void)(*instance)) == 40, "PxConvexMeshGeometry.meshFlags has unexpected offset % instead of 40", ((cast(*void)(*instance.meshFlags)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxConvexMeshGeometry.meshFlags)) == 1, "PxConvexMeshGeometry.meshFlags has unexpected size % instead of 1", size_of(type_of(PxConvexMeshGeometry.meshFlags)));
        assert(((cast(*void)(*instance.paddingFromFlags)) - cast(*void)(*instance)) == 41, "PxConvexMeshGeometry.paddingFromFlags has unexpected offset % instead of 41", ((cast(*void)(*instance.paddingFromFlags)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxConvexMeshGeometry.paddingFromFlags)) == 3, "PxConvexMeshGeometry.paddingFromFlags has unexpected size % instead of 3", size_of(type_of(PxConvexMeshGeometry.paddingFromFlags)));
        assert(size_of(PxConvexMeshGeometry) == 48, "PxConvexMeshGeometry has size % instead of 48", size_of(PxConvexMeshGeometry));
    }

    /**
    \brief A class representing the geometry of a sphere.

    Spheres are defined by their radius.
    \note The scaling of the sphere is expected to be baked into this value, there is no additional scaling parameter.
    */
    PxSphereGeometry :: struct {
        #as using pxgeometry: PxGeometry;

        Constructor :: (this: *PxSphereGeometry) -> void #cpp_method #foreign physx_lib "??0PxSphereGeometry@physx@@QEAA@XZ";
        Constructor :: (this: *PxSphereGeometry, ir: PxReal) -> void #cpp_method #foreign physx_lib "??0PxSphereGeometry@physx@@QEAA@M@Z";

        /**
        \brief Returns true if the geometry is valid.

        \return True if the current settings are valid

        \note A valid sphere has radius > 0.
        It is illegal to call PxRigidActor::createShape and PxPhysics::createShape with a sphere that has zero radius.

        @see PxRigidActor::createShape, PxPhysics::createShape
        */
        isValid :: (this: *PxSphereGeometry) -> bool #cpp_method #foreign physx_lib "?isValid@PxSphereGeometry@physx@@QEBA_NXZ";

        /**
        \brief The radius of the sphere.
        */
        radius: PxReal;
    }
    #run {if true then return;
        assert(size_of(type_of(PxSphereGeometry.pxgeometry)) == 4, "PxSphereGeometry.pxgeometry has unexpected size % instead of 4", size_of(type_of(PxSphereGeometry.pxgeometry)));
        instance: PxSphereGeometry;
        assert(((cast(*void)(*instance.radius)) - cast(*void)(*instance)) == 4, "PxSphereGeometry.radius has unexpected offset % instead of 4", ((cast(*void)(*instance.radius)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSphereGeometry.radius)) == 4, "PxSphereGeometry.radius has unexpected size % instead of 4", size_of(type_of(PxSphereGeometry.radius)));
        assert(size_of(PxSphereGeometry) == 8, "PxSphereGeometry has size % instead of 8", size_of(PxSphereGeometry));
    }

    /**
    \brief Class describing a plane geometry.

    The plane geometry specifies the half-space volume x<=0. As with other geometry types,
    when used in a PxShape the collision volume is obtained by transforming the halfspace
    by the shape local pose and the actor global pose.

    To generate a PxPlane from a PxTransform, transform PxPlane(1,0,0,0).

    To generate a PxTransform from a PxPlane, use PxTransformFromPlaneEquation.

    @see PxShape.setGeometry() PxShape.getPlaneGeometry() PxTransformFromPlaneEquation
    */
    PxPlaneGeometry :: struct {
        #as using pxgeometry: PxGeometry;

        Constructor :: (this: *PxPlaneGeometry) -> void #cpp_method #foreign physx_lib "??0PxPlaneGeometry@physx@@QEAA@XZ";

        /**
        \brief Returns true if the geometry is valid.

        \return True if the current settings are valid
        */
        isValid :: (this: *PxPlaneGeometry) -> bool #cpp_method #foreign physx_lib "?isValid@PxPlaneGeometry@physx@@QEBA_NXZ";
    }
    #run {if true then return;
        assert(size_of(type_of(PxPlaneGeometry.pxgeometry)) == 4, "PxPlaneGeometry.pxgeometry has unexpected size % instead of 4", size_of(type_of(PxPlaneGeometry.pxgeometry)));
        assert(size_of(PxPlaneGeometry) == 4, "PxPlaneGeometry has size % instead of 4", size_of(PxPlaneGeometry));
    }

    /** \brief creates a plane equation from a transform, such as the actor transform for a PxPlaneGeometry

    \param[in] transform the transform
    \return the plane
    */
    PxPlaneEquationFromTransform :: (transform: *PxTransform) -> PxPlane #cpp_return_type_is_non_pod #foreign physx_lib "?PxPlaneEquationFromTransform@physx@@YA?AVPxPlane@1@AEBVPxTransform@1@@Z";
    PxPlaneEquationFromTransform :: (transform: PxTransform) -> PxPlane #no_context {
        return PxPlaneEquationFromTransform(*transform);
    }

    /**
    \brief Flags controlling the simulated behavior of the triangle mesh geometry.

    Used in ::PxMeshGeometryFlags.
    */
    PxMeshGeometryFlag :: struct {
        Enum :: enum s32 {
            eDOUBLE_SIDED :: 2;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxMeshGeometryFlag) == 1, "PxMeshGeometryFlag has size % instead of 1", size_of(PxMeshGeometryFlag));
    }

    /**
    \brief collection of set bits defined in PxMeshGeometryFlag.

    @see PxMeshGeometryFlag
    */
    PxMeshGeometryFlags :: PxFlags(PxMeshGeometryFlag.Enum, PxU8);

    /**
    \brief Triangle mesh geometry class.

    This class unifies a mesh object with a scaling transform, and
    lets the combined object be used anywhere a PxGeometry is needed.

    The scaling is a transform along arbitrary axes contained in the scale object.
    The vertices of the mesh in geometry (or shape) space is the
    PxMeshScale::toMat33() transform, multiplied by the vertex space vertices
    in the PxConvexMesh object.
    */
    PxTriangleMeshGeometry :: struct {
        #as using pxgeometry: PxGeometry;

        /**
        \brief Default constructor.

        Creates an empty object with a NULL mesh and identity scale.
        */
        Constructor :: (this: *PxTriangleMeshGeometry) -> void #cpp_method #foreign physx_lib "??0PxTriangleMeshGeometry@physx@@QEAA@XZ";

        /**
        \brief Constructor.
        \param[in] mesh		Mesh pointer. May be NULL, though this will not make the object valid for shape construction.
        \param[in] scaling	Scale factor.
        \param[in] flags	Mesh flags.
        \
        */
        Constructor :: (this: *PxTriangleMeshGeometry, mesh: *PxTriangleMesh, scaling: *PxMeshScale, flags: PxMeshGeometryFlags = .{}) -> void #cpp_method #foreign physx_lib "??0PxTriangleMeshGeometry@physx@@QEAA@PEAVPxTriangleMesh@1@AEBVPxMeshScale@1@V?$PxFlags@W4Enum@PxMeshGeometryFlag@physx@@E@1@@Z";
        Constructor :: (this: *PxTriangleMeshGeometry, mesh: *PxTriangleMesh, scaling: PxMeshScale = PxMeshScale.{}, flags: PxMeshGeometryFlags = .{}) #no_context {
            Constructor(this, mesh, *scaling, flags);
        }

        /**
        \brief Returns true if the geometry is valid.

        \return  True if the current settings are valid for shape creation.

        \note A valid triangle mesh has a positive scale value in each direction (scale.scale.x > 0, scale.scale.y > 0, scale.scale.z > 0).
        It is illegal to call PxRigidActor::createShape and PxPhysics::createShape with a triangle mesh that has zero extents in any direction.

        @see PxRigidActor::createShape, PxPhysics::createShape
        */
        isValid :: (this: *PxTriangleMeshGeometry) -> bool #cpp_method #foreign physx_lib "?isValid@PxTriangleMeshGeometry@physx@@QEBA_NXZ";

        scale:            PxMeshScale; //!< The scaling transformation.
        meshFlags:        PxMeshGeometryFlags; //!< Mesh flags.
        paddingFromFlags: PxPadding(3); //!< padding for mesh flags
        triangleMesh:     *PxTriangleMesh; //!< A reference to the mesh object.
    }
    #run {if true then return;
        assert(size_of(type_of(PxTriangleMeshGeometry.pxgeometry)) == 4, "PxTriangleMeshGeometry.pxgeometry has unexpected size % instead of 4", size_of(type_of(PxTriangleMeshGeometry.pxgeometry)));
        instance: PxTriangleMeshGeometry;
        assert(((cast(*void)(*instance.scale)) - cast(*void)(*instance)) == 4, "PxTriangleMeshGeometry.scale has unexpected offset % instead of 4", ((cast(*void)(*instance.scale)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTriangleMeshGeometry.scale)) == 28, "PxTriangleMeshGeometry.scale has unexpected size % instead of 28", size_of(type_of(PxTriangleMeshGeometry.scale)));
        assert(((cast(*void)(*instance.meshFlags)) - cast(*void)(*instance)) == 32, "PxTriangleMeshGeometry.meshFlags has unexpected offset % instead of 32", ((cast(*void)(*instance.meshFlags)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTriangleMeshGeometry.meshFlags)) == 1, "PxTriangleMeshGeometry.meshFlags has unexpected size % instead of 1", size_of(type_of(PxTriangleMeshGeometry.meshFlags)));
        assert(((cast(*void)(*instance.paddingFromFlags)) - cast(*void)(*instance)) == 33, "PxTriangleMeshGeometry.paddingFromFlags has unexpected offset % instead of 33", ((cast(*void)(*instance.paddingFromFlags)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTriangleMeshGeometry.paddingFromFlags)) == 3, "PxTriangleMeshGeometry.paddingFromFlags has unexpected size % instead of 3", size_of(type_of(PxTriangleMeshGeometry.paddingFromFlags)));
        assert(((cast(*void)(*instance.triangleMesh)) - cast(*void)(*instance)) == 40, "PxTriangleMeshGeometry.triangleMesh has unexpected offset % instead of 40", ((cast(*void)(*instance.triangleMesh)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTriangleMeshGeometry.triangleMesh)) == 8, "PxTriangleMeshGeometry.triangleMesh has unexpected size % instead of 8", size_of(type_of(PxTriangleMeshGeometry.triangleMesh)));
        assert(size_of(PxTriangleMeshGeometry) == 48, "PxTriangleMeshGeometry has size % instead of 48", size_of(PxTriangleMeshGeometry));
    }

    /**
    \brief Height field geometry class.

    This class allows to create a scaled height field geometry instance.

    There is a minimum allowed value for Y and XZ scaling - PX_MIN_HEIGHTFIELD_XZ_SCALE, heightfield creation will fail if XZ value is below this value.
    */
    PxHeightFieldGeometry :: struct {
        #as using pxgeometry: PxGeometry;

        Constructor :: (this: *PxHeightFieldGeometry) -> void #cpp_method #foreign physx_lib "??0PxHeightFieldGeometry@physx@@QEAA@XZ";

        Constructor :: (this: *PxHeightFieldGeometry, hf: *PxHeightField, flags: PxMeshGeometryFlags, heightScale_: PxReal, rowScale_: PxReal, columnScale_: PxReal) -> void #cpp_method #foreign physx_lib "??0PxHeightFieldGeometry@physx@@QEAA@PEAVPxHeightField@1@V?$PxFlags@W4Enum@PxMeshGeometryFlag@physx@@E@1@MMM@Z";

        /**
        \brief Returns true if the geometry is valid.

        \return True if the current settings are valid

        \note A valid height field has a positive scale value in each direction (heightScale > 0, rowScale > 0, columnScale > 0).
        It is illegal to call PxRigidActor::createShape and PxPhysics::createShape with a height field that has zero extents in any direction.

        @see PxRigidActor::createShape, PxPhysics::createShape
        */
        isValid :: (this: *PxHeightFieldGeometry) -> bool #cpp_method #foreign physx_lib "?isValid@PxHeightFieldGeometry@physx@@QEBA_NXZ";

        /**
        \brief The height field data.
        */
        heightField:      *PxHeightField;

        /**
        \brief The scaling factor for the height field in vertical direction (y direction in local space).
        */
        heightScale:      PxReal;

        /**
        \brief The scaling factor for the height field in the row direction (x direction in local space).
        */
        rowScale:         PxReal;

        /**
        \brief The scaling factor for the height field in the column direction (z direction in local space).
        */
        columnScale:      PxReal;

        /**
        \brief Flags to specify some collision properties for the height field.
        */
        heightFieldFlags: PxMeshGeometryFlags;

        paddingFromFlags: PxPadding(3); //!< padding for mesh flags.
    }
    #run {if true then return;
        assert(size_of(type_of(PxHeightFieldGeometry.pxgeometry)) == 4, "PxHeightFieldGeometry.pxgeometry has unexpected size % instead of 4", size_of(type_of(PxHeightFieldGeometry.pxgeometry)));
        instance: PxHeightFieldGeometry;
        assert(((cast(*void)(*instance.heightField)) - cast(*void)(*instance)) == 8, "PxHeightFieldGeometry.heightField has unexpected offset % instead of 8", ((cast(*void)(*instance.heightField)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxHeightFieldGeometry.heightField)) == 8, "PxHeightFieldGeometry.heightField has unexpected size % instead of 8", size_of(type_of(PxHeightFieldGeometry.heightField)));
        assert(((cast(*void)(*instance.heightScale)) - cast(*void)(*instance)) == 16, "PxHeightFieldGeometry.heightScale has unexpected offset % instead of 16", ((cast(*void)(*instance.heightScale)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxHeightFieldGeometry.heightScale)) == 4, "PxHeightFieldGeometry.heightScale has unexpected size % instead of 4", size_of(type_of(PxHeightFieldGeometry.heightScale)));
        assert(((cast(*void)(*instance.rowScale)) - cast(*void)(*instance)) == 20, "PxHeightFieldGeometry.rowScale has unexpected offset % instead of 20", ((cast(*void)(*instance.rowScale)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxHeightFieldGeometry.rowScale)) == 4, "PxHeightFieldGeometry.rowScale has unexpected size % instead of 4", size_of(type_of(PxHeightFieldGeometry.rowScale)));
        assert(((cast(*void)(*instance.columnScale)) - cast(*void)(*instance)) == 24, "PxHeightFieldGeometry.columnScale has unexpected offset % instead of 24", ((cast(*void)(*instance.columnScale)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxHeightFieldGeometry.columnScale)) == 4, "PxHeightFieldGeometry.columnScale has unexpected size % instead of 4", size_of(type_of(PxHeightFieldGeometry.columnScale)));
        assert(((cast(*void)(*instance.heightFieldFlags)) - cast(*void)(*instance)) == 28, "PxHeightFieldGeometry.heightFieldFlags has unexpected offset % instead of 28", ((cast(*void)(*instance.heightFieldFlags)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxHeightFieldGeometry.heightFieldFlags)) == 1, "PxHeightFieldGeometry.heightFieldFlags has unexpected size % instead of 1", size_of(type_of(PxHeightFieldGeometry.heightFieldFlags)));
        assert(((cast(*void)(*instance.paddingFromFlags)) - cast(*void)(*instance)) == 29, "PxHeightFieldGeometry.paddingFromFlags has unexpected offset % instead of 29", ((cast(*void)(*instance.paddingFromFlags)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxHeightFieldGeometry.paddingFromFlags)) == 3, "PxHeightFieldGeometry.paddingFromFlags has unexpected size % instead of 3", size_of(type_of(PxHeightFieldGeometry.paddingFromFlags)));
        assert(size_of(PxHeightFieldGeometry) == 32, "PxHeightFieldGeometry has size % instead of 32", size_of(PxHeightFieldGeometry));
    }

    /**
    \brief Geometry holder class

    This class contains enough space to hold a value of any PxGeometry subtype.

    Its principal use is as a convenience class to allow geometries to be returned polymorphically
    from functions. See PxShape::getGeometry();
    */
    PxGeometryHolder :: struct {
        getType :: (this: *PxGeometryHolder) -> PxGeometryType.Enum #cpp_method #foreign physx_lib "?getType@PxGeometryHolder@physx@@QEBA?AW4Enum@PxGeometryType@2@XZ";

        any :: (this: *PxGeometryHolder) -> *PxGeometry #cpp_method #foreign physx_lib "?any@PxGeometryHolder@physx@@QEAAAEAVPxGeometry@2@XZ";

        any_1 :: (this: /*const*/ *PxGeometryHolder) -> *PxGeometry #cpp_method #foreign physx_lib "?any@PxGeometryHolder@physx@@QEBAAEBVPxGeometry@2@XZ";

        sphere :: (this: *PxGeometryHolder) -> *PxSphereGeometry #cpp_method #foreign physx_lib "?sphere@PxGeometryHolder@physx@@QEAAAEAVPxSphereGeometry@2@XZ";

        sphere_1 :: (this: /*const*/ *PxGeometryHolder) -> *PxSphereGeometry #cpp_method #foreign physx_lib "?sphere@PxGeometryHolder@physx@@QEBAAEBVPxSphereGeometry@2@XZ";

        plane :: (this: *PxGeometryHolder) -> *PxPlaneGeometry #cpp_method #foreign physx_lib "?plane@PxGeometryHolder@physx@@QEAAAEAVPxPlaneGeometry@2@XZ";

        plane_1 :: (this: /*const*/ *PxGeometryHolder) -> *PxPlaneGeometry #cpp_method #foreign physx_lib "?plane@PxGeometryHolder@physx@@QEBAAEBVPxPlaneGeometry@2@XZ";

        capsule :: (this: *PxGeometryHolder) -> *PxCapsuleGeometry #cpp_method #foreign physx_lib "?capsule@PxGeometryHolder@physx@@QEAAAEAVPxCapsuleGeometry@2@XZ";

        capsule_1 :: (this: /*const*/ *PxGeometryHolder) -> *PxCapsuleGeometry #cpp_method #foreign physx_lib "?capsule@PxGeometryHolder@physx@@QEBAAEBVPxCapsuleGeometry@2@XZ";

        box :: (this: *PxGeometryHolder) -> *PxBoxGeometry #cpp_method #foreign physx_lib "?box@PxGeometryHolder@physx@@QEAAAEAVPxBoxGeometry@2@XZ";

        box_1 :: (this: /*const*/ *PxGeometryHolder) -> *PxBoxGeometry #cpp_method #foreign physx_lib "?box@PxGeometryHolder@physx@@QEBAAEBVPxBoxGeometry@2@XZ";

        convexMesh :: (this: *PxGeometryHolder) -> *PxConvexMeshGeometry #cpp_method #foreign physx_lib "?convexMesh@PxGeometryHolder@physx@@QEAAAEAVPxConvexMeshGeometry@2@XZ";

        convexMesh_1 :: (this: /*const*/ *PxGeometryHolder) -> *PxConvexMeshGeometry #cpp_method #foreign physx_lib "?convexMesh@PxGeometryHolder@physx@@QEBAAEBVPxConvexMeshGeometry@2@XZ";

        triangleMesh :: (this: *PxGeometryHolder) -> *PxTriangleMeshGeometry #cpp_method #foreign physx_lib "?triangleMesh@PxGeometryHolder@physx@@QEAAAEAVPxTriangleMeshGeometry@2@XZ";

        triangleMesh_1 :: (this: /*const*/ *PxGeometryHolder) -> *PxTriangleMeshGeometry #cpp_method #foreign physx_lib "?triangleMesh@PxGeometryHolder@physx@@QEBAAEBVPxTriangleMeshGeometry@2@XZ";

        heightField :: (this: *PxGeometryHolder) -> *PxHeightFieldGeometry #cpp_method #foreign physx_lib "?heightField@PxGeometryHolder@physx@@QEAAAEAVPxHeightFieldGeometry@2@XZ";

        heightField_1 :: (this: /*const*/ *PxGeometryHolder) -> *PxHeightFieldGeometry #cpp_method #foreign physx_lib "?heightField@PxGeometryHolder@physx@@QEBAAEBVPxHeightFieldGeometry@2@XZ";

        storeAny :: (this: *PxGeometryHolder, geometry: *PxGeometry) -> void #cpp_method #foreign physx_lib "?storeAny@PxGeometryHolder@physx@@QEAAXAEBVPxGeometry@2@@Z";
        storeAny :: (this: *PxGeometryHolder, geometry: PxGeometry) #no_context {
            storeAny(this, *geometry);
        }

        Constructor :: (this: *PxGeometryHolder) -> void #cpp_method #foreign physx_lib "??0PxGeometryHolder@physx@@QEAA@XZ";
        Constructor :: (this: *PxGeometryHolder, geometry: *PxGeometry) -> void #cpp_method #foreign physx_lib "??0PxGeometryHolder@physx@@QEAA@AEBVPxGeometry@1@@Z";
        Constructor :: (this: *PxGeometryHolder, geometry: PxGeometry) #no_context {
            Constructor(this, *geometry);
        }

        bytes: union {
            geometry:    [4] PxU8;
            box:         [16] PxU8;
            sphere:      [8] PxU8;
            capsule:     [12] PxU8;
            plane:       [4] PxU8;
            convex:      [48] PxU8;
            mesh:        [48] PxU8;
            heightfield: [32] PxU8;
        };
    }
    #run {if true then return;
        instance: PxGeometryHolder;
        assert(((cast(*void)(*instance.bytes)) - cast(*void)(*instance)) == 0, "PxGeometryHolder.bytes has unexpected offset % instead of 0", ((cast(*void)(*instance.bytes)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxGeometryHolder.bytes)) == 48, "PxGeometryHolder.bytes has unexpected size % instead of 48", size_of(type_of(PxGeometryHolder.bytes)));
        assert(size_of(PxGeometryHolder) == 48, "PxGeometryHolder has size % instead of 48", size_of(PxGeometryHolder));
    }

    /**
    \brief Scene query and geometry query behavior flags.

    PxHitFlags are used for 3 different purposes:

    1) To request hit fields to be filled in by scene queries (such as hit position, normal, face index or UVs).
    2) Once query is completed, to indicate which fields are valid (note that a query may produce more valid fields than requested).
    3) To specify additional options for the narrow phase and mid-phase intersection routines.

    All these flags apply to both scene queries and geometry queries (PxGeometryQuery).

    @see PxRaycastHit PxSweepHit PxOverlapHit PxScene.raycast PxScene.sweep PxScene.overlap PxGeometryQuery PxFindFaceIndex
    */
    PxHitFlag :: struct {
        Enum :: enum s32 {
            POSITION                  :: 1;
            NORMAL                    :: 2;
            UV                        :: 8;
            ASSUME_NO_INITIAL_OVERLAP :: 16;

            MESH_MULTIPLE             :: 32;
            MESH_ANY                  :: 64;

            MESH_BOTH_SIDES           :: 128;

            PRECISE_SWEEP             :: 256;

            MTD                       :: 512;
            FACE_INDEX                :: 1024;

            DEFAULT                   :: 1027;

            MODIFIABLE_FLAGS          :: 432;

            ePOSITION                  :: POSITION;
            eNORMAL                    :: NORMAL;
            eUV                        :: UV;
            eASSUME_NO_INITIAL_OVERLAP :: ASSUME_NO_INITIAL_OVERLAP;

            eMESH_MULTIPLE             :: MESH_MULTIPLE;
            eMESH_ANY                  :: MESH_ANY;

            eMESH_BOTH_SIDES           :: MESH_BOTH_SIDES;

            ePRECISE_SWEEP             :: PRECISE_SWEEP;

            eMTD                       :: MTD;
            eFACE_INDEX                :: FACE_INDEX;

            eDEFAULT                   :: DEFAULT;

            eMODIFIABLE_FLAGS          :: MODIFIABLE_FLAGS;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxHitFlag) == 1, "PxHitFlag has size % instead of 1", size_of(PxHitFlag));
    }

    PxHitFlags :: PxFlags(PxHitFlag.Enum, PxU16);

    /**
    \brief Combines a shape pointer and the actor the shape belongs to into one memory location.

    Serves as a base class for PxQueryHit.

    @see PxQueryHit
    */
    PxActorShape :: struct {
        Constructor :: (this: *PxActorShape) -> void #cpp_method #foreign physx_lib "??0PxActorShape@physx@@QEAA@XZ";
        Constructor :: (this: *PxActorShape, a: *PxRigidActor, s: *PxShape) -> void #cpp_method #foreign physx_lib "??0PxActorShape@physx@@QEAA@PEAVPxRigidActor@1@PEAVPxShape@1@@Z";

        actor: *PxRigidActor;
        shape: *PxShape;
    }
    #run {if true then return;
        instance: PxActorShape;
        assert(((cast(*void)(*instance.actor)) - cast(*void)(*instance)) == 0, "PxActorShape.actor has unexpected offset % instead of 0", ((cast(*void)(*instance.actor)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxActorShape.actor)) == 8, "PxActorShape.actor has unexpected size % instead of 8", size_of(type_of(PxActorShape.actor)));
        assert(((cast(*void)(*instance.shape)) - cast(*void)(*instance)) == 8, "PxActorShape.shape has unexpected offset % instead of 8", ((cast(*void)(*instance.shape)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxActorShape.shape)) == 8, "PxActorShape.shape has unexpected size % instead of 8", size_of(type_of(PxActorShape.shape)));
        assert(size_of(PxActorShape) == 16, "PxActorShape has size % instead of 16", size_of(PxActorShape));
    }

    /**
    \brief Scene query hit information.
    */
    PxQueryHit :: struct {
        #as using pxactorshape: PxActorShape;

        Constructor :: (this: *PxQueryHit) -> void #cpp_method #foreign physx_lib "??0PxQueryHit@physx@@QEAA@XZ";

        /**
        Face index of touched triangle, for triangle meshes, convex meshes and height fields.

        \note This index will default to 0xFFFFffff value for overlap queries.
        \note Please refer to the user guide for more details for sweep queries.
        \note This index is remapped by mesh cooking. Use #PxTriangleMesh::getTrianglesRemap() to convert to original mesh index.
        \note For convex meshes use #PxConvexMesh::getPolygonData() to retrieve touched polygon data.
        */
        faceIndex: PxU32;
    }
    #run {if true then return;
        assert(size_of(type_of(PxQueryHit.pxactorshape)) == 16, "PxQueryHit.pxactorshape has unexpected size % instead of 16", size_of(type_of(PxQueryHit.pxactorshape)));
        instance: PxQueryHit;
        assert(((cast(*void)(*instance.faceIndex)) - cast(*void)(*instance)) == 16, "PxQueryHit.faceIndex has unexpected offset % instead of 16", ((cast(*void)(*instance.faceIndex)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxQueryHit.faceIndex)) == 4, "PxQueryHit.faceIndex has unexpected size % instead of 4", size_of(type_of(PxQueryHit.faceIndex)));
        assert(size_of(PxQueryHit) == 24, "PxQueryHit has size % instead of 24", size_of(PxQueryHit));
    }

    /**
    \brief Scene query hit information for raycasts and sweeps returning hit position and normal information.

    ::PxHitFlag flags can be passed to scene query functions, as an optimization, to cause the SDK to
    only generate specific members of this structure.
    */
    PxLocationHit :: struct {
        #as using pxqueryhit: PxQueryHit;

        Constructor :: (this: *PxLocationHit) -> void #cpp_method #foreign physx_lib "??0PxLocationHit@physx@@QEAA@XZ";

        /**
        \note For raycast hits: true for shapes overlapping with raycast origin.
        \note For sweep hits: true for shapes overlapping at zero sweep distance.

        @see PxRaycastHit PxSweepHit
        */
        hadInitialOverlap :: (this: *PxLocationHit) -> bool #cpp_method #foreign physx_lib "?hadInitialOverlap@PxLocationHit@physx@@QEBA_NXZ";

        flags:    PxHitFlags; //!< Hit flags specifying which members contain valid values.
        position: PxVec3; //!< World-space hit position (flag: #PxHitFlag::ePOSITION)
        normal:   PxVec3; //!< World-space hit normal (flag: #PxHitFlag::eNORMAL)

        /**
        \brief	Distance to hit.
        \note	If the eMTD flag is used, distance will be a negative value if shapes are overlapping indicating the penetration depth.
        \note	Otherwise, this value will be >= 0 */
        distance: PxF32;
    }
    #run {
        assert(size_of(type_of(PxLocationHit.pxqueryhit)) == 24, "PxLocationHit.pxqueryhit has unexpected size % instead of 24", size_of(type_of(PxLocationHit.pxqueryhit)));
        instance: PxLocationHit;
        assert(((cast(*void)(*instance.flags)) - cast(*void)(*instance)) == 24, "PxLocationHit.flags has unexpected offset % instead of 24", ((cast(*void)(*instance.flags)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxLocationHit.flags)) == 2, "PxLocationHit.flags has unexpected size % instead of 2", size_of(type_of(PxLocationHit.flags)));
        assert(((cast(*void)(*instance.position)) - cast(*void)(*instance)) == 28, "PxLocationHit.position has unexpected offset % instead of 28", ((cast(*void)(*instance.position)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxLocationHit.position)) == 12, "PxLocationHit.position has unexpected size % instead of 12", size_of(type_of(PxLocationHit.position)));
        assert(((cast(*void)(*instance.normal)) - cast(*void)(*instance)) == 40, "PxLocationHit.normal has unexpected offset % instead of 40", ((cast(*void)(*instance.normal)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxLocationHit.normal)) == 12, "PxLocationHit.normal has unexpected size % instead of 12", size_of(type_of(PxLocationHit.normal)));
        assert(((cast(*void)(*instance.distance)) - cast(*void)(*instance)) == 52, "PxLocationHit.distance has unexpected offset % instead of 52", ((cast(*void)(*instance.distance)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxLocationHit.distance)) == 4, "PxLocationHit.distance has unexpected size % instead of 4", size_of(type_of(PxLocationHit.distance)));
        assert(size_of(PxLocationHit) == 56, "PxLocationHit has size % instead of 56", size_of(PxLocationHit));
    }

    /**
    \brief Stores results of raycast queries.

    ::PxHitFlag flags can be passed to raycast function, as an optimization, to cause the SDK to only compute specified members of this
    structure.

    Some members like barycentric coordinates are currently only computed for triangle meshes and height fields, but next versions
    might provide them in other cases. The client code should check #flags to make sure returned values are valid.

    @see PxScene.raycast PxBatchQuery.raycast
    */
    PxRaycastHit :: struct {
        #as using pxlocationhit: PxLocationHit;

        Constructor :: (this: *PxRaycastHit) -> void #cpp_method #foreign physx_lib "??0PxRaycastHit@physx@@QEAA@XZ";

        u: PxReal; //!< barycentric coordinates of hit point, for triangle mesh and height field (flag: #PxHitFlag::eUV)
        v: PxReal; //!< barycentric coordinates of hit point, for triangle mesh and height field (flag: #PxHitFlag::eUV)
    }
    #run {
        assert(size_of(type_of(PxRaycastHit.pxlocationhit)) == 56, "PxRaycastHit.pxlocationhit has unexpected size % instead of 56", size_of(type_of(PxRaycastHit.pxlocationhit)));
        instance: PxRaycastHit;
        assert(((cast(*void)(*instance.u)) - cast(*void)(*instance)) == 56, "PxRaycastHit.u has unexpected offset % instead of 56", ((cast(*void)(*instance.u)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxRaycastHit.u)) == 4, "PxRaycastHit.u has unexpected size % instead of 4", size_of(type_of(PxRaycastHit.u)));
        assert(((cast(*void)(*instance.v)) - cast(*void)(*instance)) == 60, "PxRaycastHit.v has unexpected offset % instead of 60", ((cast(*void)(*instance.v)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxRaycastHit.v)) == 4, "PxRaycastHit.v has unexpected size % instead of 4", size_of(type_of(PxRaycastHit.v)));
        assert(size_of(PxRaycastHit) == 64, "PxRaycastHit has size % instead of 64", size_of(PxRaycastHit));
    }

    /**
    \brief Stores results of overlap queries.

    @see PxScene.overlap PxBatchQuery.overlap
    */
    PxOverlapHit :: struct {
        #as using pxqueryhit: PxQueryHit;
        padTo16Bytes: PxU32;
    }
    #run {if true then return;
        assert(size_of(type_of(PxOverlapHit.pxqueryhit)) == 24, "PxOverlapHit.pxqueryhit has unexpected size % instead of 24", size_of(type_of(PxOverlapHit.pxqueryhit)));
        instance: PxOverlapHit;
        assert(((cast(*void)(*instance.padTo16Bytes)) - cast(*void)(*instance)) == 24, "PxOverlapHit.padTo16Bytes has unexpected offset % instead of 24", ((cast(*void)(*instance.padTo16Bytes)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxOverlapHit.padTo16Bytes)) == 4, "PxOverlapHit.padTo16Bytes has unexpected size % instead of 4", size_of(type_of(PxOverlapHit.padTo16Bytes)));
        assert(size_of(PxOverlapHit) == 32, "PxOverlapHit has size % instead of 32", size_of(PxOverlapHit));
    }

    /**
    \brief Stores results of sweep queries.

    @see PxScene.sweep PxBatchQuery.sweep
    */
    PxSweepHit :: struct {
        #as using pxlocationhit: PxLocationHit;

        Constructor :: (this: *PxSweepHit) -> void #cpp_method #foreign physx_lib "??0PxSweepHit@physx@@QEAA@XZ";

        padTo16Bytes: PxU32;
    }
    #run {if true then return;
        assert(size_of(type_of(PxSweepHit.pxlocationhit)) == 56, "PxSweepHit.pxlocationhit has unexpected size % instead of 56", size_of(type_of(PxSweepHit.pxlocationhit)));
        instance: PxSweepHit;
        assert(((cast(*void)(*instance.padTo16Bytes)) - cast(*void)(*instance)) == 56, "PxSweepHit.padTo16Bytes has unexpected offset % instead of 56", ((cast(*void)(*instance.padTo16Bytes)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSweepHit.padTo16Bytes)) == 4, "PxSweepHit.padTo16Bytes has unexpected size % instead of 4", size_of(type_of(PxSweepHit.padTo16Bytes)));
        assert(size_of(PxSweepHit) == 64, "PxSweepHit has size % instead of 64", size_of(PxSweepHit));
    }

    /**
    \brief Describes query behavior after returning a partial query result via a callback.

    If callback returns true, traversal will continue and callback can be issued again.
    If callback returns false, traversal will stop, callback will not be issued again.

    @see PxHitCallback
    */
    PxAgain :: bool;

    /**
    \brief	This callback class facilitates reporting scene query hits (intersections) to the user.

    User overrides the virtual processTouches function to receive hits in (possibly multiple) fixed size blocks.

    \note	PxHitBuffer derives from this class and is used to receive touching hits in a fixed size buffer.
    \note	Since the compiler doesn't look in template dependent base classes when looking for non-dependent names
    \note	with some compilers it will be necessary to use "this->hasBlock" notation to access a parent variable
    \note	in a child callback class.
    \note	Pre-made typedef shorthands, such as ::PxRaycastCallback can be used for raycast, overlap and sweep queries.

    @see PxHitBuffer PxRaycastHit PxSweepHit PxOverlapHit PxRaycastCallback PxOverlapCallback PxSweepCallback
    */
    PxHitCallback :: struct(HitType: Type) {
        block:        HitType; //!< Holds the closest blocking hit result for the query. Invalid if hasBlock is false.
        hasBlock:     bool; //!< Set to true if there was a blocking hit during query.

        touches:      *HitType; //!< User specified buffer for touching hits.

        /**
        \brief	Size of the user specified touching hits buffer.
        \note	If set to 0 all hits will default to PxQueryHitType::eBLOCK, otherwise to PxQueryHitType::eTOUCH
        \note	Hit type returned from pre-filter overrides this default */
        maxNbTouches: PxU32;

        /**
        \brief	Number of touching hits returned by the query. Used with PxHitBuffer.
        \note	If true (PxAgain) is returned from the callback, nbTouches will be reset to 0. */
        nbTouches:    PxU32;
    }

    /**
    \brief	Returns scene query hits (intersections) to the user in a preallocated buffer.

    Will clip touch hits to maximum buffer capacity. When clipped, an arbitrary subset of touching hits will be discarded.
    Overflow does not trigger warnings or errors. block and hasBlock will be valid in finalizeQuery callback and after query completion.
    Touching hits are guaranteed to have closer or same distance ( <= condition) as the globally nearest blocking hit at the time any processTouches()
    callback is issued.

    \note	Pre-made typedef shorthands, such as ::PxRaycastBuffer can be used for raycast, overlap and sweep queries.

    @see PxHitCallback
    @see PxRaycastBuffer PxOverlapBuffer PxSweepBuffer PxRaycastBufferN PxOverlapBufferN PxSweepBufferN
    */
    PxHitBuffer :: struct(HitType: Type) {
        #as pxhitcallback: PxHitCallback(HitType); // jai: no "using" to avoid name-clashes
    }

    /** \brief Raycast query callback. */
    PxRaycastCallback :: PxHitCallback(PxRaycastHit);

    /** \brief Overlap query callback. */
    PxOverlapCallback :: PxHitCallback(PxOverlapHit);

    /** \brief Sweep query callback. */
    PxSweepCallback :: PxHitCallback(PxSweepHit);

    /** \brief Raycast query buffer. */
    PxRaycastBuffer :: PxHitBuffer(PxRaycastHit);

    /** \brief Overlap query buffer. */
    PxOverlapBuffer :: PxHitBuffer(PxOverlapHit);

    /** \brief Sweep query buffer. */
    PxSweepBuffer :: PxHitBuffer(PxSweepHit);

    /** \brief	Returns touching raycast hits to the user in a fixed size array embedded in the buffer class. **/
    PxRaycastBufferN :: struct(N: s32) {
        #as pxhitbuffer: PxHitBuffer(PxRaycastHit); // jai: no "using" to avoid name-clashes

        hits: [PxRaycastHit] PxRaycastHit;
    }

    /** \brief	Returns touching overlap hits to the user in a fixed size array embedded in the buffer class. **/
    PxOverlapBufferN :: struct(N: s32) {
        #as pxhitbuffer: PxHitBuffer(PxOverlapHit); // jai: no "using" to avoid name-clashes

        hits: [PxOverlapHit] PxOverlapHit;
    }

    /** \brief	Returns touching sweep hits to the user in a fixed size array embedded in the buffer class. **/
    PxSweepBufferN :: struct(N: s32) {
        #as pxhitbuffer: PxHitBuffer(PxSweepHit); // jai: no "using" to avoid name-clashes

        hits: [PxSweepHit] PxSweepHit;
    }

    /**
    \brief Collection of geometry object queries (sweeps, raycasts, overlaps, ...).
    */
    PxGeometryQuery :: struct {
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxGeometryQuery) == 1, "PxGeometryQuery has size % instead of 1", size_of(PxGeometryQuery));
    }

    /**
    \brief Describes the format of height field samples.
    @see PxHeightFieldDesc.format PxHeightFieldDesc.samples
    */
    PxHeightFieldFormat :: struct {
        Enum :: enum s32 {
            eS16_TM :: 1;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxHeightFieldFormat) == 1, "PxHeightFieldFormat has size % instead of 1", size_of(PxHeightFieldFormat));
    }

    /**
    \brief Determines the tessellation of height field cells.
    @see PxHeightFieldDesc.format PxHeightFieldDesc.samples
    */
    PxHeightFieldTessFlag :: struct {
        Enum :: enum s32 {
            e0TH_VERTEX_SHARED :: 1;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxHeightFieldTessFlag) == 1, "PxHeightFieldTessFlag has size % instead of 1", size_of(PxHeightFieldTessFlag));
    }

    /**
    \brief Enum with flag values to be used in PxHeightFieldDesc.flags.
    */
    PxHeightFieldFlag :: struct {
        Enum :: enum s32 {
            eNO_BOUNDARY_EDGES :: 1;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxHeightFieldFlag) == 1, "PxHeightFieldFlag has size % instead of 1", size_of(PxHeightFieldFlag));
    }

    /**
    \brief collection of set bits defined in PxHeightFieldFlag.

    @see PxHeightFieldFlag
    */
    PxHeightFieldFlags :: PxFlags(PxHeightFieldFlag.Enum, PxU16);

    /**
    \brief Special material index values for height field samples.

    @see PxHeightFieldSample.materialIndex0 PxHeightFieldSample.materialIndex1
    */
    PxHeightFieldMaterial :: struct {
        Enum :: enum s32 {
            eHOLE :: 127;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxHeightFieldMaterial) == 1, "PxHeightFieldMaterial has size % instead of 1", size_of(PxHeightFieldMaterial));
    }

    /**
    \brief Heightfield sample format.

    This format corresponds to the #PxHeightFieldFormat member PxHeightFieldFormat::eS16_TM.

    An array of heightfield samples are used when creating a PxHeightField to specify
    the elevation of the heightfield points. In addition the material and tessellation of the adjacent
    triangles are specified.

    @see PxHeightField PxHeightFieldDesc PxHeightFieldDesc.samples
    */
    PxHeightFieldSample :: struct {
        /**
        \brief The height of the heightfield sample

        This value is scaled by PxHeightFieldGeometry::heightScale.

        @see PxHeightFieldGeometry
        */
        height:         PxI16;

        /**
        \brief The triangle material index of the quad's lower triangle + tesselation flag

        An index pointing into the material table of the shape which instantiates the heightfield.
        This index determines the material of the lower of the quad's two triangles (i.e. the quad whose
        upper-left corner is this sample, see the Guide for illustrations).

        Special values of the 7 data bits are defined by PxHeightFieldMaterial

        The tesselation flag specifies which way the quad is split whose upper left corner is this sample.
        If the flag is set, the diagonal of the quad will run from this sample to the opposite vertex; if not,
        it will run between the other two vertices (see the Guide for illustrations).

        @see PxHeightFieldGeometry materialIndex1 PxShape.setmaterials() PxShape.getMaterials()
        */
        materialIndex0: PxBitAndByte;

        tessFlag :: (this: *PxHeightFieldSample) -> PxU8 #cpp_method #foreign physx_lib "?tessFlag@PxHeightFieldSample@physx@@QEBAEXZ";
        setTessFlag :: (this: *PxHeightFieldSample) -> void #cpp_method #foreign physx_lib "?setTessFlag@PxHeightFieldSample@physx@@QEAAXXZ";
        clearTessFlag :: (this: *PxHeightFieldSample) -> void #cpp_method #foreign physx_lib "?clearTessFlag@PxHeightFieldSample@physx@@QEAAXXZ";

        /**
        \brief The triangle material index of the quad's upper triangle + reserved flag

        An index pointing into the material table of the shape which instantiates the heightfield.
        This index determines the material of the upper of the quad's two triangles (i.e. the quad whose
        upper-left corner is this sample, see the Guide for illustrations).

        @see PxHeightFieldGeometry materialIndex0 PxShape.setmaterials() PxShape.getMaterials()
        */
        materialIndex1: PxBitAndByte;
    }
    #run {if true then return;
        instance: PxHeightFieldSample;
        assert(((cast(*void)(*instance.height)) - cast(*void)(*instance)) == 0, "PxHeightFieldSample.height has unexpected offset % instead of 0", ((cast(*void)(*instance.height)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxHeightFieldSample.height)) == 2, "PxHeightFieldSample.height has unexpected size % instead of 2", size_of(type_of(PxHeightFieldSample.height)));
        assert(((cast(*void)(*instance.materialIndex0)) - cast(*void)(*instance)) == 2, "PxHeightFieldSample.materialIndex0 has unexpected offset % instead of 2", ((cast(*void)(*instance.materialIndex0)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxHeightFieldSample.materialIndex0)) == 1, "PxHeightFieldSample.materialIndex0 has unexpected size % instead of 1", size_of(type_of(PxHeightFieldSample.materialIndex0)));
        assert(((cast(*void)(*instance.materialIndex1)) - cast(*void)(*instance)) == 3, "PxHeightFieldSample.materialIndex1 has unexpected offset % instead of 3", ((cast(*void)(*instance.materialIndex1)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxHeightFieldSample.materialIndex1)) == 1, "PxHeightFieldSample.materialIndex1 has unexpected size % instead of 1", size_of(type_of(PxHeightFieldSample.materialIndex1)));
        assert(size_of(PxHeightFieldSample) == 4, "PxHeightFieldSample has size % instead of 4", size_of(PxHeightFieldSample));
    }

    /**
    \brief A height field class.

    Height fields work in a similar way as triangle meshes specified to act as
    height fields, with some important differences:

    Triangle meshes can be made of nonuniform geometry, while height fields are
    regular, rectangular grids.  This means that with PxHeightField, you sacrifice
    flexibility in return for improved performance and decreased memory consumption.

    In local space rows extend in X direction, columns in Z direction and height in Y direction.

    Like Convexes and TriangleMeshes, HeightFields are referenced by shape instances
    (see #PxHeightFieldGeometry, #PxShape).

    To avoid duplicating data when you have several instances of a particular
    height field differently, you do not use this class to represent a
    height field object directly. Instead, you create an instance of this height field
    via the PxHeightFieldGeometry and PxShape classes.

    <h3>Creation</h3>

    To create an instance of this class call PxPhysics::createHeightField() or
    PxCooking::createHeightField(const PxHeightFieldDesc&, PxPhysicsInsertionCallback&).
    To delete it call release(). This is only possible
    once you have released all of its PxHeightFiedShape instances.

    <h3>Visualizations:</h3>
    \li #PxVisualizationParameter::eCOLLISION_AABBS
    \li #PxVisualizationParameter::eCOLLISION_SHAPES
    \li #PxVisualizationParameter::eCOLLISION_AXES
    \li #PxVisualizationParameter::eCOLLISION_FNORMALS
    \li #PxVisualizationParameter::eCOLLISION_EDGES

    @see PxHeightFieldDesc PxHeightFieldGeometry PxShape PxPhysics.createHeightField() PxCooking.createHeightField()
    */
    PxHeightField :: struct {
        #as using pxbase: PxBase;
        #place pxbase; pxheightfield_vtable: *PxHeightField_VTable;
    }
    PxHeightField_VTable :: struct #type_info_none {
        using pxbase: PxBase_VTable;
        saveCells: (this: *PxHeightField, destBuffer: *void, destBufferSize: PxU32) -> PxU32 #cpp_method;

        modifySamples: (this: *PxHeightField, startCol: PxI32, startRow: PxI32, subfieldDesc: *PxHeightFieldDesc, shrinkBounds := false) -> bool #cpp_method;

        getNbRows: (this: *PxHeightField) -> PxU32 #cpp_method;

        getNbColumns: (this: *PxHeightField) -> PxU32 #cpp_method;

        getFormat: (this: *PxHeightField) -> PxHeightFieldFormat.Enum #cpp_method;

        getSampleStride: (this: *PxHeightField) -> PxU32 #cpp_method;

        getConvexEdgeThreshold: (this: *PxHeightField) -> PxReal #cpp_method;

        getFlags: (this: *PxHeightField) -> PxHeightFieldFlags #cpp_method;

        getHeight: (this: *PxHeightField, x: PxReal, z: PxReal) -> PxReal #cpp_method;

        getReferenceCount: (this: *PxHeightField) -> PxU32 #cpp_method;

        acquireReference: (this: *PxHeightField) -> void #cpp_method;

        getTriangleMaterialIndex: (this: *PxHeightField, triangleIndex: PxTriangleID) -> PxMaterialTableIndex #cpp_method;

        getTriangleNormal: (this: *PxHeightField, triangleIndex: PxTriangleID) -> PxVec3 #cpp_method #cpp_return_type_is_non_pod;

        getSample: (this: *PxHeightField, row: PxU32, column: PxU32) -> *PxHeightFieldSample #cpp_method;

        getTimestamp: (this: *PxHeightField) -> PxU32 #cpp_method;
    }

    PxHeightField_saveCells :: inline (this: *PxHeightField, destBuffer: *void, destBufferSize: PxU32) -> PxU32 { return this.pxheightfield_vtable.saveCells(this, destBuffer, destBufferSize); }

    PxHeightField_modifySamples :: inline (this: *PxHeightField, startCol: PxI32, startRow: PxI32, subfieldDesc: *PxHeightFieldDesc, shrinkBounds := false) -> bool { return this.pxheightfield_vtable.modifySamples(this, startCol, startRow, subfieldDesc, shrinkBounds); }

    PxHeightField_getNbRows :: inline (this: *PxHeightField) -> PxU32 { return this.pxheightfield_vtable.getNbRows(this); }

    PxHeightField_getNbColumns :: inline (this: *PxHeightField) -> PxU32 { return this.pxheightfield_vtable.getNbColumns(this); }

    PxHeightField_getFormat :: inline (this: *PxHeightField) -> PxHeightFieldFormat.Enum { return this.pxheightfield_vtable.getFormat(this); }

    PxHeightField_getSampleStride :: inline (this: *PxHeightField) -> PxU32 { return this.pxheightfield_vtable.getSampleStride(this); }

    PxHeightField_getConvexEdgeThreshold :: inline (this: *PxHeightField) -> PxReal { return this.pxheightfield_vtable.getConvexEdgeThreshold(this); }

    PxHeightField_getFlags :: inline (this: *PxHeightField) -> PxHeightFieldFlags { return this.pxheightfield_vtable.getFlags(this); }

    PxHeightField_getHeight :: inline (this: *PxHeightField, x: PxReal, z: PxReal) -> PxReal { return this.pxheightfield_vtable.getHeight(this, x, z); }

    PxHeightField_getReferenceCount :: inline (this: *PxHeightField) -> PxU32 { return this.pxheightfield_vtable.getReferenceCount(this); }

    PxHeightField_acquireReference :: inline (this: *PxHeightField) { this.pxheightfield_vtable.acquireReference(this); }

    PxHeightField_getTriangleMaterialIndex :: inline (this: *PxHeightField, triangleIndex: PxTriangleID) -> PxMaterialTableIndex { return this.pxheightfield_vtable.getTriangleMaterialIndex(this, triangleIndex); }

    PxHeightField_getTriangleNormal :: inline (this: *PxHeightField, triangleIndex: PxTriangleID) -> PxVec3 { return this.pxheightfield_vtable.getTriangleNormal(this, triangleIndex); }

    PxHeightField_getSample :: inline (this: *PxHeightField, row: PxU32, column: PxU32) -> *PxHeightFieldSample { return this.pxheightfield_vtable.getSample(this, row, column); }

    PxHeightField_getTimestamp :: inline (this: *PxHeightField) -> PxU32 { return this.pxheightfield_vtable.getTimestamp(this); }

    vtable :: (obj: *PxHeightField) -> *PxHeightField_VTable { return obj.pxheightfield_vtable; }

    #run {if true then return;
        assert(size_of(type_of(PxHeightField.pxbase)) == 16, "PxHeightField.pxbase has unexpected size % instead of 16", size_of(type_of(PxHeightField.pxbase)));
        assert(size_of(PxHeightField) == 16, "PxHeightField has size % instead of 16", size_of(PxHeightField));
    }

    /**
    \brief Descriptor class for #PxHeightField.

    \note The heightfield data is *copied* when a PxHeightField object is created from this descriptor. After the call the
    user may discard the height data.

    @see PxHeightField PxHeightFieldGeometry PxShape PxPhysics.createHeightField() PxCooking.createHeightField()
    */
    PxHeightFieldDesc :: struct {
        /**
        \brief Number of sample rows in the height field samples array.

        \note Local space X-axis corresponds to rows.

        <b>Range:</b> &gt;1<br>
        <b>Default:</b> 0
        */
        nbRows:              PxU32;

        /**
        \brief Number of sample columns in the height field samples array.

        \note Local space Z-axis corresponds to columns.

        <b>Range:</b> &gt;1<br>
        <b>Default:</b> 0
        */
        nbColumns:           PxU32;

        /**
        \brief Format of the sample data.

        Currently the only supported format is PxHeightFieldFormat::eS16_TM:

        <b>Default:</b> PxHeightFieldFormat::eS16_TM

        @see PxHeightFormat PxHeightFieldDesc.samples
        */
        format:              PxHeightFieldFormat.Enum;

        /**
        \brief The samples array.

        It is copied to the SDK's storage at creation time.

        There are nbRows * nbColumn samples in the array,
        which define nbRows * nbColumn vertices and cells,
        of which (nbRows - 1) * (nbColumns - 1) cells are actually used.

        The array index of sample(row, column) = row * nbColumns + column.
        The byte offset of sample(row, column) = sampleStride * (row * nbColumns + column).
        The sample data follows at the offset and spans the number of bytes defined by the format.
        Then there are zero or more unused bytes depending on sampleStride before the next sample.

        <b>Default:</b> NULL

        @see PxHeightFormat
        */
        samples:             PxStridedData;

        /**
        This threshold is used by the collision detection to determine if a height field edge is convex
        and can generate contact points.
        Usually the convexity of an edge is determined from the angle (or cosine of the angle) between
        the normals of the faces sharing that edge.
        The height field allows a more efficient approach by comparing height values of neighboring vertices.
        This parameter offsets the comparison. Smaller changes than 0.5 will not alter the set of convex edges.
        The rule of thumb is that larger values will result in fewer edge contacts.

        This parameter is ignored in contact generation with sphere and capsule primitives.

        <b>Range:</b> [0, PX_MAX_F32)<br>
        <b>Default:</b> 0
        */
        convexEdgeThreshold: PxReal;

        /**
        \brief Flags bits, combined from values of the enum ::PxHeightFieldFlag.

        <b>Default:</b> 0

        @see PxHeightFieldFlag PxHeightFieldFlags
        */
        flags:               PxHeightFieldFlags;

        /**
        \brief Constructor sets to default.
        */
        Constructor :: (this: *PxHeightFieldDesc) -> void #cpp_method #foreign physx_lib "??0PxHeightFieldDesc@physx@@QEAA@XZ";

        /**
        \brief (re)sets the structure to the default.
        */
        setToDefault :: (this: *PxHeightFieldDesc) -> void #cpp_method #foreign physx_lib "?setToDefault@PxHeightFieldDesc@physx@@QEAAXXZ";

        /**
        \brief Returns true if the descriptor is valid.
        \return True if the current settings are valid.
        */
        isValid :: (this: *PxHeightFieldDesc) -> bool #cpp_method #foreign physx_lib "?isValid@PxHeightFieldDesc@physx@@QEBA_NXZ";
    }
    #run {if true then return;
        instance: PxHeightFieldDesc;
        assert(((cast(*void)(*instance.nbRows)) - cast(*void)(*instance)) == 0, "PxHeightFieldDesc.nbRows has unexpected offset % instead of 0", ((cast(*void)(*instance.nbRows)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxHeightFieldDesc.nbRows)) == 4, "PxHeightFieldDesc.nbRows has unexpected size % instead of 4", size_of(type_of(PxHeightFieldDesc.nbRows)));
        assert(((cast(*void)(*instance.nbColumns)) - cast(*void)(*instance)) == 4, "PxHeightFieldDesc.nbColumns has unexpected offset % instead of 4", ((cast(*void)(*instance.nbColumns)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxHeightFieldDesc.nbColumns)) == 4, "PxHeightFieldDesc.nbColumns has unexpected size % instead of 4", size_of(type_of(PxHeightFieldDesc.nbColumns)));
        assert(((cast(*void)(*instance.format)) - cast(*void)(*instance)) == 8, "PxHeightFieldDesc.format has unexpected offset % instead of 8", ((cast(*void)(*instance.format)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxHeightFieldDesc.format)) == 4, "PxHeightFieldDesc.format has unexpected size % instead of 4", size_of(type_of(PxHeightFieldDesc.format)));
        assert(((cast(*void)(*instance.samples)) - cast(*void)(*instance)) == 16, "PxHeightFieldDesc.samples has unexpected offset % instead of 16", ((cast(*void)(*instance.samples)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxHeightFieldDesc.samples)) == 16, "PxHeightFieldDesc.samples has unexpected size % instead of 16", size_of(type_of(PxHeightFieldDesc.samples)));
        assert(((cast(*void)(*instance.convexEdgeThreshold)) - cast(*void)(*instance)) == 32, "PxHeightFieldDesc.convexEdgeThreshold has unexpected offset % instead of 32", ((cast(*void)(*instance.convexEdgeThreshold)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxHeightFieldDesc.convexEdgeThreshold)) == 4, "PxHeightFieldDesc.convexEdgeThreshold has unexpected size % instead of 4", size_of(type_of(PxHeightFieldDesc.convexEdgeThreshold)));
        assert(((cast(*void)(*instance.flags)) - cast(*void)(*instance)) == 36, "PxHeightFieldDesc.flags has unexpected offset % instead of 36", ((cast(*void)(*instance.flags)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxHeightFieldDesc.flags)) == 2, "PxHeightFieldDesc.flags has unexpected size % instead of 2", size_of(type_of(PxHeightFieldDesc.flags)));
        assert(size_of(PxHeightFieldDesc) == 40, "PxHeightFieldDesc has size % instead of 40", size_of(PxHeightFieldDesc));
    }

    PxMeshQuery :: struct {
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxMeshQuery) == 1, "PxMeshQuery has size % instead of 1", size_of(PxMeshQuery));
    }

    /**
    \brief Enum with flag values to be used in PxSimpleTriangleMesh::flags.
    */
    PxMeshFlag :: struct {
        Enum :: enum s32 {
            FLIPNORMALS     :: 1;
            _16_BIT_INDICES :: 2;

            eFLIPNORMALS    :: FLIPNORMALS;
            e16_BIT_INDICES :: _16_BIT_INDICES;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxMeshFlag) == 1, "PxMeshFlag has size % instead of 1", size_of(PxMeshFlag));
    }

    /**
    \brief collection of set bits defined in PxMeshFlag.

    @see PxMeshFlag
    */
    PxMeshFlags :: PxFlags(PxMeshFlag.Enum, PxU16);

    /**
    \brief A structure describing a triangle mesh.
    */
    PxSimpleTriangleMesh :: struct {
        /**
        \brief Pointer to first vertex point.
        */
        points:    PxBoundedData;

        /**
        \brief Pointer to first triangle.

        Caller may add triangleStrideBytes bytes to the pointer to access the next triangle.

        These are triplets of 0 based indices:
        vert0 vert1 vert2
        vert0 vert1 vert2
        vert0 vert1 vert2
        ...

        where vertex is either a 32 or 16 bit unsigned integer. There are numTriangles*3 indices.

        This is declared as a void pointer because it is actually either an PxU16 or a PxU32 pointer.
        */
        triangles: PxBoundedData;

        /**
        \brief Flags bits, combined from values of the enum ::PxMeshFlag
        */
        flags:     PxMeshFlags;

        /**
        \brief constructor sets to default.
        */
        Constructor :: (this: *PxSimpleTriangleMesh) -> void #cpp_method #foreign physx_lib "??0PxSimpleTriangleMesh@physx@@QEAA@XZ";

        /**
        \brief (re)sets the structure to the default.
        */
        setToDefault :: (this: *PxSimpleTriangleMesh) -> void #cpp_method #foreign physx_lib "?setToDefault@PxSimpleTriangleMesh@physx@@QEAAXXZ";

        /**
        \brief returns true if the current settings are valid
        */
        isValid :: (this: *PxSimpleTriangleMesh) -> bool #cpp_method #foreign physx_lib "?isValid@PxSimpleTriangleMesh@physx@@QEBA_NXZ";
    }
    #run {if true then return;
        instance: PxSimpleTriangleMesh;
        assert(((cast(*void)(*instance.points)) - cast(*void)(*instance)) == 0, "PxSimpleTriangleMesh.points has unexpected offset % instead of 0", ((cast(*void)(*instance.points)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSimpleTriangleMesh.points)) == 24, "PxSimpleTriangleMesh.points has unexpected size % instead of 24", size_of(type_of(PxSimpleTriangleMesh.points)));
        assert(((cast(*void)(*instance.triangles)) - cast(*void)(*instance)) == 24, "PxSimpleTriangleMesh.triangles has unexpected offset % instead of 24", ((cast(*void)(*instance.triangles)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSimpleTriangleMesh.triangles)) == 24, "PxSimpleTriangleMesh.triangles has unexpected size % instead of 24", size_of(type_of(PxSimpleTriangleMesh.triangles)));
        assert(((cast(*void)(*instance.flags)) - cast(*void)(*instance)) == 48, "PxSimpleTriangleMesh.flags has unexpected offset % instead of 48", ((cast(*void)(*instance.flags)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSimpleTriangleMesh.flags)) == 2, "PxSimpleTriangleMesh.flags has unexpected size % instead of 2", size_of(type_of(PxSimpleTriangleMesh.flags)));
        assert(size_of(PxSimpleTriangleMesh) == 56, "PxSimpleTriangleMesh has size % instead of 56", size_of(PxSimpleTriangleMesh));
    }

    /**
    \brief Triangle class.
    */
    PxTriangle :: struct {
        /**
        \brief Constructor
        */
        Constructor :: (this: *PxTriangle) -> void #cpp_method #foreign physx_lib "??0PxTriangle@physx@@QEAA@XZ";

        /**
        \brief Constructor

        \param[in] p0 Point 0
        \param[in] p1 Point 1
        \param[in] p2 Point 2
        */
        Constructor :: (this: *PxTriangle, p0: *PxVec3, p1: *PxVec3, p2: *PxVec3) -> void #cpp_method #foreign physx_lib "??0PxTriangle@physx@@QEAA@AEBVPxVec3@1@00@Z";
        Constructor :: (this: *PxTriangle, p0: PxVec3, p1: PxVec3, p2: PxVec3) #no_context {
            Constructor(this, *p0, *p1, *p2);
        }

        /**
        \brief Destructor
        */
        Destructor :: (this: *PxTriangle) -> void #cpp_method #foreign physx_lib "??1PxTriangle@physx@@QEAA@XZ";

        /**
        \brief Compute the normal of the Triangle.

        \param[out] _normal Triangle normal.
        */
        normal :: (this: *PxTriangle, _normal: *PxVec3) -> void #cpp_method #foreign physx_lib "?normal@PxTriangle@physx@@QEBAXAEAVPxVec3@2@@Z";

        /**
        \brief Compute the unnormalized normal of the triangle.

        \param[out] _normal Triangle normal (not normalized).
        */
        denormalizedNormal :: (this: *PxTriangle, _normal: *PxVec3) -> void #cpp_method #foreign physx_lib "?denormalizedNormal@PxTriangle@physx@@QEBAXAEAVPxVec3@2@@Z";

        /**
        \brief Compute the area of the triangle.

        \return Area of the triangle.
        */
        area :: (this: *PxTriangle) -> PxReal #cpp_method #foreign physx_lib "?area@PxTriangle@physx@@QEBAMXZ";

        /**
        \return Computes a point on the triangle from u and v barycentric coordinates.
        */
        pointFromUV :: (this: *PxTriangle, u: PxReal, v: PxReal) -> PxVec3 #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "?pointFromUV@PxTriangle@physx@@QEBA?AVPxVec3@2@MM@Z";

        /**
        \brief Array of Vertices.
        */
        verts: [3] PxVec3;
    }
    #run {if true then return;
        instance: PxTriangle;
        assert(((cast(*void)(*instance.verts)) - cast(*void)(*instance)) == 0, "PxTriangle.verts has unexpected offset % instead of 0", ((cast(*void)(*instance.verts)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTriangle.verts)) == 36, "PxTriangle.verts has unexpected size % instead of 36", size_of(type_of(PxTriangle.verts)));
        assert(size_of(PxTriangle) == 36, "PxTriangle has size % instead of 36", size_of(PxTriangle));
    }

    /**
    \brief Mesh midphase structure. This enum is used to select the desired acceleration structure for midphase queries
    (i.e. raycasts, overlaps, sweeps vs triangle meshes).

    The PxMeshMidPhase::eBVH33 structure is the one used in recent PhysX versions (up to PhysX 3.3). It has great performance and is
    supported on all platforms.

    The PxMeshMidPhase::eBVH34 structure is a revisited implementation introduced in PhysX 3.4. It can be significantly faster both
    in terms of cooking performance and runtime performance, but it is currently only available on platforms supporting the
    SSE2 instuction set.
    */
    PxMeshMidPhase :: struct {
        Enum :: enum s32 {
            BVH33 :: 0;
            BVH34 :: 1;

            LAST  :: 2;

            eBVH33 :: BVH33;
            eBVH34 :: BVH34;

            eLAST  :: LAST;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxMeshMidPhase) == 1, "PxMeshMidPhase has size % instead of 1", size_of(PxMeshMidPhase));
    }

    /**
    \brief Flags for the mesh geometry properties.

    Used in ::PxTriangleMeshFlags.
    */
    PxTriangleMeshFlag :: struct {
        Enum :: enum s32 {
            _16_BIT_INDICES :: 2;
            ADJACENCY_INFO  :: 4;

            e16_BIT_INDICES :: _16_BIT_INDICES;
            eADJACENCY_INFO :: ADJACENCY_INFO;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxTriangleMeshFlag) == 1, "PxTriangleMeshFlag has size % instead of 1", size_of(PxTriangleMeshFlag));
    }

    /**
    \brief collection of set bits defined in PxTriangleMeshFlag.

    @see PxTriangleMeshFlag
    */
    PxTriangleMeshFlags :: PxFlags(PxTriangleMeshFlag.Enum, PxU8);

    /**

    \brief A triangle mesh, also called a 'polygon soup'.

    It is represented as an indexed triangle list. There are no restrictions on the
    triangle data.

    To avoid duplicating data when you have several instances of a particular
    mesh positioned differently, you do not use this class to represent a
    mesh object directly. Instead, you create an instance of this mesh via
    the PxTriangleMeshGeometry and PxShape classes.

    <h3>Creation</h3>

    To create an instance of this class call PxPhysics::createTriangleMesh(),
    and release() to delete it. This is only possible
    once you have released all of its PxShape instances.


    <h3>Visualizations:</h3>
    \li #PxVisualizationParameter::eCOLLISION_AABBS
    \li #PxVisualizationParameter::eCOLLISION_SHAPES
    \li #PxVisualizationParameter::eCOLLISION_AXES
    \li #PxVisualizationParameter::eCOLLISION_FNORMALS
    \li #PxVisualizationParameter::eCOLLISION_EDGES

    @see PxTriangleMeshDesc PxTriangleMeshGeometry PxShape PxPhysics.createTriangleMesh()
    */
    PxTriangleMesh :: struct {
        #as using pxbase: PxBase;
        #place pxbase; pxtrianglemesh_vtable: *PxTriangleMesh_VTable;
    }
    PxTriangleMesh_VTable :: struct #type_info_none {
        using pxbase: PxBase_VTable;
        getNbVertices: (this: *PxTriangleMesh) -> PxU32 #cpp_method;

        getVertices: (this: *PxTriangleMesh) -> *PxVec3 #cpp_method;

        getVerticesForModification: (this: *PxTriangleMesh) -> *PxVec3 #cpp_method;

        refitBVH: (this: *PxTriangleMesh) -> PxBounds3 #cpp_method #cpp_return_type_is_non_pod;

        getNbTriangles: (this: *PxTriangleMesh) -> PxU32 #cpp_method;

        getTriangles: (this: *PxTriangleMesh) -> *void #cpp_method;

        getTriangleMeshFlags: (this: *PxTriangleMesh) -> PxTriangleMeshFlags #cpp_method;

        getTrianglesRemap: (this: *PxTriangleMesh) -> *PxU32 #cpp_method;

        getTriangleMaterialIndex: (this: *PxTriangleMesh, triangleIndex: PxTriangleID) -> PxMaterialTableIndex #cpp_method;

        getLocalBounds: (this: *PxTriangleMesh) -> PxBounds3 #cpp_method #cpp_return_type_is_non_pod;

        getReferenceCount: (this: *PxTriangleMesh) -> PxU32 #cpp_method;

        acquireReference: (this: *PxTriangleMesh) -> void #cpp_method;
    }

    PxTriangleMesh_getNbVertices :: inline (this: *PxTriangleMesh) -> PxU32 { return this.pxtrianglemesh_vtable.getNbVertices(this); }

    PxTriangleMesh_getVertices :: inline (this: *PxTriangleMesh) -> *PxVec3 { return this.pxtrianglemesh_vtable.getVertices(this); }

    PxTriangleMesh_getVerticesForModification :: inline (this: *PxTriangleMesh) -> *PxVec3 { return this.pxtrianglemesh_vtable.getVerticesForModification(this); }

    PxTriangleMesh_refitBVH :: inline (this: *PxTriangleMesh) -> PxBounds3 { return this.pxtrianglemesh_vtable.refitBVH(this); }

    PxTriangleMesh_getNbTriangles :: inline (this: *PxTriangleMesh) -> PxU32 { return this.pxtrianglemesh_vtable.getNbTriangles(this); }

    PxTriangleMesh_getTriangles :: inline (this: *PxTriangleMesh) -> *void { return this.pxtrianglemesh_vtable.getTriangles(this); }

    PxTriangleMesh_getTriangleMeshFlags :: inline (this: *PxTriangleMesh) -> PxTriangleMeshFlags { return this.pxtrianglemesh_vtable.getTriangleMeshFlags(this); }

    PxTriangleMesh_getTrianglesRemap :: inline (this: *PxTriangleMesh) -> *PxU32 { return this.pxtrianglemesh_vtable.getTrianglesRemap(this); }

    PxTriangleMesh_getTriangleMaterialIndex :: inline (this: *PxTriangleMesh, triangleIndex: PxTriangleID) -> PxMaterialTableIndex { return this.pxtrianglemesh_vtable.getTriangleMaterialIndex(this, triangleIndex); }

    PxTriangleMesh_getLocalBounds :: inline (this: *PxTriangleMesh) -> PxBounds3 { return this.pxtrianglemesh_vtable.getLocalBounds(this); }

    PxTriangleMesh_getReferenceCount :: inline (this: *PxTriangleMesh) -> PxU32 { return this.pxtrianglemesh_vtable.getReferenceCount(this); }

    PxTriangleMesh_acquireReference :: inline (this: *PxTriangleMesh) { this.pxtrianglemesh_vtable.acquireReference(this); }

    vtable :: (obj: *PxTriangleMesh) -> *PxTriangleMesh_VTable { return obj.pxtrianglemesh_vtable; }

    #run {if true then return;
        assert(size_of(type_of(PxTriangleMesh.pxbase)) == 16, "PxTriangleMesh.pxbase has unexpected size % instead of 16", size_of(type_of(PxTriangleMesh.pxbase)));
        assert(size_of(PxTriangleMesh) == 16, "PxTriangleMesh has size % instead of 16", size_of(PxTriangleMesh));
    }

    /**

    \brief A triangle mesh containing the PxMeshMidPhase::eBVH33 structure.

    @see PxMeshMidPhase
    */
    PxBVH33TriangleMesh :: struct {
        #as using pxtrianglemesh: PxTriangleMesh;
    }
    #run {if true then return;
        assert(size_of(type_of(PxBVH33TriangleMesh.pxtrianglemesh)) == 16, "PxBVH33TriangleMesh.pxtrianglemesh has unexpected size % instead of 16", size_of(type_of(PxBVH33TriangleMesh.pxtrianglemesh)));
        assert(size_of(PxBVH33TriangleMesh) == 16, "PxBVH33TriangleMesh has size % instead of 16", size_of(PxBVH33TriangleMesh));
    }

    /**

    \brief A triangle mesh containing the PxMeshMidPhase::eBVH34 structure.

    @see PxMeshMidPhase
    */
    PxBVH34TriangleMesh :: struct {
        #as using pxtrianglemesh: PxTriangleMesh;
    }
    #run {if true then return;
        assert(size_of(type_of(PxBVH34TriangleMesh.pxtrianglemesh)) == 16, "PxBVH34TriangleMesh.pxtrianglemesh has unexpected size % instead of 16", size_of(type_of(PxBVH34TriangleMesh.pxtrianglemesh)));
        assert(size_of(PxBVH34TriangleMesh) == 16, "PxBVH34TriangleMesh has size % instead of 16", size_of(PxBVH34TriangleMesh));
    }

    /**
    \brief An ID to identify different clients for multiclient support.

    @see PxScene::createClient()
    */
    PxClientID :: PxU8;

    /**
    \brief The predefined default PxClientID value.

    @see PxClientID PxScene::createClient()
    */
    PX_DEFAULT_CLIENT: PxClientID : 0;

    /**
    \brief The maximum number of clients we support.

    @see PxClientID PxScene::createClient()
    */
    PX_MAX_CLIENTS: PxClientID : 128;

    /** Group index which allows to specify 1- or 2-way interaction */
    PxDominanceGroup :: PxU8;

    /**
    \brief Flags which control the behavior of an actor.

    @see PxActorFlags PxActor PxActor.setActorFlag() PxActor.getActorFlags()
    */
    PxActorFlag :: struct {
        Enum :: enum s32 {
            VISUALIZATION       :: 1;

            DISABLE_GRAVITY     :: 2;

            SEND_SLEEP_NOTIFIES :: 4;

            DISABLE_SIMULATION  :: 8;

            eVISUALIZATION       :: VISUALIZATION;

            eDISABLE_GRAVITY     :: DISABLE_GRAVITY;

            eSEND_SLEEP_NOTIFIES :: SEND_SLEEP_NOTIFIES;

            eDISABLE_SIMULATION  :: DISABLE_SIMULATION;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxActorFlag) == 1, "PxActorFlag has size % instead of 1", size_of(PxActorFlag));
    }

    /**
    \brief collection of set bits defined in PxActorFlag.

    @see PxActorFlag
    */
    PxActorFlags :: PxFlags(PxActorFlag.Enum, PxU8);

    /**
    \brief Identifies each type of actor.
    @see PxActor
    */
    PxActorType :: struct {
        Enum :: enum s32 {
            RIGID_STATIC      :: 0;

            RIGID_DYNAMIC     :: 1;

            ARTICULATION_LINK :: 2;

            ACTOR_COUNT       :: 3;

            ACTOR_FORCE_DWORD :: 2147483647;

            eRIGID_STATIC      :: RIGID_STATIC;

            eRIGID_DYNAMIC     :: RIGID_DYNAMIC;

            eARTICULATION_LINK :: ARTICULATION_LINK;

            eACTOR_COUNT       :: ACTOR_COUNT;

            eACTOR_FORCE_DWORD :: ACTOR_FORCE_DWORD;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxActorType) == 1, "PxActorType has size % instead of 1", size_of(PxActorType));
    }

    /**
    \brief PxActor is the base class for the main simulation objects in the physics SDK.

    The actor is owned by and contained in a PxScene.

    */
    PxActor :: struct {
        #as using pxbase: PxBase;

        userData: *void; //!< user can assign this to whatever, usually to create a 1:1 relationship with a user object.
        #place pxbase; pxactor_vtable: *PxActor_VTable;
    }
    PxActor_VTable :: struct #type_info_none {
        using pxbase: PxBase_VTable;
        getType: (this: *PxActor) -> PxActorType.Enum #cpp_method;

        getScene: (this: *PxActor) -> *PxScene #cpp_method;

        setName: (this: *PxActor, name: *u8) -> void #cpp_method;

        getName: (this: *PxActor) -> *u8 #cpp_method;

        getWorldBounds: (this: *PxActor, inflation: float = 1.01) -> PxBounds3 #cpp_method #cpp_return_type_is_non_pod;

        setActorFlag: (this: *PxActor, flag: PxActorFlag.Enum, value: bool) -> void #cpp_method;

        setActorFlags: (this: *PxActor, inFlags: PxActorFlags) -> void #cpp_method;

        getActorFlags: (this: *PxActor) -> PxActorFlags #cpp_method;

        setDominanceGroup: (this: *PxActor, dominanceGroup: PxDominanceGroup) -> void #cpp_method;

        getDominanceGroup: (this: *PxActor) -> PxDominanceGroup #cpp_method;

        setOwnerClient: (this: *PxActor, inClient: PxClientID) -> void #cpp_method;

        getOwnerClient: (this: *PxActor) -> PxClientID #cpp_method;

        getAggregate: (this: *PxActor) -> *PxAggregate #cpp_method;
    }

    PxActor_getType :: inline (this: *PxActor) -> PxActorType.Enum { return this.pxactor_vtable.getType(this); }

    PxActor_getScene :: inline (this: *PxActor) -> *PxScene { return this.pxactor_vtable.getScene(this); }

    PxActor_setName :: inline (this: *PxActor, name: *u8) { this.pxactor_vtable.setName(this, name); }

    PxActor_getName :: inline (this: *PxActor) -> *u8 { return this.pxactor_vtable.getName(this); }

    PxActor_getWorldBounds :: inline (this: *PxActor, inflation: float = 1.01) -> PxBounds3 { return this.pxactor_vtable.getWorldBounds(this, inflation); }

    PxActor_setActorFlag :: inline (this: *PxActor, flag: PxActorFlag.Enum, value: bool) { this.pxactor_vtable.setActorFlag(this, flag, value); }

    PxActor_setActorFlags :: inline (this: *PxActor, inFlags: PxActorFlags) { this.pxactor_vtable.setActorFlags(this, inFlags); }

    PxActor_getActorFlags :: inline (this: *PxActor) -> PxActorFlags { return this.pxactor_vtable.getActorFlags(this); }

    PxActor_setDominanceGroup :: inline (this: *PxActor, dominanceGroup: PxDominanceGroup) { this.pxactor_vtable.setDominanceGroup(this, dominanceGroup); }

    PxActor_getDominanceGroup :: inline (this: *PxActor) -> PxDominanceGroup { return this.pxactor_vtable.getDominanceGroup(this); }

    PxActor_setOwnerClient :: inline (this: *PxActor, inClient: PxClientID) { this.pxactor_vtable.setOwnerClient(this, inClient); }

    PxActor_getOwnerClient :: inline (this: *PxActor) -> PxClientID { return this.pxactor_vtable.getOwnerClient(this); }

    PxActor_getAggregate :: inline (this: *PxActor) -> *PxAggregate { return this.pxactor_vtable.getAggregate(this); }

    vtable :: (obj: *PxActor) -> *PxActor_VTable { return obj.pxactor_vtable; }

    #run {if true then return;
        assert(size_of(type_of(PxActor.pxbase)) == 16, "PxActor.pxbase has unexpected size % instead of 16", size_of(type_of(PxActor.pxbase)));
        instance: PxActor;
        assert(((cast(*void)(*instance.userData)) - cast(*void)(*instance)) == 16, "PxActor.userData has unexpected offset % instead of 16", ((cast(*void)(*instance.userData)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxActor.userData)) == 8, "PxActor.userData has unexpected size % instead of 8", size_of(type_of(PxActor.userData)));
        assert(size_of(PxActor) == 24, "PxActor has size % instead of 24", size_of(PxActor));
    }

    /**
    \brief Class to aggregate actors into a single broad-phase entry.

    A PxAggregate object is a collection of PxActors, which will exist as a single entry in the
    broad-phase structures. This has 3 main benefits:

    1) it reduces "broad phase pollution" by allowing a collection of spatially coherent broad-phase
    entries to be replaced by a single aggregated entry (e.g. a ragdoll or a single actor with a
    large number of attached shapes).

    2) it reduces broad-phase memory usage

    3) filtering can be optimized a lot if self-collisions within an aggregate are not needed. For
    example if you don't need collisions between ragdoll bones, it's faster to simply disable
    filtering once and for all, for the aggregate containing the ragdoll, rather than filtering
    out each bone-bone collision in the filter shader.

    @see PxActor, PxPhysics.createAggregate
    */
    PxAggregate :: struct {
        #as using pxbase: PxBase;
        #place pxbase; pxaggregate_vtable: *PxAggregate_VTable;
    }
    PxAggregate_VTable :: struct #type_info_none {
        using pxbase: PxBase_VTable;
        addActor: (this: *PxAggregate, actor: *PxActor, bvhStructure: *PxBVHStructure = null) -> bool #cpp_method;

        removeActor: (this: *PxAggregate, actor: *PxActor) -> bool #cpp_method;

        addArticulation: (this: *PxAggregate, articulation: *PxArticulationBase) -> bool #cpp_method;

        removeArticulation: (this: *PxAggregate, articulation: *PxArticulationBase) -> bool #cpp_method;

        getNbActors: (this: *PxAggregate) -> PxU32 #cpp_method;

        getMaxNbActors: (this: *PxAggregate) -> PxU32 #cpp_method;

        getActors: (this: *PxAggregate, userBuffer: **PxActor, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        getScene: (this: *PxAggregate) -> *PxScene #cpp_method;

        getSelfCollision: (this: *PxAggregate) -> bool #cpp_method;
    }

    PxAggregate_addActor :: inline (this: *PxAggregate, actor: *PxActor, bvhStructure: *PxBVHStructure = null) -> bool { return this.pxaggregate_vtable.addActor(this, actor, bvhStructure); }

    PxAggregate_removeActor :: inline (this: *PxAggregate, actor: *PxActor) -> bool { return this.pxaggregate_vtable.removeActor(this, actor); }

    PxAggregate_addArticulation :: inline (this: *PxAggregate, articulation: *PxArticulationBase) -> bool { return this.pxaggregate_vtable.addArticulation(this, articulation); }

    PxAggregate_removeArticulation :: inline (this: *PxAggregate, articulation: *PxArticulationBase) -> bool { return this.pxaggregate_vtable.removeArticulation(this, articulation); }

    PxAggregate_getNbActors :: inline (this: *PxAggregate) -> PxU32 { return this.pxaggregate_vtable.getNbActors(this); }

    PxAggregate_getMaxNbActors :: inline (this: *PxAggregate) -> PxU32 { return this.pxaggregate_vtable.getMaxNbActors(this); }

    PxAggregate_getActors :: inline (this: *PxAggregate, userBuffer: **PxActor, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.pxaggregate_vtable.getActors(this, userBuffer, bufferSize, startIndex); }

    PxAggregate_getScene :: inline (this: *PxAggregate) -> *PxScene { return this.pxaggregate_vtable.getScene(this); }

    PxAggregate_getSelfCollision :: inline (this: *PxAggregate) -> bool { return this.pxaggregate_vtable.getSelfCollision(this); }

    vtable :: (obj: *PxAggregate) -> *PxAggregate_VTable { return obj.pxaggregate_vtable; }

    #run {if true then return;
        assert(size_of(type_of(PxAggregate.pxbase)) == 16, "PxAggregate.pxbase has unexpected size % instead of 16", size_of(type_of(PxAggregate.pxbase)));
        assert(size_of(PxAggregate) == 16, "PxAggregate has size % instead of 16", size_of(PxAggregate));
    }

    PxArticulationImpl :: struct {}

    /**
    \brief a tree structure of bodies connected by joints that is treated as a unit by the dynamics solver

    Articulations are more expensive to simulate than the equivalent collection of
    PxRigidDynamic and PxJoint structures, but because the dynamics solver treats
    each articulation as a single object, they are much less prone to separation and
    have better support for actuation. An articulation may have at most 64 links.

    @see PxArticulationJoint PxArticulationLink PxPhysics.createArticulation
    */
    PxArticulationBase :: struct {
        #as using pxbase: PxBase;

        userData: *void; //!< user can assign this to whatever, usually to create a 1:1 relationship with a user object.
        #place pxbase; pxarticulationbase_vtable: *PxArticulationBase_VTable;
    }
    PxArticulationBase_VTable :: struct #type_info_none {
        using pxbase: PxBase_VTable;
        getScene: (this: *PxArticulationBase) -> *PxScene #cpp_method;

        setSolverIterationCounts: (this: *PxArticulationBase, minPositionIters: PxU32, minVelocityIters: PxU32 = 1) -> void #cpp_method;

        getSolverIterationCounts: (this: *PxArticulationBase, minPositionIters: *PxU32, minVelocityIters: *PxU32) -> void #cpp_method;

        isSleeping: (this: *PxArticulationBase) -> bool #cpp_method;

        setSleepThreshold: (this: *PxArticulationBase, threshold: PxReal) -> void #cpp_method;

        getSleepThreshold: (this: *PxArticulationBase) -> PxReal #cpp_method;

        setStabilizationThreshold: (this: *PxArticulationBase, threshold: PxReal) -> void #cpp_method;

        getStabilizationThreshold: (this: *PxArticulationBase) -> PxReal #cpp_method;

        setWakeCounter: (this: *PxArticulationBase, wakeCounterValue: PxReal) -> void #cpp_method;

        getWakeCounter: (this: *PxArticulationBase) -> PxReal #cpp_method;

        wakeUp: (this: *PxArticulationBase) -> void #cpp_method;

        putToSleep: (this: *PxArticulationBase) -> void #cpp_method;

        createLink: (this: *PxArticulationBase, parent: *PxArticulationLink, pose: *PxTransform) -> *PxArticulationLink #cpp_method;

        getNbLinks: (this: *PxArticulationBase) -> PxU32 #cpp_method;

        getLinks: (this: *PxArticulationBase, userBuffer: **PxArticulationLink, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        setName: (this: *PxArticulationBase, name: *u8) -> void #cpp_method;

        getName: (this: *PxArticulationBase) -> *u8 #cpp_method;

        getWorldBounds: (this: *PxArticulationBase, inflation: float = 1.01) -> PxBounds3 #cpp_method #cpp_return_type_is_non_pod;

        getAggregate: (this: *PxArticulationBase) -> *PxAggregate #cpp_method;

        getImpl_1: (this: /*const*/ *PxArticulationBase) -> *PxArticulationImpl #cpp_method;

        getImpl: (this: *PxArticulationBase) -> *PxArticulationImpl #cpp_method;

        createArticulationJoint: (this: *PxArticulationBase, parent: *PxArticulationLink, parentFrame: *PxTransform, child: *PxArticulationLink, childFrame: *PxTransform) -> *PxArticulationJointBase #cpp_method;
        releaseArticulationJoint: (this: *PxArticulationBase, joint: *PxArticulationJointBase) -> void #cpp_method;
    }

    PxArticulationBase_getScene :: inline (this: *PxArticulationBase) -> *PxScene { return this.pxarticulationbase_vtable.getScene(this); }

    PxArticulationBase_setSolverIterationCounts :: inline (this: *PxArticulationBase, minPositionIters: PxU32, minVelocityIters: PxU32 = 1) { this.pxarticulationbase_vtable.setSolverIterationCounts(this, minPositionIters, minVelocityIters); }

    PxArticulationBase_getSolverIterationCounts :: inline (this: *PxArticulationBase, minPositionIters: *PxU32, minVelocityIters: *PxU32) { this.pxarticulationbase_vtable.getSolverIterationCounts(this, minPositionIters, minVelocityIters); }

    PxArticulationBase_isSleeping :: inline (this: *PxArticulationBase) -> bool { return this.pxarticulationbase_vtable.isSleeping(this); }

    PxArticulationBase_setSleepThreshold :: inline (this: *PxArticulationBase, threshold: PxReal) { this.pxarticulationbase_vtable.setSleepThreshold(this, threshold); }

    PxArticulationBase_getSleepThreshold :: inline (this: *PxArticulationBase) -> PxReal { return this.pxarticulationbase_vtable.getSleepThreshold(this); }

    PxArticulationBase_setStabilizationThreshold :: inline (this: *PxArticulationBase, threshold: PxReal) { this.pxarticulationbase_vtable.setStabilizationThreshold(this, threshold); }

    PxArticulationBase_getStabilizationThreshold :: inline (this: *PxArticulationBase) -> PxReal { return this.pxarticulationbase_vtable.getStabilizationThreshold(this); }

    PxArticulationBase_setWakeCounter :: inline (this: *PxArticulationBase, wakeCounterValue: PxReal) { this.pxarticulationbase_vtable.setWakeCounter(this, wakeCounterValue); }

    PxArticulationBase_getWakeCounter :: inline (this: *PxArticulationBase) -> PxReal { return this.pxarticulationbase_vtable.getWakeCounter(this); }

    PxArticulationBase_wakeUp :: inline (this: *PxArticulationBase) { this.pxarticulationbase_vtable.wakeUp(this); }

    PxArticulationBase_putToSleep :: inline (this: *PxArticulationBase) { this.pxarticulationbase_vtable.putToSleep(this); }

    PxArticulationBase_createLink :: inline (this: *PxArticulationBase, parent: *PxArticulationLink, pose: *PxTransform) -> *PxArticulationLink { return this.pxarticulationbase_vtable.createLink(this, parent, pose); }

    PxArticulationBase_getNbLinks :: inline (this: *PxArticulationBase) -> PxU32 { return this.pxarticulationbase_vtable.getNbLinks(this); }

    PxArticulationBase_getLinks :: inline (this: *PxArticulationBase, userBuffer: **PxArticulationLink, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.pxarticulationbase_vtable.getLinks(this, userBuffer, bufferSize, startIndex); }

    PxArticulationBase_setName :: inline (this: *PxArticulationBase, name: *u8) { this.pxarticulationbase_vtable.setName(this, name); }

    PxArticulationBase_getName :: inline (this: *PxArticulationBase) -> *u8 { return this.pxarticulationbase_vtable.getName(this); }

    PxArticulationBase_getWorldBounds :: inline (this: *PxArticulationBase, inflation: float = 1.01) -> PxBounds3 { return this.pxarticulationbase_vtable.getWorldBounds(this, inflation); }

    PxArticulationBase_getAggregate :: inline (this: *PxArticulationBase) -> *PxAggregate { return this.pxarticulationbase_vtable.getAggregate(this); }

    PxArticulationBase_getImpl_1 :: inline (this: /*const*/ *PxArticulationBase) -> *PxArticulationImpl { return this.pxarticulationbase_vtable.getImpl_1(this); }

    PxArticulationBase_getImpl :: inline (this: *PxArticulationBase) -> *PxArticulationImpl { return this.pxarticulationbase_vtable.getImpl(this); }

    PxArticulationBase_createArticulationJoint :: inline (this: *PxArticulationBase, parent: *PxArticulationLink, parentFrame: *PxTransform, child: *PxArticulationLink, childFrame: *PxTransform) -> *PxArticulationJointBase { return this.pxarticulationbase_vtable.createArticulationJoint(this, parent, parentFrame, child, childFrame); }
    PxArticulationBase_releaseArticulationJoint :: inline (this: *PxArticulationBase, joint: *PxArticulationJointBase) { this.pxarticulationbase_vtable.releaseArticulationJoint(this, joint); }

    vtable :: (obj: *PxArticulationBase) -> *PxArticulationBase_VTable { return obj.pxarticulationbase_vtable; }

    #run {if true then return;
        assert(size_of(type_of(PxArticulationBase.pxbase)) == 16, "PxArticulationBase.pxbase has unexpected size % instead of 16", size_of(type_of(PxArticulationBase.pxbase)));
        instance: PxArticulationBase;
        assert(((cast(*void)(*instance.userData)) - cast(*void)(*instance)) == 16, "PxArticulationBase.userData has unexpected offset % instead of 16", ((cast(*void)(*instance.userData)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxArticulationBase.userData)) == 8, "PxArticulationBase.userData has unexpected size % instead of 8", size_of(type_of(PxArticulationBase.userData)));
        assert(size_of(PxArticulationBase) == 24, "PxArticulationBase has size % instead of 24", size_of(PxArticulationBase));
    }

    /**
    \brief Articulation drive cache

    This cache is used for making one or more impulse applications to the articulation.

    @see PxArticulation PxArticulation.createDriveCache
    */
    PxArticulationDriveCache :: struct {
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxArticulationDriveCache) == 1, "PxArticulationDriveCache has size % instead of 1", size_of(PxArticulationDriveCache));
    }

    PxArticulation :: struct {
        #as using pxarticulationbase: PxArticulationBase;
        #place pxarticulationbase; pxarticulation_vtable: *PxArticulation_VTable;
    }
    PxArticulation_VTable :: struct #type_info_none {
        using pxarticulationbase: PxArticulationBase_VTable;
        setMaxProjectionIterations: (this: *PxArticulation, iterations: PxU32) -> void #cpp_method;

        getMaxProjectionIterations: (this: *PxArticulation) -> PxU32 #cpp_method;

        setSeparationTolerance: (this: *PxArticulation, tolerance: PxReal) -> void #cpp_method;

        getSeparationTolerance: (this: *PxArticulation) -> PxReal #cpp_method;

        setInternalDriveIterations: (this: *PxArticulation, iterations: PxU32) -> void #cpp_method;

        getInternalDriveIterations: (this: *PxArticulation) -> PxU32 #cpp_method;

        setExternalDriveIterations: (this: *PxArticulation, iterations: PxU32) -> void #cpp_method;

        getExternalDriveIterations: (this: *PxArticulation) -> PxU32 #cpp_method;

        createDriveCache: (this: *PxArticulation, compliance: PxReal, driveIterations: PxU32) -> *PxArticulationDriveCache #cpp_method;

        updateDriveCache: (this: *PxArticulation, driveCache: *PxArticulationDriveCache, compliance: PxReal, driveIterations: PxU32) -> void #cpp_method;

        releaseDriveCache: (this: *PxArticulation, driveCache: *PxArticulationDriveCache) -> void #cpp_method;

        applyImpulse: (this: *PxArticulation, link: *PxArticulationLink, driveCache: *PxArticulationDriveCache, linearImpulse: *PxVec3, angularImpulse: *PxVec3) -> void #cpp_method;

        computeImpulseResponse: (this: *PxArticulation, link: *PxArticulationLink, linearResponse: *PxVec3, angularResponse: *PxVec3, driveCache: *PxArticulationDriveCache, linearImpulse: *PxVec3, angularImpulse: *PxVec3) -> void #cpp_method;
    }

    PxArticulation_setMaxProjectionIterations :: inline (this: *PxArticulation, iterations: PxU32) { this.pxarticulation_vtable.setMaxProjectionIterations(this, iterations); }

    PxArticulation_getMaxProjectionIterations :: inline (this: *PxArticulation) -> PxU32 { return this.pxarticulation_vtable.getMaxProjectionIterations(this); }

    PxArticulation_setSeparationTolerance :: inline (this: *PxArticulation, tolerance: PxReal) { this.pxarticulation_vtable.setSeparationTolerance(this, tolerance); }

    PxArticulation_getSeparationTolerance :: inline (this: *PxArticulation) -> PxReal { return this.pxarticulation_vtable.getSeparationTolerance(this); }

    PxArticulation_setInternalDriveIterations :: inline (this: *PxArticulation, iterations: PxU32) { this.pxarticulation_vtable.setInternalDriveIterations(this, iterations); }

    PxArticulation_getInternalDriveIterations :: inline (this: *PxArticulation) -> PxU32 { return this.pxarticulation_vtable.getInternalDriveIterations(this); }

    PxArticulation_setExternalDriveIterations :: inline (this: *PxArticulation, iterations: PxU32) { this.pxarticulation_vtable.setExternalDriveIterations(this, iterations); }

    PxArticulation_getExternalDriveIterations :: inline (this: *PxArticulation) -> PxU32 { return this.pxarticulation_vtable.getExternalDriveIterations(this); }

    PxArticulation_createDriveCache :: inline (this: *PxArticulation, compliance: PxReal, driveIterations: PxU32) -> *PxArticulationDriveCache { return this.pxarticulation_vtable.createDriveCache(this, compliance, driveIterations); }

    PxArticulation_updateDriveCache :: inline (this: *PxArticulation, driveCache: *PxArticulationDriveCache, compliance: PxReal, driveIterations: PxU32) { this.pxarticulation_vtable.updateDriveCache(this, driveCache, compliance, driveIterations); }

    PxArticulation_releaseDriveCache :: inline (this: *PxArticulation, driveCache: *PxArticulationDriveCache) { this.pxarticulation_vtable.releaseDriveCache(this, driveCache); }

    PxArticulation_applyImpulse :: inline (this: *PxArticulation, link: *PxArticulationLink, driveCache: *PxArticulationDriveCache, linearImpulse: *PxVec3, angularImpulse: *PxVec3) { this.pxarticulation_vtable.applyImpulse(this, link, driveCache, linearImpulse, angularImpulse); }

    PxArticulation_computeImpulseResponse :: inline (this: *PxArticulation, link: *PxArticulationLink, linearResponse: *PxVec3, angularResponse: *PxVec3, driveCache: *PxArticulationDriveCache, linearImpulse: *PxVec3, angularImpulse: *PxVec3) { this.pxarticulation_vtable.computeImpulseResponse(this, link, linearResponse, angularResponse, driveCache, linearImpulse, angularImpulse); }

    vtable :: (obj: *PxArticulation) -> *PxArticulation_VTable { return obj.pxarticulation_vtable; }

    #run {if true then return;
        assert(size_of(type_of(PxArticulation.pxarticulationbase)) == 24, "PxArticulation.pxarticulationbase has unexpected size % instead of 24", size_of(type_of(PxArticulation.pxarticulationbase)));
        assert(size_of(PxArticulation) == 24, "PxArticulation has size % instead of 24", size_of(PxArticulation));
    }

    pvdsdk :: struct {
        PvdDataStream :: struct {}

        PvdClient :: struct {}
        PvdDebugPoint :: struct {}
        PvdDebugLine :: struct {}
        PvdDebugTriangle :: struct {}
        PvdDebugText :: struct {}
    }

    /**
    \brief constraint row flags

    These flags configure the post-processing of constraint rows and the behavior of the solver while solving constraints
    */
    Px1DConstraintFlag :: struct {
        Type :: enum s32 {
            SPRING              :: 1;
            ACCELERATION_SPRING :: 2;
            RESTITUTION         :: 4;
            KEEPBIAS            :: 8;
            OUTPUT_FORCE        :: 16;
            HAS_DRIVE_LIMIT     :: 32;
            ANGULAR_CONSTRAINT  :: 64;
            DRIVE_ROW           :: 128;

            eSPRING              :: SPRING;
            eACCELERATION_SPRING :: ACCELERATION_SPRING;
            eRESTITUTION         :: RESTITUTION;
            eKEEPBIAS            :: KEEPBIAS;
            eOUTPUT_FORCE        :: OUTPUT_FORCE;
            eHAS_DRIVE_LIMIT     :: HAS_DRIVE_LIMIT;
            eANGULAR_CONSTRAINT  :: ANGULAR_CONSTRAINT;
            eDRIVE_ROW           :: DRIVE_ROW;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(Px1DConstraintFlag) == 1, "Px1DConstraintFlag has size % instead of 1", size_of(Px1DConstraintFlag));
    }

    Px1DConstraintFlags :: PxFlags(Px1DConstraintFlag.Type, PxU16);

    /**
    \brief constraint type hints which the solver uses to optimize constraint handling
    */
    PxConstraintSolveHint :: struct {
        Enum :: enum s32 {
            NONE                  :: 0;
            ACCELERATION1         :: 256;
            SLERP_SPRING          :: 258;
            ACCELERATION2         :: 512;
            ACCELERATION3         :: 768;
            ROTATIONAL_EQUALITY   :: 1024;
            ROTATIONAL_INEQUALITY :: 1025;
            EQUALITY              :: 2048;
            INEQUALITY            :: 2049;

            eNONE                  :: NONE;
            eACCELERATION1         :: ACCELERATION1;
            eSLERP_SPRING          :: SLERP_SPRING;
            eACCELERATION2         :: ACCELERATION2;
            eACCELERATION3         :: ACCELERATION3;
            eROTATIONAL_EQUALITY   :: ROTATIONAL_EQUALITY;
            eROTATIONAL_INEQUALITY :: ROTATIONAL_INEQUALITY;
            eEQUALITY              :: EQUALITY;
            eINEQUALITY            :: INEQUALITY;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxConstraintSolveHint) == 1, "PxConstraintSolveHint has size % instead of 1", size_of(PxConstraintSolveHint));
    }

    /**
    \brief A constraint

    A constraint is expressed as a set of 1-dimensional constraint rows which define the required constraint
    on the objects' velocities.

    Each constraint is either a hard constraint or a spring. We define the velocity at the constraint to be
    the quantity

    v = body0vel.dot(lin0,ang0) - body1vel.dot(lin1, ang1)

    For a hard constraint, the solver attempts to generate

    1. a set of velocities for the objects which, when integrated, respect the constraint errors:

    v + (geometricError / timestep) = velocityTarget

    2. a set of velocities for the objects which respect the constraints:

    v = velocityTarget

    Hard constraints support restitution: if the impact velocity exceeds the bounce threshold, then the target velocity
    of the constraint will be set to restitution * -v

    Alternatively, the solver can attempt to resolve the velocity constraint as an implicit spring:

    F = stiffness * -geometricError + damping * (velocityTarget - v)

    where F is the constraint force or acceleration. Springs are fully implicit: that is, the force or acceleration
    is a function of the position and velocity after the solve.

    All constraints support limits on the minimum or maximum impulse applied.
    */
    Px1DConstraint :: struct {
        linear0:        PxVec3; //!< linear component of velocity jacobian in world space
        geometricError: PxReal; //!< geometric error of the constraint along this axis
        angular0:       PxVec3; //!< angular component of velocity jacobian in world space
        velocityTarget: PxReal; //!< velocity target for the constraint along this axis

        linear1:        PxVec3; //!< linear component of velocity jacobian in world space
        minImpulse:     PxReal; //!< minimum impulse the solver may apply to enforce this constraint
        angular1:       PxVec3; //!< angular component of velocity jacobian in world space
        maxImpulse:     PxReal; //!< maximum impulse the solver may apply to enforce this constraint

        mods:           union {
            SpringModifiers :: struct {
                stiffness: PxReal; //!< spring parameter, for spring constraints
                damping:   PxReal; //!< damping parameter, for spring constraints
            }
            #run {if true then return;
                instance: SpringModifiers;
                assert(((cast(*void)(*instance.stiffness)) - cast(*void)(*instance)) == 0, "SpringModifiers.stiffness has unexpected offset % instead of 0", ((cast(*void)(*instance.stiffness)) - cast(*void)(*instance)));
                assert(size_of(type_of(SpringModifiers.stiffness)) == 4, "SpringModifiers.stiffness has unexpected size % instead of 4", size_of(type_of(SpringModifiers.stiffness)));
                assert(((cast(*void)(*instance.damping)) - cast(*void)(*instance)) == 4, "SpringModifiers.damping has unexpected offset % instead of 4", ((cast(*void)(*instance.damping)) - cast(*void)(*instance)));
                assert(size_of(type_of(SpringModifiers.damping)) == 4, "SpringModifiers.damping has unexpected size % instead of 4", size_of(type_of(SpringModifiers.damping)));
                assert(size_of(SpringModifiers) == 8, "SpringModifiers has size % instead of 8", size_of(SpringModifiers));
            }

            spring: SpringModifiers;
            RestitutionModifiers :: struct {
                restitution:       PxReal; //!< restitution parameter for determining additional "bounce"
                velocityThreshold: PxReal; //!< minimum impact velocity for bounce
            }
            #run {if true then return;
                instance: RestitutionModifiers;
                assert(((cast(*void)(*instance.restitution)) - cast(*void)(*instance)) == 0, "RestitutionModifiers.restitution has unexpected offset % instead of 0", ((cast(*void)(*instance.restitution)) - cast(*void)(*instance)));
                assert(size_of(type_of(RestitutionModifiers.restitution)) == 4, "RestitutionModifiers.restitution has unexpected size % instead of 4", size_of(type_of(RestitutionModifiers.restitution)));
                assert(((cast(*void)(*instance.velocityThreshold)) - cast(*void)(*instance)) == 4, "RestitutionModifiers.velocityThreshold has unexpected offset % instead of 4", ((cast(*void)(*instance.velocityThreshold)) - cast(*void)(*instance)));
                assert(size_of(type_of(RestitutionModifiers.velocityThreshold)) == 4, "RestitutionModifiers.velocityThreshold has unexpected size % instead of 4", size_of(type_of(RestitutionModifiers.velocityThreshold)));
                assert(size_of(RestitutionModifiers) == 8, "RestitutionModifiers has size % instead of 8", size_of(RestitutionModifiers));
            }

            bounce: RestitutionModifiers;
        };

        forInternalUse: PxReal; //!< for internal use only
        flags:          PxU16; //!< a set of Px1DConstraintFlags
        solveHint:      PxU16; //!< constraint optimization hint, should be an element of PxConstraintSolveHint
    }
    #run {if true then return;
        instance: Px1DConstraint;
        assert(((cast(*void)(*instance.linear0)) - cast(*void)(*instance)) == 0, "Px1DConstraint.linear0 has unexpected offset % instead of 0", ((cast(*void)(*instance.linear0)) - cast(*void)(*instance)));
        assert(size_of(type_of(Px1DConstraint.linear0)) == 12, "Px1DConstraint.linear0 has unexpected size % instead of 12", size_of(type_of(Px1DConstraint.linear0)));
        assert(((cast(*void)(*instance.geometricError)) - cast(*void)(*instance)) == 12, "Px1DConstraint.geometricError has unexpected offset % instead of 12", ((cast(*void)(*instance.geometricError)) - cast(*void)(*instance)));
        assert(size_of(type_of(Px1DConstraint.geometricError)) == 4, "Px1DConstraint.geometricError has unexpected size % instead of 4", size_of(type_of(Px1DConstraint.geometricError)));
        assert(((cast(*void)(*instance.angular0)) - cast(*void)(*instance)) == 16, "Px1DConstraint.angular0 has unexpected offset % instead of 16", ((cast(*void)(*instance.angular0)) - cast(*void)(*instance)));
        assert(size_of(type_of(Px1DConstraint.angular0)) == 12, "Px1DConstraint.angular0 has unexpected size % instead of 12", size_of(type_of(Px1DConstraint.angular0)));
        assert(((cast(*void)(*instance.velocityTarget)) - cast(*void)(*instance)) == 28, "Px1DConstraint.velocityTarget has unexpected offset % instead of 28", ((cast(*void)(*instance.velocityTarget)) - cast(*void)(*instance)));
        assert(size_of(type_of(Px1DConstraint.velocityTarget)) == 4, "Px1DConstraint.velocityTarget has unexpected size % instead of 4", size_of(type_of(Px1DConstraint.velocityTarget)));
        assert(((cast(*void)(*instance.linear1)) - cast(*void)(*instance)) == 32, "Px1DConstraint.linear1 has unexpected offset % instead of 32", ((cast(*void)(*instance.linear1)) - cast(*void)(*instance)));
        assert(size_of(type_of(Px1DConstraint.linear1)) == 12, "Px1DConstraint.linear1 has unexpected size % instead of 12", size_of(type_of(Px1DConstraint.linear1)));
        assert(((cast(*void)(*instance.minImpulse)) - cast(*void)(*instance)) == 44, "Px1DConstraint.minImpulse has unexpected offset % instead of 44", ((cast(*void)(*instance.minImpulse)) - cast(*void)(*instance)));
        assert(size_of(type_of(Px1DConstraint.minImpulse)) == 4, "Px1DConstraint.minImpulse has unexpected size % instead of 4", size_of(type_of(Px1DConstraint.minImpulse)));
        assert(((cast(*void)(*instance.angular1)) - cast(*void)(*instance)) == 48, "Px1DConstraint.angular1 has unexpected offset % instead of 48", ((cast(*void)(*instance.angular1)) - cast(*void)(*instance)));
        assert(size_of(type_of(Px1DConstraint.angular1)) == 12, "Px1DConstraint.angular1 has unexpected size % instead of 12", size_of(type_of(Px1DConstraint.angular1)));
        assert(((cast(*void)(*instance.maxImpulse)) - cast(*void)(*instance)) == 60, "Px1DConstraint.maxImpulse has unexpected offset % instead of 60", ((cast(*void)(*instance.maxImpulse)) - cast(*void)(*instance)));
        assert(size_of(type_of(Px1DConstraint.maxImpulse)) == 4, "Px1DConstraint.maxImpulse has unexpected size % instead of 4", size_of(type_of(Px1DConstraint.maxImpulse)));
        assert(((cast(*void)(*instance.mods)) - cast(*void)(*instance)) == 64, "Px1DConstraint.mods has unexpected offset % instead of 64", ((cast(*void)(*instance.mods)) - cast(*void)(*instance)));
        assert(size_of(type_of(Px1DConstraint.mods)) == 8, "Px1DConstraint.mods has unexpected size % instead of 8", size_of(type_of(Px1DConstraint.mods)));
        assert(((cast(*void)(*instance.forInternalUse)) - cast(*void)(*instance)) == 72, "Px1DConstraint.forInternalUse has unexpected offset % instead of 72", ((cast(*void)(*instance.forInternalUse)) - cast(*void)(*instance)));
        assert(size_of(type_of(Px1DConstraint.forInternalUse)) == 4, "Px1DConstraint.forInternalUse has unexpected size % instead of 4", size_of(type_of(Px1DConstraint.forInternalUse)));
        assert(((cast(*void)(*instance.flags)) - cast(*void)(*instance)) == 76, "Px1DConstraint.flags has unexpected offset % instead of 76", ((cast(*void)(*instance.flags)) - cast(*void)(*instance)));
        assert(size_of(type_of(Px1DConstraint.flags)) == 2, "Px1DConstraint.flags has unexpected size % instead of 2", size_of(type_of(Px1DConstraint.flags)));
        assert(((cast(*void)(*instance.solveHint)) - cast(*void)(*instance)) == 78, "Px1DConstraint.solveHint has unexpected offset % instead of 78", ((cast(*void)(*instance.solveHint)) - cast(*void)(*instance)));
        assert(size_of(type_of(Px1DConstraint.solveHint)) == 2, "Px1DConstraint.solveHint has unexpected size % instead of 2", size_of(type_of(Px1DConstraint.solveHint)));
        assert(size_of(Px1DConstraint) == 80, "Px1DConstraint has size % instead of 80", size_of(Px1DConstraint));
    }

    /**
    \brief Flags for determining which components of the constraint should be visualized.

    @see PxConstraintVisualize
    */
    PxConstraintVisualizationFlag :: struct {
        Enum :: enum s32 {
            OCAL_FRAMES :: 1;
            IMITS       :: 2;

            eLOCAL_FRAMES :: OCAL_FRAMES;
            eLIMITS       :: IMITS;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxConstraintVisualizationFlag) == 1, "PxConstraintVisualizationFlag has size % instead of 1", size_of(PxConstraintVisualizationFlag));
    }

    PxConstraintInvMassScale :: struct {
        linear0:  PxReal; //!< multiplier for inverse mass of body0
        angular0: PxReal; //!< multiplier for inverse MoI of body0
        linear1:  PxReal; //!< multiplier for inverse mass of body1
        angular1: PxReal; //!< multiplier for inverse MoI of body1

        Constructor :: (this: *PxConstraintInvMassScale) -> void #cpp_method #foreign physx_lib "??0PxConstraintInvMassScale@physx@@QEAA@XZ";
        Constructor :: (this: *PxConstraintInvMassScale, lin0: PxReal, ang0: PxReal, lin1: PxReal, ang1: PxReal) -> void #cpp_method #foreign physx_lib "??0PxConstraintInvMassScale@physx@@QEAA@MMMM@Z";
    }
    #run {if true then return;
        instance: PxConstraintInvMassScale;
        assert(((cast(*void)(*instance.linear0)) - cast(*void)(*instance)) == 0, "PxConstraintInvMassScale.linear0 has unexpected offset % instead of 0", ((cast(*void)(*instance.linear0)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxConstraintInvMassScale.linear0)) == 4, "PxConstraintInvMassScale.linear0 has unexpected size % instead of 4", size_of(type_of(PxConstraintInvMassScale.linear0)));
        assert(((cast(*void)(*instance.angular0)) - cast(*void)(*instance)) == 4, "PxConstraintInvMassScale.angular0 has unexpected offset % instead of 4", ((cast(*void)(*instance.angular0)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxConstraintInvMassScale.angular0)) == 4, "PxConstraintInvMassScale.angular0 has unexpected size % instead of 4", size_of(type_of(PxConstraintInvMassScale.angular0)));
        assert(((cast(*void)(*instance.linear1)) - cast(*void)(*instance)) == 8, "PxConstraintInvMassScale.linear1 has unexpected offset % instead of 8", ((cast(*void)(*instance.linear1)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxConstraintInvMassScale.linear1)) == 4, "PxConstraintInvMassScale.linear1 has unexpected size % instead of 4", size_of(type_of(PxConstraintInvMassScale.linear1)));
        assert(((cast(*void)(*instance.angular1)) - cast(*void)(*instance)) == 12, "PxConstraintInvMassScale.angular1 has unexpected offset % instead of 12", ((cast(*void)(*instance.angular1)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxConstraintInvMassScale.angular1)) == 4, "PxConstraintInvMassScale.angular1 has unexpected size % instead of 4", size_of(type_of(PxConstraintInvMassScale.angular1)));
        assert(size_of(PxConstraintInvMassScale) == 16, "PxConstraintInvMassScale has size % instead of 16", size_of(PxConstraintInvMassScale));
    }

    /** solver constraint generation shader

    This function is called by the constraint solver framework. The function must be reentrant, since it may be called simultaneously
    from multiple threads, and should access only the arguments passed into it.

    Developers writing custom constraints are encouraged to read the documentation in the user guide and the implementation code in PhysXExtensions.

    \param[out] constraints			An array of solver constraint rows to be filled in
    \param[out] bodyAWorldOffset	The origin point (offset from the position vector of bodyA's center of mass) at which the constraint is resolved. This value does not affect how constraints are solved, only the constraint force reported.
    \param[in] maxConstraints		The size of the constraint buffer. At most this many constraints rows may be written
    \param[out] invMassScale		The inverse mass and inertia scales for the constraint
    \param[in] constantBlock		The constant data block
    \param[in] bodyAToWorld			The center of mass frame of the first constrained body (the identity transform if the first actor is static, or if a NULL actor pointer was provided for it)
    \param[in] bodyBToWorld			The center of mass frame of the second constrained body (the identity transform if the second actor is static, or if a NULL actor pointer was provided for it)
    \param[in] useExtendedLimits	Enables limit ranges outside of (-PI, PI)
    \param[out] cAtW				The world space location of body A's joint frame (position only)
    \param[out] cBtW				The world space location of body B's joint frame (position only)

    \return the number of constraint rows written.
    */
    PxConstraintSolverPrep :: #type (constraints: *Px1DConstraint, bodyAWorldOffset: *PxVec3, maxConstraints: PxU32, invMassScale: *PxConstraintInvMassScale, constantBlock: *void, bodyAToWorld: *PxTransform, bodyBToWorld: *PxTransform, useExtendedLimits: bool, cAtW: *PxVec3, cBtW: *PxVec3) -> PxU32 #c_call;

    /** solver constraint projection shader

    This function is called by the constraint post-solver framework. The function must be reentrant, since it may be called simultaneously
    from multiple threads and should access only the arguments passed into it.

    \param[in] constantBlock	The constant data block
    \param[out] bodyAToWorld	The center of mass frame of the first constrained body (the identity if the actor is static or a NULL pointer was provided for it)
    \param[out] bodyBToWorld	The center of mass frame of the second constrained body (the identity if the actor is static or a NULL pointer was provided for it)
    \param[in] projectToA		True if the constraint should be projected by moving the second body towards the first, false if the converse
    */
    PxConstraintProject :: #type (constantBlock: *void, bodyAToWorld: *PxTransform, bodyBToWorld: *PxTransform, projectToA: bool) -> void #c_call;

    /**
    API used to visualize details about a constraint.
    */
    PxConstraintVisualizer :: struct {
        vtable: *PxConstraintVisualizer_VTable;
    }
    PxConstraintVisualizer_VTable :: struct #type_info_none {
        Destructor: (this: *PxConstraintVisualizer, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

        visualizeJointFrames: (this: *PxConstraintVisualizer, parent: *PxTransform, child: *PxTransform) -> void #cpp_method;

        visualizeLinearLimit: (this: *PxConstraintVisualizer, t0: *PxTransform, t1: *PxTransform, value: PxReal, active: bool) -> void #cpp_method;

        visualizeAngularLimit: (this: *PxConstraintVisualizer, t0: *PxTransform, lower: PxReal, upper: PxReal, active: bool) -> void #cpp_method;

        visualizeLimitCone: (this: *PxConstraintVisualizer, t: *PxTransform, tanQSwingY: PxReal, tanQSwingZ: PxReal, active: bool) -> void #cpp_method;

        visualizeDoubleCone: (this: *PxConstraintVisualizer, t: *PxTransform, angle: PxReal, active: bool) -> void #cpp_method;

        visualizeLine: (this: *PxConstraintVisualizer, p0: *PxVec3, p1: *PxVec3, color: PxU32) -> void #cpp_method;
    }

    PxConstraintVisualizer_Destructor :: inline (this: *PxConstraintVisualizer, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    PxConstraintVisualizer_visualizeJointFrames :: inline (this: *PxConstraintVisualizer, parent: *PxTransform, child: *PxTransform) { this.vtable.visualizeJointFrames(this, parent, child); }

    PxConstraintVisualizer_visualizeLinearLimit :: inline (this: *PxConstraintVisualizer, t0: *PxTransform, t1: *PxTransform, value: PxReal, active: bool) { this.vtable.visualizeLinearLimit(this, t0, t1, value, active); }

    PxConstraintVisualizer_visualizeAngularLimit :: inline (this: *PxConstraintVisualizer, t0: *PxTransform, lower: PxReal, upper: PxReal, active: bool) { this.vtable.visualizeAngularLimit(this, t0, lower, upper, active); }

    PxConstraintVisualizer_visualizeLimitCone :: inline (this: *PxConstraintVisualizer, t: *PxTransform, tanQSwingY: PxReal, tanQSwingZ: PxReal, active: bool) { this.vtable.visualizeLimitCone(this, t, tanQSwingY, tanQSwingZ, active); }

    PxConstraintVisualizer_visualizeDoubleCone :: inline (this: *PxConstraintVisualizer, t: *PxTransform, angle: PxReal, active: bool) { this.vtable.visualizeDoubleCone(this, t, angle, active); }

    PxConstraintVisualizer_visualizeLine :: inline (this: *PxConstraintVisualizer, p0: *PxVec3, p1: *PxVec3, color: PxU32) { this.vtable.visualizeLine(this, p0, p1, color); }

    vtable :: (obj: *PxConstraintVisualizer) -> *PxConstraintVisualizer_VTable { return obj.vtable; }

    #run {if true then return;
        assert(size_of(PxConstraintVisualizer) == 8, "PxConstraintVisualizer has size % instead of 8", size_of(PxConstraintVisualizer));
    }

    /** solver constraint visualization function

    This function is called by the constraint post-solver framework to visualize the constraint

    \param[out] visualizer		The render buffer to render to
    \param[in] constantBlock	The constant data block
    \param[in] body0Transform	The center of mass frame of the first constrained body (the identity if the actor is static, or a NULL pointer was provided for it)
    \param[in] body1Transform	The center of mass frame of the second constrained body (the identity if the actor is static, or a NULL pointer was provided for it)
    \param[in] flags			The visualization flags (PxConstraintVisualizationFlag)

    @see PxRenderBuffer
    */
    PxConstraintVisualize :: #type (visualizer: *PxConstraintVisualizer, constantBlock: *void, body0Transform: *PxTransform, body1Transform: *PxTransform, flags: PxU32) -> void #c_call;

    PxPvdUpdateType :: struct {
        Enum :: enum s32 {
            CREATE_INSTANCE       :: 0;
            RELEASE_INSTANCE      :: 1;
            UPDATE_ALL_PROPERTIES :: 2;
            UPDATE_SIM_PROPERTIES :: 3;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxPvdUpdateType) == 1, "PxPvdUpdateType has size % instead of 1", size_of(PxPvdUpdateType));
    }

    /**

    \brief This class connects a custom constraint to the SDK

    This class connects a custom constraint to the SDK, and functions are called by the SDK
    to query the custom implementation for specific information to pass on to the application
    or inform the constraint when the application makes calls into the SDK which will update
    the custom constraint's internal implementation
    */
    PxConstraintConnector :: struct {
        vtable: *PxConstraintConnector_VTable;
    }
    PxConstraintConnector_VTable :: struct #type_info_none {
        prepareData: (this: *PxConstraintConnector) -> *void #cpp_method;

        updatePvdProperties: (this: *PxConstraintConnector, pvdConnection: *pvdsdk.PvdDataStream, c: *PxConstraint, updateType: PxPvdUpdateType.Enum) -> bool #cpp_method;

        onConstraintRelease: (this: *PxConstraintConnector) -> void #cpp_method;

        onComShift: (this: *PxConstraintConnector, actor: PxU32) -> void #cpp_method;

        onOriginShift: (this: *PxConstraintConnector, shift: *PxVec3) -> void #cpp_method;

        getExternalReference: (this: *PxConstraintConnector, typeID: *PxU32) -> *void #cpp_method;

        getSerializable: (this: *PxConstraintConnector) -> *PxBase #cpp_method;

        getPrep: (this: *PxConstraintConnector) -> PxConstraintSolverPrep #cpp_method;

        getConstantBlock: (this: *PxConstraintConnector) -> *void #cpp_method;

        Destructor: (this: *PxConstraintConnector, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxConstraintConnector_prepareData :: inline (this: *PxConstraintConnector) -> *void { return this.vtable.prepareData(this); }

    PxConstraintConnector_updatePvdProperties :: inline (this: *PxConstraintConnector, pvdConnection: *pvdsdk.PvdDataStream, c: *PxConstraint, updateType: PxPvdUpdateType.Enum) -> bool { return this.vtable.updatePvdProperties(this, pvdConnection, c, updateType); }

    PxConstraintConnector_onConstraintRelease :: inline (this: *PxConstraintConnector) { this.vtable.onConstraintRelease(this); }

    PxConstraintConnector_onComShift :: inline (this: *PxConstraintConnector, actor: PxU32) { this.vtable.onComShift(this, actor); }

    PxConstraintConnector_onOriginShift :: inline (this: *PxConstraintConnector, shift: *PxVec3) { this.vtable.onOriginShift(this, shift); }

    PxConstraintConnector_getExternalReference :: inline (this: *PxConstraintConnector, typeID: *PxU32) -> *void { return this.vtable.getExternalReference(this, typeID); }

    PxConstraintConnector_getSerializable :: inline (this: *PxConstraintConnector) -> *PxBase { return this.vtable.getSerializable(this); }

    PxConstraintConnector_getPrep :: inline (this: *PxConstraintConnector) -> PxConstraintSolverPrep { return this.vtable.getPrep(this); }

    PxConstraintConnector_getConstantBlock :: inline (this: *PxConstraintConnector) -> *void { return this.vtable.getConstantBlock(this); }

    PxConstraintConnector_Destructor :: inline (this: *PxConstraintConnector, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxConstraintConnector) -> *PxConstraintConnector_VTable { return obj.vtable; }

    #run {if true then return;
        assert(size_of(PxConstraintConnector) == 8, "PxConstraintConnector has size % instead of 8", size_of(PxConstraintConnector));
    }

    Gu :: struct {
        ContactPoint :: struct {
            normal:             PxVec3;

            /**
            \brief The separation of the shapes at the contact point.  A negative separation denotes a penetration.
            */
            separation:         PxReal;

            point:              PxVec3;

            /**
            \brief The max impulse permitted at this point
            */
            maxImpulse:         PxReal;

            targetVel:          PxVec3;

            /**
            \brief The static friction coefficient
            */
            staticFriction:     PxReal;

            /**
            \brief Material flags for this contact (eDISABLE_FRICTION, eDISABLE_STRONG_FRICTION). @see PxMaterialFlag
            */
            materialFlags:      PxU8;

            /**
            \brief internal structure used for internal use only
            */
            forInternalUse:     PxU16;

            /**
            \brief The surface index of shape 1 at the contact point.  This is used to identify the surface material.

            \note This field is only supported by triangle meshes and heightfields, else it will be set to PXC_CONTACT_NO_FACE_INDEX.
            \note This value must be directly after internalFaceIndex0 in memory
            */
            internalFaceIndex1: PxU32;

            /**
            \brief The dynamic friction coefficient
            */
            dynamicFriction:    PxReal;

            /**
            \brief The restitution coefficient
            */
            restitution:        PxReal;
        }
        #run {if true then return;
            instance: ContactPoint;
            assert(((cast(*void)(*instance.normal)) - cast(*void)(*instance)) == 0, "ContactPoint.normal has unexpected offset % instead of 0", ((cast(*void)(*instance.normal)) - cast(*void)(*instance)));
            assert(size_of(type_of(ContactPoint.normal)) == 12, "ContactPoint.normal has unexpected size % instead of 12", size_of(type_of(ContactPoint.normal)));
            assert(((cast(*void)(*instance.separation)) - cast(*void)(*instance)) == 12, "ContactPoint.separation has unexpected offset % instead of 12", ((cast(*void)(*instance.separation)) - cast(*void)(*instance)));
            assert(size_of(type_of(ContactPoint.separation)) == 4, "ContactPoint.separation has unexpected size % instead of 4", size_of(type_of(ContactPoint.separation)));
            assert(((cast(*void)(*instance.point)) - cast(*void)(*instance)) == 16, "ContactPoint.point has unexpected offset % instead of 16", ((cast(*void)(*instance.point)) - cast(*void)(*instance)));
            assert(size_of(type_of(ContactPoint.point)) == 12, "ContactPoint.point has unexpected size % instead of 12", size_of(type_of(ContactPoint.point)));
            assert(((cast(*void)(*instance.maxImpulse)) - cast(*void)(*instance)) == 28, "ContactPoint.maxImpulse has unexpected offset % instead of 28", ((cast(*void)(*instance.maxImpulse)) - cast(*void)(*instance)));
            assert(size_of(type_of(ContactPoint.maxImpulse)) == 4, "ContactPoint.maxImpulse has unexpected size % instead of 4", size_of(type_of(ContactPoint.maxImpulse)));
            assert(((cast(*void)(*instance.targetVel)) - cast(*void)(*instance)) == 32, "ContactPoint.targetVel has unexpected offset % instead of 32", ((cast(*void)(*instance.targetVel)) - cast(*void)(*instance)));
            assert(size_of(type_of(ContactPoint.targetVel)) == 12, "ContactPoint.targetVel has unexpected size % instead of 12", size_of(type_of(ContactPoint.targetVel)));
            assert(((cast(*void)(*instance.staticFriction)) - cast(*void)(*instance)) == 44, "ContactPoint.staticFriction has unexpected offset % instead of 44", ((cast(*void)(*instance.staticFriction)) - cast(*void)(*instance)));
            assert(size_of(type_of(ContactPoint.staticFriction)) == 4, "ContactPoint.staticFriction has unexpected size % instead of 4", size_of(type_of(ContactPoint.staticFriction)));
            assert(((cast(*void)(*instance.materialFlags)) - cast(*void)(*instance)) == 48, "ContactPoint.materialFlags has unexpected offset % instead of 48", ((cast(*void)(*instance.materialFlags)) - cast(*void)(*instance)));
            assert(size_of(type_of(ContactPoint.materialFlags)) == 1, "ContactPoint.materialFlags has unexpected size % instead of 1", size_of(type_of(ContactPoint.materialFlags)));
            assert(((cast(*void)(*instance.forInternalUse)) - cast(*void)(*instance)) == 50, "ContactPoint.forInternalUse has unexpected offset % instead of 50", ((cast(*void)(*instance.forInternalUse)) - cast(*void)(*instance)));
            assert(size_of(type_of(ContactPoint.forInternalUse)) == 2, "ContactPoint.forInternalUse has unexpected size % instead of 2", size_of(type_of(ContactPoint.forInternalUse)));
            assert(((cast(*void)(*instance.internalFaceIndex1)) - cast(*void)(*instance)) == 52, "ContactPoint.internalFaceIndex1 has unexpected offset % instead of 52", ((cast(*void)(*instance.internalFaceIndex1)) - cast(*void)(*instance)));
            assert(size_of(type_of(ContactPoint.internalFaceIndex1)) == 4, "ContactPoint.internalFaceIndex1 has unexpected size % instead of 4", size_of(type_of(ContactPoint.internalFaceIndex1)));
            assert(((cast(*void)(*instance.dynamicFriction)) - cast(*void)(*instance)) == 56, "ContactPoint.dynamicFriction has unexpected offset % instead of 56", ((cast(*void)(*instance.dynamicFriction)) - cast(*void)(*instance)));
            assert(size_of(type_of(ContactPoint.dynamicFriction)) == 4, "ContactPoint.dynamicFriction has unexpected size % instead of 4", size_of(type_of(ContactPoint.dynamicFriction)));
            assert(((cast(*void)(*instance.restitution)) - cast(*void)(*instance)) == 60, "ContactPoint.restitution has unexpected offset % instead of 60", ((cast(*void)(*instance.restitution)) - cast(*void)(*instance)));
            assert(size_of(type_of(ContactPoint.restitution)) == 4, "ContactPoint.restitution has unexpected size % instead of 4", size_of(type_of(ContactPoint.restitution)));
            assert(size_of(ContactPoint) == 64, "ContactPoint has size % instead of 64", size_of(ContactPoint));
        }
    }

    Dy :: struct {
        ArticulationV :: struct {}
        ArticulationLinkHandle :: size_t;
    }

    Sc :: struct {
        ShapeInteraction :: struct {}
    }

    PxSolverBody :: struct {
        linearVelocity:            PxVec3; //!< Delta linear velocity computed by the solver
        maxSolverNormalProgress:   PxU16; //!< Progress counter used by constraint batching and parallel island solver.
        maxSolverFrictionProgress: PxU16; //!< Progress counter used by constraint batching and parallel island solver.

        angularState:              PxVec3; //!< Delta angular velocity state computed by the solver.

        solverProgress:            PxU32; //!< Progress counter used by constraint batching and parallel island solver

        Constructor :: (this: *PxSolverBody) -> void #cpp_method #foreign physx_lib "??0PxSolverBody@physx@@QEAA@XZ";
    }
    #run {if true then return;
        instance: PxSolverBody;
        assert(((cast(*void)(*instance.linearVelocity)) - cast(*void)(*instance)) == 0, "PxSolverBody.linearVelocity has unexpected offset % instead of 0", ((cast(*void)(*instance.linearVelocity)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverBody.linearVelocity)) == 12, "PxSolverBody.linearVelocity has unexpected size % instead of 12", size_of(type_of(PxSolverBody.linearVelocity)));
        assert(((cast(*void)(*instance.maxSolverNormalProgress)) - cast(*void)(*instance)) == 12, "PxSolverBody.maxSolverNormalProgress has unexpected offset % instead of 12", ((cast(*void)(*instance.maxSolverNormalProgress)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverBody.maxSolverNormalProgress)) == 2, "PxSolverBody.maxSolverNormalProgress has unexpected size % instead of 2", size_of(type_of(PxSolverBody.maxSolverNormalProgress)));
        assert(((cast(*void)(*instance.maxSolverFrictionProgress)) - cast(*void)(*instance)) == 14, "PxSolverBody.maxSolverFrictionProgress has unexpected offset % instead of 14", ((cast(*void)(*instance.maxSolverFrictionProgress)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverBody.maxSolverFrictionProgress)) == 2, "PxSolverBody.maxSolverFrictionProgress has unexpected size % instead of 2", size_of(type_of(PxSolverBody.maxSolverFrictionProgress)));
        assert(((cast(*void)(*instance.angularState)) - cast(*void)(*instance)) == 16, "PxSolverBody.angularState has unexpected offset % instead of 16", ((cast(*void)(*instance.angularState)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverBody.angularState)) == 12, "PxSolverBody.angularState has unexpected size % instead of 12", size_of(type_of(PxSolverBody.angularState)));
        assert(((cast(*void)(*instance.solverProgress)) - cast(*void)(*instance)) == 28, "PxSolverBody.solverProgress has unexpected offset % instead of 28", ((cast(*void)(*instance.solverProgress)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverBody.solverProgress)) == 4, "PxSolverBody.solverProgress has unexpected size % instead of 4", size_of(type_of(PxSolverBody.solverProgress)));
        assert(size_of(PxSolverBody) == 32, "PxSolverBody has size % instead of 32", size_of(PxSolverBody));
    }

    PxCompileTimeAssert_Dummy1 :: [1] u8;

    PxSolverBodyData :: struct {
        linearVelocity:    PxVec3;
        invMass:           PxReal; //!< 16 inverse mass
        angularVelocity:   PxVec3; //!< 28 Pre-solver angular velocity
        reportThreshold:   PxReal; //!< 32 contact force threshold
        sqrtInvInertia:    PxMat33; //!< 68 inverse inertia in world space
        penBiasClamp:      PxReal; //!< 72 the penetration bias clamp
        nodeIndex:         PxU32; //!< 76 the node idx of this solverBodyData. Used by solver to reference between solver bodies and island bodies. Not required by immediate mode
        maxContactImpulse: PxReal; //!< 80 the max contact impulse
        body2World:        PxTransform; //!< 108 the body's transform
        lockFlags:         PxU16; //!< 110 lock flags
        pad:               PxU16; //!< 112 pad

        projectVelocity :: (this: *PxSolverBodyData, lin: *PxVec3, ang: *PxVec3) -> PxReal #cpp_method #foreign physx_lib "?projectVelocity@PxSolverBodyData@physx@@QEBAMAEBVPxVec3@2@0@Z";
        projectVelocity :: (this: *PxSolverBodyData, lin: PxVec3, ang: PxVec3) -> PxReal #no_context {
            return projectVelocity(this, *lin, *ang);
        }
    }
    #run {if true then return;
        instance: PxSolverBodyData;
        assert(((cast(*void)(*instance.linearVelocity)) - cast(*void)(*instance)) == 0, "PxSolverBodyData.linearVelocity has unexpected offset % instead of 0", ((cast(*void)(*instance.linearVelocity)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverBodyData.linearVelocity)) == 12, "PxSolverBodyData.linearVelocity has unexpected size % instead of 12", size_of(type_of(PxSolverBodyData.linearVelocity)));
        assert(((cast(*void)(*instance.invMass)) - cast(*void)(*instance)) == 12, "PxSolverBodyData.invMass has unexpected offset % instead of 12", ((cast(*void)(*instance.invMass)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverBodyData.invMass)) == 4, "PxSolverBodyData.invMass has unexpected size % instead of 4", size_of(type_of(PxSolverBodyData.invMass)));
        assert(((cast(*void)(*instance.angularVelocity)) - cast(*void)(*instance)) == 16, "PxSolverBodyData.angularVelocity has unexpected offset % instead of 16", ((cast(*void)(*instance.angularVelocity)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverBodyData.angularVelocity)) == 12, "PxSolverBodyData.angularVelocity has unexpected size % instead of 12", size_of(type_of(PxSolverBodyData.angularVelocity)));
        assert(((cast(*void)(*instance.reportThreshold)) - cast(*void)(*instance)) == 28, "PxSolverBodyData.reportThreshold has unexpected offset % instead of 28", ((cast(*void)(*instance.reportThreshold)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverBodyData.reportThreshold)) == 4, "PxSolverBodyData.reportThreshold has unexpected size % instead of 4", size_of(type_of(PxSolverBodyData.reportThreshold)));
        assert(((cast(*void)(*instance.sqrtInvInertia)) - cast(*void)(*instance)) == 32, "PxSolverBodyData.sqrtInvInertia has unexpected offset % instead of 32", ((cast(*void)(*instance.sqrtInvInertia)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverBodyData.sqrtInvInertia)) == 36, "PxSolverBodyData.sqrtInvInertia has unexpected size % instead of 36", size_of(type_of(PxSolverBodyData.sqrtInvInertia)));
        assert(((cast(*void)(*instance.penBiasClamp)) - cast(*void)(*instance)) == 68, "PxSolverBodyData.penBiasClamp has unexpected offset % instead of 68", ((cast(*void)(*instance.penBiasClamp)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverBodyData.penBiasClamp)) == 4, "PxSolverBodyData.penBiasClamp has unexpected size % instead of 4", size_of(type_of(PxSolverBodyData.penBiasClamp)));
        assert(((cast(*void)(*instance.nodeIndex)) - cast(*void)(*instance)) == 72, "PxSolverBodyData.nodeIndex has unexpected offset % instead of 72", ((cast(*void)(*instance.nodeIndex)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverBodyData.nodeIndex)) == 4, "PxSolverBodyData.nodeIndex has unexpected size % instead of 4", size_of(type_of(PxSolverBodyData.nodeIndex)));
        assert(((cast(*void)(*instance.maxContactImpulse)) - cast(*void)(*instance)) == 76, "PxSolverBodyData.maxContactImpulse has unexpected offset % instead of 76", ((cast(*void)(*instance.maxContactImpulse)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverBodyData.maxContactImpulse)) == 4, "PxSolverBodyData.maxContactImpulse has unexpected size % instead of 4", size_of(type_of(PxSolverBodyData.maxContactImpulse)));
        assert(((cast(*void)(*instance.body2World)) - cast(*void)(*instance)) == 80, "PxSolverBodyData.body2World has unexpected offset % instead of 80", ((cast(*void)(*instance.body2World)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverBodyData.body2World)) == 28, "PxSolverBodyData.body2World has unexpected size % instead of 28", size_of(type_of(PxSolverBodyData.body2World)));
        assert(((cast(*void)(*instance.lockFlags)) - cast(*void)(*instance)) == 108, "PxSolverBodyData.lockFlags has unexpected offset % instead of 108", ((cast(*void)(*instance.lockFlags)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverBodyData.lockFlags)) == 2, "PxSolverBodyData.lockFlags has unexpected size % instead of 2", size_of(type_of(PxSolverBodyData.lockFlags)));
        assert(((cast(*void)(*instance.pad)) - cast(*void)(*instance)) == 110, "PxSolverBodyData.pad has unexpected offset % instead of 110", ((cast(*void)(*instance.pad)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverBodyData.pad)) == 2, "PxSolverBodyData.pad has unexpected size % instead of 2", size_of(type_of(PxSolverBodyData.pad)));
        assert(size_of(PxSolverBodyData) == 112, "PxSolverBodyData has size % instead of 112", size_of(PxSolverBodyData));
    }

    //----------------------------------
    /*
    * A header that defines the size of a specific batch of constraints (of same type and without dependencies)
    */
    PxConstraintBatchHeader :: struct {
        startIndex:     PxU32; //!< Start index for this batch
        stride:         PxU16; //!< Number of constraints in this batch (range: 1-4)
        constraintType: PxU16; //!< The type of constraint this batch references
    }
    #run {if true then return;
        instance: PxConstraintBatchHeader;
        assert(((cast(*void)(*instance.startIndex)) - cast(*void)(*instance)) == 0, "PxConstraintBatchHeader.startIndex has unexpected offset % instead of 0", ((cast(*void)(*instance.startIndex)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxConstraintBatchHeader.startIndex)) == 4, "PxConstraintBatchHeader.startIndex has unexpected size % instead of 4", size_of(type_of(PxConstraintBatchHeader.startIndex)));
        assert(((cast(*void)(*instance.stride)) - cast(*void)(*instance)) == 4, "PxConstraintBatchHeader.stride has unexpected offset % instead of 4", ((cast(*void)(*instance.stride)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxConstraintBatchHeader.stride)) == 2, "PxConstraintBatchHeader.stride has unexpected size % instead of 2", size_of(type_of(PxConstraintBatchHeader.stride)));
        assert(((cast(*void)(*instance.constraintType)) - cast(*void)(*instance)) == 6, "PxConstraintBatchHeader.constraintType has unexpected offset % instead of 6", ((cast(*void)(*instance.constraintType)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxConstraintBatchHeader.constraintType)) == 2, "PxConstraintBatchHeader.constraintType has unexpected size % instead of 2", size_of(type_of(PxConstraintBatchHeader.constraintType)));
        assert(size_of(PxConstraintBatchHeader) == 8, "PxConstraintBatchHeader has size % instead of 8", size_of(PxConstraintBatchHeader));
    }

    PxSolverConstraintDesc :: struct {
        ConstraintType :: enum s32 {
            CONTACT_CONSTRAINT :: 0;
            JOINT_CONSTRAINT   :: 1;

            eCONTACT_CONSTRAINT :: CONTACT_CONSTRAINT;
            eJOINT_CONSTRAINT   :: JOINT_CONSTRAINT;
        }

        union {
            bodyA:         *PxSolverBody; //!< bodyA pointer
            tgsBodyA:      *PxTGSSolverBodyVel; //!< bodyA pointer
            articulationA: *Dy.ArticulationV; //!< Articulation pointer for body A
        }

        union {
            bodyB:         *PxSolverBody; //!< BodyB pointer
            tgsBodyB:      *PxTGSSolverBodyVel; //!< BodyB pointer
            articulationB: *Dy.ArticulationV; //!< Articulation pointer for body B
        }

        linkIndexA:             PxU16; //!< Link index defining which link in Articulation A this constraint affects. If not an articulation, must be NO_LINK
        linkIndexB:             PxU16; //!< Link index defining which link in Articulation B this constraint affects. If not an articulation, must be NO_LINK.
        bodyADataIndex:         PxU32; //!< Body A's index into the SolverBodyData array
        bodyBDataIndex:         PxU32; //!< Body B's index into the SolverBodyData array
        writeBackLengthOver4:   PxU16; //!< writeBackLength/4, max writeback length is 256K, allows PxSolverConstraintDesc to fit in 32 bytes
        constraintLengthOver16: PxU16; //!< constraintLength/16, max constraint length is 1MB, allows PxSolverConstraintDesc to fit in 32 bytes
        constraint:             *PxU8; //!< Pointer to the constraint rows to be solved
        writeBack:              *void; //!< Pointer to the writeback structure results for this given constraint are to be written to
    }
    #run {if true then return;
        instance: PxSolverConstraintDesc;
        assert(((cast(*void)(*instance.linkIndexA)) - cast(*void)(*instance)) == 16, "PxSolverConstraintDesc.linkIndexA has unexpected offset % instead of 16", ((cast(*void)(*instance.linkIndexA)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverConstraintDesc.linkIndexA)) == 2, "PxSolverConstraintDesc.linkIndexA has unexpected size % instead of 2", size_of(type_of(PxSolverConstraintDesc.linkIndexA)));
        assert(((cast(*void)(*instance.linkIndexB)) - cast(*void)(*instance)) == 18, "PxSolverConstraintDesc.linkIndexB has unexpected offset % instead of 18", ((cast(*void)(*instance.linkIndexB)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverConstraintDesc.linkIndexB)) == 2, "PxSolverConstraintDesc.linkIndexB has unexpected size % instead of 2", size_of(type_of(PxSolverConstraintDesc.linkIndexB)));
        assert(((cast(*void)(*instance.bodyADataIndex)) - cast(*void)(*instance)) == 20, "PxSolverConstraintDesc.bodyADataIndex has unexpected offset % instead of 20", ((cast(*void)(*instance.bodyADataIndex)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverConstraintDesc.bodyADataIndex)) == 4, "PxSolverConstraintDesc.bodyADataIndex has unexpected size % instead of 4", size_of(type_of(PxSolverConstraintDesc.bodyADataIndex)));
        assert(((cast(*void)(*instance.bodyBDataIndex)) - cast(*void)(*instance)) == 24, "PxSolverConstraintDesc.bodyBDataIndex has unexpected offset % instead of 24", ((cast(*void)(*instance.bodyBDataIndex)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverConstraintDesc.bodyBDataIndex)) == 4, "PxSolverConstraintDesc.bodyBDataIndex has unexpected size % instead of 4", size_of(type_of(PxSolverConstraintDesc.bodyBDataIndex)));
        assert(((cast(*void)(*instance.writeBackLengthOver4)) - cast(*void)(*instance)) == 28, "PxSolverConstraintDesc.writeBackLengthOver4 has unexpected offset % instead of 28", ((cast(*void)(*instance.writeBackLengthOver4)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverConstraintDesc.writeBackLengthOver4)) == 2, "PxSolverConstraintDesc.writeBackLengthOver4 has unexpected size % instead of 2", size_of(type_of(PxSolverConstraintDesc.writeBackLengthOver4)));
        assert(((cast(*void)(*instance.constraintLengthOver16)) - cast(*void)(*instance)) == 30, "PxSolverConstraintDesc.constraintLengthOver16 has unexpected offset % instead of 30", ((cast(*void)(*instance.constraintLengthOver16)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverConstraintDesc.constraintLengthOver16)) == 2, "PxSolverConstraintDesc.constraintLengthOver16 has unexpected size % instead of 2", size_of(type_of(PxSolverConstraintDesc.constraintLengthOver16)));
        assert(((cast(*void)(*instance.constraint)) - cast(*void)(*instance)) == 32, "PxSolverConstraintDesc.constraint has unexpected offset % instead of 32", ((cast(*void)(*instance.constraint)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverConstraintDesc.constraint)) == 8, "PxSolverConstraintDesc.constraint has unexpected size % instead of 8", size_of(type_of(PxSolverConstraintDesc.constraint)));
        assert(((cast(*void)(*instance.writeBack)) - cast(*void)(*instance)) == 40, "PxSolverConstraintDesc.writeBack has unexpected offset % instead of 40", ((cast(*void)(*instance.writeBack)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverConstraintDesc.writeBack)) == 8, "PxSolverConstraintDesc.writeBack has unexpected size % instead of 8", size_of(type_of(PxSolverConstraintDesc.writeBack)));
        assert(size_of(PxSolverConstraintDesc) == 48, "PxSolverConstraintDesc has size % instead of 48", size_of(PxSolverConstraintDesc));
    }

    PxSolverConstraintPrepDescBase :: struct {
        BodyState :: enum s32 {
            DYNAMIC_BODY   :: 1;
            STATIC_BODY    :: 2;
            KINEMATIC_BODY :: 4;
            ARTICULATION   :: 8;

            eDYNAMIC_BODY   :: DYNAMIC_BODY;
            eSTATIC_BODY    :: STATIC_BODY;
            eKINEMATIC_BODY :: KINEMATIC_BODY;
            eARTICULATION   :: ARTICULATION;
        }

        invMassScales: PxConstraintInvMassScale; //!< In: The local mass scaling for this pair.

        desc:          *PxSolverConstraintDesc; //!< Output: The PxSolverConstraintDesc filled in by contact prep

        body0:         *PxSolverBody; //!< In: The first body. Stores velocity information. Unused unless contact involves articulations.
        body1:         *PxSolverBody; //!< In: The second body. Stores velocity information. Unused unless contact involves articulations.

        data0:         *PxSolverBodyData; //!< In: The first PxSolverBodyData. Stores mass and miscellaneous information for the first body.
        data1:         *PxSolverBodyData; //!< In: The second PxSolverBodyData. Stores mass and miscellaneous information for the second body

        bodyFrame0:    PxTransform; //!< In: The world-space transform of the first body.
        bodyFrame1:    PxTransform; //!< In: The world-space transform of the second body.

        bodyState0:    BodyState; //!< In: Defines what kind of actor the first body is
        bodyState1:    BodyState; //!< In: Defines what kind of actor the second body is
    }
    #run {if true then return;
        instance: PxSolverConstraintPrepDescBase;
        assert(((cast(*void)(*instance.invMassScales)) - cast(*void)(*instance)) == 0, "PxSolverConstraintPrepDescBase.invMassScales has unexpected offset % instead of 0", ((cast(*void)(*instance.invMassScales)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverConstraintPrepDescBase.invMassScales)) == 16, "PxSolverConstraintPrepDescBase.invMassScales has unexpected size % instead of 16", size_of(type_of(PxSolverConstraintPrepDescBase.invMassScales)));
        assert(((cast(*void)(*instance.desc)) - cast(*void)(*instance)) == 16, "PxSolverConstraintPrepDescBase.desc has unexpected offset % instead of 16", ((cast(*void)(*instance.desc)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverConstraintPrepDescBase.desc)) == 8, "PxSolverConstraintPrepDescBase.desc has unexpected size % instead of 8", size_of(type_of(PxSolverConstraintPrepDescBase.desc)));
        assert(((cast(*void)(*instance.body0)) - cast(*void)(*instance)) == 24, "PxSolverConstraintPrepDescBase.body0 has unexpected offset % instead of 24", ((cast(*void)(*instance.body0)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverConstraintPrepDescBase.body0)) == 8, "PxSolverConstraintPrepDescBase.body0 has unexpected size % instead of 8", size_of(type_of(PxSolverConstraintPrepDescBase.body0)));
        assert(((cast(*void)(*instance.body1)) - cast(*void)(*instance)) == 32, "PxSolverConstraintPrepDescBase.body1 has unexpected offset % instead of 32", ((cast(*void)(*instance.body1)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverConstraintPrepDescBase.body1)) == 8, "PxSolverConstraintPrepDescBase.body1 has unexpected size % instead of 8", size_of(type_of(PxSolverConstraintPrepDescBase.body1)));
        assert(((cast(*void)(*instance.data0)) - cast(*void)(*instance)) == 40, "PxSolverConstraintPrepDescBase.data0 has unexpected offset % instead of 40", ((cast(*void)(*instance.data0)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverConstraintPrepDescBase.data0)) == 8, "PxSolverConstraintPrepDescBase.data0 has unexpected size % instead of 8", size_of(type_of(PxSolverConstraintPrepDescBase.data0)));
        assert(((cast(*void)(*instance.data1)) - cast(*void)(*instance)) == 48, "PxSolverConstraintPrepDescBase.data1 has unexpected offset % instead of 48", ((cast(*void)(*instance.data1)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverConstraintPrepDescBase.data1)) == 8, "PxSolverConstraintPrepDescBase.data1 has unexpected size % instead of 8", size_of(type_of(PxSolverConstraintPrepDescBase.data1)));
        assert(((cast(*void)(*instance.bodyFrame0)) - cast(*void)(*instance)) == 56, "PxSolverConstraintPrepDescBase.bodyFrame0 has unexpected offset % instead of 56", ((cast(*void)(*instance.bodyFrame0)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverConstraintPrepDescBase.bodyFrame0)) == 28, "PxSolverConstraintPrepDescBase.bodyFrame0 has unexpected size % instead of 28", size_of(type_of(PxSolverConstraintPrepDescBase.bodyFrame0)));
        assert(((cast(*void)(*instance.bodyFrame1)) - cast(*void)(*instance)) == 84, "PxSolverConstraintPrepDescBase.bodyFrame1 has unexpected offset % instead of 84", ((cast(*void)(*instance.bodyFrame1)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverConstraintPrepDescBase.bodyFrame1)) == 28, "PxSolverConstraintPrepDescBase.bodyFrame1 has unexpected size % instead of 28", size_of(type_of(PxSolverConstraintPrepDescBase.bodyFrame1)));
        assert(((cast(*void)(*instance.bodyState0)) - cast(*void)(*instance)) == 112, "PxSolverConstraintPrepDescBase.bodyState0 has unexpected offset % instead of 112", ((cast(*void)(*instance.bodyState0)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverConstraintPrepDescBase.bodyState0)) == 4, "PxSolverConstraintPrepDescBase.bodyState0 has unexpected size % instead of 4", size_of(type_of(PxSolverConstraintPrepDescBase.bodyState0)));
        assert(((cast(*void)(*instance.bodyState1)) - cast(*void)(*instance)) == 116, "PxSolverConstraintPrepDescBase.bodyState1 has unexpected offset % instead of 116", ((cast(*void)(*instance.bodyState1)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverConstraintPrepDescBase.bodyState1)) == 4, "PxSolverConstraintPrepDescBase.bodyState1 has unexpected size % instead of 4", size_of(type_of(PxSolverConstraintPrepDescBase.bodyState1)));
        assert(size_of(PxSolverConstraintPrepDescBase) == 128, "PxSolverConstraintPrepDescBase has size % instead of 128", size_of(PxSolverConstraintPrepDescBase));
    }

    PxSolverConstraintPrepDesc :: struct {
        #as using pxsolverconstraintprepdescbase: PxSolverConstraintPrepDescBase;

        rows:                 *Px1DConstraint;
        numRows:              PxU32; //!< The number of rows

        linBreakForce:        PxReal; //!< Break forces
        angBreakForce:        PxReal; //!< Break forces
        minResponseThreshold: PxReal; //!< The minimum response threshold
        writeback:            *void; //!< Pointer to constraint writeback structure. Reports back joint breaking. If not required, set to NULL.
        disablePreprocessing: bool; //!< Disable joint pre-processing. Pre-processing can improve stability but under certain circumstances, e.g. when some invInertia rows are zero/almost zero, can cause instabilities.
        improvedSlerp:        bool; //!< Use improved slerp model
        driveLimitsAreForces: bool; //!< Indicates whether drive limits are forces
        extendedLimits:       bool; //!< Indicates whether we want to use extended limits

        body0WorldOffset:     PxVec3; //!< Body0 world offset
    }
    #run {if true then return;
        assert(size_of(type_of(PxSolverConstraintPrepDesc.pxsolverconstraintprepdescbase)) == 128, "PxSolverConstraintPrepDesc.pxsolverconstraintprepdescbase has unexpected size % instead of 128", size_of(type_of(PxSolverConstraintPrepDesc.pxsolverconstraintprepdescbase)));
        instance: PxSolverConstraintPrepDesc;
        assert(((cast(*void)(*instance.rows)) - cast(*void)(*instance)) == 128, "PxSolverConstraintPrepDesc.rows has unexpected offset % instead of 128", ((cast(*void)(*instance.rows)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverConstraintPrepDesc.rows)) == 8, "PxSolverConstraintPrepDesc.rows has unexpected size % instead of 8", size_of(type_of(PxSolverConstraintPrepDesc.rows)));
        assert(((cast(*void)(*instance.numRows)) - cast(*void)(*instance)) == 136, "PxSolverConstraintPrepDesc.numRows has unexpected offset % instead of 136", ((cast(*void)(*instance.numRows)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverConstraintPrepDesc.numRows)) == 4, "PxSolverConstraintPrepDesc.numRows has unexpected size % instead of 4", size_of(type_of(PxSolverConstraintPrepDesc.numRows)));
        assert(((cast(*void)(*instance.linBreakForce)) - cast(*void)(*instance)) == 140, "PxSolverConstraintPrepDesc.linBreakForce has unexpected offset % instead of 140", ((cast(*void)(*instance.linBreakForce)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverConstraintPrepDesc.linBreakForce)) == 4, "PxSolverConstraintPrepDesc.linBreakForce has unexpected size % instead of 4", size_of(type_of(PxSolverConstraintPrepDesc.linBreakForce)));
        assert(((cast(*void)(*instance.angBreakForce)) - cast(*void)(*instance)) == 144, "PxSolverConstraintPrepDesc.angBreakForce has unexpected offset % instead of 144", ((cast(*void)(*instance.angBreakForce)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverConstraintPrepDesc.angBreakForce)) == 4, "PxSolverConstraintPrepDesc.angBreakForce has unexpected size % instead of 4", size_of(type_of(PxSolverConstraintPrepDesc.angBreakForce)));
        assert(((cast(*void)(*instance.minResponseThreshold)) - cast(*void)(*instance)) == 148, "PxSolverConstraintPrepDesc.minResponseThreshold has unexpected offset % instead of 148", ((cast(*void)(*instance.minResponseThreshold)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverConstraintPrepDesc.minResponseThreshold)) == 4, "PxSolverConstraintPrepDesc.minResponseThreshold has unexpected size % instead of 4", size_of(type_of(PxSolverConstraintPrepDesc.minResponseThreshold)));
        assert(((cast(*void)(*instance.writeback)) - cast(*void)(*instance)) == 152, "PxSolverConstraintPrepDesc.writeback has unexpected offset % instead of 152", ((cast(*void)(*instance.writeback)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverConstraintPrepDesc.writeback)) == 8, "PxSolverConstraintPrepDesc.writeback has unexpected size % instead of 8", size_of(type_of(PxSolverConstraintPrepDesc.writeback)));
        assert(((cast(*void)(*instance.disablePreprocessing)) - cast(*void)(*instance)) == 160, "PxSolverConstraintPrepDesc.disablePreprocessing has unexpected offset % instead of 160", ((cast(*void)(*instance.disablePreprocessing)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverConstraintPrepDesc.disablePreprocessing)) == 1, "PxSolverConstraintPrepDesc.disablePreprocessing has unexpected size % instead of 1", size_of(type_of(PxSolverConstraintPrepDesc.disablePreprocessing)));
        assert(((cast(*void)(*instance.improvedSlerp)) - cast(*void)(*instance)) == 161, "PxSolverConstraintPrepDesc.improvedSlerp has unexpected offset % instead of 161", ((cast(*void)(*instance.improvedSlerp)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverConstraintPrepDesc.improvedSlerp)) == 1, "PxSolverConstraintPrepDesc.improvedSlerp has unexpected size % instead of 1", size_of(type_of(PxSolverConstraintPrepDesc.improvedSlerp)));
        assert(((cast(*void)(*instance.driveLimitsAreForces)) - cast(*void)(*instance)) == 162, "PxSolverConstraintPrepDesc.driveLimitsAreForces has unexpected offset % instead of 162", ((cast(*void)(*instance.driveLimitsAreForces)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverConstraintPrepDesc.driveLimitsAreForces)) == 1, "PxSolverConstraintPrepDesc.driveLimitsAreForces has unexpected size % instead of 1", size_of(type_of(PxSolverConstraintPrepDesc.driveLimitsAreForces)));
        assert(((cast(*void)(*instance.extendedLimits)) - cast(*void)(*instance)) == 163, "PxSolverConstraintPrepDesc.extendedLimits has unexpected offset % instead of 163", ((cast(*void)(*instance.extendedLimits)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverConstraintPrepDesc.extendedLimits)) == 1, "PxSolverConstraintPrepDesc.extendedLimits has unexpected size % instead of 1", size_of(type_of(PxSolverConstraintPrepDesc.extendedLimits)));
        assert(((cast(*void)(*instance.body0WorldOffset)) - cast(*void)(*instance)) == 164, "PxSolverConstraintPrepDesc.body0WorldOffset has unexpected offset % instead of 164", ((cast(*void)(*instance.body0WorldOffset)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverConstraintPrepDesc.body0WorldOffset)) == 12, "PxSolverConstraintPrepDesc.body0WorldOffset has unexpected size % instead of 12", size_of(type_of(PxSolverConstraintPrepDesc.body0WorldOffset)));
        assert(size_of(PxSolverConstraintPrepDesc) == 176, "PxSolverConstraintPrepDesc has size % instead of 176", size_of(PxSolverConstraintPrepDesc));
    }

    PxSolverContactDesc :: struct {
        #as using pxsolverconstraintprepdescbase: PxSolverConstraintPrepDescBase;

        shapeInteraction:        *Sc.ShapeInteraction;
        contacts:                *Gu.ContactPoint; //!< The start of the contacts for this pair
        numContacts:             PxU32; //!< The total number of contacs this pair references.

        hasMaxImpulse:           bool; //!< Defines whether this pairs has maxImpulses clamping enabled
        disableStrongFriction:   bool; //!< Defines whether this pair disables strong friction (sticky friction correlation)
        hasForceThresholds:      bool; //!< Defines whether this pair requires force thresholds

        restDistance:            PxReal; //!< A distance at which the solver should aim to hold the bodies separated. Default is 0
        maxCCDSeparation:        PxReal; //!< A distance used to configure speculative CCD behavior. Default is PX_MAX_F32. Set internally in PhysX for bodies with eENABLE_SPECULATIVE_CCD on. Do not set directly!

        frictionPtr:             *PxU8; //!< InOut: Friction patch correlation data. Set each frame by solver. Can be retained for improved behaviour or discarded each frame.
        frictionCount:           PxU8; //!< The total number of friction patches in this pair

        contactForces:           *PxReal; //!< Out: A buffer for the solver to write applied contact forces to.

        startFrictionPatchIndex: PxU32; //!< Start index of friction patch in the correlation buffer. Set by friction correlation
        numFrictionPatches:      PxU32; //!< Total number of friction patches in this pair. Set by friction correlation

        startContactPatchIndex:  PxU32; //!< The start index of this pair's contact patches in the correlation buffer. For internal use only
        numContactPatches:       PxU16; //!< Total number of contact patches.
        axisConstraintCount:     PxU16; //!< Axis constraint count. Defines how many constraint rows this pair has produced. Useful for statistical purposes.

        pad:                     [8] PxU8;
    }
    #run {if true then return;
        assert(size_of(type_of(PxSolverContactDesc.pxsolverconstraintprepdescbase)) == 128, "PxSolverContactDesc.pxsolverconstraintprepdescbase has unexpected size % instead of 128", size_of(type_of(PxSolverContactDesc.pxsolverconstraintprepdescbase)));
        instance: PxSolverContactDesc;
        assert(((cast(*void)(*instance.shapeInteraction)) - cast(*void)(*instance)) == 128, "PxSolverContactDesc.shapeInteraction has unexpected offset % instead of 128", ((cast(*void)(*instance.shapeInteraction)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverContactDesc.shapeInteraction)) == 8, "PxSolverContactDesc.shapeInteraction has unexpected size % instead of 8", size_of(type_of(PxSolverContactDesc.shapeInteraction)));
        assert(((cast(*void)(*instance.contacts)) - cast(*void)(*instance)) == 136, "PxSolverContactDesc.contacts has unexpected offset % instead of 136", ((cast(*void)(*instance.contacts)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverContactDesc.contacts)) == 8, "PxSolverContactDesc.contacts has unexpected size % instead of 8", size_of(type_of(PxSolverContactDesc.contacts)));
        assert(((cast(*void)(*instance.numContacts)) - cast(*void)(*instance)) == 144, "PxSolverContactDesc.numContacts has unexpected offset % instead of 144", ((cast(*void)(*instance.numContacts)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverContactDesc.numContacts)) == 4, "PxSolverContactDesc.numContacts has unexpected size % instead of 4", size_of(type_of(PxSolverContactDesc.numContacts)));
        assert(((cast(*void)(*instance.hasMaxImpulse)) - cast(*void)(*instance)) == 148, "PxSolverContactDesc.hasMaxImpulse has unexpected offset % instead of 148", ((cast(*void)(*instance.hasMaxImpulse)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverContactDesc.hasMaxImpulse)) == 1, "PxSolverContactDesc.hasMaxImpulse has unexpected size % instead of 1", size_of(type_of(PxSolverContactDesc.hasMaxImpulse)));
        assert(((cast(*void)(*instance.disableStrongFriction)) - cast(*void)(*instance)) == 149, "PxSolverContactDesc.disableStrongFriction has unexpected offset % instead of 149", ((cast(*void)(*instance.disableStrongFriction)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverContactDesc.disableStrongFriction)) == 1, "PxSolverContactDesc.disableStrongFriction has unexpected size % instead of 1", size_of(type_of(PxSolverContactDesc.disableStrongFriction)));
        assert(((cast(*void)(*instance.hasForceThresholds)) - cast(*void)(*instance)) == 150, "PxSolverContactDesc.hasForceThresholds has unexpected offset % instead of 150", ((cast(*void)(*instance.hasForceThresholds)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverContactDesc.hasForceThresholds)) == 1, "PxSolverContactDesc.hasForceThresholds has unexpected size % instead of 1", size_of(type_of(PxSolverContactDesc.hasForceThresholds)));
        assert(((cast(*void)(*instance.restDistance)) - cast(*void)(*instance)) == 152, "PxSolverContactDesc.restDistance has unexpected offset % instead of 152", ((cast(*void)(*instance.restDistance)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverContactDesc.restDistance)) == 4, "PxSolverContactDesc.restDistance has unexpected size % instead of 4", size_of(type_of(PxSolverContactDesc.restDistance)));
        assert(((cast(*void)(*instance.maxCCDSeparation)) - cast(*void)(*instance)) == 156, "PxSolverContactDesc.maxCCDSeparation has unexpected offset % instead of 156", ((cast(*void)(*instance.maxCCDSeparation)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverContactDesc.maxCCDSeparation)) == 4, "PxSolverContactDesc.maxCCDSeparation has unexpected size % instead of 4", size_of(type_of(PxSolverContactDesc.maxCCDSeparation)));
        assert(((cast(*void)(*instance.frictionPtr)) - cast(*void)(*instance)) == 160, "PxSolverContactDesc.frictionPtr has unexpected offset % instead of 160", ((cast(*void)(*instance.frictionPtr)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverContactDesc.frictionPtr)) == 8, "PxSolverContactDesc.frictionPtr has unexpected size % instead of 8", size_of(type_of(PxSolverContactDesc.frictionPtr)));
        assert(((cast(*void)(*instance.frictionCount)) - cast(*void)(*instance)) == 168, "PxSolverContactDesc.frictionCount has unexpected offset % instead of 168", ((cast(*void)(*instance.frictionCount)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverContactDesc.frictionCount)) == 1, "PxSolverContactDesc.frictionCount has unexpected size % instead of 1", size_of(type_of(PxSolverContactDesc.frictionCount)));
        assert(((cast(*void)(*instance.contactForces)) - cast(*void)(*instance)) == 176, "PxSolverContactDesc.contactForces has unexpected offset % instead of 176", ((cast(*void)(*instance.contactForces)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverContactDesc.contactForces)) == 8, "PxSolverContactDesc.contactForces has unexpected size % instead of 8", size_of(type_of(PxSolverContactDesc.contactForces)));
        assert(((cast(*void)(*instance.startFrictionPatchIndex)) - cast(*void)(*instance)) == 184, "PxSolverContactDesc.startFrictionPatchIndex has unexpected offset % instead of 184", ((cast(*void)(*instance.startFrictionPatchIndex)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverContactDesc.startFrictionPatchIndex)) == 4, "PxSolverContactDesc.startFrictionPatchIndex has unexpected size % instead of 4", size_of(type_of(PxSolverContactDesc.startFrictionPatchIndex)));
        assert(((cast(*void)(*instance.numFrictionPatches)) - cast(*void)(*instance)) == 188, "PxSolverContactDesc.numFrictionPatches has unexpected offset % instead of 188", ((cast(*void)(*instance.numFrictionPatches)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverContactDesc.numFrictionPatches)) == 4, "PxSolverContactDesc.numFrictionPatches has unexpected size % instead of 4", size_of(type_of(PxSolverContactDesc.numFrictionPatches)));
        assert(((cast(*void)(*instance.startContactPatchIndex)) - cast(*void)(*instance)) == 192, "PxSolverContactDesc.startContactPatchIndex has unexpected offset % instead of 192", ((cast(*void)(*instance.startContactPatchIndex)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverContactDesc.startContactPatchIndex)) == 4, "PxSolverContactDesc.startContactPatchIndex has unexpected size % instead of 4", size_of(type_of(PxSolverContactDesc.startContactPatchIndex)));
        assert(((cast(*void)(*instance.numContactPatches)) - cast(*void)(*instance)) == 196, "PxSolverContactDesc.numContactPatches has unexpected offset % instead of 196", ((cast(*void)(*instance.numContactPatches)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverContactDesc.numContactPatches)) == 2, "PxSolverContactDesc.numContactPatches has unexpected size % instead of 2", size_of(type_of(PxSolverContactDesc.numContactPatches)));
        assert(((cast(*void)(*instance.axisConstraintCount)) - cast(*void)(*instance)) == 198, "PxSolverContactDesc.axisConstraintCount has unexpected offset % instead of 198", ((cast(*void)(*instance.axisConstraintCount)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverContactDesc.axisConstraintCount)) == 2, "PxSolverContactDesc.axisConstraintCount has unexpected size % instead of 2", size_of(type_of(PxSolverContactDesc.axisConstraintCount)));
        assert(((cast(*void)(*instance.pad)) - cast(*void)(*instance)) == 200, "PxSolverContactDesc.pad has unexpected offset % instead of 200", ((cast(*void)(*instance.pad)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSolverContactDesc.pad)) == 8, "PxSolverContactDesc.pad has unexpected size % instead of 8", size_of(type_of(PxSolverContactDesc.pad)));
        assert(size_of(PxSolverContactDesc) == 208, "PxSolverContactDesc has size % instead of 208", size_of(PxSolverContactDesc));
    }

    PxConstraintAllocator :: struct {
        vtable: *PxConstraintAllocator_VTable;
    }
    PxConstraintAllocator_VTable :: struct #type_info_none {
        reserveConstraintData: (this: *PxConstraintAllocator, byteSize: PxU32) -> *PxU8 #cpp_method;

        reserveFrictionData: (this: *PxConstraintAllocator, byteSize: PxU32) -> *PxU8 #cpp_method;

        Destructor: (this: *PxConstraintAllocator, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxConstraintAllocator_reserveConstraintData :: inline (this: *PxConstraintAllocator, byteSize: PxU32) -> *PxU8 { return this.vtable.reserveConstraintData(this, byteSize); }

    PxConstraintAllocator_reserveFrictionData :: inline (this: *PxConstraintAllocator, byteSize: PxU32) -> *PxU8 { return this.vtable.reserveFrictionData(this, byteSize); }

    PxConstraintAllocator_Destructor :: inline (this: *PxConstraintAllocator, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxConstraintAllocator) -> *PxConstraintAllocator_VTable { return obj.vtable; }

    #run {if true then return;
        assert(size_of(PxConstraintAllocator) == 8, "PxConstraintAllocator has size % instead of 8", size_of(PxConstraintAllocator));
    }

    PxArticulationAxis :: struct {
        Enum :: enum s32 {
            TWIST  :: 0;
            SWING1 :: 1;
            SWING2 :: 2;
            X      :: 3;
            Y      :: 4;
            Z      :: 5;
            COUNT  :: 6;

            eTWIST  :: TWIST;
            eSWING1 :: SWING1;
            eSWING2 :: SWING2;
            eX      :: X;
            eY      :: Y;
            eZ      :: Z;
            eCOUNT  :: COUNT;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxArticulationAxis) == 1, "PxArticulationAxis has size % instead of 1", size_of(PxArticulationAxis));
    }

    PxArticulationMotion :: struct {
        Enum :: enum s32 {
            LOCKED  :: 0;
            LIMITED :: 1;
            FREE    :: 2;

            eLOCKED  :: LOCKED;
            eLIMITED :: LIMITED;
            eFREE    :: FREE;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxArticulationMotion) == 1, "PxArticulationMotion has size % instead of 1", size_of(PxArticulationMotion));
    }

    PxArticulationMotions :: PxFlags(PxArticulationMotion.Enum, PxU8);

    PxArticulationJointType :: struct {
        Enum :: enum s32 {
            PRISMATIC :: 0;
            REVOLUTE  :: 1;
            SPHERICAL :: 2;
            FIX       :: 3;
            UNDEFINED :: 4;

            ePRISMATIC :: PRISMATIC;
            eREVOLUTE  :: REVOLUTE;
            eSPHERICAL :: SPHERICAL;
            eFIX       :: FIX;
            eUNDEFINED :: UNDEFINED;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxArticulationJointType) == 1, "PxArticulationJointType has size % instead of 1", size_of(PxArticulationJointType));
    }

    PxArticulationFlag :: struct {
        Enum :: enum s32 {
            FIX_BASE                :: 1;
            DRIVE_LIMITS_ARE_FORCES :: 2;

            eFIX_BASE                :: FIX_BASE;
            eDRIVE_LIMITS_ARE_FORCES :: DRIVE_LIMITS_ARE_FORCES;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxArticulationFlag) == 1, "PxArticulationFlag has size % instead of 1", size_of(PxArticulationFlag));
    }

    PxArticulationFlags :: PxFlags(PxArticulationFlag.Enum, PxU8);

    PxArticulationDriveType :: struct {
        Enum :: enum s32 {
            FORCE        :: 0;
            ACCELERATION :: 1;
            TARGET       :: 2;
            VELOCITY     :: 3;
            NONE         :: 4;

            eFORCE        :: FORCE;
            eACCELERATION :: ACCELERATION;
            eTARGET       :: TARGET;
            eVELOCITY     :: VELOCITY;
            eNONE         :: NONE;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxArticulationDriveType) == 1, "PxArticulationDriveType has size % instead of 1", size_of(PxArticulationDriveType));
    }

    PxArticulationLimit :: struct {
        low:  PxReal;
        high: PxReal;
    }
    #run {if true then return;
        instance: PxArticulationLimit;
        assert(((cast(*void)(*instance.low)) - cast(*void)(*instance)) == 0, "PxArticulationLimit.low has unexpected offset % instead of 0", ((cast(*void)(*instance.low)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxArticulationLimit.low)) == 4, "PxArticulationLimit.low has unexpected size % instead of 4", size_of(type_of(PxArticulationLimit.low)));
        assert(((cast(*void)(*instance.high)) - cast(*void)(*instance)) == 4, "PxArticulationLimit.high has unexpected offset % instead of 4", ((cast(*void)(*instance.high)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxArticulationLimit.high)) == 4, "PxArticulationLimit.high has unexpected size % instead of 4", size_of(type_of(PxArticulationLimit.high)));
        assert(size_of(PxArticulationLimit) == 8, "PxArticulationLimit has size % instead of 8", size_of(PxArticulationLimit));
    }

    PxArticulationDrive :: struct {
        stiffness: PxReal;
        damping:   PxReal;
        maxForce:  PxReal;
        driveType: PxArticulationDriveType.Enum;
    }
    #run {if true then return;
        instance: PxArticulationDrive;
        assert(((cast(*void)(*instance.stiffness)) - cast(*void)(*instance)) == 0, "PxArticulationDrive.stiffness has unexpected offset % instead of 0", ((cast(*void)(*instance.stiffness)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxArticulationDrive.stiffness)) == 4, "PxArticulationDrive.stiffness has unexpected size % instead of 4", size_of(type_of(PxArticulationDrive.stiffness)));
        assert(((cast(*void)(*instance.damping)) - cast(*void)(*instance)) == 4, "PxArticulationDrive.damping has unexpected offset % instead of 4", ((cast(*void)(*instance.damping)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxArticulationDrive.damping)) == 4, "PxArticulationDrive.damping has unexpected size % instead of 4", size_of(type_of(PxArticulationDrive.damping)));
        assert(((cast(*void)(*instance.maxForce)) - cast(*void)(*instance)) == 8, "PxArticulationDrive.maxForce has unexpected offset % instead of 8", ((cast(*void)(*instance.maxForce)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxArticulationDrive.maxForce)) == 4, "PxArticulationDrive.maxForce has unexpected size % instead of 4", size_of(type_of(PxArticulationDrive.maxForce)));
        assert(((cast(*void)(*instance.driveType)) - cast(*void)(*instance)) == 12, "PxArticulationDrive.driveType has unexpected offset % instead of 12", ((cast(*void)(*instance.driveType)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxArticulationDrive.driveType)) == 4, "PxArticulationDrive.driveType has unexpected size % instead of 4", size_of(type_of(PxArticulationDrive.driveType)));
        assert(size_of(PxArticulationDrive) == 16, "PxArticulationDrive has size % instead of 16", size_of(PxArticulationDrive));
    }

    PxTGSSolverBodyVel :: struct {
        linearVelocity:       PxVec3; //12
        nbStaticInteractions: PxU16; //14 Used to accumulate the number of static interactions
        maxDynamicPartition:  PxU16; //16 Used to accumualte the max partition of dynamic interactions
        angularVelocity:      PxVec3; //28
        partitionMask:        PxU32; //32 Used in partitioning as a bit-field
        deltaAngDt:           PxVec3; //44
        maxAngVel:            PxReal; //48
        deltaLinDt:           PxVec3; //60
        lockFlags:            PxU16; //62
        isKinematic:          bool; //63
        pad:                  PxU8; //64

        projectVelocity :: (this: *PxTGSSolverBodyVel, lin: *PxVec3, ang: *PxVec3) -> PxReal #cpp_method #foreign physx_lib "?projectVelocity@PxTGSSolverBodyVel@physx@@QEBAMAEBVPxVec3@2@0@Z";
        projectVelocity :: (this: *PxTGSSolverBodyVel, lin: PxVec3, ang: PxVec3) -> PxReal #no_context {
            return projectVelocity(this, *lin, *ang);
        }
    }
    #run {if true then return;
        instance: PxTGSSolverBodyVel;
        assert(((cast(*void)(*instance.linearVelocity)) - cast(*void)(*instance)) == 0, "PxTGSSolverBodyVel.linearVelocity has unexpected offset % instead of 0", ((cast(*void)(*instance.linearVelocity)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverBodyVel.linearVelocity)) == 12, "PxTGSSolverBodyVel.linearVelocity has unexpected size % instead of 12", size_of(type_of(PxTGSSolverBodyVel.linearVelocity)));
        assert(((cast(*void)(*instance.nbStaticInteractions)) - cast(*void)(*instance)) == 12, "PxTGSSolverBodyVel.nbStaticInteractions has unexpected offset % instead of 12", ((cast(*void)(*instance.nbStaticInteractions)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverBodyVel.nbStaticInteractions)) == 2, "PxTGSSolverBodyVel.nbStaticInteractions has unexpected size % instead of 2", size_of(type_of(PxTGSSolverBodyVel.nbStaticInteractions)));
        assert(((cast(*void)(*instance.maxDynamicPartition)) - cast(*void)(*instance)) == 14, "PxTGSSolverBodyVel.maxDynamicPartition has unexpected offset % instead of 14", ((cast(*void)(*instance.maxDynamicPartition)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverBodyVel.maxDynamicPartition)) == 2, "PxTGSSolverBodyVel.maxDynamicPartition has unexpected size % instead of 2", size_of(type_of(PxTGSSolverBodyVel.maxDynamicPartition)));
        assert(((cast(*void)(*instance.angularVelocity)) - cast(*void)(*instance)) == 16, "PxTGSSolverBodyVel.angularVelocity has unexpected offset % instead of 16", ((cast(*void)(*instance.angularVelocity)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverBodyVel.angularVelocity)) == 12, "PxTGSSolverBodyVel.angularVelocity has unexpected size % instead of 12", size_of(type_of(PxTGSSolverBodyVel.angularVelocity)));
        assert(((cast(*void)(*instance.partitionMask)) - cast(*void)(*instance)) == 28, "PxTGSSolverBodyVel.partitionMask has unexpected offset % instead of 28", ((cast(*void)(*instance.partitionMask)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverBodyVel.partitionMask)) == 4, "PxTGSSolverBodyVel.partitionMask has unexpected size % instead of 4", size_of(type_of(PxTGSSolverBodyVel.partitionMask)));
        assert(((cast(*void)(*instance.deltaAngDt)) - cast(*void)(*instance)) == 32, "PxTGSSolverBodyVel.deltaAngDt has unexpected offset % instead of 32", ((cast(*void)(*instance.deltaAngDt)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverBodyVel.deltaAngDt)) == 12, "PxTGSSolverBodyVel.deltaAngDt has unexpected size % instead of 12", size_of(type_of(PxTGSSolverBodyVel.deltaAngDt)));
        assert(((cast(*void)(*instance.maxAngVel)) - cast(*void)(*instance)) == 44, "PxTGSSolverBodyVel.maxAngVel has unexpected offset % instead of 44", ((cast(*void)(*instance.maxAngVel)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverBodyVel.maxAngVel)) == 4, "PxTGSSolverBodyVel.maxAngVel has unexpected size % instead of 4", size_of(type_of(PxTGSSolverBodyVel.maxAngVel)));
        assert(((cast(*void)(*instance.deltaLinDt)) - cast(*void)(*instance)) == 48, "PxTGSSolverBodyVel.deltaLinDt has unexpected offset % instead of 48", ((cast(*void)(*instance.deltaLinDt)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverBodyVel.deltaLinDt)) == 12, "PxTGSSolverBodyVel.deltaLinDt has unexpected size % instead of 12", size_of(type_of(PxTGSSolverBodyVel.deltaLinDt)));
        assert(((cast(*void)(*instance.lockFlags)) - cast(*void)(*instance)) == 60, "PxTGSSolverBodyVel.lockFlags has unexpected offset % instead of 60", ((cast(*void)(*instance.lockFlags)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverBodyVel.lockFlags)) == 2, "PxTGSSolverBodyVel.lockFlags has unexpected size % instead of 2", size_of(type_of(PxTGSSolverBodyVel.lockFlags)));
        assert(((cast(*void)(*instance.isKinematic)) - cast(*void)(*instance)) == 62, "PxTGSSolverBodyVel.isKinematic has unexpected offset % instead of 62", ((cast(*void)(*instance.isKinematic)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverBodyVel.isKinematic)) == 1, "PxTGSSolverBodyVel.isKinematic has unexpected size % instead of 1", size_of(type_of(PxTGSSolverBodyVel.isKinematic)));
        assert(((cast(*void)(*instance.pad)) - cast(*void)(*instance)) == 63, "PxTGSSolverBodyVel.pad has unexpected offset % instead of 63", ((cast(*void)(*instance.pad)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverBodyVel.pad)) == 1, "PxTGSSolverBodyVel.pad has unexpected size % instead of 1", size_of(type_of(PxTGSSolverBodyVel.pad)));
        assert(size_of(PxTGSSolverBodyVel) == 64, "PxTGSSolverBodyVel has size % instead of 64", size_of(PxTGSSolverBodyVel));
    }

    //Needed only by prep, integration and 1D constraints
    PxTGSSolverBodyTxInertia :: struct {
        deltaBody2World: PxTransform;
        sqrtInvInertia:  PxMat33;
    }
    #run {if true then return;
        instance: PxTGSSolverBodyTxInertia;
        assert(((cast(*void)(*instance.deltaBody2World)) - cast(*void)(*instance)) == 0, "PxTGSSolverBodyTxInertia.deltaBody2World has unexpected offset % instead of 0", ((cast(*void)(*instance.deltaBody2World)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverBodyTxInertia.deltaBody2World)) == 28, "PxTGSSolverBodyTxInertia.deltaBody2World has unexpected size % instead of 28", size_of(type_of(PxTGSSolverBodyTxInertia.deltaBody2World)));
        assert(((cast(*void)(*instance.sqrtInvInertia)) - cast(*void)(*instance)) == 28, "PxTGSSolverBodyTxInertia.sqrtInvInertia has unexpected offset % instead of 28", ((cast(*void)(*instance.sqrtInvInertia)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverBodyTxInertia.sqrtInvInertia)) == 36, "PxTGSSolverBodyTxInertia.sqrtInvInertia has unexpected size % instead of 36", size_of(type_of(PxTGSSolverBodyTxInertia.sqrtInvInertia)));
        assert(size_of(PxTGSSolverBodyTxInertia) == 64, "PxTGSSolverBodyTxInertia has size % instead of 64", size_of(PxTGSSolverBodyTxInertia));
    }

    PxTGSSolverBodyData :: struct {
        originalLinearVelocity:  PxVec3;
        maxContactImpulse:       PxReal;
        originalAngularVelocity: PxVec3;
        penBiasClamp:            PxReal;

        invMass:                 PxReal;
        nodeIndex:               PxU32;
        reportThreshold:         PxReal;
        pad:                     PxU32;

        projectVelocity :: (this: *PxTGSSolverBodyData, linear: *PxVec3, angular: *PxVec3) -> PxReal #cpp_method #foreign physx_lib "?projectVelocity@PxTGSSolverBodyData@physx@@QEBAMAEBVPxVec3@2@0@Z";
        projectVelocity :: (this: *PxTGSSolverBodyData, linear: PxVec3, angular: PxVec3) -> PxReal #no_context {
            return projectVelocity(this, *linear, *angular);
        }
    }
    #run {if true then return;
        instance: PxTGSSolverBodyData;
        assert(((cast(*void)(*instance.originalLinearVelocity)) - cast(*void)(*instance)) == 0, "PxTGSSolverBodyData.originalLinearVelocity has unexpected offset % instead of 0", ((cast(*void)(*instance.originalLinearVelocity)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverBodyData.originalLinearVelocity)) == 12, "PxTGSSolverBodyData.originalLinearVelocity has unexpected size % instead of 12", size_of(type_of(PxTGSSolverBodyData.originalLinearVelocity)));
        assert(((cast(*void)(*instance.maxContactImpulse)) - cast(*void)(*instance)) == 12, "PxTGSSolverBodyData.maxContactImpulse has unexpected offset % instead of 12", ((cast(*void)(*instance.maxContactImpulse)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverBodyData.maxContactImpulse)) == 4, "PxTGSSolverBodyData.maxContactImpulse has unexpected size % instead of 4", size_of(type_of(PxTGSSolverBodyData.maxContactImpulse)));
        assert(((cast(*void)(*instance.originalAngularVelocity)) - cast(*void)(*instance)) == 16, "PxTGSSolverBodyData.originalAngularVelocity has unexpected offset % instead of 16", ((cast(*void)(*instance.originalAngularVelocity)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverBodyData.originalAngularVelocity)) == 12, "PxTGSSolverBodyData.originalAngularVelocity has unexpected size % instead of 12", size_of(type_of(PxTGSSolverBodyData.originalAngularVelocity)));
        assert(((cast(*void)(*instance.penBiasClamp)) - cast(*void)(*instance)) == 28, "PxTGSSolverBodyData.penBiasClamp has unexpected offset % instead of 28", ((cast(*void)(*instance.penBiasClamp)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverBodyData.penBiasClamp)) == 4, "PxTGSSolverBodyData.penBiasClamp has unexpected size % instead of 4", size_of(type_of(PxTGSSolverBodyData.penBiasClamp)));
        assert(((cast(*void)(*instance.invMass)) - cast(*void)(*instance)) == 32, "PxTGSSolverBodyData.invMass has unexpected offset % instead of 32", ((cast(*void)(*instance.invMass)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverBodyData.invMass)) == 4, "PxTGSSolverBodyData.invMass has unexpected size % instead of 4", size_of(type_of(PxTGSSolverBodyData.invMass)));
        assert(((cast(*void)(*instance.nodeIndex)) - cast(*void)(*instance)) == 36, "PxTGSSolverBodyData.nodeIndex has unexpected offset % instead of 36", ((cast(*void)(*instance.nodeIndex)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverBodyData.nodeIndex)) == 4, "PxTGSSolverBodyData.nodeIndex has unexpected size % instead of 4", size_of(type_of(PxTGSSolverBodyData.nodeIndex)));
        assert(((cast(*void)(*instance.reportThreshold)) - cast(*void)(*instance)) == 40, "PxTGSSolverBodyData.reportThreshold has unexpected offset % instead of 40", ((cast(*void)(*instance.reportThreshold)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverBodyData.reportThreshold)) == 4, "PxTGSSolverBodyData.reportThreshold has unexpected size % instead of 4", size_of(type_of(PxTGSSolverBodyData.reportThreshold)));
        assert(((cast(*void)(*instance.pad)) - cast(*void)(*instance)) == 44, "PxTGSSolverBodyData.pad has unexpected offset % instead of 44", ((cast(*void)(*instance.pad)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverBodyData.pad)) == 4, "PxTGSSolverBodyData.pad has unexpected size % instead of 4", size_of(type_of(PxTGSSolverBodyData.pad)));
        assert(size_of(PxTGSSolverBodyData) == 48, "PxTGSSolverBodyData has size % instead of 48", size_of(PxTGSSolverBodyData));
    }

    PxTGSSolverConstraintPrepDescBase :: struct {
        invMassScales: PxConstraintInvMassScale; //!< In: The local mass scaling for this pair.

        desc:          *PxSolverConstraintDesc; //!< Output: The PxSolverConstraintDesc filled in by contact prep

        body0:         *PxTGSSolverBodyVel; //!< In: The first body. Stores velocity information. Unused unless contact involves articulations.
        body1:         *PxTGSSolverBodyVel; //!< In: The second body. Stores velocity information. Unused unless contact involves articulations.

        body0TxI:      *PxTGSSolverBodyTxInertia;
        body1TxI:      *PxTGSSolverBodyTxInertia;

        bodyData0:     *PxTGSSolverBodyData;
        bodyData1:     *PxTGSSolverBodyData;

        bodyFrame0:    PxTransform; //!< In: The world-space transform of the first body.
        bodyFrame1:    PxTransform; //!< In: The world-space transform of the second body.

        bodyState0:    PxSolverConstraintPrepDescBase.BodyState; //!< In: Defines what kind of actor the first body is
        bodyState1:    PxSolverConstraintPrepDescBase.BodyState; //!< In: Defines what kind of actor the second body is
    }
    #run {if true then return;
        instance: PxTGSSolverConstraintPrepDescBase;
        assert(((cast(*void)(*instance.invMassScales)) - cast(*void)(*instance)) == 0, "PxTGSSolverConstraintPrepDescBase.invMassScales has unexpected offset % instead of 0", ((cast(*void)(*instance.invMassScales)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverConstraintPrepDescBase.invMassScales)) == 16, "PxTGSSolverConstraintPrepDescBase.invMassScales has unexpected size % instead of 16", size_of(type_of(PxTGSSolverConstraintPrepDescBase.invMassScales)));
        assert(((cast(*void)(*instance.desc)) - cast(*void)(*instance)) == 16, "PxTGSSolverConstraintPrepDescBase.desc has unexpected offset % instead of 16", ((cast(*void)(*instance.desc)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverConstraintPrepDescBase.desc)) == 8, "PxTGSSolverConstraintPrepDescBase.desc has unexpected size % instead of 8", size_of(type_of(PxTGSSolverConstraintPrepDescBase.desc)));
        assert(((cast(*void)(*instance.body0)) - cast(*void)(*instance)) == 24, "PxTGSSolverConstraintPrepDescBase.body0 has unexpected offset % instead of 24", ((cast(*void)(*instance.body0)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverConstraintPrepDescBase.body0)) == 8, "PxTGSSolverConstraintPrepDescBase.body0 has unexpected size % instead of 8", size_of(type_of(PxTGSSolverConstraintPrepDescBase.body0)));
        assert(((cast(*void)(*instance.body1)) - cast(*void)(*instance)) == 32, "PxTGSSolverConstraintPrepDescBase.body1 has unexpected offset % instead of 32", ((cast(*void)(*instance.body1)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverConstraintPrepDescBase.body1)) == 8, "PxTGSSolverConstraintPrepDescBase.body1 has unexpected size % instead of 8", size_of(type_of(PxTGSSolverConstraintPrepDescBase.body1)));
        assert(((cast(*void)(*instance.body0TxI)) - cast(*void)(*instance)) == 40, "PxTGSSolverConstraintPrepDescBase.body0TxI has unexpected offset % instead of 40", ((cast(*void)(*instance.body0TxI)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverConstraintPrepDescBase.body0TxI)) == 8, "PxTGSSolverConstraintPrepDescBase.body0TxI has unexpected size % instead of 8", size_of(type_of(PxTGSSolverConstraintPrepDescBase.body0TxI)));
        assert(((cast(*void)(*instance.body1TxI)) - cast(*void)(*instance)) == 48, "PxTGSSolverConstraintPrepDescBase.body1TxI has unexpected offset % instead of 48", ((cast(*void)(*instance.body1TxI)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverConstraintPrepDescBase.body1TxI)) == 8, "PxTGSSolverConstraintPrepDescBase.body1TxI has unexpected size % instead of 8", size_of(type_of(PxTGSSolverConstraintPrepDescBase.body1TxI)));
        assert(((cast(*void)(*instance.bodyData0)) - cast(*void)(*instance)) == 56, "PxTGSSolverConstraintPrepDescBase.bodyData0 has unexpected offset % instead of 56", ((cast(*void)(*instance.bodyData0)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverConstraintPrepDescBase.bodyData0)) == 8, "PxTGSSolverConstraintPrepDescBase.bodyData0 has unexpected size % instead of 8", size_of(type_of(PxTGSSolverConstraintPrepDescBase.bodyData0)));
        assert(((cast(*void)(*instance.bodyData1)) - cast(*void)(*instance)) == 64, "PxTGSSolverConstraintPrepDescBase.bodyData1 has unexpected offset % instead of 64", ((cast(*void)(*instance.bodyData1)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverConstraintPrepDescBase.bodyData1)) == 8, "PxTGSSolverConstraintPrepDescBase.bodyData1 has unexpected size % instead of 8", size_of(type_of(PxTGSSolverConstraintPrepDescBase.bodyData1)));
        assert(((cast(*void)(*instance.bodyFrame0)) - cast(*void)(*instance)) == 72, "PxTGSSolverConstraintPrepDescBase.bodyFrame0 has unexpected offset % instead of 72", ((cast(*void)(*instance.bodyFrame0)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverConstraintPrepDescBase.bodyFrame0)) == 28, "PxTGSSolverConstraintPrepDescBase.bodyFrame0 has unexpected size % instead of 28", size_of(type_of(PxTGSSolverConstraintPrepDescBase.bodyFrame0)));
        assert(((cast(*void)(*instance.bodyFrame1)) - cast(*void)(*instance)) == 100, "PxTGSSolverConstraintPrepDescBase.bodyFrame1 has unexpected offset % instead of 100", ((cast(*void)(*instance.bodyFrame1)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverConstraintPrepDescBase.bodyFrame1)) == 28, "PxTGSSolverConstraintPrepDescBase.bodyFrame1 has unexpected size % instead of 28", size_of(type_of(PxTGSSolverConstraintPrepDescBase.bodyFrame1)));
        assert(((cast(*void)(*instance.bodyState0)) - cast(*void)(*instance)) == 128, "PxTGSSolverConstraintPrepDescBase.bodyState0 has unexpected offset % instead of 128", ((cast(*void)(*instance.bodyState0)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverConstraintPrepDescBase.bodyState0)) == 4, "PxTGSSolverConstraintPrepDescBase.bodyState0 has unexpected size % instead of 4", size_of(type_of(PxTGSSolverConstraintPrepDescBase.bodyState0)));
        assert(((cast(*void)(*instance.bodyState1)) - cast(*void)(*instance)) == 132, "PxTGSSolverConstraintPrepDescBase.bodyState1 has unexpected offset % instead of 132", ((cast(*void)(*instance.bodyState1)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverConstraintPrepDescBase.bodyState1)) == 4, "PxTGSSolverConstraintPrepDescBase.bodyState1 has unexpected size % instead of 4", size_of(type_of(PxTGSSolverConstraintPrepDescBase.bodyState1)));
        assert(size_of(PxTGSSolverConstraintPrepDescBase) == 144, "PxTGSSolverConstraintPrepDescBase has size % instead of 144", size_of(PxTGSSolverConstraintPrepDescBase));
    }

    PxTGSSolverConstraintPrepDesc :: struct {
        #as using pxtgssolverconstraintprepdescbase: PxTGSSolverConstraintPrepDescBase;

        rows:                 *Px1DConstraint; //!< The start of the constraint rows
        numRows:              PxU32; //!< The number of rows

        linBreakForce:        PxReal; //!< Break forces
        angBreakForce:        PxReal; //!< Break forces
        minResponseThreshold: PxReal; //!< The minimum response threshold
        writeback:            *void; //!< Pointer to constraint writeback structure. Reports back joint breaking. If not required, set to NULL.
        disablePreprocessing: bool; //!< Disable joint pre-processing. Pre-processing can improve stability but under certain circumstances, e.g. when some invInertia rows are zero/almost zero, can cause instabilities.
        improvedSlerp:        bool; //!< Use improved slerp model
        driveLimitsAreForces: bool; //!< Indicates whether drive limits are forces
        extendedLimits:       bool; //!< Indiciates whether extended limits are used

        body0WorldOffset:     PxVec3; //!< Body0 world offset
        cA2w:                 PxVec3; //!< Location of anchor point A in world space
        cB2w:                 PxVec3; //!< Location of anchor point B in world space
    }
    #run {if true then return;
        assert(size_of(type_of(PxTGSSolverConstraintPrepDesc.pxtgssolverconstraintprepdescbase)) == 144, "PxTGSSolverConstraintPrepDesc.pxtgssolverconstraintprepdescbase has unexpected size % instead of 144", size_of(type_of(PxTGSSolverConstraintPrepDesc.pxtgssolverconstraintprepdescbase)));
        instance: PxTGSSolverConstraintPrepDesc;
        assert(((cast(*void)(*instance.rows)) - cast(*void)(*instance)) == 144, "PxTGSSolverConstraintPrepDesc.rows has unexpected offset % instead of 144", ((cast(*void)(*instance.rows)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverConstraintPrepDesc.rows)) == 8, "PxTGSSolverConstraintPrepDesc.rows has unexpected size % instead of 8", size_of(type_of(PxTGSSolverConstraintPrepDesc.rows)));
        assert(((cast(*void)(*instance.numRows)) - cast(*void)(*instance)) == 152, "PxTGSSolverConstraintPrepDesc.numRows has unexpected offset % instead of 152", ((cast(*void)(*instance.numRows)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverConstraintPrepDesc.numRows)) == 4, "PxTGSSolverConstraintPrepDesc.numRows has unexpected size % instead of 4", size_of(type_of(PxTGSSolverConstraintPrepDesc.numRows)));
        assert(((cast(*void)(*instance.linBreakForce)) - cast(*void)(*instance)) == 156, "PxTGSSolverConstraintPrepDesc.linBreakForce has unexpected offset % instead of 156", ((cast(*void)(*instance.linBreakForce)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverConstraintPrepDesc.linBreakForce)) == 4, "PxTGSSolverConstraintPrepDesc.linBreakForce has unexpected size % instead of 4", size_of(type_of(PxTGSSolverConstraintPrepDesc.linBreakForce)));
        assert(((cast(*void)(*instance.angBreakForce)) - cast(*void)(*instance)) == 160, "PxTGSSolverConstraintPrepDesc.angBreakForce has unexpected offset % instead of 160", ((cast(*void)(*instance.angBreakForce)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverConstraintPrepDesc.angBreakForce)) == 4, "PxTGSSolverConstraintPrepDesc.angBreakForce has unexpected size % instead of 4", size_of(type_of(PxTGSSolverConstraintPrepDesc.angBreakForce)));
        assert(((cast(*void)(*instance.minResponseThreshold)) - cast(*void)(*instance)) == 164, "PxTGSSolverConstraintPrepDesc.minResponseThreshold has unexpected offset % instead of 164", ((cast(*void)(*instance.minResponseThreshold)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverConstraintPrepDesc.minResponseThreshold)) == 4, "PxTGSSolverConstraintPrepDesc.minResponseThreshold has unexpected size % instead of 4", size_of(type_of(PxTGSSolverConstraintPrepDesc.minResponseThreshold)));
        assert(((cast(*void)(*instance.writeback)) - cast(*void)(*instance)) == 168, "PxTGSSolverConstraintPrepDesc.writeback has unexpected offset % instead of 168", ((cast(*void)(*instance.writeback)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverConstraintPrepDesc.writeback)) == 8, "PxTGSSolverConstraintPrepDesc.writeback has unexpected size % instead of 8", size_of(type_of(PxTGSSolverConstraintPrepDesc.writeback)));
        assert(((cast(*void)(*instance.disablePreprocessing)) - cast(*void)(*instance)) == 176, "PxTGSSolverConstraintPrepDesc.disablePreprocessing has unexpected offset % instead of 176", ((cast(*void)(*instance.disablePreprocessing)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverConstraintPrepDesc.disablePreprocessing)) == 1, "PxTGSSolverConstraintPrepDesc.disablePreprocessing has unexpected size % instead of 1", size_of(type_of(PxTGSSolverConstraintPrepDesc.disablePreprocessing)));
        assert(((cast(*void)(*instance.improvedSlerp)) - cast(*void)(*instance)) == 177, "PxTGSSolverConstraintPrepDesc.improvedSlerp has unexpected offset % instead of 177", ((cast(*void)(*instance.improvedSlerp)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverConstraintPrepDesc.improvedSlerp)) == 1, "PxTGSSolverConstraintPrepDesc.improvedSlerp has unexpected size % instead of 1", size_of(type_of(PxTGSSolverConstraintPrepDesc.improvedSlerp)));
        assert(((cast(*void)(*instance.driveLimitsAreForces)) - cast(*void)(*instance)) == 178, "PxTGSSolverConstraintPrepDesc.driveLimitsAreForces has unexpected offset % instead of 178", ((cast(*void)(*instance.driveLimitsAreForces)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverConstraintPrepDesc.driveLimitsAreForces)) == 1, "PxTGSSolverConstraintPrepDesc.driveLimitsAreForces has unexpected size % instead of 1", size_of(type_of(PxTGSSolverConstraintPrepDesc.driveLimitsAreForces)));
        assert(((cast(*void)(*instance.extendedLimits)) - cast(*void)(*instance)) == 179, "PxTGSSolverConstraintPrepDesc.extendedLimits has unexpected offset % instead of 179", ((cast(*void)(*instance.extendedLimits)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverConstraintPrepDesc.extendedLimits)) == 1, "PxTGSSolverConstraintPrepDesc.extendedLimits has unexpected size % instead of 1", size_of(type_of(PxTGSSolverConstraintPrepDesc.extendedLimits)));
        assert(((cast(*void)(*instance.body0WorldOffset)) - cast(*void)(*instance)) == 180, "PxTGSSolverConstraintPrepDesc.body0WorldOffset has unexpected offset % instead of 180", ((cast(*void)(*instance.body0WorldOffset)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverConstraintPrepDesc.body0WorldOffset)) == 12, "PxTGSSolverConstraintPrepDesc.body0WorldOffset has unexpected size % instead of 12", size_of(type_of(PxTGSSolverConstraintPrepDesc.body0WorldOffset)));
        assert(((cast(*void)(*instance.cA2w)) - cast(*void)(*instance)) == 192, "PxTGSSolverConstraintPrepDesc.cA2w has unexpected offset % instead of 192", ((cast(*void)(*instance.cA2w)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverConstraintPrepDesc.cA2w)) == 12, "PxTGSSolverConstraintPrepDesc.cA2w has unexpected size % instead of 12", size_of(type_of(PxTGSSolverConstraintPrepDesc.cA2w)));
        assert(((cast(*void)(*instance.cB2w)) - cast(*void)(*instance)) == 204, "PxTGSSolverConstraintPrepDesc.cB2w has unexpected offset % instead of 204", ((cast(*void)(*instance.cB2w)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverConstraintPrepDesc.cB2w)) == 12, "PxTGSSolverConstraintPrepDesc.cB2w has unexpected size % instead of 12", size_of(type_of(PxTGSSolverConstraintPrepDesc.cB2w)));
        assert(size_of(PxTGSSolverConstraintPrepDesc) == 224, "PxTGSSolverConstraintPrepDesc has size % instead of 224", size_of(PxTGSSolverConstraintPrepDesc));
    }

    PxTGSSolverContactDesc :: struct {
        #as using pxtgssolverconstraintprepdescbase: PxTGSSolverConstraintPrepDescBase;

        shapeInteraction:        *Sc.ShapeInteraction; //!< Pointer to share interaction. Used for force threshold reports in solver. Set to NULL if using immediate mode.
        contacts:                *Gu.ContactPoint; //!< The start of the contacts for this pair
        numContacts:             PxU32; //!< The total number of contacs this pair references.

        hasMaxImpulse:           bool; //!< Defines whether this pairs has maxImpulses clamping enabled
        disableStrongFriction:   bool; //!< Defines whether this pair disables strong friction (sticky friction correlation)
        hasForceThresholds:      bool; //!< Defines whether this pair requires force thresholds

        restDistance:            PxReal; //!< A distance at which the solver should aim to hold the bodies separated. Default is 0
        maxCCDSeparation:        PxReal; //!< A distance used to configure speculative CCD behavior. Default is PX_MAX_F32. Set internally in PhysX for bodies with eENABLE_SPECULATIVE_CCD on. Do not set directly!

        frictionPtr:             *PxU8; //!< InOut: Friction patch correlation data. Set each frame by solver. Can be retained for improved behaviour or discarded each frame.
        frictionCount:           PxU8; //!< The total number of friction patches in this pair

        contactForces:           *PxReal; //!< Out: A buffer for the solver to write applied contact forces to.

        startFrictionPatchIndex: PxU32; //!< Start index of friction patch in the correlation buffer. Set by friction correlation
        numFrictionPatches:      PxU32; //!< Total number of friction patches in this pair. Set by friction correlation

        startContactPatchIndex:  PxU32; //!< The start index of this pair's contact patches in the correlation buffer. For internal use only
        numContactPatches:       PxU16; //!< Total number of contact patches.
        axisConstraintCount:     PxU16; //!< Axis constraint count. Defines how many constraint rows this pair has produced. Useful for statistical purposes.

        maxImpulse:              PxReal;

        torsionalPatchRadius:    PxReal;
        minTorsionalPatchRadius: PxReal;
    }
    #run {if true then return;
        assert(size_of(type_of(PxTGSSolverContactDesc.pxtgssolverconstraintprepdescbase)) == 144, "PxTGSSolverContactDesc.pxtgssolverconstraintprepdescbase has unexpected size % instead of 144", size_of(type_of(PxTGSSolverContactDesc.pxtgssolverconstraintprepdescbase)));
        instance: PxTGSSolverContactDesc;
        assert(((cast(*void)(*instance.shapeInteraction)) - cast(*void)(*instance)) == 144, "PxTGSSolverContactDesc.shapeInteraction has unexpected offset % instead of 144", ((cast(*void)(*instance.shapeInteraction)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverContactDesc.shapeInteraction)) == 8, "PxTGSSolverContactDesc.shapeInteraction has unexpected size % instead of 8", size_of(type_of(PxTGSSolverContactDesc.shapeInteraction)));
        assert(((cast(*void)(*instance.contacts)) - cast(*void)(*instance)) == 152, "PxTGSSolverContactDesc.contacts has unexpected offset % instead of 152", ((cast(*void)(*instance.contacts)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverContactDesc.contacts)) == 8, "PxTGSSolverContactDesc.contacts has unexpected size % instead of 8", size_of(type_of(PxTGSSolverContactDesc.contacts)));
        assert(((cast(*void)(*instance.numContacts)) - cast(*void)(*instance)) == 160, "PxTGSSolverContactDesc.numContacts has unexpected offset % instead of 160", ((cast(*void)(*instance.numContacts)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverContactDesc.numContacts)) == 4, "PxTGSSolverContactDesc.numContacts has unexpected size % instead of 4", size_of(type_of(PxTGSSolverContactDesc.numContacts)));
        assert(((cast(*void)(*instance.hasMaxImpulse)) - cast(*void)(*instance)) == 164, "PxTGSSolverContactDesc.hasMaxImpulse has unexpected offset % instead of 164", ((cast(*void)(*instance.hasMaxImpulse)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverContactDesc.hasMaxImpulse)) == 1, "PxTGSSolverContactDesc.hasMaxImpulse has unexpected size % instead of 1", size_of(type_of(PxTGSSolverContactDesc.hasMaxImpulse)));
        assert(((cast(*void)(*instance.disableStrongFriction)) - cast(*void)(*instance)) == 165, "PxTGSSolverContactDesc.disableStrongFriction has unexpected offset % instead of 165", ((cast(*void)(*instance.disableStrongFriction)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverContactDesc.disableStrongFriction)) == 1, "PxTGSSolverContactDesc.disableStrongFriction has unexpected size % instead of 1", size_of(type_of(PxTGSSolverContactDesc.disableStrongFriction)));
        assert(((cast(*void)(*instance.hasForceThresholds)) - cast(*void)(*instance)) == 166, "PxTGSSolverContactDesc.hasForceThresholds has unexpected offset % instead of 166", ((cast(*void)(*instance.hasForceThresholds)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverContactDesc.hasForceThresholds)) == 1, "PxTGSSolverContactDesc.hasForceThresholds has unexpected size % instead of 1", size_of(type_of(PxTGSSolverContactDesc.hasForceThresholds)));
        assert(((cast(*void)(*instance.restDistance)) - cast(*void)(*instance)) == 168, "PxTGSSolverContactDesc.restDistance has unexpected offset % instead of 168", ((cast(*void)(*instance.restDistance)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverContactDesc.restDistance)) == 4, "PxTGSSolverContactDesc.restDistance has unexpected size % instead of 4", size_of(type_of(PxTGSSolverContactDesc.restDistance)));
        assert(((cast(*void)(*instance.maxCCDSeparation)) - cast(*void)(*instance)) == 172, "PxTGSSolverContactDesc.maxCCDSeparation has unexpected offset % instead of 172", ((cast(*void)(*instance.maxCCDSeparation)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverContactDesc.maxCCDSeparation)) == 4, "PxTGSSolverContactDesc.maxCCDSeparation has unexpected size % instead of 4", size_of(type_of(PxTGSSolverContactDesc.maxCCDSeparation)));
        assert(((cast(*void)(*instance.frictionPtr)) - cast(*void)(*instance)) == 176, "PxTGSSolverContactDesc.frictionPtr has unexpected offset % instead of 176", ((cast(*void)(*instance.frictionPtr)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverContactDesc.frictionPtr)) == 8, "PxTGSSolverContactDesc.frictionPtr has unexpected size % instead of 8", size_of(type_of(PxTGSSolverContactDesc.frictionPtr)));
        assert(((cast(*void)(*instance.frictionCount)) - cast(*void)(*instance)) == 184, "PxTGSSolverContactDesc.frictionCount has unexpected offset % instead of 184", ((cast(*void)(*instance.frictionCount)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverContactDesc.frictionCount)) == 1, "PxTGSSolverContactDesc.frictionCount has unexpected size % instead of 1", size_of(type_of(PxTGSSolverContactDesc.frictionCount)));
        assert(((cast(*void)(*instance.contactForces)) - cast(*void)(*instance)) == 192, "PxTGSSolverContactDesc.contactForces has unexpected offset % instead of 192", ((cast(*void)(*instance.contactForces)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverContactDesc.contactForces)) == 8, "PxTGSSolverContactDesc.contactForces has unexpected size % instead of 8", size_of(type_of(PxTGSSolverContactDesc.contactForces)));
        assert(((cast(*void)(*instance.startFrictionPatchIndex)) - cast(*void)(*instance)) == 200, "PxTGSSolverContactDesc.startFrictionPatchIndex has unexpected offset % instead of 200", ((cast(*void)(*instance.startFrictionPatchIndex)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverContactDesc.startFrictionPatchIndex)) == 4, "PxTGSSolverContactDesc.startFrictionPatchIndex has unexpected size % instead of 4", size_of(type_of(PxTGSSolverContactDesc.startFrictionPatchIndex)));
        assert(((cast(*void)(*instance.numFrictionPatches)) - cast(*void)(*instance)) == 204, "PxTGSSolverContactDesc.numFrictionPatches has unexpected offset % instead of 204", ((cast(*void)(*instance.numFrictionPatches)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverContactDesc.numFrictionPatches)) == 4, "PxTGSSolverContactDesc.numFrictionPatches has unexpected size % instead of 4", size_of(type_of(PxTGSSolverContactDesc.numFrictionPatches)));
        assert(((cast(*void)(*instance.startContactPatchIndex)) - cast(*void)(*instance)) == 208, "PxTGSSolverContactDesc.startContactPatchIndex has unexpected offset % instead of 208", ((cast(*void)(*instance.startContactPatchIndex)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverContactDesc.startContactPatchIndex)) == 4, "PxTGSSolverContactDesc.startContactPatchIndex has unexpected size % instead of 4", size_of(type_of(PxTGSSolverContactDesc.startContactPatchIndex)));
        assert(((cast(*void)(*instance.numContactPatches)) - cast(*void)(*instance)) == 212, "PxTGSSolverContactDesc.numContactPatches has unexpected offset % instead of 212", ((cast(*void)(*instance.numContactPatches)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverContactDesc.numContactPatches)) == 2, "PxTGSSolverContactDesc.numContactPatches has unexpected size % instead of 2", size_of(type_of(PxTGSSolverContactDesc.numContactPatches)));
        assert(((cast(*void)(*instance.axisConstraintCount)) - cast(*void)(*instance)) == 214, "PxTGSSolverContactDesc.axisConstraintCount has unexpected offset % instead of 214", ((cast(*void)(*instance.axisConstraintCount)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverContactDesc.axisConstraintCount)) == 2, "PxTGSSolverContactDesc.axisConstraintCount has unexpected size % instead of 2", size_of(type_of(PxTGSSolverContactDesc.axisConstraintCount)));
        assert(((cast(*void)(*instance.maxImpulse)) - cast(*void)(*instance)) == 216, "PxTGSSolverContactDesc.maxImpulse has unexpected offset % instead of 216", ((cast(*void)(*instance.maxImpulse)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverContactDesc.maxImpulse)) == 4, "PxTGSSolverContactDesc.maxImpulse has unexpected size % instead of 4", size_of(type_of(PxTGSSolverContactDesc.maxImpulse)));
        assert(((cast(*void)(*instance.torsionalPatchRadius)) - cast(*void)(*instance)) == 220, "PxTGSSolverContactDesc.torsionalPatchRadius has unexpected offset % instead of 220", ((cast(*void)(*instance.torsionalPatchRadius)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverContactDesc.torsionalPatchRadius)) == 4, "PxTGSSolverContactDesc.torsionalPatchRadius has unexpected size % instead of 4", size_of(type_of(PxTGSSolverContactDesc.torsionalPatchRadius)));
        assert(((cast(*void)(*instance.minTorsionalPatchRadius)) - cast(*void)(*instance)) == 224, "PxTGSSolverContactDesc.minTorsionalPatchRadius has unexpected offset % instead of 224", ((cast(*void)(*instance.minTorsionalPatchRadius)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTGSSolverContactDesc.minTorsionalPatchRadius)) == 4, "PxTGSSolverContactDesc.minTorsionalPatchRadius has unexpected size % instead of 4", size_of(type_of(PxTGSSolverContactDesc.minTorsionalPatchRadius)));
        assert(size_of(PxTGSSolverContactDesc) == 240, "PxTGSSolverContactDesc has size % instead of 240", size_of(PxTGSSolverContactDesc));
    }

    PxSpatialForce :: struct {
        force:  PxVec3;
        pad0:   PxReal;
        torque: PxVec3;
        pad1:   PxReal;
    }
    #run {if true then return;
        instance: PxSpatialForce;
        assert(((cast(*void)(*instance.force)) - cast(*void)(*instance)) == 0, "PxSpatialForce.force has unexpected offset % instead of 0", ((cast(*void)(*instance.force)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSpatialForce.force)) == 12, "PxSpatialForce.force has unexpected size % instead of 12", size_of(type_of(PxSpatialForce.force)));
        assert(((cast(*void)(*instance.pad0)) - cast(*void)(*instance)) == 12, "PxSpatialForce.pad0 has unexpected offset % instead of 12", ((cast(*void)(*instance.pad0)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSpatialForce.pad0)) == 4, "PxSpatialForce.pad0 has unexpected size % instead of 4", size_of(type_of(PxSpatialForce.pad0)));
        assert(((cast(*void)(*instance.torque)) - cast(*void)(*instance)) == 16, "PxSpatialForce.torque has unexpected offset % instead of 16", ((cast(*void)(*instance.torque)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSpatialForce.torque)) == 12, "PxSpatialForce.torque has unexpected size % instead of 12", size_of(type_of(PxSpatialForce.torque)));
        assert(((cast(*void)(*instance.pad1)) - cast(*void)(*instance)) == 28, "PxSpatialForce.pad1 has unexpected offset % instead of 28", ((cast(*void)(*instance.pad1)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSpatialForce.pad1)) == 4, "PxSpatialForce.pad1 has unexpected size % instead of 4", size_of(type_of(PxSpatialForce.pad1)));
        assert(size_of(PxSpatialForce) == 32, "PxSpatialForce has size % instead of 32", size_of(PxSpatialForce));
    }

    PxSpatialVelocity :: struct {
        linear:  PxVec3;
        pad0:    PxReal;
        angular: PxVec3;
        pad1:    PxReal;
    }
    #run {if true then return;
        instance: PxSpatialVelocity;
        assert(((cast(*void)(*instance.linear)) - cast(*void)(*instance)) == 0, "PxSpatialVelocity.linear has unexpected offset % instead of 0", ((cast(*void)(*instance.linear)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSpatialVelocity.linear)) == 12, "PxSpatialVelocity.linear has unexpected size % instead of 12", size_of(type_of(PxSpatialVelocity.linear)));
        assert(((cast(*void)(*instance.pad0)) - cast(*void)(*instance)) == 12, "PxSpatialVelocity.pad0 has unexpected offset % instead of 12", ((cast(*void)(*instance.pad0)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSpatialVelocity.pad0)) == 4, "PxSpatialVelocity.pad0 has unexpected size % instead of 4", size_of(type_of(PxSpatialVelocity.pad0)));
        assert(((cast(*void)(*instance.angular)) - cast(*void)(*instance)) == 16, "PxSpatialVelocity.angular has unexpected offset % instead of 16", ((cast(*void)(*instance.angular)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSpatialVelocity.angular)) == 12, "PxSpatialVelocity.angular has unexpected size % instead of 12", size_of(type_of(PxSpatialVelocity.angular)));
        assert(((cast(*void)(*instance.pad1)) - cast(*void)(*instance)) == 28, "PxSpatialVelocity.pad1 has unexpected offset % instead of 28", ((cast(*void)(*instance.pad1)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSpatialVelocity.pad1)) == 4, "PxSpatialVelocity.pad1 has unexpected size % instead of 4", size_of(type_of(PxSpatialVelocity.pad1)));
        assert(size_of(PxSpatialVelocity) == 32, "PxSpatialVelocity has size % instead of 32", size_of(PxSpatialVelocity));
    }

    PxArticulationRootLinkData :: struct {
        transform:     PxTransform;
        worldLinVel:   PxVec3;
        worldAngVel:   PxVec3;
        worldLinAccel: PxVec3;
        worldAngAccel: PxVec3;
    }
    #run {if true then return;
        instance: PxArticulationRootLinkData;
        assert(((cast(*void)(*instance.transform)) - cast(*void)(*instance)) == 0, "PxArticulationRootLinkData.transform has unexpected offset % instead of 0", ((cast(*void)(*instance.transform)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxArticulationRootLinkData.transform)) == 28, "PxArticulationRootLinkData.transform has unexpected size % instead of 28", size_of(type_of(PxArticulationRootLinkData.transform)));
        assert(((cast(*void)(*instance.worldLinVel)) - cast(*void)(*instance)) == 28, "PxArticulationRootLinkData.worldLinVel has unexpected offset % instead of 28", ((cast(*void)(*instance.worldLinVel)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxArticulationRootLinkData.worldLinVel)) == 12, "PxArticulationRootLinkData.worldLinVel has unexpected size % instead of 12", size_of(type_of(PxArticulationRootLinkData.worldLinVel)));
        assert(((cast(*void)(*instance.worldAngVel)) - cast(*void)(*instance)) == 40, "PxArticulationRootLinkData.worldAngVel has unexpected offset % instead of 40", ((cast(*void)(*instance.worldAngVel)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxArticulationRootLinkData.worldAngVel)) == 12, "PxArticulationRootLinkData.worldAngVel has unexpected size % instead of 12", size_of(type_of(PxArticulationRootLinkData.worldAngVel)));
        assert(((cast(*void)(*instance.worldLinAccel)) - cast(*void)(*instance)) == 52, "PxArticulationRootLinkData.worldLinAccel has unexpected offset % instead of 52", ((cast(*void)(*instance.worldLinAccel)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxArticulationRootLinkData.worldLinAccel)) == 12, "PxArticulationRootLinkData.worldLinAccel has unexpected size % instead of 12", size_of(type_of(PxArticulationRootLinkData.worldLinAccel)));
        assert(((cast(*void)(*instance.worldAngAccel)) - cast(*void)(*instance)) == 64, "PxArticulationRootLinkData.worldAngAccel has unexpected offset % instead of 64", ((cast(*void)(*instance.worldAngAccel)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxArticulationRootLinkData.worldAngAccel)) == 12, "PxArticulationRootLinkData.worldAngAccel has unexpected size % instead of 12", size_of(type_of(PxArticulationRootLinkData.worldAngAccel)));
        assert(size_of(PxArticulationRootLinkData) == 76, "PxArticulationRootLinkData has size % instead of 76", size_of(PxArticulationRootLinkData));
    }

    PxArticulationCache :: struct {
        Enum :: enum s32 {
            VELOCITY         :: 1;
            ACCELERATION     :: 2;
            POSITION         :: 4;
            FORCE            :: 8;
            LINKVELOCITY     :: 16;
            LINKACCELERATION :: 32;
            ROOT             :: 64;
            ALL              :: 119;

            eVELOCITY         :: VELOCITY;
            eACCELERATION     :: ACCELERATION;
            ePOSITION         :: POSITION;
            eFORCE            :: FORCE;
            eLINKVELOCITY     :: LINKVELOCITY;
            eLINKACCELERATION :: LINKACCELERATION;
            eROOT             :: ROOT;
            eALL              :: ALL;
        }

        Constructor :: (this: *PxArticulationCache) -> void #cpp_method #foreign physx_lib "??0PxArticulationCache@physx@@QEAA@XZ";

        externalForces:    *PxSpatialForce; // N = getNbLinks()
        denseJacobian:     *PxReal; // N = 6*getDofs()*NumJoints, NumJoints = getNbLinks() - 1
        massMatrix:        *PxReal; // N = getDofs()*getDofs()
        jointVelocity:     *PxReal; // N = getDofs()
        jointAcceleration: *PxReal; // N = getDofs()
        jointPosition:     *PxReal; // N = getDofs()
        jointForce:        *PxReal; // N = getDofs()
        linkVelocity:      *PxSpatialVelocity; // N = getNbLinks()
        linkAcceleration:  *PxSpatialVelocity; // N = getNbLinks()
        rootLinkData:      *PxArticulationRootLinkData; // root link Data

        //application need to allocate those memory and assign them to the cache
        coefficientMatrix: *PxReal;
        lambda:            *PxReal;

        scratchMemory:     *void; //this is used for internal calculation
        scratchAllocator:  *void;
        version:           PxU32; //cache version. If the articulation configuration change, the cache is invalid
    }
    #run {if true then return;
        instance: PxArticulationCache;
        assert(((cast(*void)(*instance.externalForces)) - cast(*void)(*instance)) == 0, "PxArticulationCache.externalForces has unexpected offset % instead of 0", ((cast(*void)(*instance.externalForces)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxArticulationCache.externalForces)) == 8, "PxArticulationCache.externalForces has unexpected size % instead of 8", size_of(type_of(PxArticulationCache.externalForces)));
        assert(((cast(*void)(*instance.denseJacobian)) - cast(*void)(*instance)) == 8, "PxArticulationCache.denseJacobian has unexpected offset % instead of 8", ((cast(*void)(*instance.denseJacobian)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxArticulationCache.denseJacobian)) == 8, "PxArticulationCache.denseJacobian has unexpected size % instead of 8", size_of(type_of(PxArticulationCache.denseJacobian)));
        assert(((cast(*void)(*instance.massMatrix)) - cast(*void)(*instance)) == 16, "PxArticulationCache.massMatrix has unexpected offset % instead of 16", ((cast(*void)(*instance.massMatrix)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxArticulationCache.massMatrix)) == 8, "PxArticulationCache.massMatrix has unexpected size % instead of 8", size_of(type_of(PxArticulationCache.massMatrix)));
        assert(((cast(*void)(*instance.jointVelocity)) - cast(*void)(*instance)) == 24, "PxArticulationCache.jointVelocity has unexpected offset % instead of 24", ((cast(*void)(*instance.jointVelocity)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxArticulationCache.jointVelocity)) == 8, "PxArticulationCache.jointVelocity has unexpected size % instead of 8", size_of(type_of(PxArticulationCache.jointVelocity)));
        assert(((cast(*void)(*instance.jointAcceleration)) - cast(*void)(*instance)) == 32, "PxArticulationCache.jointAcceleration has unexpected offset % instead of 32", ((cast(*void)(*instance.jointAcceleration)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxArticulationCache.jointAcceleration)) == 8, "PxArticulationCache.jointAcceleration has unexpected size % instead of 8", size_of(type_of(PxArticulationCache.jointAcceleration)));
        assert(((cast(*void)(*instance.jointPosition)) - cast(*void)(*instance)) == 40, "PxArticulationCache.jointPosition has unexpected offset % instead of 40", ((cast(*void)(*instance.jointPosition)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxArticulationCache.jointPosition)) == 8, "PxArticulationCache.jointPosition has unexpected size % instead of 8", size_of(type_of(PxArticulationCache.jointPosition)));
        assert(((cast(*void)(*instance.jointForce)) - cast(*void)(*instance)) == 48, "PxArticulationCache.jointForce has unexpected offset % instead of 48", ((cast(*void)(*instance.jointForce)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxArticulationCache.jointForce)) == 8, "PxArticulationCache.jointForce has unexpected size % instead of 8", size_of(type_of(PxArticulationCache.jointForce)));
        assert(((cast(*void)(*instance.linkVelocity)) - cast(*void)(*instance)) == 56, "PxArticulationCache.linkVelocity has unexpected offset % instead of 56", ((cast(*void)(*instance.linkVelocity)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxArticulationCache.linkVelocity)) == 8, "PxArticulationCache.linkVelocity has unexpected size % instead of 8", size_of(type_of(PxArticulationCache.linkVelocity)));
        assert(((cast(*void)(*instance.linkAcceleration)) - cast(*void)(*instance)) == 64, "PxArticulationCache.linkAcceleration has unexpected offset % instead of 64", ((cast(*void)(*instance.linkAcceleration)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxArticulationCache.linkAcceleration)) == 8, "PxArticulationCache.linkAcceleration has unexpected size % instead of 8", size_of(type_of(PxArticulationCache.linkAcceleration)));
        assert(((cast(*void)(*instance.rootLinkData)) - cast(*void)(*instance)) == 72, "PxArticulationCache.rootLinkData has unexpected offset % instead of 72", ((cast(*void)(*instance.rootLinkData)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxArticulationCache.rootLinkData)) == 8, "PxArticulationCache.rootLinkData has unexpected size % instead of 8", size_of(type_of(PxArticulationCache.rootLinkData)));
        assert(((cast(*void)(*instance.coefficientMatrix)) - cast(*void)(*instance)) == 80, "PxArticulationCache.coefficientMatrix has unexpected offset % instead of 80", ((cast(*void)(*instance.coefficientMatrix)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxArticulationCache.coefficientMatrix)) == 8, "PxArticulationCache.coefficientMatrix has unexpected size % instead of 8", size_of(type_of(PxArticulationCache.coefficientMatrix)));
        assert(((cast(*void)(*instance.lambda)) - cast(*void)(*instance)) == 88, "PxArticulationCache.lambda has unexpected offset % instead of 88", ((cast(*void)(*instance.lambda)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxArticulationCache.lambda)) == 8, "PxArticulationCache.lambda has unexpected size % instead of 8", size_of(type_of(PxArticulationCache.lambda)));
        assert(((cast(*void)(*instance.scratchMemory)) - cast(*void)(*instance)) == 96, "PxArticulationCache.scratchMemory has unexpected offset % instead of 96", ((cast(*void)(*instance.scratchMemory)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxArticulationCache.scratchMemory)) == 8, "PxArticulationCache.scratchMemory has unexpected size % instead of 8", size_of(type_of(PxArticulationCache.scratchMemory)));
        assert(((cast(*void)(*instance.scratchAllocator)) - cast(*void)(*instance)) == 104, "PxArticulationCache.scratchAllocator has unexpected offset % instead of 104", ((cast(*void)(*instance.scratchAllocator)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxArticulationCache.scratchAllocator)) == 8, "PxArticulationCache.scratchAllocator has unexpected size % instead of 8", size_of(type_of(PxArticulationCache.scratchAllocator)));
        assert(((cast(*void)(*instance.version)) - cast(*void)(*instance)) == 112, "PxArticulationCache.version has unexpected offset % instead of 112", ((cast(*void)(*instance.version)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxArticulationCache.version)) == 4, "PxArticulationCache.version has unexpected size % instead of 4", size_of(type_of(PxArticulationCache.version)));
        assert(size_of(PxArticulationCache) == 120, "PxArticulationCache has size % instead of 120", size_of(PxArticulationCache));
    }

    PxArticulationCacheFlags :: PxFlags(PxArticulationCache.Enum, PxU8);

    PxArticulationReducedCoordinate :: struct {
        #as using pxarticulationbase: PxArticulationBase;
        #place pxarticulationbase; pxarticulationreducedcoordinate_vtable: *PxArticulationReducedCoordinate_VTable;
    }
    PxArticulationReducedCoordinate_VTable :: struct #type_info_none {
        using pxarticulationbase: PxArticulationBase_VTable;
        setArticulationFlags: (this: *PxArticulationReducedCoordinate, flags: PxArticulationFlags) -> void #cpp_method;

        setArticulationFlag: (this: *PxArticulationReducedCoordinate, flag: PxArticulationFlag.Enum, value: bool) -> void #cpp_method;

        getArticulationFlags: (this: *PxArticulationReducedCoordinate) -> PxArticulationFlags #cpp_method;

        getDofs: (this: *PxArticulationReducedCoordinate) -> PxU32 #cpp_method;

        createCache: (this: *PxArticulationReducedCoordinate) -> *PxArticulationCache #cpp_method;

        getCacheDataSize: (this: *PxArticulationReducedCoordinate) -> PxU32 #cpp_method;

        zeroCache: (this: *PxArticulationReducedCoordinate, cache: *PxArticulationCache) -> void #cpp_method;

        applyCache: (this: *PxArticulationReducedCoordinate, cache: *PxArticulationCache, flag: PxArticulationCacheFlags, autowake := true) -> void #cpp_method;

        copyInternalStateToCache: (this: *PxArticulationReducedCoordinate, cache: *PxArticulationCache, flag: PxArticulationCacheFlags) -> void #cpp_method;

        releaseCache: (this: *PxArticulationReducedCoordinate, cache: *PxArticulationCache) -> void #cpp_method;

        packJointData: (this: *PxArticulationReducedCoordinate, maximum: *PxReal, reduced: *PxReal) -> void #cpp_method;

        unpackJointData: (this: *PxArticulationReducedCoordinate, reduced: *PxReal, maximum: *PxReal) -> void #cpp_method;

        commonInit: (this: *PxArticulationReducedCoordinate) -> void #cpp_method;

        computeGeneralizedGravityForce: (this: *PxArticulationReducedCoordinate, cache: *PxArticulationCache) -> void #cpp_method;

        computeCoriolisAndCentrifugalForce: (this: *PxArticulationReducedCoordinate, cache: *PxArticulationCache) -> void #cpp_method;

        computeGeneralizedExternalForce: (this: *PxArticulationReducedCoordinate, cache: *PxArticulationCache) -> void #cpp_method;

        computeJointAcceleration: (this: *PxArticulationReducedCoordinate, cache: *PxArticulationCache) -> void #cpp_method;

        computeJointForce: (this: *PxArticulationReducedCoordinate, cache: *PxArticulationCache) -> void #cpp_method;

        computeDenseJacobian: (this: *PxArticulationReducedCoordinate, cache: *PxArticulationCache, nRows: *PxU32, nCols: *PxU32) -> void #cpp_method;

        computeCoefficientMatrix: (this: *PxArticulationReducedCoordinate, cache: *PxArticulationCache) -> void #cpp_method;

        computeLambda: (this: *PxArticulationReducedCoordinate, cache: *PxArticulationCache, initialState: *PxArticulationCache, jointTorque: *PxReal, maxIter: PxU32) -> bool #cpp_method;

        computeGeneralizedMassMatrix: (this: *PxArticulationReducedCoordinate, cache: *PxArticulationCache) -> void #cpp_method;

        addLoopJoint: (this: *PxArticulationReducedCoordinate, joint: *PxJoint) -> void #cpp_method;

        removeLoopJoint: (this: *PxArticulationReducedCoordinate, joint: *PxJoint) -> void #cpp_method;

        getNbLoopJoints: (this: *PxArticulationReducedCoordinate) -> PxU32 #cpp_method;

        getLoopJoints: (this: *PxArticulationReducedCoordinate, userBuffer: **PxJoint, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        getCoefficientMatrixSize: (this: *PxArticulationReducedCoordinate) -> PxU32 #cpp_method;

        teleportRootLink: (this: *PxArticulationReducedCoordinate, pose: *PxTransform, autowake: bool) -> void #cpp_method;

        getLinkVelocity: (this: *PxArticulationReducedCoordinate, linkId: PxU32) -> PxSpatialVelocity #cpp_method;

        getLinkAcceleration: (this: *PxArticulationReducedCoordinate, linkId: PxU32) -> PxSpatialVelocity #cpp_method;
    }

    PxArticulationReducedCoordinate_setArticulationFlags :: inline (this: *PxArticulationReducedCoordinate, flags: PxArticulationFlags) { this.pxarticulationreducedcoordinate_vtable.setArticulationFlags(this, flags); }

    PxArticulationReducedCoordinate_setArticulationFlag :: inline (this: *PxArticulationReducedCoordinate, flag: PxArticulationFlag.Enum, value: bool) { this.pxarticulationreducedcoordinate_vtable.setArticulationFlag(this, flag, value); }

    PxArticulationReducedCoordinate_getArticulationFlags :: inline (this: *PxArticulationReducedCoordinate) -> PxArticulationFlags { return this.pxarticulationreducedcoordinate_vtable.getArticulationFlags(this); }

    PxArticulationReducedCoordinate_getDofs :: inline (this: *PxArticulationReducedCoordinate) -> PxU32 { return this.pxarticulationreducedcoordinate_vtable.getDofs(this); }

    PxArticulationReducedCoordinate_createCache :: inline (this: *PxArticulationReducedCoordinate) -> *PxArticulationCache { return this.pxarticulationreducedcoordinate_vtable.createCache(this); }

    PxArticulationReducedCoordinate_getCacheDataSize :: inline (this: *PxArticulationReducedCoordinate) -> PxU32 { return this.pxarticulationreducedcoordinate_vtable.getCacheDataSize(this); }

    PxArticulationReducedCoordinate_zeroCache :: inline (this: *PxArticulationReducedCoordinate, cache: *PxArticulationCache) { this.pxarticulationreducedcoordinate_vtable.zeroCache(this, cache); }

    PxArticulationReducedCoordinate_applyCache :: inline (this: *PxArticulationReducedCoordinate, cache: *PxArticulationCache, flag: PxArticulationCacheFlags, autowake := true) { this.pxarticulationreducedcoordinate_vtable.applyCache(this, cache, flag, autowake); }

    PxArticulationReducedCoordinate_copyInternalStateToCache :: inline (this: *PxArticulationReducedCoordinate, cache: *PxArticulationCache, flag: PxArticulationCacheFlags) { this.pxarticulationreducedcoordinate_vtable.copyInternalStateToCache(this, cache, flag); }

    PxArticulationReducedCoordinate_releaseCache :: inline (this: *PxArticulationReducedCoordinate, cache: *PxArticulationCache) { this.pxarticulationreducedcoordinate_vtable.releaseCache(this, cache); }

    PxArticulationReducedCoordinate_packJointData :: inline (this: *PxArticulationReducedCoordinate, maximum: *PxReal, reduced: *PxReal) { this.pxarticulationreducedcoordinate_vtable.packJointData(this, maximum, reduced); }

    PxArticulationReducedCoordinate_unpackJointData :: inline (this: *PxArticulationReducedCoordinate, reduced: *PxReal, maximum: *PxReal) { this.pxarticulationreducedcoordinate_vtable.unpackJointData(this, reduced, maximum); }

    PxArticulationReducedCoordinate_commonInit :: inline (this: *PxArticulationReducedCoordinate) { this.pxarticulationreducedcoordinate_vtable.commonInit(this); }

    PxArticulationReducedCoordinate_computeGeneralizedGravityForce :: inline (this: *PxArticulationReducedCoordinate, cache: *PxArticulationCache) { this.pxarticulationreducedcoordinate_vtable.computeGeneralizedGravityForce(this, cache); }

    PxArticulationReducedCoordinate_computeCoriolisAndCentrifugalForce :: inline (this: *PxArticulationReducedCoordinate, cache: *PxArticulationCache) { this.pxarticulationreducedcoordinate_vtable.computeCoriolisAndCentrifugalForce(this, cache); }

    PxArticulationReducedCoordinate_computeGeneralizedExternalForce :: inline (this: *PxArticulationReducedCoordinate, cache: *PxArticulationCache) { this.pxarticulationreducedcoordinate_vtable.computeGeneralizedExternalForce(this, cache); }

    PxArticulationReducedCoordinate_computeJointAcceleration :: inline (this: *PxArticulationReducedCoordinate, cache: *PxArticulationCache) { this.pxarticulationreducedcoordinate_vtable.computeJointAcceleration(this, cache); }

    PxArticulationReducedCoordinate_computeJointForce :: inline (this: *PxArticulationReducedCoordinate, cache: *PxArticulationCache) { this.pxarticulationreducedcoordinate_vtable.computeJointForce(this, cache); }

    PxArticulationReducedCoordinate_computeDenseJacobian :: inline (this: *PxArticulationReducedCoordinate, cache: *PxArticulationCache, nRows: *PxU32, nCols: *PxU32) { this.pxarticulationreducedcoordinate_vtable.computeDenseJacobian(this, cache, nRows, nCols); }

    PxArticulationReducedCoordinate_computeCoefficientMatrix :: inline (this: *PxArticulationReducedCoordinate, cache: *PxArticulationCache) { this.pxarticulationreducedcoordinate_vtable.computeCoefficientMatrix(this, cache); }

    PxArticulationReducedCoordinate_computeLambda :: inline (this: *PxArticulationReducedCoordinate, cache: *PxArticulationCache, initialState: *PxArticulationCache, jointTorque: *PxReal, maxIter: PxU32) -> bool { return this.pxarticulationreducedcoordinate_vtable.computeLambda(this, cache, initialState, jointTorque, maxIter); }

    PxArticulationReducedCoordinate_computeGeneralizedMassMatrix :: inline (this: *PxArticulationReducedCoordinate, cache: *PxArticulationCache) { this.pxarticulationreducedcoordinate_vtable.computeGeneralizedMassMatrix(this, cache); }

    PxArticulationReducedCoordinate_addLoopJoint :: inline (this: *PxArticulationReducedCoordinate, joint: *PxJoint) { this.pxarticulationreducedcoordinate_vtable.addLoopJoint(this, joint); }

    PxArticulationReducedCoordinate_removeLoopJoint :: inline (this: *PxArticulationReducedCoordinate, joint: *PxJoint) { this.pxarticulationreducedcoordinate_vtable.removeLoopJoint(this, joint); }

    PxArticulationReducedCoordinate_getNbLoopJoints :: inline (this: *PxArticulationReducedCoordinate) -> PxU32 { return this.pxarticulationreducedcoordinate_vtable.getNbLoopJoints(this); }

    PxArticulationReducedCoordinate_getLoopJoints :: inline (this: *PxArticulationReducedCoordinate, userBuffer: **PxJoint, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.pxarticulationreducedcoordinate_vtable.getLoopJoints(this, userBuffer, bufferSize, startIndex); }

    PxArticulationReducedCoordinate_getCoefficientMatrixSize :: inline (this: *PxArticulationReducedCoordinate) -> PxU32 { return this.pxarticulationreducedcoordinate_vtable.getCoefficientMatrixSize(this); }

    PxArticulationReducedCoordinate_teleportRootLink :: inline (this: *PxArticulationReducedCoordinate, pose: *PxTransform, autowake: bool) { this.pxarticulationreducedcoordinate_vtable.teleportRootLink(this, pose, autowake); }

    PxArticulationReducedCoordinate_getLinkVelocity :: inline (this: *PxArticulationReducedCoordinate, linkId: PxU32) -> PxSpatialVelocity { return this.pxarticulationreducedcoordinate_vtable.getLinkVelocity(this, linkId); }

    PxArticulationReducedCoordinate_getLinkAcceleration :: inline (this: *PxArticulationReducedCoordinate, linkId: PxU32) -> PxSpatialVelocity { return this.pxarticulationreducedcoordinate_vtable.getLinkAcceleration(this, linkId); }

    vtable :: (obj: *PxArticulationReducedCoordinate) -> *PxArticulationReducedCoordinate_VTable { return obj.pxarticulationreducedcoordinate_vtable; }

    #run {if true then return;
        assert(size_of(type_of(PxArticulationReducedCoordinate.pxarticulationbase)) == 24, "PxArticulationReducedCoordinate.pxarticulationbase has unexpected size % instead of 24", size_of(type_of(PxArticulationReducedCoordinate.pxarticulationbase)));
        assert(size_of(PxArticulationReducedCoordinate) == 24, "PxArticulationReducedCoordinate has size % instead of 24", size_of(PxArticulationReducedCoordinate));
    }

    PxArticulationJointImpl :: struct {}

    /**
    \brief The type of joint drive to use for the articulation joint.

    Two drive models are currently supported. in the TARGET model, the drive spring displacement will be determined
    as the rotation vector from the relative quaternion beetween child and parent, and the target quaternion.

    In the ERROR model, the drive spring displacement will be taken directly from the imaginary part of the relative
    quaternion. This drive model requires more computation on the part of the application, but allows driving the joint
    with a spring displacement that is more than a complete rotation.

    @see PxArticulationJoint
    */
    PxArticulationJointDriveType :: struct {
        Enum :: enum s32 {
            TARGET :: 0;
            ERROR  :: 1;

            eTARGET :: TARGET;
            eERROR  :: ERROR;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxArticulationJointDriveType) == 1, "PxArticulationJointDriveType has size % instead of 1", size_of(PxArticulationJointDriveType));
    }

    PxArticulationJointBase :: struct {
        #as using pxbase: PxBase;
        #place pxbase; pxarticulationjointbase_vtable: *PxArticulationJointBase_VTable;
    }
    PxArticulationJointBase_VTable :: struct #type_info_none {
        using pxbase: PxBase_VTable;
        getParentArticulationLink: (this: *PxArticulationJointBase) -> *PxArticulationLink #cpp_method;

        setParentPose: (this: *PxArticulationJointBase, pose: *PxTransform) -> void #cpp_method;

        getParentPose: (this: *PxArticulationJointBase) -> PxTransform #cpp_method #cpp_return_type_is_non_pod;

        getChildArticulationLink: (this: *PxArticulationJointBase) -> *PxArticulationLink #cpp_method;

        setChildPose: (this: *PxArticulationJointBase, pose: *PxTransform) -> void #cpp_method;

        getChildPose: (this: *PxArticulationJointBase) -> PxTransform #cpp_method #cpp_return_type_is_non_pod;

        getImpl_1: (this: /*const*/ *PxArticulationJointBase) -> *PxArticulationJointImpl #cpp_method;

        getImpl: (this: *PxArticulationJointBase) -> *PxArticulationJointImpl #cpp_method;
    }

    PxArticulationJointBase_getParentArticulationLink :: inline (this: *PxArticulationJointBase) -> *PxArticulationLink { return this.pxarticulationjointbase_vtable.getParentArticulationLink(this); }

    PxArticulationJointBase_setParentPose :: inline (this: *PxArticulationJointBase, pose: *PxTransform) { this.pxarticulationjointbase_vtable.setParentPose(this, pose); }

    PxArticulationJointBase_getParentPose :: inline (this: *PxArticulationJointBase) -> PxTransform { return this.pxarticulationjointbase_vtable.getParentPose(this); }

    PxArticulationJointBase_getChildArticulationLink :: inline (this: *PxArticulationJointBase) -> *PxArticulationLink { return this.pxarticulationjointbase_vtable.getChildArticulationLink(this); }

    PxArticulationJointBase_setChildPose :: inline (this: *PxArticulationJointBase, pose: *PxTransform) { this.pxarticulationjointbase_vtable.setChildPose(this, pose); }

    PxArticulationJointBase_getChildPose :: inline (this: *PxArticulationJointBase) -> PxTransform { return this.pxarticulationjointbase_vtable.getChildPose(this); }

    PxArticulationJointBase_getImpl_1 :: inline (this: /*const*/ *PxArticulationJointBase) -> *PxArticulationJointImpl { return this.pxarticulationjointbase_vtable.getImpl_1(this); }

    PxArticulationJointBase_getImpl :: inline (this: *PxArticulationJointBase) -> *PxArticulationJointImpl { return this.pxarticulationjointbase_vtable.getImpl(this); }

    vtable :: (obj: *PxArticulationJointBase) -> *PxArticulationJointBase_VTable { return obj.pxarticulationjointbase_vtable; }

    #run {if true then return;
        assert(size_of(type_of(PxArticulationJointBase.pxbase)) == 16, "PxArticulationJointBase.pxbase has unexpected size % instead of 16", size_of(type_of(PxArticulationJointBase.pxbase)));
        assert(size_of(PxArticulationJointBase) == 16, "PxArticulationJointBase has size % instead of 16", size_of(PxArticulationJointBase));
    }

    /**
    \brief a joint between two links in an articulation.

    The joint model is very similar to a PxSphericalJoint with swing and twist limits,
    and an implicit drive model.

    @see PxArticulation PxArticulationLink
    */
    PxArticulationJoint :: struct {
        #as using pxarticulationjointbase: PxArticulationJointBase;
        #place pxarticulationjointbase; pxarticulationjoint_vtable: *PxArticulationJoint_VTable;
    }
    PxArticulationJoint_VTable :: struct #type_info_none {
        using pxarticulationjointbase: PxArticulationJointBase_VTable;
        setTargetOrientation: (this: *PxArticulationJoint, orientation: *PxQuat) -> void #cpp_method;

        getTargetOrientation: (this: *PxArticulationJoint) -> PxQuat #cpp_method #cpp_return_type_is_non_pod;

        setTargetVelocity: (this: *PxArticulationJoint, velocity: *PxVec3) -> void #cpp_method;

        getTargetVelocity: (this: *PxArticulationJoint) -> PxVec3 #cpp_method #cpp_return_type_is_non_pod;

        setDriveType: (this: *PxArticulationJoint, driveType: PxArticulationJointDriveType.Enum) -> void #cpp_method;

        getDriveType: (this: *PxArticulationJoint) -> PxArticulationJointDriveType.Enum #cpp_method;

        setStiffness: (this: *PxArticulationJoint, spring: PxReal) -> void #cpp_method;

        getStiffness: (this: *PxArticulationJoint) -> PxReal #cpp_method;

        setDamping: (this: *PxArticulationJoint, damping: PxReal) -> void #cpp_method;

        getDamping: (this: *PxArticulationJoint) -> PxReal #cpp_method;

        setInternalCompliance: (this: *PxArticulationJoint, compliance: PxReal) -> void #cpp_method;

        getInternalCompliance: (this: *PxArticulationJoint) -> PxReal #cpp_method;

        setExternalCompliance: (this: *PxArticulationJoint, compliance: PxReal) -> void #cpp_method;

        getExternalCompliance: (this: *PxArticulationJoint) -> PxReal #cpp_method;

        setSwingLimit: (this: *PxArticulationJoint, zLimit: PxReal, yLimit: PxReal) -> void #cpp_method;

        getSwingLimit: (this: *PxArticulationJoint, zLimit: *PxReal, yLimit: *PxReal) -> void #cpp_method;

        setTangentialStiffness: (this: *PxArticulationJoint, spring: PxReal) -> void #cpp_method;

        getTangentialStiffness: (this: *PxArticulationJoint) -> PxReal #cpp_method;

        setTangentialDamping: (this: *PxArticulationJoint, damping: PxReal) -> void #cpp_method;

        getTangentialDamping: (this: *PxArticulationJoint) -> PxReal #cpp_method;

        setSwingLimitContactDistance: (this: *PxArticulationJoint, contactDistance: PxReal) -> void #cpp_method;

        getSwingLimitContactDistance: (this: *PxArticulationJoint) -> PxReal #cpp_method;

        setSwingLimitEnabled: (this: *PxArticulationJoint, enabled: bool) -> void #cpp_method;

        getSwingLimitEnabled: (this: *PxArticulationJoint) -> bool #cpp_method;

        setTwistLimit: (this: *PxArticulationJoint, lower: PxReal, upper: PxReal) -> void #cpp_method;

        getTwistLimit: (this: *PxArticulationJoint, lower: *PxReal, upper: *PxReal) -> void #cpp_method;

        setTwistLimitEnabled: (this: *PxArticulationJoint, enabled: bool) -> void #cpp_method;

        getTwistLimitEnabled: (this: *PxArticulationJoint) -> bool #cpp_method;

        setTwistLimitContactDistance: (this: *PxArticulationJoint, contactDistance: PxReal) -> void #cpp_method;

        getTwistLimitContactDistance: (this: *PxArticulationJoint) -> PxReal #cpp_method;
    }

    PxArticulationJoint_setTargetOrientation :: inline (this: *PxArticulationJoint, orientation: *PxQuat) { this.pxarticulationjoint_vtable.setTargetOrientation(this, orientation); }

    PxArticulationJoint_getTargetOrientation :: inline (this: *PxArticulationJoint) -> PxQuat { return this.pxarticulationjoint_vtable.getTargetOrientation(this); }

    PxArticulationJoint_setTargetVelocity :: inline (this: *PxArticulationJoint, velocity: *PxVec3) { this.pxarticulationjoint_vtable.setTargetVelocity(this, velocity); }

    PxArticulationJoint_getTargetVelocity :: inline (this: *PxArticulationJoint) -> PxVec3 { return this.pxarticulationjoint_vtable.getTargetVelocity(this); }

    PxArticulationJoint_setDriveType :: inline (this: *PxArticulationJoint, driveType: PxArticulationJointDriveType.Enum) { this.pxarticulationjoint_vtable.setDriveType(this, driveType); }

    PxArticulationJoint_getDriveType :: inline (this: *PxArticulationJoint) -> PxArticulationJointDriveType.Enum { return this.pxarticulationjoint_vtable.getDriveType(this); }

    PxArticulationJoint_setStiffness :: inline (this: *PxArticulationJoint, spring: PxReal) { this.pxarticulationjoint_vtable.setStiffness(this, spring); }

    PxArticulationJoint_getStiffness :: inline (this: *PxArticulationJoint) -> PxReal { return this.pxarticulationjoint_vtable.getStiffness(this); }

    PxArticulationJoint_setDamping :: inline (this: *PxArticulationJoint, damping: PxReal) { this.pxarticulationjoint_vtable.setDamping(this, damping); }

    PxArticulationJoint_getDamping :: inline (this: *PxArticulationJoint) -> PxReal { return this.pxarticulationjoint_vtable.getDamping(this); }

    PxArticulationJoint_setInternalCompliance :: inline (this: *PxArticulationJoint, compliance: PxReal) { this.pxarticulationjoint_vtable.setInternalCompliance(this, compliance); }

    PxArticulationJoint_getInternalCompliance :: inline (this: *PxArticulationJoint) -> PxReal { return this.pxarticulationjoint_vtable.getInternalCompliance(this); }

    PxArticulationJoint_setExternalCompliance :: inline (this: *PxArticulationJoint, compliance: PxReal) { this.pxarticulationjoint_vtable.setExternalCompliance(this, compliance); }

    PxArticulationJoint_getExternalCompliance :: inline (this: *PxArticulationJoint) -> PxReal { return this.pxarticulationjoint_vtable.getExternalCompliance(this); }

    PxArticulationJoint_setSwingLimit :: inline (this: *PxArticulationJoint, zLimit: PxReal, yLimit: PxReal) { this.pxarticulationjoint_vtable.setSwingLimit(this, zLimit, yLimit); }

    PxArticulationJoint_getSwingLimit :: inline (this: *PxArticulationJoint, zLimit: *PxReal, yLimit: *PxReal) { this.pxarticulationjoint_vtable.getSwingLimit(this, zLimit, yLimit); }

    PxArticulationJoint_setTangentialStiffness :: inline (this: *PxArticulationJoint, spring: PxReal) { this.pxarticulationjoint_vtable.setTangentialStiffness(this, spring); }

    PxArticulationJoint_getTangentialStiffness :: inline (this: *PxArticulationJoint) -> PxReal { return this.pxarticulationjoint_vtable.getTangentialStiffness(this); }

    PxArticulationJoint_setTangentialDamping :: inline (this: *PxArticulationJoint, damping: PxReal) { this.pxarticulationjoint_vtable.setTangentialDamping(this, damping); }

    PxArticulationJoint_getTangentialDamping :: inline (this: *PxArticulationJoint) -> PxReal { return this.pxarticulationjoint_vtable.getTangentialDamping(this); }

    PxArticulationJoint_setSwingLimitContactDistance :: inline (this: *PxArticulationJoint, contactDistance: PxReal) { this.pxarticulationjoint_vtable.setSwingLimitContactDistance(this, contactDistance); }

    PxArticulationJoint_getSwingLimitContactDistance :: inline (this: *PxArticulationJoint) -> PxReal { return this.pxarticulationjoint_vtable.getSwingLimitContactDistance(this); }

    PxArticulationJoint_setSwingLimitEnabled :: inline (this: *PxArticulationJoint, enabled: bool) { this.pxarticulationjoint_vtable.setSwingLimitEnabled(this, enabled); }

    PxArticulationJoint_getSwingLimitEnabled :: inline (this: *PxArticulationJoint) -> bool { return this.pxarticulationjoint_vtable.getSwingLimitEnabled(this); }

    PxArticulationJoint_setTwistLimit :: inline (this: *PxArticulationJoint, lower: PxReal, upper: PxReal) { this.pxarticulationjoint_vtable.setTwistLimit(this, lower, upper); }

    PxArticulationJoint_getTwistLimit :: inline (this: *PxArticulationJoint, lower: *PxReal, upper: *PxReal) { this.pxarticulationjoint_vtable.getTwistLimit(this, lower, upper); }

    PxArticulationJoint_setTwistLimitEnabled :: inline (this: *PxArticulationJoint, enabled: bool) { this.pxarticulationjoint_vtable.setTwistLimitEnabled(this, enabled); }

    PxArticulationJoint_getTwistLimitEnabled :: inline (this: *PxArticulationJoint) -> bool { return this.pxarticulationjoint_vtable.getTwistLimitEnabled(this); }

    PxArticulationJoint_setTwistLimitContactDistance :: inline (this: *PxArticulationJoint, contactDistance: PxReal) { this.pxarticulationjoint_vtable.setTwistLimitContactDistance(this, contactDistance); }

    PxArticulationJoint_getTwistLimitContactDistance :: inline (this: *PxArticulationJoint) -> PxReal { return this.pxarticulationjoint_vtable.getTwistLimitContactDistance(this); }

    vtable :: (obj: *PxArticulationJoint) -> *PxArticulationJoint_VTable { return obj.pxarticulationjoint_vtable; }

    #run {if true then return;
        assert(size_of(type_of(PxArticulationJoint.pxarticulationjointbase)) == 16, "PxArticulationJoint.pxarticulationjointbase has unexpected size % instead of 16", size_of(type_of(PxArticulationJoint.pxarticulationjointbase)));
        assert(size_of(PxArticulationJoint) == 16, "PxArticulationJoint has size % instead of 16", size_of(PxArticulationJoint));
    }

    /**
    \brief a joint between two links in an articulation.

    The joint model is very similar to a PxSphericalJoint with swing and twist limits,
    and an implicit drive model.

    @see PxArticulation PxArticulationLink
    */
    PxArticulationJointReducedCoordinate :: struct {
        #as using pxarticulationjointbase: PxArticulationJointBase;
        #place pxarticulationjointbase; pxarticulationjointreducedcoordinate_vtable: *PxArticulationJointReducedCoordinate_VTable;
    }
    PxArticulationJointReducedCoordinate_VTable :: struct #type_info_none {
        using pxarticulationjointbase: PxArticulationJointBase_VTable;
        setJointType: (this: *PxArticulationJointReducedCoordinate, jointType: PxArticulationJointType.Enum) -> void #cpp_method;
        getJointType: (this: *PxArticulationJointReducedCoordinate) -> PxArticulationJointType.Enum #cpp_method;

        setMotion: (this: *PxArticulationJointReducedCoordinate, axis: PxArticulationAxis.Enum, motion: PxArticulationMotion.Enum) -> void #cpp_method;
        getMotion: (this: *PxArticulationJointReducedCoordinate, axis: PxArticulationAxis.Enum) -> PxArticulationMotion.Enum #cpp_method;

        setLimit: (this: *PxArticulationJointReducedCoordinate, axis: PxArticulationAxis.Enum, lowLimit: PxReal, highLimit: PxReal) -> void #cpp_method;
        getLimit: (this: *PxArticulationJointReducedCoordinate, axis: PxArticulationAxis.Enum, lowLimit: *PxReal, highLimit: *PxReal) -> void #cpp_method;
        setDrive: (this: *PxArticulationJointReducedCoordinate, axis: PxArticulationAxis.Enum, stiffness: PxReal, damping: PxReal, maxForce: PxReal, driveType: PxArticulationDriveType.Enum = .FORCE) -> void #cpp_method;
        getDrive: (this: *PxArticulationJointReducedCoordinate, axis: PxArticulationAxis.Enum, stiffness: *PxReal, damping: *PxReal, maxForce: *PxReal, driveType: *PxArticulationDriveType.Enum) -> void #cpp_method;
        setDriveTarget: (this: *PxArticulationJointReducedCoordinate, axis: PxArticulationAxis.Enum, target: PxReal) -> void #cpp_method;
        setDriveVelocity: (this: *PxArticulationJointReducedCoordinate, axis: PxArticulationAxis.Enum, targetVel: PxReal) -> void #cpp_method;
        getDriveTarget: (this: *PxArticulationJointReducedCoordinate, axis: PxArticulationAxis.Enum) -> PxReal #cpp_method;
        getDriveVelocity: (this: *PxArticulationJointReducedCoordinate, axis: PxArticulationAxis.Enum) -> PxReal #cpp_method;

        setFrictionCoefficient: (this: *PxArticulationJointReducedCoordinate, coefficient: PxReal) -> void #cpp_method;
        getFrictionCoefficient: (this: *PxArticulationJointReducedCoordinate) -> PxReal #cpp_method;

        setMaxJointVelocity: (this: *PxArticulationJointReducedCoordinate, maxJointV: PxReal) -> void #cpp_method;
        getMaxJointVelocity: (this: *PxArticulationJointReducedCoordinate) -> PxReal #cpp_method;
    }

    PxArticulationJointReducedCoordinate_setJointType :: inline (this: *PxArticulationJointReducedCoordinate, jointType: PxArticulationJointType.Enum) { this.pxarticulationjointreducedcoordinate_vtable.setJointType(this, jointType); }
    PxArticulationJointReducedCoordinate_getJointType :: inline (this: *PxArticulationJointReducedCoordinate) -> PxArticulationJointType.Enum { return this.pxarticulationjointreducedcoordinate_vtable.getJointType(this); }

    PxArticulationJointReducedCoordinate_setMotion :: inline (this: *PxArticulationJointReducedCoordinate, axis: PxArticulationAxis.Enum, motion: PxArticulationMotion.Enum) { this.pxarticulationjointreducedcoordinate_vtable.setMotion(this, axis, motion); }
    PxArticulationJointReducedCoordinate_getMotion :: inline (this: *PxArticulationJointReducedCoordinate, axis: PxArticulationAxis.Enum) -> PxArticulationMotion.Enum { return this.pxarticulationjointreducedcoordinate_vtable.getMotion(this, axis); }

    PxArticulationJointReducedCoordinate_setLimit :: inline (this: *PxArticulationJointReducedCoordinate, axis: PxArticulationAxis.Enum, lowLimit: PxReal, highLimit: PxReal) { this.pxarticulationjointreducedcoordinate_vtable.setLimit(this, axis, lowLimit, highLimit); }
    PxArticulationJointReducedCoordinate_getLimit :: inline (this: *PxArticulationJointReducedCoordinate, axis: PxArticulationAxis.Enum, lowLimit: *PxReal, highLimit: *PxReal) { this.pxarticulationjointreducedcoordinate_vtable.getLimit(this, axis, lowLimit, highLimit); }
    PxArticulationJointReducedCoordinate_setDrive :: inline (this: *PxArticulationJointReducedCoordinate, axis: PxArticulationAxis.Enum, stiffness: PxReal, damping: PxReal, maxForce: PxReal, driveType: PxArticulationDriveType.Enum = .FORCE) { this.pxarticulationjointreducedcoordinate_vtable.setDrive(this, axis, stiffness, damping, maxForce, driveType); }
    PxArticulationJointReducedCoordinate_getDrive :: inline (this: *PxArticulationJointReducedCoordinate, axis: PxArticulationAxis.Enum, stiffness: *PxReal, damping: *PxReal, maxForce: *PxReal, driveType: *PxArticulationDriveType.Enum) { this.pxarticulationjointreducedcoordinate_vtable.getDrive(this, axis, stiffness, damping, maxForce, driveType); }
    PxArticulationJointReducedCoordinate_setDriveTarget :: inline (this: *PxArticulationJointReducedCoordinate, axis: PxArticulationAxis.Enum, target: PxReal) { this.pxarticulationjointreducedcoordinate_vtable.setDriveTarget(this, axis, target); }
    PxArticulationJointReducedCoordinate_setDriveVelocity :: inline (this: *PxArticulationJointReducedCoordinate, axis: PxArticulationAxis.Enum, targetVel: PxReal) { this.pxarticulationjointreducedcoordinate_vtable.setDriveVelocity(this, axis, targetVel); }
    PxArticulationJointReducedCoordinate_getDriveTarget :: inline (this: *PxArticulationJointReducedCoordinate, axis: PxArticulationAxis.Enum) -> PxReal { return this.pxarticulationjointreducedcoordinate_vtable.getDriveTarget(this, axis); }
    PxArticulationJointReducedCoordinate_getDriveVelocity :: inline (this: *PxArticulationJointReducedCoordinate, axis: PxArticulationAxis.Enum) -> PxReal { return this.pxarticulationjointreducedcoordinate_vtable.getDriveVelocity(this, axis); }

    PxArticulationJointReducedCoordinate_setFrictionCoefficient :: inline (this: *PxArticulationJointReducedCoordinate, coefficient: PxReal) { this.pxarticulationjointreducedcoordinate_vtable.setFrictionCoefficient(this, coefficient); }
    PxArticulationJointReducedCoordinate_getFrictionCoefficient :: inline (this: *PxArticulationJointReducedCoordinate) -> PxReal { return this.pxarticulationjointreducedcoordinate_vtable.getFrictionCoefficient(this); }

    PxArticulationJointReducedCoordinate_setMaxJointVelocity :: inline (this: *PxArticulationJointReducedCoordinate, maxJointV: PxReal) { this.pxarticulationjointreducedcoordinate_vtable.setMaxJointVelocity(this, maxJointV); }
    PxArticulationJointReducedCoordinate_getMaxJointVelocity :: inline (this: *PxArticulationJointReducedCoordinate) -> PxReal { return this.pxarticulationjointreducedcoordinate_vtable.getMaxJointVelocity(this); }

    vtable :: (obj: *PxArticulationJointReducedCoordinate) -> *PxArticulationJointReducedCoordinate_VTable { return obj.pxarticulationjointreducedcoordinate_vtable; }

    #run {if true then return;
        assert(size_of(type_of(PxArticulationJointReducedCoordinate.pxarticulationjointbase)) == 16, "PxArticulationJointReducedCoordinate.pxarticulationjointbase has unexpected size % instead of 16", size_of(type_of(PxArticulationJointReducedCoordinate.pxarticulationjointbase)));
        assert(size_of(PxArticulationJointReducedCoordinate) == 16, "PxArticulationJointReducedCoordinate has size % instead of 16", size_of(PxArticulationJointReducedCoordinate));
    }

    /**
    \brief Flags which affect the behavior of PxShapes.

    @see PxShape PxShape.setFlag()
    */
    PxShapeFlag :: struct {
        Enum :: enum s32 {
            SIMULATION_SHAPE  :: 1;

            SCENE_QUERY_SHAPE :: 2;

            TRIGGER_SHAPE     :: 4;

            VISUALIZATION     :: 8;

            eSIMULATION_SHAPE  :: SIMULATION_SHAPE;

            eSCENE_QUERY_SHAPE :: SCENE_QUERY_SHAPE;

            eTRIGGER_SHAPE     :: TRIGGER_SHAPE;

            eVISUALIZATION     :: VISUALIZATION;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {
        assert(size_of(PxShapeFlag) == 1, "PxShapeFlag has size % instead of 1", size_of(PxShapeFlag));
    }

    /**
    \brief collection of set bits defined in PxShapeFlag.

    @see PxShapeFlag
    */
    PxShapeFlags :: PxFlags(PxShapeFlag.Enum, PxU8);

    /**
    \brief Abstract class for collision shapes.

    Shapes are shared, reference counted objects.

    An instance can be created by calling the createShape() method of the PxRigidActor class, or
    the createShape() method of the PxPhysics class.

    <h3>Visualizations</h3>
    \li PxVisualizationParameter::eCOLLISION_AABBS
    \li PxVisualizationParameter::eCOLLISION_SHAPES
    \li PxVisualizationParameter::eCOLLISION_AXES

    @see PxPhysics.createShape() PxRigidActor.createShape() PxBoxGeometry PxSphereGeometry PxCapsuleGeometry PxPlaneGeometry PxConvexMeshGeometry
    PxTriangleMeshGeometry PxHeightFieldGeometry
    */
    PxShape :: struct {
        #as using pxbase: PxBase;

        userData: *void; //!< user can assign this to whatever, usually to create a 1:1 relationship with a user object.
        #place pxbase; pxshape_vtable: *PxShape_VTable;
    }
    PxShape_VTable :: struct #type_info_none {
        using pxbase: PxBase_VTable;
        getReferenceCount: (this: *PxShape) -> PxU32 #cpp_method;

        acquireReference: (this: *PxShape) -> void #cpp_method;

        getGeometryType: (this: *PxShape) -> PxGeometryType.Enum #cpp_method;

        setGeometry: (this: *PxShape, geometry: *PxGeometry) -> void #cpp_method;

        getGeometry: (this: *PxShape) -> PxGeometryHolder #cpp_method #cpp_return_type_is_non_pod;

        getBoxGeometry: (this: *PxShape, geometry: *PxBoxGeometry) -> bool #cpp_method;

        getSphereGeometry: (this: *PxShape, geometry: *PxSphereGeometry) -> bool #cpp_method;

        getCapsuleGeometry: (this: *PxShape, geometry: *PxCapsuleGeometry) -> bool #cpp_method;

        getPlaneGeometry: (this: *PxShape, geometry: *PxPlaneGeometry) -> bool #cpp_method;

        getConvexMeshGeometry: (this: *PxShape, geometry: *PxConvexMeshGeometry) -> bool #cpp_method;

        getTriangleMeshGeometry: (this: *PxShape, geometry: *PxTriangleMeshGeometry) -> bool #cpp_method;

        getHeightFieldGeometry: (this: *PxShape, geometry: *PxHeightFieldGeometry) -> bool #cpp_method;

        getActor: (this: *PxShape) -> *PxRigidActor #cpp_method;

        setLocalPose: (this: *PxShape, pose: *PxTransform) -> void #cpp_method;

        getLocalPose: (this: *PxShape) -> PxTransform #cpp_method #cpp_return_type_is_non_pod;

        setSimulationFilterData: (this: *PxShape, data: *PxFilterData) -> void #cpp_method;

        getSimulationFilterData: (this: *PxShape) -> PxFilterData #cpp_method #cpp_return_type_is_non_pod;

        setQueryFilterData: (this: *PxShape, data: *PxFilterData) -> void #cpp_method;

        getQueryFilterData: (this: *PxShape) -> PxFilterData #cpp_method #cpp_return_type_is_non_pod;

        setMaterials: (this: *PxShape, materials: **PxMaterial, materialCount: PxU16) -> void #cpp_method;

        getNbMaterials: (this: *PxShape) -> PxU16 #cpp_method;

        getMaterials: (this: *PxShape, userBuffer: **PxMaterial, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        getMaterialFromInternalFaceIndex: (this: *PxShape, faceIndex: PxU32) -> *PxMaterial #cpp_method;

        setContactOffset: (this: *PxShape, contactOffset: PxReal) -> void #cpp_method;

        getContactOffset: (this: *PxShape) -> PxReal #cpp_method;

        setRestOffset: (this: *PxShape, restOffset: PxReal) -> void #cpp_method;

        getRestOffset: (this: *PxShape) -> PxReal #cpp_method;

        setTorsionalPatchRadius: (this: *PxShape, radius: PxReal) -> void #cpp_method;

        getTorsionalPatchRadius: (this: *PxShape) -> PxReal #cpp_method;

        setMinTorsionalPatchRadius: (this: *PxShape, radius: PxReal) -> void #cpp_method;

        getMinTorsionalPatchRadius: (this: *PxShape) -> PxReal #cpp_method;

        setFlag: (this: *PxShape, flag: PxShapeFlag.Enum, value: bool) -> void #cpp_method;

        setFlags: (this: *PxShape, inFlags: PxShapeFlags) -> void #cpp_method;

        getFlags: (this: *PxShape) -> PxShapeFlags #cpp_method;

        isExclusive: (this: *PxShape) -> bool #cpp_method;

        setName: (this: *PxShape, name: *u8) -> void #cpp_method;

        getName: (this: *PxShape) -> *u8 #cpp_method;
    }

    PxShape_getReferenceCount :: inline (this: *PxShape) -> PxU32 { return this.pxshape_vtable.getReferenceCount(this); }

    PxShape_acquireReference :: inline (this: *PxShape) { this.pxshape_vtable.acquireReference(this); }

    PxShape_getGeometryType :: inline (this: *PxShape) -> PxGeometryType.Enum { return this.pxshape_vtable.getGeometryType(this); }

    PxShape_setGeometry :: inline (this: *PxShape, geometry: *PxGeometry) { this.pxshape_vtable.setGeometry(this, geometry); }

    PxShape_getGeometry :: inline (this: *PxShape) -> PxGeometryHolder { return this.pxshape_vtable.getGeometry(this); }

    PxShape_getBoxGeometry :: inline (this: *PxShape, geometry: *PxBoxGeometry) -> bool { return this.pxshape_vtable.getBoxGeometry(this, geometry); }

    PxShape_getSphereGeometry :: inline (this: *PxShape, geometry: *PxSphereGeometry) -> bool { return this.pxshape_vtable.getSphereGeometry(this, geometry); }

    PxShape_getCapsuleGeometry :: inline (this: *PxShape, geometry: *PxCapsuleGeometry) -> bool { return this.pxshape_vtable.getCapsuleGeometry(this, geometry); }

    PxShape_getPlaneGeometry :: inline (this: *PxShape, geometry: *PxPlaneGeometry) -> bool { return this.pxshape_vtable.getPlaneGeometry(this, geometry); }

    PxShape_getConvexMeshGeometry :: inline (this: *PxShape, geometry: *PxConvexMeshGeometry) -> bool { return this.pxshape_vtable.getConvexMeshGeometry(this, geometry); }

    PxShape_getTriangleMeshGeometry :: inline (this: *PxShape, geometry: *PxTriangleMeshGeometry) -> bool { return this.pxshape_vtable.getTriangleMeshGeometry(this, geometry); }

    PxShape_getHeightFieldGeometry :: inline (this: *PxShape, geometry: *PxHeightFieldGeometry) -> bool { return this.pxshape_vtable.getHeightFieldGeometry(this, geometry); }

    PxShape_getActor :: inline (this: *PxShape) -> *PxRigidActor { return this.pxshape_vtable.getActor(this); }

    PxShape_setLocalPose :: inline (this: *PxShape, pose: *PxTransform) { this.pxshape_vtable.setLocalPose(this, pose); }

    PxShape_getLocalPose :: inline (this: *PxShape) -> PxTransform { return this.pxshape_vtable.getLocalPose(this); }

    PxShape_setSimulationFilterData :: inline (this: *PxShape, data: *PxFilterData) { this.pxshape_vtable.setSimulationFilterData(this, data); }

    PxShape_getSimulationFilterData :: inline (this: *PxShape) -> PxFilterData { return this.pxshape_vtable.getSimulationFilterData(this); }

    PxShape_setQueryFilterData :: inline (this: *PxShape, data: *PxFilterData) { this.pxshape_vtable.setQueryFilterData(this, data); }

    PxShape_getQueryFilterData :: inline (this: *PxShape) -> PxFilterData { return this.pxshape_vtable.getQueryFilterData(this); }

    PxShape_setMaterials :: inline (this: *PxShape, materials: **PxMaterial, materialCount: PxU16) { this.pxshape_vtable.setMaterials(this, materials, materialCount); }

    PxShape_getNbMaterials :: inline (this: *PxShape) -> PxU16 { return this.pxshape_vtable.getNbMaterials(this); }

    PxShape_getMaterials :: inline (this: *PxShape, userBuffer: **PxMaterial, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.pxshape_vtable.getMaterials(this, userBuffer, bufferSize, startIndex); }

    PxShape_getMaterialFromInternalFaceIndex :: inline (this: *PxShape, faceIndex: PxU32) -> *PxMaterial { return this.pxshape_vtable.getMaterialFromInternalFaceIndex(this, faceIndex); }

    PxShape_setContactOffset :: inline (this: *PxShape, contactOffset: PxReal) { this.pxshape_vtable.setContactOffset(this, contactOffset); }

    PxShape_getContactOffset :: inline (this: *PxShape) -> PxReal { return this.pxshape_vtable.getContactOffset(this); }

    PxShape_setRestOffset :: inline (this: *PxShape, restOffset: PxReal) { this.pxshape_vtable.setRestOffset(this, restOffset); }

    PxShape_getRestOffset :: inline (this: *PxShape) -> PxReal { return this.pxshape_vtable.getRestOffset(this); }

    PxShape_setTorsionalPatchRadius :: inline (this: *PxShape, radius: PxReal) { this.pxshape_vtable.setTorsionalPatchRadius(this, radius); }

    PxShape_getTorsionalPatchRadius :: inline (this: *PxShape) -> PxReal { return this.pxshape_vtable.getTorsionalPatchRadius(this); }

    PxShape_setMinTorsionalPatchRadius :: inline (this: *PxShape, radius: PxReal) { this.pxshape_vtable.setMinTorsionalPatchRadius(this, radius); }

    PxShape_getMinTorsionalPatchRadius :: inline (this: *PxShape) -> PxReal { return this.pxshape_vtable.getMinTorsionalPatchRadius(this); }

    PxShape_setFlag :: inline (this: *PxShape, flag: PxShapeFlag.Enum, value: bool) { this.pxshape_vtable.setFlag(this, flag, value); }

    PxShape_setFlags :: inline (this: *PxShape, inFlags: PxShapeFlags) { this.pxshape_vtable.setFlags(this, inFlags); }

    PxShape_getFlags :: inline (this: *PxShape) -> PxShapeFlags { return this.pxshape_vtable.getFlags(this); }

    PxShape_isExclusive :: inline (this: *PxShape) -> bool { return this.pxshape_vtable.isExclusive(this); }

    PxShape_setName :: inline (this: *PxShape, name: *u8) { this.pxshape_vtable.setName(this, name); }

    PxShape_getName :: inline (this: *PxShape) -> *u8 { return this.pxshape_vtable.getName(this); }

    vtable :: (obj: *PxShape) -> *PxShape_VTable { return obj.pxshape_vtable; }

    #run {if true then return;
        assert(size_of(type_of(PxShape.pxbase)) == 16, "PxShape.pxbase has unexpected size % instead of 16", size_of(type_of(PxShape.pxbase)));
        instance: PxShape;
        assert(((cast(*void)(*instance.userData)) - cast(*void)(*instance)) == 16, "PxShape.userData has unexpected offset % instead of 16", ((cast(*void)(*instance.userData)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxShape.userData)) == 8, "PxShape.userData has unexpected size % instead of 8", size_of(type_of(PxShape.userData)));
        assert(size_of(PxShape) == 24, "PxShape has size % instead of 24", size_of(PxShape));
    }

    /**
    \brief PxRigidActor represents a base class shared between dynamic and static rigid bodies in the physics SDK.

    PxRigidActor objects specify the geometry of the object by defining a set of attached shapes (see #PxShape).

    @see PxActor
    */
    PxRigidActor :: struct {
        #as using pxactor: PxActor;
        #place pxactor; pxrigidactor_vtable: *PxRigidActor_VTable;
    }
    PxRigidActor_VTable :: struct #type_info_none {
        using pxactor: PxActor_VTable;
        getGlobalPose: (this: *PxRigidActor) -> PxTransform #cpp_method #cpp_return_type_is_non_pod;

        setGlobalPose: (this: *PxRigidActor, pose: *PxTransform, autowake := true) -> void #cpp_method;

        attachShape: (this: *PxRigidActor, shape: *PxShape) -> bool #cpp_method;

        detachShape: (this: *PxRigidActor, shape: *PxShape, wakeOnLostTouch := true) -> void #cpp_method;

        getNbShapes: (this: *PxRigidActor) -> PxU32 #cpp_method;

        getShapes: (this: *PxRigidActor, userBuffer: **PxShape, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        getNbConstraints: (this: *PxRigidActor) -> PxU32 #cpp_method;

        getConstraints: (this: *PxRigidActor, userBuffer: **PxConstraint, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;
    }

    PxRigidActor_getGlobalPose :: inline (this: *PxRigidActor) -> PxTransform { return this.pxrigidactor_vtable.getGlobalPose(this); }

    PxRigidActor_setGlobalPose :: inline (this: *PxRigidActor, pose: *PxTransform, autowake := true) { this.pxrigidactor_vtable.setGlobalPose(this, pose, autowake); }

    PxRigidActor_attachShape :: inline (this: *PxRigidActor, shape: *PxShape) -> bool { return this.pxrigidactor_vtable.attachShape(this, shape); }

    PxRigidActor_detachShape :: inline (this: *PxRigidActor, shape: *PxShape, wakeOnLostTouch := true) { this.pxrigidactor_vtable.detachShape(this, shape, wakeOnLostTouch); }

    PxRigidActor_getNbShapes :: inline (this: *PxRigidActor) -> PxU32 { return this.pxrigidactor_vtable.getNbShapes(this); }

    PxRigidActor_getShapes :: inline (this: *PxRigidActor, userBuffer: **PxShape, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.pxrigidactor_vtable.getShapes(this, userBuffer, bufferSize, startIndex); }

    PxRigidActor_getNbConstraints :: inline (this: *PxRigidActor) -> PxU32 { return this.pxrigidactor_vtable.getNbConstraints(this); }

    PxRigidActor_getConstraints :: inline (this: *PxRigidActor, userBuffer: **PxConstraint, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.pxrigidactor_vtable.getConstraints(this, userBuffer, bufferSize, startIndex); }

    vtable :: (obj: *PxRigidActor) -> *PxRigidActor_VTable { return obj.pxrigidactor_vtable; }

    #run {if true then return;
        assert(size_of(type_of(PxRigidActor.pxactor)) == 24, "PxRigidActor.pxactor has unexpected size % instead of 24", size_of(type_of(PxRigidActor.pxactor)));
        assert(size_of(PxRigidActor) == 24, "PxRigidActor has size % instead of 24", size_of(PxRigidActor));
    }

    /**
    \brief Parameter to addForce() and addTorque() calls, determines the exact operation that is carried out.

    @see PxRigidBody.addForce() PxRigidBody.addTorque()
    */
    PxForceMode :: struct {
        Enum :: enum s32 {
            FORCE           :: 0;
            IMPULSE         :: 1;
            VELOCITY_CHANGE :: 2;
            ACCELERATION    :: 3;

            eFORCE           :: FORCE;
            eIMPULSE         :: IMPULSE;
            eVELOCITY_CHANGE :: VELOCITY_CHANGE;
            eACCELERATION    :: ACCELERATION;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxForceMode) == 1, "PxForceMode has size % instead of 1", size_of(PxForceMode));
    }

    /**
    \brief Collection of flags describing the behavior of a rigid body.

    @see PxRigidBody.setRigidBodyFlag(), PxRigidBody.getRigidBodyFlags()
    */
    PxRigidBodyFlag :: struct {
        Enum :: enum s32 {
            KINEMATIC                              :: 1;

            USE_KINEMATIC_TARGET_FOR_SCENE_QUERIES :: 2;

            ENABLE_CCD                             :: 4;

            ENABLE_CCD_FRICTION                    :: 8;

            ENABLE_POSE_INTEGRATION_PREVIEW        :: 16;

            ENABLE_SPECULATIVE_CCD                 :: 32;

            ENABLE_CCD_MAX_CONTACT_IMPULSE         :: 64;

            RETAIN_ACCELERATIONS                   :: 128;

            eKINEMATIC                              :: KINEMATIC;

            eUSE_KINEMATIC_TARGET_FOR_SCENE_QUERIES :: USE_KINEMATIC_TARGET_FOR_SCENE_QUERIES;

            eENABLE_CCD                             :: ENABLE_CCD;

            eENABLE_CCD_FRICTION                    :: ENABLE_CCD_FRICTION;

            eENABLE_POSE_INTEGRATION_PREVIEW        :: ENABLE_POSE_INTEGRATION_PREVIEW;

            eENABLE_SPECULATIVE_CCD                 :: ENABLE_SPECULATIVE_CCD;

            eENABLE_CCD_MAX_CONTACT_IMPULSE         :: ENABLE_CCD_MAX_CONTACT_IMPULSE;

            eRETAIN_ACCELERATIONS                   :: RETAIN_ACCELERATIONS;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxRigidBodyFlag) == 1, "PxRigidBodyFlag has size % instead of 1", size_of(PxRigidBodyFlag));
    }

    /**
    \brief collection of set bits defined in PxRigidBodyFlag.

    @see PxRigidBodyFlag
    */
    PxRigidBodyFlags :: PxFlags(PxRigidBodyFlag.Enum, PxU8);

    /**
    \brief PxRigidBody is a base class shared between dynamic rigid body objects.

    @see PxRigidActor
    */
    PxRigidBody :: struct {
        #as using pxrigidactor: PxRigidActor;
        #place pxrigidactor; pxrigidbody_vtable: *PxRigidBody_VTable;
    }
    PxRigidBody_VTable :: struct #type_info_none {
        using pxrigidactor: PxRigidActor_VTable;
        setCMassLocalPose: (this: *PxRigidBody, pose: *PxTransform) -> void #cpp_method;

        getCMassLocalPose: (this: *PxRigidBody) -> PxTransform #cpp_method #cpp_return_type_is_non_pod;

        setMass: (this: *PxRigidBody, mass: PxReal) -> void #cpp_method;

        getMass: (this: *PxRigidBody) -> PxReal #cpp_method;

        getInvMass: (this: *PxRigidBody) -> PxReal #cpp_method;

        setMassSpaceInertiaTensor: (this: *PxRigidBody, m: *PxVec3) -> void #cpp_method;

        getMassSpaceInertiaTensor: (this: *PxRigidBody) -> PxVec3 #cpp_method #cpp_return_type_is_non_pod;

        getMassSpaceInvInertiaTensor: (this: *PxRigidBody) -> PxVec3 #cpp_method #cpp_return_type_is_non_pod;

        setLinearDamping: (this: *PxRigidBody, linDamp: PxReal) -> void #cpp_method;

        getLinearDamping: (this: *PxRigidBody) -> PxReal #cpp_method;

        setAngularDamping: (this: *PxRigidBody, angDamp: PxReal) -> void #cpp_method;

        getAngularDamping: (this: *PxRigidBody) -> PxReal #cpp_method;

        getLinearVelocity: (this: *PxRigidBody) -> PxVec3 #cpp_method #cpp_return_type_is_non_pod;

        setLinearVelocity: (this: *PxRigidBody, linVel: *PxVec3, autowake := true) -> void #cpp_method;

        getAngularVelocity: (this: *PxRigidBody) -> PxVec3 #cpp_method #cpp_return_type_is_non_pod;

        setAngularVelocity: (this: *PxRigidBody, angVel: *PxVec3, autowake := true) -> void #cpp_method;

        setMaxAngularVelocity: (this: *PxRigidBody, maxAngVel: PxReal) -> void #cpp_method;

        getMaxAngularVelocity: (this: *PxRigidBody) -> PxReal #cpp_method;

        setMaxLinearVelocity: (this: *PxRigidBody, maxLinVel: PxReal) -> void #cpp_method;

        getMaxLinearVelocity: (this: *PxRigidBody) -> PxReal #cpp_method;

        addForce: (this: *PxRigidBody, force: *PxVec3, mode: PxForceMode.Enum = .FORCE, autowake := true) -> void #cpp_method;

        addTorque: (this: *PxRigidBody, torque: *PxVec3, mode: PxForceMode.Enum = .FORCE, autowake := true) -> void #cpp_method;

        clearForce: (this: *PxRigidBody, mode: PxForceMode.Enum = .FORCE) -> void #cpp_method;

        clearTorque: (this: *PxRigidBody, mode: PxForceMode.Enum = .FORCE) -> void #cpp_method;

        setForceAndTorque: (this: *PxRigidBody, force: *PxVec3, torque: *PxVec3, mode: PxForceMode.Enum = .FORCE) -> void #cpp_method;

        setRigidBodyFlag: (this: *PxRigidBody, flag: PxRigidBodyFlag.Enum, value: bool) -> void #cpp_method;
        setRigidBodyFlags: (this: *PxRigidBody, inFlags: PxRigidBodyFlags) -> void #cpp_method;

        getRigidBodyFlags: (this: *PxRigidBody) -> PxRigidBodyFlags #cpp_method;

        setMinCCDAdvanceCoefficient: (this: *PxRigidBody, advanceCoefficient: PxReal) -> void #cpp_method;

        getMinCCDAdvanceCoefficient: (this: *PxRigidBody) -> PxReal #cpp_method;

        setMaxDepenetrationVelocity: (this: *PxRigidBody, biasClamp: PxReal) -> void #cpp_method;

        getMaxDepenetrationVelocity: (this: *PxRigidBody) -> PxReal #cpp_method;

        setMaxContactImpulse: (this: *PxRigidBody, maxImpulse: PxReal) -> void #cpp_method;

        getMaxContactImpulse: (this: *PxRigidBody) -> PxReal #cpp_method;

        getInternalIslandNodeIndex: (this: *PxRigidBody) -> PxU32 #cpp_method;
    }

    PxRigidBody_setCMassLocalPose :: inline (this: *PxRigidBody, pose: *PxTransform) { this.pxrigidbody_vtable.setCMassLocalPose(this, pose); }

    PxRigidBody_getCMassLocalPose :: inline (this: *PxRigidBody) -> PxTransform { return this.pxrigidbody_vtable.getCMassLocalPose(this); }

    PxRigidBody_setMass :: inline (this: *PxRigidBody, mass: PxReal) { this.pxrigidbody_vtable.setMass(this, mass); }

    PxRigidBody_getMass :: inline (this: *PxRigidBody) -> PxReal { return this.pxrigidbody_vtable.getMass(this); }

    PxRigidBody_getInvMass :: inline (this: *PxRigidBody) -> PxReal { return this.pxrigidbody_vtable.getInvMass(this); }

    PxRigidBody_setMassSpaceInertiaTensor :: inline (this: *PxRigidBody, m: *PxVec3) { this.pxrigidbody_vtable.setMassSpaceInertiaTensor(this, m); }

    PxRigidBody_getMassSpaceInertiaTensor :: inline (this: *PxRigidBody) -> PxVec3 { return this.pxrigidbody_vtable.getMassSpaceInertiaTensor(this); }

    PxRigidBody_getMassSpaceInvInertiaTensor :: inline (this: *PxRigidBody) -> PxVec3 { return this.pxrigidbody_vtable.getMassSpaceInvInertiaTensor(this); }

    PxRigidBody_setLinearDamping :: inline (this: *PxRigidBody, linDamp: PxReal) { this.pxrigidbody_vtable.setLinearDamping(this, linDamp); }

    PxRigidBody_getLinearDamping :: inline (this: *PxRigidBody) -> PxReal { return this.pxrigidbody_vtable.getLinearDamping(this); }

    PxRigidBody_setAngularDamping :: inline (this: *PxRigidBody, angDamp: PxReal) { this.pxrigidbody_vtable.setAngularDamping(this, angDamp); }

    PxRigidBody_getAngularDamping :: inline (this: *PxRigidBody) -> PxReal { return this.pxrigidbody_vtable.getAngularDamping(this); }

    PxRigidBody_getLinearVelocity :: inline (this: *PxRigidBody) -> PxVec3 { return this.pxrigidbody_vtable.getLinearVelocity(this); }

    PxRigidBody_setLinearVelocity :: inline (this: *PxRigidBody, linVel: *PxVec3, autowake := true) { this.pxrigidbody_vtable.setLinearVelocity(this, linVel, autowake); }

    PxRigidBody_getAngularVelocity :: inline (this: *PxRigidBody) -> PxVec3 { return this.pxrigidbody_vtable.getAngularVelocity(this); }

    PxRigidBody_setAngularVelocity :: inline (this: *PxRigidBody, angVel: *PxVec3, autowake := true) { this.pxrigidbody_vtable.setAngularVelocity(this, angVel, autowake); }

    PxRigidBody_setMaxAngularVelocity :: inline (this: *PxRigidBody, maxAngVel: PxReal) { this.pxrigidbody_vtable.setMaxAngularVelocity(this, maxAngVel); }

    PxRigidBody_getMaxAngularVelocity :: inline (this: *PxRigidBody) -> PxReal { return this.pxrigidbody_vtable.getMaxAngularVelocity(this); }

    PxRigidBody_setMaxLinearVelocity :: inline (this: *PxRigidBody, maxLinVel: PxReal) { this.pxrigidbody_vtable.setMaxLinearVelocity(this, maxLinVel); }

    PxRigidBody_getMaxLinearVelocity :: inline (this: *PxRigidBody) -> PxReal { return this.pxrigidbody_vtable.getMaxLinearVelocity(this); }

    PxRigidBody_addForce :: inline (this: *PxRigidBody, force: *PxVec3, mode: PxForceMode.Enum = .FORCE, autowake := true) { this.pxrigidbody_vtable.addForce(this, force, mode, autowake); }

    PxRigidBody_addTorque :: inline (this: *PxRigidBody, torque: *PxVec3, mode: PxForceMode.Enum = .FORCE, autowake := true) { this.pxrigidbody_vtable.addTorque(this, torque, mode, autowake); }

    PxRigidBody_clearForce :: inline (this: *PxRigidBody, mode: PxForceMode.Enum = .FORCE) { this.pxrigidbody_vtable.clearForce(this, mode); }

    PxRigidBody_clearTorque :: inline (this: *PxRigidBody, mode: PxForceMode.Enum = .FORCE) { this.pxrigidbody_vtable.clearTorque(this, mode); }

    PxRigidBody_setForceAndTorque :: inline (this: *PxRigidBody, force: *PxVec3, torque: *PxVec3, mode: PxForceMode.Enum = .FORCE) { this.pxrigidbody_vtable.setForceAndTorque(this, force, torque, mode); }

    PxRigidBody_setRigidBodyFlag :: inline (this: *PxRigidBody, flag: PxRigidBodyFlag.Enum, value: bool) { this.pxrigidbody_vtable.setRigidBodyFlag(this, flag, value); }
    PxRigidBody_setRigidBodyFlags :: inline (this: *PxRigidBody, inFlags: PxRigidBodyFlags) { this.pxrigidbody_vtable.setRigidBodyFlags(this, inFlags); }

    PxRigidBody_getRigidBodyFlags :: inline (this: *PxRigidBody) -> PxRigidBodyFlags { return this.pxrigidbody_vtable.getRigidBodyFlags(this); }

    PxRigidBody_setMinCCDAdvanceCoefficient :: inline (this: *PxRigidBody, advanceCoefficient: PxReal) { this.pxrigidbody_vtable.setMinCCDAdvanceCoefficient(this, advanceCoefficient); }

    PxRigidBody_getMinCCDAdvanceCoefficient :: inline (this: *PxRigidBody) -> PxReal { return this.pxrigidbody_vtable.getMinCCDAdvanceCoefficient(this); }

    PxRigidBody_setMaxDepenetrationVelocity :: inline (this: *PxRigidBody, biasClamp: PxReal) { this.pxrigidbody_vtable.setMaxDepenetrationVelocity(this, biasClamp); }

    PxRigidBody_getMaxDepenetrationVelocity :: inline (this: *PxRigidBody) -> PxReal { return this.pxrigidbody_vtable.getMaxDepenetrationVelocity(this); }

    PxRigidBody_setMaxContactImpulse :: inline (this: *PxRigidBody, maxImpulse: PxReal) { this.pxrigidbody_vtable.setMaxContactImpulse(this, maxImpulse); }

    PxRigidBody_getMaxContactImpulse :: inline (this: *PxRigidBody) -> PxReal { return this.pxrigidbody_vtable.getMaxContactImpulse(this); }

    PxRigidBody_getInternalIslandNodeIndex :: inline (this: *PxRigidBody) -> PxU32 { return this.pxrigidbody_vtable.getInternalIslandNodeIndex(this); }

    vtable :: (obj: *PxRigidBody) -> *PxRigidBody_VTable { return obj.pxrigidbody_vtable; }

    #run {if true then return;
        assert(size_of(type_of(PxRigidBody.pxrigidactor)) == 24, "PxRigidBody.pxrigidactor has unexpected size % instead of 24", size_of(type_of(PxRigidBody.pxrigidactor)));
        assert(size_of(PxRigidBody) == 24, "PxRigidBody has size % instead of 24", size_of(PxRigidBody));
    }

    /**
    \brief a component of an articulation that represents a rigid body

    A limited subset of the properties of PxRigidDynamic are supported. In particular, sleep properties
    are attributes of the articulation rather than each individual body, damping and velocity limits
    are not supported, and links may not be kinematic.

    @see PxArticulation PxArticulation.createLink PxArticulationJoint PxRigidBody
    */
    PxArticulationLink :: struct {
        #as using pxrigidbody: PxRigidBody;
        #place pxrigidbody; pxarticulationlink_vtable: *PxArticulationLink_VTable;
    }
    PxArticulationLink_VTable :: struct #type_info_none {
        using pxrigidbody: PxRigidBody_VTable;
        getArticulation: (this: *PxArticulationLink) -> *PxArticulationBase #cpp_method;

        getInboundJoint: (this: *PxArticulationLink) -> *PxArticulationJointBase #cpp_method;

        getInboundJointDof: (this: *PxArticulationLink) -> PxU32 #cpp_method;

        getNbChildren: (this: *PxArticulationLink) -> PxU32 #cpp_method;

        getLinkIndex: (this: *PxArticulationLink) -> PxU32 #cpp_method;

        getChildren: (this: *PxArticulationLink, userBuffer: **PxArticulationLink, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;
    }

    PxArticulationLink_getArticulation :: inline (this: *PxArticulationLink) -> *PxArticulationBase { return this.pxarticulationlink_vtable.getArticulation(this); }

    PxArticulationLink_getInboundJoint :: inline (this: *PxArticulationLink) -> *PxArticulationJointBase { return this.pxarticulationlink_vtable.getInboundJoint(this); }

    PxArticulationLink_getInboundJointDof :: inline (this: *PxArticulationLink) -> PxU32 { return this.pxarticulationlink_vtable.getInboundJointDof(this); }

    PxArticulationLink_getNbChildren :: inline (this: *PxArticulationLink) -> PxU32 { return this.pxarticulationlink_vtable.getNbChildren(this); }

    PxArticulationLink_getLinkIndex :: inline (this: *PxArticulationLink) -> PxU32 { return this.pxarticulationlink_vtable.getLinkIndex(this); }

    PxArticulationLink_getChildren :: inline (this: *PxArticulationLink, userBuffer: **PxArticulationLink, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.pxarticulationlink_vtable.getChildren(this, userBuffer, bufferSize, startIndex); }

    vtable :: (obj: *PxArticulationLink) -> *PxArticulationLink_VTable { return obj.pxarticulationlink_vtable; }

    #run {if true then return;
        assert(size_of(type_of(PxArticulationLink.pxrigidbody)) == 24, "PxArticulationLink.pxrigidbody has unexpected size % instead of 24", size_of(type_of(PxArticulationLink.pxrigidbody)));
        assert(size_of(PxArticulationLink) == 24, "PxArticulationLink has size % instead of 24", size_of(PxArticulationLink));
    }

    INVALID_FILTER_PAIR_INDEX: PxU32 : 4294967295;

    /**
    \brief Collection of flags describing the actions to take for a collision pair.

    @see PxPairFlags PxSimulationFilterShader.filter() PxSimulationFilterCallback
    */
    PxPairFlag :: struct {
        Enum :: enum s32 {
            SOLVE_CONTACT                   :: 1;

            MODIFY_CONTACTS                 :: 2;

            NOTIFY_TOUCH_FOUND              :: 4;

            NOTIFY_TOUCH_PERSISTS           :: 8;

            NOTIFY_TOUCH_LOST               :: 16;

            NOTIFY_TOUCH_CCD                :: 32;

            NOTIFY_THRESHOLD_FORCE_FOUND    :: 64;

            NOTIFY_THRESHOLD_FORCE_PERSISTS :: 128;

            NOTIFY_THRESHOLD_FORCE_LOST     :: 256;

            NOTIFY_CONTACT_POINTS           :: 512;

            DETECT_DISCRETE_CONTACT         :: 1024;

            DETECT_CCD_CONTACT              :: 2048;

            PRE_SOLVER_VELOCITY             :: 4096;

            POST_SOLVER_VELOCITY            :: 8192;

            CONTACT_EVENT_POSE              :: 16384;

            NEXT_FREE                       :: 32768;

            CONTACT_DEFAULT                 :: 1025;

            TRIGGER_DEFAULT                 :: 1044;

            eSOLVE_CONTACT                   :: SOLVE_CONTACT;

            eMODIFY_CONTACTS                 :: MODIFY_CONTACTS;

            eNOTIFY_TOUCH_FOUND              :: NOTIFY_TOUCH_FOUND;

            eNOTIFY_TOUCH_PERSISTS           :: NOTIFY_TOUCH_PERSISTS;

            eNOTIFY_TOUCH_LOST               :: NOTIFY_TOUCH_LOST;

            eNOTIFY_TOUCH_CCD                :: NOTIFY_TOUCH_CCD;

            eNOTIFY_THRESHOLD_FORCE_FOUND    :: NOTIFY_THRESHOLD_FORCE_FOUND;

            eNOTIFY_THRESHOLD_FORCE_PERSISTS :: NOTIFY_THRESHOLD_FORCE_PERSISTS;

            eNOTIFY_THRESHOLD_FORCE_LOST     :: NOTIFY_THRESHOLD_FORCE_LOST;

            eNOTIFY_CONTACT_POINTS           :: NOTIFY_CONTACT_POINTS;

            eDETECT_DISCRETE_CONTACT         :: DETECT_DISCRETE_CONTACT;

            eDETECT_CCD_CONTACT              :: DETECT_CCD_CONTACT;

            ePRE_SOLVER_VELOCITY             :: PRE_SOLVER_VELOCITY;

            ePOST_SOLVER_VELOCITY            :: POST_SOLVER_VELOCITY;

            eCONTACT_EVENT_POSE              :: CONTACT_EVENT_POSE;

            eNEXT_FREE                       :: NEXT_FREE;

            eCONTACT_DEFAULT                 :: CONTACT_DEFAULT;

            eTRIGGER_DEFAULT                 :: TRIGGER_DEFAULT;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxPairFlag) == 1, "PxPairFlag has size % instead of 1", size_of(PxPairFlag));
    }

    /**
    \brief Bitfield that contains a set of raised flags defined in PxPairFlag.

    @see PxPairFlag
    */
    PxPairFlags :: PxFlags(PxPairFlag.Enum, PxU16);

    /**
    \brief Collection of flags describing the filter actions to take for a collision pair.

    @see PxFilterFlags PxSimulationFilterShader PxSimulationFilterCallback
    */
    PxFilterFlag :: struct {
        Enum :: enum s32 {
            KILL     :: 1;

            SUPPRESS :: 2;

            CALLBACK :: 4;

            NOTIFY   :: 12;

            DEFAULT  :: 0;

            eKILL     :: KILL;

            eSUPPRESS :: SUPPRESS;

            eCALLBACK :: CALLBACK;

            eNOTIFY   :: NOTIFY;

            eDEFAULT  :: DEFAULT;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxFilterFlag) == 1, "PxFilterFlag has size % instead of 1", size_of(PxFilterFlag));
    }

    /**
    \brief Bitfield that contains a set of raised flags defined in PxFilterFlag.

    @see PxFilterFlag
    */
    PxFilterFlags :: PxFlags(PxFilterFlag.Enum, PxU16);

    /**
    \brief PxFilterData is user-definable data which gets passed into the collision filtering shader and/or callback.

    @see PxShape.setSimulationFilterData() PxShape.getSimulationFilterData()  PxSimulationFilterShader PxSimulationFilterCallback
    */
    PxFilterData :: struct {
        //= ATTENTION! =====================================================================================
        // Changing the data layout of this class breaks the binary serialization format.  See comments for
        // PX_BINARY_SERIAL_VERSION.  If a modification is required, please adjust the getBinaryMetaData
        // function.  If the modification is made on a custom branch, please change PX_BINARY_SERIAL_VERSION
        // accordingly.
        //==================================================================================================
        Constructor :: (this: *PxFilterData, unknown0: PxEMPTY) -> void #cpp_method #foreign physx_lib "??0PxFilterData@physx@@QEAA@W4PxEMPTY@1@@Z";

        /**
        \brief Default constructor.
        */
        Constructor :: (this: *PxFilterData) -> void #cpp_method #foreign physx_lib "??0PxFilterData@physx@@QEAA@XZ";

        /**
        \brief Copy constructor.
        */
        CopyConstructor :: (this: *PxFilterData, fd: *PxFilterData) -> void #cpp_method #foreign physx_lib "??0PxFilterData@physx@@QEAA@AEBU01@@Z";
        CopyConstructor :: (this: *PxFilterData, fd: PxFilterData) #no_context {
            CopyConstructor(this, *fd);
        }

        /**
        \brief Constructor to set filter data initially.
        */
        Constructor :: (this: *PxFilterData, w0: PxU32, w1: PxU32, w2: PxU32, w3: PxU32) -> void #cpp_method #foreign physx_lib "??0PxFilterData@physx@@QEAA@IIII@Z";

        /**
        \brief (re)sets the structure to the default.
        */
        setToDefault :: (this: *PxFilterData) -> void #cpp_method #foreign physx_lib "?setToDefault@PxFilterData@physx@@QEAAXXZ";

        word0: PxU32;
        word1: PxU32;
        word2: PxU32;
        word3: PxU32;
    }

    /**
    \brief Assignment operator
    */
    operator_assign :: (this: *physx.PxFilterData, fd: *physx.PxFilterData) -> void #cpp_method #foreign physx_lib "??4PxFilterData@physx@@QEAAXAEBU01@@Z";
    operator_assign :: (this: *physx.PxFilterData, fd: physx.PxFilterData) #no_context {
        operator_assign(this, *fd);
    }
    #run {if true then return;
        instance: PxFilterData;
        assert(((cast(*void)(*instance.word0)) - cast(*void)(*instance)) == 0, "PxFilterData.word0 has unexpected offset % instead of 0", ((cast(*void)(*instance.word0)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxFilterData.word0)) == 4, "PxFilterData.word0 has unexpected size % instead of 4", size_of(type_of(PxFilterData.word0)));
        assert(((cast(*void)(*instance.word1)) - cast(*void)(*instance)) == 4, "PxFilterData.word1 has unexpected offset % instead of 4", ((cast(*void)(*instance.word1)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxFilterData.word1)) == 4, "PxFilterData.word1 has unexpected size % instead of 4", size_of(type_of(PxFilterData.word1)));
        assert(((cast(*void)(*instance.word2)) - cast(*void)(*instance)) == 8, "PxFilterData.word2 has unexpected offset % instead of 8", ((cast(*void)(*instance.word2)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxFilterData.word2)) == 4, "PxFilterData.word2 has unexpected size % instead of 4", size_of(type_of(PxFilterData.word2)));
        assert(((cast(*void)(*instance.word3)) - cast(*void)(*instance)) == 12, "PxFilterData.word3 has unexpected offset % instead of 12", ((cast(*void)(*instance.word3)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxFilterData.word3)) == 4, "PxFilterData.word3 has unexpected size % instead of 4", size_of(type_of(PxFilterData.word3)));
        assert(size_of(PxFilterData) == 16, "PxFilterData has size % instead of 16", size_of(PxFilterData));
    }

    /**
    \brief Identifies each type of filter object.

    @see PxGetFilterObjectType()
    */
    PxFilterObjectType :: struct {
        Enum :: enum s32 {
            RIGID_STATIC   :: 0;

            RIGID_DYNAMIC  :: 1;

            ARTICULATION   :: 2;

            MAX_TYPE_COUNT :: 16;

            UNDEFINED      :: 15;

            eRIGID_STATIC   :: RIGID_STATIC;

            eRIGID_DYNAMIC  :: RIGID_DYNAMIC;

            eARTICULATION   :: ARTICULATION;

            eMAX_TYPE_COUNT :: MAX_TYPE_COUNT;

            eUNDEFINED      :: UNDEFINED;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxFilterObjectType) == 1, "PxFilterObjectType has size % instead of 1", size_of(PxFilterObjectType));
    }

    // For internal use only
    PxFilterObjectFlag :: struct {
        Enum :: enum s32 {
            KINEMATIC :: 16;
            TRIGGER   :: 32;

            eKINEMATIC :: KINEMATIC;
            eTRIGGER   :: TRIGGER;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxFilterObjectFlag) == 1, "PxFilterObjectFlag has size % instead of 1", size_of(PxFilterObjectFlag));
    }

    /**
    \brief Structure which gets passed into the collision filtering shader and/or callback providing additional information on objects of a collision pair

    @see PxSimulationFilterShader PxSimulationFilterCallback getActorType() PxFilterObjectIsKinematic() PxFilterObjectIsTrigger()
    */
    PxFilterObjectAttributes :: PxU32;

    /**
    \brief Extract filter object type from the filter attributes of a collision pair object

    \param[in] attr The filter attribute of a collision pair object
    \return The type of the collision pair object.

    @see PxFilterObjectType
    */
    PxGetFilterObjectType :: (attr: PxFilterObjectAttributes) -> PxFilterObjectType.Enum #foreign physx_lib "?PxGetFilterObjectType@physx@@YA?AW4Enum@PxFilterObjectType@1@I@Z";

    /**
    \brief Specifies whether the collision object belongs to a kinematic rigid body

    \param[in] attr The filter attribute of a collision pair object
    \return True if the object belongs to a kinematic rigid body, else false

    @see PxRigidBodyFlag::eKINEMATIC
    */
    PxFilterObjectIsKinematic :: (attr: PxFilterObjectAttributes) -> bool #foreign physx_lib "?PxFilterObjectIsKinematic@physx@@YA_NI@Z";

    /**
    \brief Specifies whether the collision object is a trigger shape

    \param[in] attr The filter attribute of a collision pair object
    \return True if the object is a trigger shape, else false

    @see PxShapeFlag::eTRIGGER_SHAPE
    */
    PxFilterObjectIsTrigger :: (attr: PxFilterObjectAttributes) -> bool #foreign physx_lib "?PxFilterObjectIsTrigger@physx@@YA_NI@Z";

    /**
    \brief Filter method to specify how a pair of potentially colliding objects should be processed.

    Return the PxFilterFlag flags and set the PxPairFlag flags to define what the simulation should do with the given collision pair.

    This methods gets called when:
    \li The bounding volumes of two objects start to overlap.
    \li The bounding volumes of two objects overlap and the filter data or filter attributes of one of the objects changed
    \li A re-filtering was forced through resetFiltering() (see #PxScene::resetFiltering())
    \li Filtering is requested in scene queries

    \note Certain pairs of objects are always ignored and this method does not get called. This is the case for the
    following pairs:

    \li Pair of static rigid actors
    \li A static rigid actor and a kinematic actor (unless one is a trigger or if explicitly enabled through PxPairFilteringMode::eKEEP)
    \li Two kinematic actors (unless one is a trigger or if explicitly enabled through PxPairFilteringMode::eKEEP)
    \li Two jointed rigid bodies and the joint was defined to disable collision
    \li Two articulation links if connected through an articulation joint

    \note This is a performance critical method and should be stateless. You should neither access external objects
    from within this method nor should you call external methods that are not inlined. If you need a more complex
    logic to filter a collision pair then use the filter callback mechanism for this pair (see #PxSimulationFilterCallback,
    #PxFilterFlag::eCALLBACK, #PxFilterFlag::eNOTIFY).

    \param[in] attributes0 The filter attribute of the first object
    \param[in] filterData0 The custom filter data of the first object
    \param[in] attributes1 The filter attribute of the second object
    \param[in] filterData1 The custom filter data of the second object
    \param[out] pairFlags Flags giving additional information on how an accepted pair should get processed
    \param[in] constantBlock The constant global filter data (see #PxSceneDesc.filterShaderData)
    \param[in] constantBlockSize Size of the global filter data (see #PxSceneDesc.filterShaderDataSize)
    \return Filter flags defining whether the pair should be discarded, temporarily ignored, processed and whether the
    filter callback should get invoked for this pair.

    @see PxSimulationFilterCallback PxFilterData PxFilterObjectAttributes PxFilterFlag PxFilterFlags PxPairFlag PxPairFlags
    */
    PxSimulationFilterShader :: #type (attributes0: PxFilterObjectAttributes, filterData0: PxFilterData, attributes1: PxFilterObjectAttributes, filterData1: PxFilterData, pairFlags: *PxPairFlags, constantBlock: *void, constantBlockSize: PxU32) -> PxFilterFlags #c_call;

    /**
    \brief Filter callback to specify handling of collision pairs.

    This class is provided to implement more complex and flexible collision pair filtering logic, for instance, taking
    the state of the user application into account. Filter callbacks also give the user the opportunity to track collision
    pairs and update their filter state.

    You might want to check the documentation on #PxSimulationFilterShader as well since it includes more general information
    on filtering.

    \note SDK state should not be modified from within the callbacks. In particular objects should not
    be created or destroyed. If state modification is needed then the changes should be stored to a buffer
    and performed after the simulation step.

    \note The callbacks may execute in user threads or simulation threads, possibly simultaneously. The corresponding objects
    may have been deleted by the application earlier in the frame. It is the application's responsibility to prevent race conditions
    arising from using the SDK API in the callback while an application thread is making write calls to the scene, and to ensure that
    the callbacks are thread-safe. Return values which depend on when the callback is called during the frame will introduce nondeterminism
    into the simulation.

    @see PxSceneDesc.filterCallback PxSimulationFilterShader
    */
    PxSimulationFilterCallback :: struct {
        vtable: *PxSimulationFilterCallback_VTable;
    }
    PxSimulationFilterCallback_VTable :: struct #type_info_none {
        pairFound: (this: *PxSimulationFilterCallback, pairID: PxU32, attributes0: PxFilterObjectAttributes, filterData0: PxFilterData, a0: *PxActor, s0: *PxShape, attributes1: PxFilterObjectAttributes, filterData1: PxFilterData, a1: *PxActor, s1: *PxShape, pairFlags: *PxPairFlags) -> PxFilterFlags #cpp_method;

        pairLost: (this: *PxSimulationFilterCallback, pairID: PxU32, attributes0: PxFilterObjectAttributes, filterData0: PxFilterData, attributes1: PxFilterObjectAttributes, filterData1: PxFilterData, objectRemoved: bool) -> void #cpp_method;

        statusChange: (this: *PxSimulationFilterCallback, pairID: *PxU32, pairFlags: *PxPairFlags, filterFlags: *PxFilterFlags) -> bool #cpp_method;

        Destructor: (this: *PxSimulationFilterCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxSimulationFilterCallback_pairFound :: inline (this: *PxSimulationFilterCallback, pairID: PxU32, attributes0: PxFilterObjectAttributes, filterData0: PxFilterData, a0: *PxActor, s0: *PxShape, attributes1: PxFilterObjectAttributes, filterData1: PxFilterData, a1: *PxActor, s1: *PxShape, pairFlags: *PxPairFlags) -> PxFilterFlags { return this.vtable.pairFound(this, pairID, attributes0, filterData0, a0, s0, attributes1, filterData1, a1, s1, pairFlags); }

    PxSimulationFilterCallback_pairLost :: inline (this: *PxSimulationFilterCallback, pairID: PxU32, attributes0: PxFilterObjectAttributes, filterData0: PxFilterData, attributes1: PxFilterObjectAttributes, filterData1: PxFilterData, objectRemoved: bool) { this.vtable.pairLost(this, pairID, attributes0, filterData0, attributes1, filterData1, objectRemoved); }

    PxSimulationFilterCallback_statusChange :: inline (this: *PxSimulationFilterCallback, pairID: *PxU32, pairFlags: *PxPairFlags, filterFlags: *PxFilterFlags) -> bool { return this.vtable.statusChange(this, pairID, pairFlags, filterFlags); }

    PxSimulationFilterCallback_Destructor :: inline (this: *PxSimulationFilterCallback, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxSimulationFilterCallback) -> *PxSimulationFilterCallback_VTable { return obj.vtable; }

    #run {if true then return;
        assert(size_of(PxSimulationFilterCallback) == 8, "PxSimulationFilterCallback has size % instead of 8", size_of(PxSimulationFilterCallback));
    }

    PxPairFilteringMode :: struct {
        Enum :: enum s32 {
            KEEP     :: 0;

            SUPPRESS :: 1;

            KILL     :: 2;

            DEFAULT  :: 1;

            eKEEP     :: KEEP;

            eSUPPRESS :: SUPPRESS;

            eKILL     :: KILL;

            eDEFAULT  :: DEFAULT;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxPairFilteringMode) == 1, "PxPairFilteringMode has size % instead of 1", size_of(PxPairFilteringMode));
    }

    /**
    \brief Filtering flags for scene queries.

    @see PxQueryFilterData.flags
    */
    PxQueryFlag :: struct {
        Enum :: enum s32 {
            STATIC     :: 1;

            DYNAMIC    :: 2;

            PREFILTER  :: 4;

            POSTFILTER :: 8;

            ANY_HIT    :: 16;

            NO_BLOCK   :: 32;

            RESERVED   :: 32768;

            eSTATIC     :: STATIC;

            eDYNAMIC    :: DYNAMIC;

            ePREFILTER  :: PREFILTER;

            ePOSTFILTER :: POSTFILTER;

            eANY_HIT    :: ANY_HIT;

            eNO_BLOCK   :: NO_BLOCK;

            eRESERVED   :: RESERVED;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxQueryFlag) == 1, "PxQueryFlag has size % instead of 1", size_of(PxQueryFlag));
    }

    PxCompileTimeAssert_Dummy2 :: [1] u8;
    PxCompileTimeAssert_Dummy3 :: [1] u8;

    /**
    \brief Flags typedef for the set of bits defined in PxQueryFlag.

    */
    PxQueryFlags :: PxFlags(PxQueryFlag.Enum, PxU16);
    // operator| :: (a: PxQueryFlag.Enum, b: PxQueryFlag.Enum) -> PxFlags(PxQueryFlag.Enum, PxU16) #foreign physx_lib "??Uphysx@@YA?AV?$PxFlags@W4Enum@PxQueryFlag@physx@@G@0@W4Enum@PxQueryFlag@0@0@Z";

    /**
    \brief Classification of scene query hits (intersections).

    - eNONE: Returning this hit type means that the hit should not be reported.
    - eBLOCK: For all raycast, sweep and overlap queries the nearest eBLOCK type hit will always be returned in PxHitCallback::block member.
    - eTOUCH: Whenever a raycast, sweep or overlap query was called with non-zero PxHitCallback::nbTouches and PxHitCallback::touches
    parameters, eTOUCH type hits that are closer or same distance (touchDistance <= blockDistance condition)
    as the globally nearest eBLOCK type hit, will be reported.
    - For example, to record all hits from a raycast query, always return eTOUCH.

    All hits in overlap() queries are treated as if the intersection distance were zero.
    This means the hits are unsorted and all eTOUCH hits are recorded by the callback even if an eBLOCK overlap hit was encountered.
    Even though all overlap() blocking hits have zero length, only one (arbitrary) eBLOCK overlap hit is recorded in PxHitCallback::block.
    All overlap() eTOUCH type hits are reported (zero touchDistance <= zero blockDistance condition).

    For raycast/sweep/overlap calls with zero touch buffer or PxHitCallback::nbTouches member,
    only the closest hit of type eBLOCK is returned. All eTOUCH hits are discarded.

    @see PxQueryFilterCallback.preFilter PxQueryFilterCallback.postFilter PxScene.raycast PxScene.sweep PxScene.overlap
    */
    PxQueryHitType :: struct {
        Enum :: enum s32 {
            NONE  :: 0;
            TOUCH :: 1;
            BLOCK :: 2;

            eNONE  :: NONE;
            eTOUCH :: TOUCH;
            eBLOCK :: BLOCK;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxQueryHitType) == 1, "PxQueryHitType has size % instead of 1", size_of(PxQueryHitType));
    }

    /**
    \brief Scene query filtering data.

    Whenever the scene query intersects a shape, filtering is performed in the following order:

    \li For non-batched queries only:<br>If the data field is non-zero, and the bitwise-AND value of data AND the shape's
    queryFilterData is zero, the shape is skipped
    \li If filter callbacks are enabled in flags field (see #PxQueryFlags) they will get invoked accordingly.
    \li If neither #PxQueryFlag::ePREFILTER or #PxQueryFlag::ePOSTFILTER is set, the hit defaults
    to type #PxQueryHitType::eBLOCK when the value of PxHitCallback::nbTouches provided with the query is zero and to type
    #PxQueryHitType::eTOUCH when PxHitCallback::nbTouches is positive.

    @see PxScene.raycast PxScene.sweep PxScene.overlap PxBatchQuery.raycast PxBatchQuery.sweep PxBatchQuery.overlap PxQueryFlag::eANY_HIT
    */
    PxQueryFilterData :: struct {
        /** \brief default constructor */
        Constructor :: (this: *PxQueryFilterData) -> void #cpp_method #foreign physx_lib "??0PxQueryFilterData@physx@@QEAA@XZ";

        /** \brief constructor to set both filter data and filter flags */
        Constructor :: (this: *PxQueryFilterData, fd: *PxFilterData, f: PxQueryFlags) -> void #cpp_method #foreign physx_lib "??0PxQueryFilterData@physx@@QEAA@AEBUPxFilterData@1@V?$PxFlags@W4Enum@PxQueryFlag@physx@@G@1@@Z";
        Constructor :: (this: *PxQueryFilterData, fd: PxFilterData, f: PxQueryFlags) #no_context {
            Constructor(this, *fd, f);
        }

        /** \brief constructor to set filter flags only */
        Constructor :: (this: *PxQueryFilterData, f: PxQueryFlags) -> void #cpp_method #foreign physx_lib "??0PxQueryFilterData@physx@@QEAA@V?$PxFlags@W4Enum@PxQueryFlag@physx@@G@1@@Z";

        data:  PxFilterData; //!< Filter data associated with the scene query
        flags: PxQueryFlags; //!< Filter flags (see #PxQueryFlags)
    }
    #run {if true then return;
        instance: PxQueryFilterData;
        assert(((cast(*void)(*instance.data)) - cast(*void)(*instance)) == 0, "PxQueryFilterData.data has unexpected offset % instead of 0", ((cast(*void)(*instance.data)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxQueryFilterData.data)) == 16, "PxQueryFilterData.data has unexpected size % instead of 16", size_of(type_of(PxQueryFilterData.data)));
        assert(((cast(*void)(*instance.flags)) - cast(*void)(*instance)) == 16, "PxQueryFilterData.flags has unexpected offset % instead of 16", ((cast(*void)(*instance.flags)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxQueryFilterData.flags)) == 2, "PxQueryFilterData.flags has unexpected size % instead of 2", size_of(type_of(PxQueryFilterData.flags)));
        assert(size_of(PxQueryFilterData) == 20, "PxQueryFilterData has size % instead of 20", size_of(PxQueryFilterData));
    }

    /**
    \brief Scene query filtering callbacks.

    Custom filtering logic for scene query intersection candidates. If an intersection candidate object passes the data based filter
    (see #PxQueryFilterData), filtering callbacks are executed if requested (see #PxQueryFilterData.flags)

    \li If #PxQueryFlag::ePREFILTER is set, the preFilter function runs before exact intersection tests.
    If this function returns #PxQueryHitType::eTOUCH or #PxQueryHitType::eBLOCK, exact testing is performed to
    determine the intersection location.

    The preFilter function may overwrite the copy of queryFlags it receives as an argument to specify any of #PxHitFlag::eMODIFIABLE_FLAGS
    on a per-shape basis. Changes apply only to the shape being filtered, and changes to other flags are ignored.

    \li If #PxQueryFlag::ePREFILTER is not set, precise intersection testing is performed using the original query's filterData.flags.

    \li If #PxQueryFlag::ePOSTFILTER is set, the postFilter function is called for each intersection to determine the touch/block status.
    This overrides any touch/block status previously returned from the preFilter function for this shape.

    Filtering calls are not guaranteed to be sorted along the ray or sweep direction.

    @see PxScene.raycast PxScene.sweep PxScene.overlap PxQueryFlags PxHitFlags
    */
    PxQueryFilterCallback :: struct {
        vtable: *PxQueryFilterCallback_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.
        /**
        \brief virtual destructor
        */
        virtual_Destructor :: (this: *PxQueryFilterCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_lib "??1PxQueryFilterCallback@physx@@UEAA@XZ";
    }
    PxQueryFilterCallback_VTable :: struct #type_info_none {
        preFilter: (this: *PxQueryFilterCallback, filterData: *PxFilterData, shape: *PxShape, actor: *PxRigidActor, queryFlags: *PxHitFlags) -> PxQueryHitType.Enum #cpp_method;

        postFilter: (this: *PxQueryFilterCallback, filterData: *PxFilterData, hit: *PxQueryHit) -> PxQueryHitType.Enum #cpp_method;

        Destructor: (this: *PxQueryFilterCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxQueryFilterCallback_preFilter :: inline (this: *PxQueryFilterCallback, filterData: *PxFilterData, shape: *PxShape, actor: *PxRigidActor, queryFlags: *PxHitFlags) -> PxQueryHitType.Enum { return this.vtable.preFilter(this, filterData, shape, actor, queryFlags); }

    PxQueryFilterCallback_postFilter :: inline (this: *PxQueryFilterCallback, filterData: *PxFilterData, hit: *PxQueryHit) -> PxQueryHitType.Enum { return this.vtable.postFilter(this, filterData, hit); }

    PxQueryFilterCallback_Destructor :: inline (this: *PxQueryFilterCallback, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxQueryFilterCallback) -> *PxQueryFilterCallback_VTable { return obj.vtable; }

    #run {if true then return;
        assert(size_of(PxQueryFilterCallback) == 8, "PxQueryFilterCallback has size % instead of 8", size_of(PxQueryFilterCallback));
    }

    /**
    \param[in] queryFilterData Query filter data
    \param[in] objectFilterData Object filter data
    \param[in] constantBlock Global constant filter data (see #PxBatchQuery)
    \param[in] constantBlockSize Size of global filter data (see #PxBatchQuery)
    \param[in,out] hitFlags Per-object modifiable hit flags (only flags from PxHitFlag::eMODIFIABLE_FLAGS mask can be modified)
    \return the updated hit type for this hit (see #PxQueryHitType)

    @see PxBatchQueryPostFilterShader
    */
    PxBatchQueryPreFilterShader :: #type (queryFilterData: PxFilterData, objectFilterData: PxFilterData, constantBlock: *void, constantBlockSize: PxU32, hitFlags: *PxHitFlags) -> PxQueryHitType.Enum #c_call;

    /**
    \param[in] queryFilterData Query filter data
    \param[in] objectFilterData Object filter data
    \param[in] constantBlock Global constant filter data (see #PxBatchQuery)
    \param[in] constantBlockSize Size of global filter data (see #PxBatchQuery)
    \param[in] hit Hit data from the prior exact intersection test.
    \return the new hit type for this hit (see #PxQueryHitType)

    @see PxBatchQueryPreFilterShader
    */
    PxBatchQueryPostFilterShader :: #type (queryFilterData: PxFilterData, objectFilterData: PxFilterData, constantBlock: *void, constantBlockSize: PxU32, hit: *PxQueryHit) -> PxQueryHitType.Enum #c_call;

    /**
    \brief Batched query status.

    \deprecated The batched query feature has been deprecated in PhysX version 3.4
    */
    PxBatchQueryStatus :: struct {
        Enum :: enum s32 {
            PENDING  :: 0;

            SUCCESS  :: 1;

            OVERFLOW :: 2;

            ePENDING  :: PENDING;

            eSUCCESS  :: SUCCESS;

            eOVERFLOW :: OVERFLOW;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxBatchQueryStatus) == 1, "PxBatchQueryStatus has size % instead of 1", size_of(PxBatchQueryStatus));
    }

    /**
    \brief Generic struct for receiving results of single query in a batch. Gets templated on hit type PxRaycastHit, PxSweepHit or PxOverlapHit.

    \deprecated The batched query feature has been deprecated in PhysX version 3.4
    */
    PxBatchQueryResult :: struct(HitType: Type) {
        block:       HitType; //!< Holds the closest blocking hit for a single query in a batch. Only valid if hasBlock is true.
        //!< This pointer will either be set to NULL for 0 nbTouches or will point
        //!< into the user provided batch query results buffer specified in PxBatchQueryDesc.
        touches:     *HitType;

        nbTouches:   PxU32; //!< Number of touching hits returned by this query, works in tandem with touches pointer.
        userData:    *void; //!< Copy of the userData pointer specified in the corresponding query.
        queryStatus: PxU8; //!< Takes on values from PxBatchQueryStatus::Enum.
        hasBlock:    bool; //!< True if there was a blocking hit.
        pad:         PxU16; //!< pads the struct to 16 bytes.
    }

    /** \brief Convenience typedef for the result of a batched raycast query. */
    PxRaycastQueryResult :: PxBatchQueryResult(PxRaycastHit);

    /** \brief Convenience typedef for the result of a batched sweep query. */
    PxSweepQueryResult :: PxBatchQueryResult(PxSweepHit);

    /** \brief Convenience typedef for the result of a batched overlap query. */
    PxOverlapQueryResult :: PxBatchQueryResult(PxOverlapHit);

    /**
    \brief Struct for #PxBatchQuery memory pointers.

    \deprecated The batched query feature has been deprecated in PhysX version 3.4

    @see PxBatchQuery PxBatchQueryDesc
    */
    PxBatchQueryMemory :: struct {
        /**
        \brief The pointer to the user-allocated buffer for results of raycast queries in corresponding order of issue

        \note The size should be large enough to fit the number of expected raycast queries.

        @see PxRaycastQueryResult
        */
        userRaycastResultBuffer: *PxRaycastQueryResult;

        /**
        \brief The pointer to the user-allocated buffer for raycast touch hits.
        \note The size of this buffer should be large enough to store PxRaycastHit.
        If the buffer is too small to store hits, the related PxRaycastQueryResult.queryStatus will be set to eOVERFLOW

        */
        userRaycastTouchBuffer:  *PxRaycastHit;

        /**
        \brief The pointer to the user-allocated buffer for results of sweep queries in corresponding order of issue

        \note The size should be large enough to fit the number of expected sweep queries.

        @see PxRaycastQueryResult
        */
        userSweepResultBuffer:   *PxSweepQueryResult;

        /**
        \brief The pointer to the user-allocated buffer for sweep hits.
        \note The size of this buffer should be large enough to store PxSweepHit.
        If the buffer is too small to store hits, the related PxSweepQueryResult.queryStatus will be set to eOVERFLOW

        */
        userSweepTouchBuffer:    *PxSweepHit;

        /**
        \brief The pointer to the user-allocated buffer for results of overlap queries in corresponding order of issue

        \note The size should be large enough to fit the number of expected overlap queries.

        @see PxRaycastQueryResult
        */
        userOverlapResultBuffer: *PxOverlapQueryResult;

        /**
        \brief The pointer to the user-allocated buffer for overlap hits.
        \note The size of this buffer should be large enough to store the hits returned.
        If the buffer is too small to store hits, the related PxOverlapQueryResult.queryStatus will be set to eABORTED

        */
        userOverlapTouchBuffer:  *PxOverlapHit;

        /** \brief Capacity of the user-allocated userRaycastTouchBuffer in elements */
        raycastTouchBufferSize:  PxU32;

        /** \brief Capacity of the user-allocated userSweepTouchBuffer in elements */
        sweepTouchBufferSize:    PxU32;

        /** \brief Capacity of the user-allocated userOverlapTouchBuffer in elements */
        overlapTouchBufferSize:  PxU32;

        /** \return Capacity of the user-allocated userRaycastResultBuffer in elements (max number of raycast() calls before execute() call) */
        getMaxRaycastsPerExecute :: (this: *PxBatchQueryMemory) -> PxU32 #cpp_method #foreign physx_lib "?getMaxRaycastsPerExecute@PxBatchQueryMemory@physx@@QEBAIXZ";

        /** \return Capacity of the user-allocated userSweepResultBuffer in elements (max number of sweep() calls before execute() call) */
        getMaxSweepsPerExecute :: (this: *PxBatchQueryMemory) -> PxU32 #cpp_method #foreign physx_lib "?getMaxSweepsPerExecute@PxBatchQueryMemory@physx@@QEBAIXZ";

        /** \return Capacity of the user-allocated userOverlapResultBuffer in elements (max number of overlap() calls before execute() call) */
        getMaxOverlapsPerExecute :: (this: *PxBatchQueryMemory) -> PxU32 #cpp_method #foreign physx_lib "?getMaxOverlapsPerExecute@PxBatchQueryMemory@physx@@QEBAIXZ";

        Constructor :: (this: *PxBatchQueryMemory, raycastResultBufferSize_: PxU32, sweepResultBufferSize_: PxU32, overlapResultBufferSize_: PxU32) -> void #cpp_method #foreign physx_lib "??0PxBatchQueryMemory@physx@@QEAA@III@Z";

        raycastResultBufferSize: PxU32;
        sweepResultBufferSize:   PxU32;
        overlapResultBufferSize: PxU32;
    }
    #run {if true then return;
        instance: PxBatchQueryMemory;
        assert(((cast(*void)(*instance.userRaycastResultBuffer)) - cast(*void)(*instance)) == 0, "PxBatchQueryMemory.userRaycastResultBuffer has unexpected offset % instead of 0", ((cast(*void)(*instance.userRaycastResultBuffer)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxBatchQueryMemory.userRaycastResultBuffer)) == 8, "PxBatchQueryMemory.userRaycastResultBuffer has unexpected size % instead of 8", size_of(type_of(PxBatchQueryMemory.userRaycastResultBuffer)));
        assert(((cast(*void)(*instance.userRaycastTouchBuffer)) - cast(*void)(*instance)) == 8, "PxBatchQueryMemory.userRaycastTouchBuffer has unexpected offset % instead of 8", ((cast(*void)(*instance.userRaycastTouchBuffer)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxBatchQueryMemory.userRaycastTouchBuffer)) == 8, "PxBatchQueryMemory.userRaycastTouchBuffer has unexpected size % instead of 8", size_of(type_of(PxBatchQueryMemory.userRaycastTouchBuffer)));
        assert(((cast(*void)(*instance.userSweepResultBuffer)) - cast(*void)(*instance)) == 16, "PxBatchQueryMemory.userSweepResultBuffer has unexpected offset % instead of 16", ((cast(*void)(*instance.userSweepResultBuffer)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxBatchQueryMemory.userSweepResultBuffer)) == 8, "PxBatchQueryMemory.userSweepResultBuffer has unexpected size % instead of 8", size_of(type_of(PxBatchQueryMemory.userSweepResultBuffer)));
        assert(((cast(*void)(*instance.userSweepTouchBuffer)) - cast(*void)(*instance)) == 24, "PxBatchQueryMemory.userSweepTouchBuffer has unexpected offset % instead of 24", ((cast(*void)(*instance.userSweepTouchBuffer)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxBatchQueryMemory.userSweepTouchBuffer)) == 8, "PxBatchQueryMemory.userSweepTouchBuffer has unexpected size % instead of 8", size_of(type_of(PxBatchQueryMemory.userSweepTouchBuffer)));
        assert(((cast(*void)(*instance.userOverlapResultBuffer)) - cast(*void)(*instance)) == 32, "PxBatchQueryMemory.userOverlapResultBuffer has unexpected offset % instead of 32", ((cast(*void)(*instance.userOverlapResultBuffer)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxBatchQueryMemory.userOverlapResultBuffer)) == 8, "PxBatchQueryMemory.userOverlapResultBuffer has unexpected size % instead of 8", size_of(type_of(PxBatchQueryMemory.userOverlapResultBuffer)));
        assert(((cast(*void)(*instance.userOverlapTouchBuffer)) - cast(*void)(*instance)) == 40, "PxBatchQueryMemory.userOverlapTouchBuffer has unexpected offset % instead of 40", ((cast(*void)(*instance.userOverlapTouchBuffer)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxBatchQueryMemory.userOverlapTouchBuffer)) == 8, "PxBatchQueryMemory.userOverlapTouchBuffer has unexpected size % instead of 8", size_of(type_of(PxBatchQueryMemory.userOverlapTouchBuffer)));
        assert(((cast(*void)(*instance.raycastTouchBufferSize)) - cast(*void)(*instance)) == 48, "PxBatchQueryMemory.raycastTouchBufferSize has unexpected offset % instead of 48", ((cast(*void)(*instance.raycastTouchBufferSize)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxBatchQueryMemory.raycastTouchBufferSize)) == 4, "PxBatchQueryMemory.raycastTouchBufferSize has unexpected size % instead of 4", size_of(type_of(PxBatchQueryMemory.raycastTouchBufferSize)));
        assert(((cast(*void)(*instance.sweepTouchBufferSize)) - cast(*void)(*instance)) == 52, "PxBatchQueryMemory.sweepTouchBufferSize has unexpected offset % instead of 52", ((cast(*void)(*instance.sweepTouchBufferSize)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxBatchQueryMemory.sweepTouchBufferSize)) == 4, "PxBatchQueryMemory.sweepTouchBufferSize has unexpected size % instead of 4", size_of(type_of(PxBatchQueryMemory.sweepTouchBufferSize)));
        assert(((cast(*void)(*instance.overlapTouchBufferSize)) - cast(*void)(*instance)) == 56, "PxBatchQueryMemory.overlapTouchBufferSize has unexpected offset % instead of 56", ((cast(*void)(*instance.overlapTouchBufferSize)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxBatchQueryMemory.overlapTouchBufferSize)) == 4, "PxBatchQueryMemory.overlapTouchBufferSize has unexpected size % instead of 4", size_of(type_of(PxBatchQueryMemory.overlapTouchBufferSize)));
        assert(((cast(*void)(*instance.raycastResultBufferSize)) - cast(*void)(*instance)) == 60, "PxBatchQueryMemory.raycastResultBufferSize has unexpected offset % instead of 60", ((cast(*void)(*instance.raycastResultBufferSize)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxBatchQueryMemory.raycastResultBufferSize)) == 4, "PxBatchQueryMemory.raycastResultBufferSize has unexpected size % instead of 4", size_of(type_of(PxBatchQueryMemory.raycastResultBufferSize)));
        assert(((cast(*void)(*instance.sweepResultBufferSize)) - cast(*void)(*instance)) == 64, "PxBatchQueryMemory.sweepResultBufferSize has unexpected offset % instead of 64", ((cast(*void)(*instance.sweepResultBufferSize)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxBatchQueryMemory.sweepResultBufferSize)) == 4, "PxBatchQueryMemory.sweepResultBufferSize has unexpected size % instead of 4", size_of(type_of(PxBatchQueryMemory.sweepResultBufferSize)));
        assert(((cast(*void)(*instance.overlapResultBufferSize)) - cast(*void)(*instance)) == 68, "PxBatchQueryMemory.overlapResultBufferSize has unexpected offset % instead of 68", ((cast(*void)(*instance.overlapResultBufferSize)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxBatchQueryMemory.overlapResultBufferSize)) == 4, "PxBatchQueryMemory.overlapResultBufferSize has unexpected size % instead of 4", size_of(type_of(PxBatchQueryMemory.overlapResultBufferSize)));
        assert(size_of(PxBatchQueryMemory) == 72, "PxBatchQueryMemory has size % instead of 72", size_of(PxBatchQueryMemory));
    }

    /**
    \brief Descriptor class for #PxBatchQuery.

    \deprecated The batched query feature has been deprecated in PhysX version 3.4

    @see PxBatchQuery PxSceneQueryExecuteMode
    */
    PxBatchQueryDesc :: struct {
        /**
        \brief Shared global filter data which will get passed into the filter shader.

        \note The provided data will get copied to internal buffers and this copy will be used for filtering calls.

        <b>Default:</b> NULL

        @see PxSimulationFilterShader
        */
        filterShaderData:     *void;

        /**
        \brief Size (in bytes) of the shared global filter data #filterShaderData.

        <b>Default:</b> 0

        @see PxSimulationFilterShader filterShaderData
        */
        filterShaderDataSize: PxU32;

        /**
        \brief The custom preFilter shader to use for filtering.

        @see PxBatchQueryPreFilterShader PxDefaultPreFilterShader
        */
        preFilterShader:      PxBatchQueryPreFilterShader;

        /**
        \brief The custom postFilter shader to use for filtering.

        @see PxBatchQueryPostFilterShader PxDefaultPostFilterShader
        */
        postFilterShader:     PxBatchQueryPostFilterShader;

        /**
        \brief User memory buffers for the query.

        @see PxBatchQueryMemory
        */
        queryMemory:          PxBatchQueryMemory;

        /**
        \brief Construct a batch query with specified maximum number of queries per batch.

        If the number of raycasts/sweeps/overlaps per execute exceeds the limit, the query will be discarded with a warning.

        \param maxRaycastsPerExecute	Maximum number of raycast() calls allowed before execute() call.
        This has to match the amount of memory allocated for PxBatchQueryMemory::userRaycastResultBuffer.
        \param maxSweepsPerExecute	Maximum number of sweep() calls allowed before execute() call.
        This has to match the amount of memory allocated for PxBatchQueryMemory::userSweepResultBuffer.
        \param maxOverlapsPerExecute	Maximum number of overlap() calls allowed before execute() call.
        This has to match the amount of memory allocated for PxBatchQueryMemory::userOverlapResultBuffer.
        */
        Constructor :: (this: *PxBatchQueryDesc, maxRaycastsPerExecute: PxU32, maxSweepsPerExecute: PxU32, maxOverlapsPerExecute: PxU32) -> void #cpp_method #foreign physx_lib "??0PxBatchQueryDesc@physx@@QEAA@III@Z";

        isValid :: (this: *PxBatchQueryDesc) -> bool #cpp_method #foreign physx_lib "?isValid@PxBatchQueryDesc@physx@@QEBA_NXZ";
    }
    #run {if true then return;
        instance: PxBatchQueryDesc;
        assert(((cast(*void)(*instance.filterShaderData)) - cast(*void)(*instance)) == 0, "PxBatchQueryDesc.filterShaderData has unexpected offset % instead of 0", ((cast(*void)(*instance.filterShaderData)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxBatchQueryDesc.filterShaderData)) == 8, "PxBatchQueryDesc.filterShaderData has unexpected size % instead of 8", size_of(type_of(PxBatchQueryDesc.filterShaderData)));
        assert(((cast(*void)(*instance.filterShaderDataSize)) - cast(*void)(*instance)) == 8, "PxBatchQueryDesc.filterShaderDataSize has unexpected offset % instead of 8", ((cast(*void)(*instance.filterShaderDataSize)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxBatchQueryDesc.filterShaderDataSize)) == 4, "PxBatchQueryDesc.filterShaderDataSize has unexpected size % instead of 4", size_of(type_of(PxBatchQueryDesc.filterShaderDataSize)));
        assert(((cast(*void)(*instance.preFilterShader)) - cast(*void)(*instance)) == 16, "PxBatchQueryDesc.preFilterShader has unexpected offset % instead of 16", ((cast(*void)(*instance.preFilterShader)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxBatchQueryDesc.preFilterShader)) == 8, "PxBatchQueryDesc.preFilterShader has unexpected size % instead of 8", size_of(type_of(PxBatchQueryDesc.preFilterShader)));
        assert(((cast(*void)(*instance.postFilterShader)) - cast(*void)(*instance)) == 24, "PxBatchQueryDesc.postFilterShader has unexpected offset % instead of 24", ((cast(*void)(*instance.postFilterShader)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxBatchQueryDesc.postFilterShader)) == 8, "PxBatchQueryDesc.postFilterShader has unexpected size % instead of 8", size_of(type_of(PxBatchQueryDesc.postFilterShader)));
        assert(((cast(*void)(*instance.queryMemory)) - cast(*void)(*instance)) == 32, "PxBatchQueryDesc.queryMemory has unexpected offset % instead of 32", ((cast(*void)(*instance.queryMemory)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxBatchQueryDesc.queryMemory)) == 72, "PxBatchQueryDesc.queryMemory has unexpected size % instead of 72", size_of(type_of(PxBatchQueryDesc.queryMemory)));
        assert(size_of(PxBatchQueryDesc) == 104, "PxBatchQueryDesc has size % instead of 104", size_of(PxBatchQueryDesc));
    }

    /**
    \brief Batched queries object. This is used to perform several queries at the same time.

    \deprecated The batched query feature has been deprecated in PhysX version 3.4

    @see PxScene, PxScene.createBatchQuery
    */
    PxBatchQuery :: struct {
        vtable: *PxBatchQuery_VTable;
    }
    PxBatchQuery_VTable :: struct #type_info_none {
        execute: (this: *PxBatchQuery) -> void #cpp_method;

        getPreFilterShader: (this: *PxBatchQuery) -> PxBatchQueryPreFilterShader #cpp_method;

        getPostFilterShader: (this: *PxBatchQuery) -> PxBatchQueryPostFilterShader #cpp_method;

        getFilterShaderData: (this: *PxBatchQuery) -> *void #cpp_method;

        getFilterShaderDataSize: (this: *PxBatchQuery) -> PxU32 #cpp_method;

        setUserMemory: (this: *PxBatchQuery, unknown0: *PxBatchQueryMemory) -> void #cpp_method;

        getUserMemory: (this: *PxBatchQuery) -> *PxBatchQueryMemory #cpp_method;

        release: (this: *PxBatchQuery) -> void #cpp_method;

        raycast: (this: *PxBatchQuery, origin: *PxVec3, unitDir: *PxVec3, distance: PxReal = FLOAT32_MAX, maxTouchHits: PxU16 = 0, hitFlags: PxHitFlags, filterData: *PxQueryFilterData, userData: *void = null, cache: *PxQueryCache = null) -> void #cpp_method;
        // raycast :: (this: *PxBatchQuery, origin: PxVec3, unitDir: PxVec3, distance: PxReal = FLOAT32_MAX, maxTouchHits: PxU16 = 0, hitFlags: PxHitFlags, filterData: PxQueryFilterData = PxQueryFilterData.{}, userData: *void = null, cache: *PxQueryCache = null) #no_context {
        //     raycast(this, *origin, *unitDir, distance, maxTouchHits, hitFlags, *filterData, userData, cache);
        // }

        overlap: (this: *PxBatchQuery, geometry: *PxGeometry, pose: *PxTransform, maxTouchHits: PxU16 = 0, filterData: *PxQueryFilterData, userData: *void = null, cache: *PxQueryCache = null) -> void #cpp_method;
        // overlap :: (this: *PxBatchQuery, geometry: PxGeometry, pose: PxTransform, maxTouchHits: PxU16 = 0, filterData: PxQueryFilterData = PxQueryFilterData.{}, userData: *void = null, cache: *PxQueryCache = null) #no_context {
        //     overlap(this, *geometry, *pose, maxTouchHits, *filterData, userData, cache);
        // }

        sweep: (this: *PxBatchQuery, geometry: *PxGeometry, pose: *PxTransform, unitDir: *PxVec3, distance: PxReal, maxTouchHits: PxU16 = 0, hitFlags: PxHitFlags, filterData: *PxQueryFilterData, userData: *void = null, cache: *PxQueryCache = null, inflation: PxReal = 0.0) -> void #cpp_method;
        // sweep :: (this: *PxBatchQuery, geometry: PxGeometry, pose: PxTransform, unitDir: PxVec3, distance: PxReal, maxTouchHits: PxU16 = 0, hitFlags: PxHitFlags, filterData: PxQueryFilterData = PxQueryFilterData.{}, userData: *void = null, cache: *PxQueryCache = null, inflation: PxReal = 0.0) #no_context {
        //     sweep(this, *geometry, *pose, *unitDir, distance, maxTouchHits, hitFlags, *filterData, userData, cache, inflation);
        // }

        Destructor: (this: *PxBatchQuery, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxBatchQuery_execute :: inline (this: *PxBatchQuery) { this.vtable.execute(this); }

    PxBatchQuery_getPreFilterShader :: inline (this: *PxBatchQuery) -> PxBatchQueryPreFilterShader { return this.vtable.getPreFilterShader(this); }

    PxBatchQuery_getPostFilterShader :: inline (this: *PxBatchQuery) -> PxBatchQueryPostFilterShader { return this.vtable.getPostFilterShader(this); }

    PxBatchQuery_getFilterShaderData :: inline (this: *PxBatchQuery) -> *void { return this.vtable.getFilterShaderData(this); }

    PxBatchQuery_getFilterShaderDataSize :: inline (this: *PxBatchQuery) -> PxU32 { return this.vtable.getFilterShaderDataSize(this); }

    PxBatchQuery_setUserMemory :: inline (this: *PxBatchQuery, unknown0: *PxBatchQueryMemory) { this.vtable.setUserMemory(this, unknown0); }

    PxBatchQuery_getUserMemory :: inline (this: *PxBatchQuery) -> *PxBatchQueryMemory { return this.vtable.getUserMemory(this); }

    PxBatchQuery_release :: inline (this: *PxBatchQuery) { this.vtable.release(this); }

    PxBatchQuery_raycast :: inline (this: *PxBatchQuery, origin: *PxVec3, unitDir: *PxVec3, distance: PxReal = FLOAT32_MAX, maxTouchHits: PxU16 = 0, hitFlags: PxHitFlags, filterData: *PxQueryFilterData, userData: *void = null, cache: *PxQueryCache = null) { this.vtable.raycast(this, origin, unitDir, distance, maxTouchHits, hitFlags, filterData, userData, cache); }

    PxBatchQuery_overlap :: inline (this: *PxBatchQuery, geometry: *PxGeometry, pose: *PxTransform, maxTouchHits: PxU16 = 0, filterData: *PxQueryFilterData, userData: *void = null, cache: *PxQueryCache = null) { this.vtable.overlap(this, geometry, pose, maxTouchHits, filterData, userData, cache); }

    PxBatchQuery_sweep :: inline (this: *PxBatchQuery, geometry: *PxGeometry, pose: *PxTransform, unitDir: *PxVec3, distance: PxReal, maxTouchHits: PxU16 = 0, hitFlags: PxHitFlags, filterData: *PxQueryFilterData, userData: *void = null, cache: *PxQueryCache = null, inflation: PxReal = 0.0) { this.vtable.sweep(this, geometry, pose, unitDir, distance, maxTouchHits, hitFlags, filterData, userData, cache, inflation); }

    PxBatchQuery_Destructor :: inline (this: *PxBatchQuery, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxBatchQuery) -> *PxBatchQuery_VTable { return obj.vtable; }

    #run {if true then return;
        assert(size_of(PxBatchQuery) == 8, "PxBatchQuery has size % instead of 8", size_of(PxBatchQuery));
    }

    /**
    \brief constraint flags

    \note eBROKEN is a read only flag
    */
    PxConstraintFlag :: struct {
        Enum :: enum s32 {
            BROKEN                  :: 1;
            PROJECT_TO_ACTOR0       :: 2;
            PROJECT_TO_ACTOR1       :: 4;
            PROJECTION              :: 6;
            COLLISION_ENABLED       :: 8;
            VISUALIZATION           :: 16;
            DRIVE_LIMITS_ARE_FORCES :: 32;
            IMPROVED_SLERP          :: 128;
            DISABLE_PREPROCESSING   :: 256;
            ENABLE_EXTENDED_LIMITS  :: 512;
            GPU_COMPATIBLE          :: 1024;

            eBROKEN                  :: BROKEN;
            ePROJECT_TO_ACTOR0       :: PROJECT_TO_ACTOR0;
            ePROJECT_TO_ACTOR1       :: PROJECT_TO_ACTOR1;
            ePROJECTION              :: PROJECTION;
            eCOLLISION_ENABLED       :: COLLISION_ENABLED;
            eVISUALIZATION           :: VISUALIZATION;
            eDRIVE_LIMITS_ARE_FORCES :: DRIVE_LIMITS_ARE_FORCES;
            eIMPROVED_SLERP          :: IMPROVED_SLERP;
            eDISABLE_PREPROCESSING   :: DISABLE_PREPROCESSING;
            eENABLE_EXTENDED_LIMITS  :: ENABLE_EXTENDED_LIMITS;
            eGPU_COMPATIBLE          :: GPU_COMPATIBLE;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxConstraintFlag) == 1, "PxConstraintFlag has size % instead of 1", size_of(PxConstraintFlag));
    }

    /**
    \brief constraint flags
    @see PxConstraintFlag
    */
    PxConstraintFlags :: PxFlags(PxConstraintFlag.Enum, PxU16);

    PxConstraintShaderTable :: struct {
        anon_enum_1 :: enum s32 {
            eMAX_SOLVERPRPEP_DATASIZE :: 400;
        }

        solverPrep: PxConstraintSolverPrep; //!< solver constraint generation function
        project:    PxConstraintProject; //!< constraint projection function
        visualize:  PxConstraintVisualize; //!< constraint visualization function
        flag:       PxConstraintFlag.Enum; //!< gpu constraint
    }
    #run {if true then return;
        instance: PxConstraintShaderTable;
        assert(((cast(*void)(*instance.solverPrep)) - cast(*void)(*instance)) == 0, "PxConstraintShaderTable.solverPrep has unexpected offset % instead of 0", ((cast(*void)(*instance.solverPrep)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxConstraintShaderTable.solverPrep)) == 8, "PxConstraintShaderTable.solverPrep has unexpected size % instead of 8", size_of(type_of(PxConstraintShaderTable.solverPrep)));
        assert(((cast(*void)(*instance.project)) - cast(*void)(*instance)) == 8, "PxConstraintShaderTable.project has unexpected offset % instead of 8", ((cast(*void)(*instance.project)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxConstraintShaderTable.project)) == 8, "PxConstraintShaderTable.project has unexpected size % instead of 8", size_of(type_of(PxConstraintShaderTable.project)));
        assert(((cast(*void)(*instance.visualize)) - cast(*void)(*instance)) == 16, "PxConstraintShaderTable.visualize has unexpected offset % instead of 16", ((cast(*void)(*instance.visualize)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxConstraintShaderTable.visualize)) == 8, "PxConstraintShaderTable.visualize has unexpected size % instead of 8", size_of(type_of(PxConstraintShaderTable.visualize)));
        assert(((cast(*void)(*instance.flag)) - cast(*void)(*instance)) == 24, "PxConstraintShaderTable.flag has unexpected offset % instead of 24", ((cast(*void)(*instance.flag)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxConstraintShaderTable.flag)) == 4, "PxConstraintShaderTable.flag has unexpected size % instead of 4", size_of(type_of(PxConstraintShaderTable.flag)));
        assert(size_of(PxConstraintShaderTable) == 32, "PxConstraintShaderTable has size % instead of 32", size_of(PxConstraintShaderTable));
    }

    /**
    \brief A plugin class for implementing constraints

    @see PxPhysics.createConstraint
    */
    PxConstraint :: struct {
        #as using pxbase: PxBase;
        #place pxbase; pxconstraint_vtable: *PxConstraint_VTable;
    }
    PxConstraint_VTable :: struct #type_info_none {
        using pxbase: PxBase_VTable;
        getScene: (this: *PxConstraint) -> *PxScene #cpp_method;

        getActors: (this: *PxConstraint, actor0: **PxRigidActor, actor1: **PxRigidActor) -> void #cpp_method;

        setActors: (this: *PxConstraint, actor0: *PxRigidActor, actor1: *PxRigidActor) -> void #cpp_method;

        markDirty: (this: *PxConstraint) -> void #cpp_method;

        setFlags: (this: *PxConstraint, flags: PxConstraintFlags) -> void #cpp_method;

        getFlags: (this: *PxConstraint) -> PxConstraintFlags #cpp_method;

        setFlag: (this: *PxConstraint, flag: PxConstraintFlag.Enum, value: bool) -> void #cpp_method;

        getForce: (this: *PxConstraint, linear: *PxVec3, angular: *PxVec3) -> void #cpp_method;

        isValid: (this: *PxConstraint) -> bool #cpp_method;

        setBreakForce: (this: *PxConstraint, linear: PxReal, angular: PxReal) -> void #cpp_method;

        getBreakForce: (this: *PxConstraint, linear: *PxReal, angular: *PxReal) -> void #cpp_method;

        setMinResponseThreshold: (this: *PxConstraint, threshold: PxReal) -> void #cpp_method;

        getMinResponseThreshold: (this: *PxConstraint) -> PxReal #cpp_method;

        getExternalReference: (this: *PxConstraint, typeID: *PxU32) -> *void #cpp_method;

        setConstraintFunctions: (this: *PxConstraint, connector: *PxConstraintConnector, shaders: *PxConstraintShaderTable) -> void #cpp_method;
    }

    PxConstraint_getScene :: inline (this: *PxConstraint) -> *PxScene { return this.pxconstraint_vtable.getScene(this); }

    PxConstraint_getActors :: inline (this: *PxConstraint, actor0: **PxRigidActor, actor1: **PxRigidActor) { this.pxconstraint_vtable.getActors(this, actor0, actor1); }

    PxConstraint_setActors :: inline (this: *PxConstraint, actor0: *PxRigidActor, actor1: *PxRigidActor) { this.pxconstraint_vtable.setActors(this, actor0, actor1); }

    PxConstraint_markDirty :: inline (this: *PxConstraint) { this.pxconstraint_vtable.markDirty(this); }

    PxConstraint_setFlags :: inline (this: *PxConstraint, flags: PxConstraintFlags) { this.pxconstraint_vtable.setFlags(this, flags); }

    PxConstraint_getFlags :: inline (this: *PxConstraint) -> PxConstraintFlags { return this.pxconstraint_vtable.getFlags(this); }

    PxConstraint_setFlag :: inline (this: *PxConstraint, flag: PxConstraintFlag.Enum, value: bool) { this.pxconstraint_vtable.setFlag(this, flag, value); }

    PxConstraint_getForce :: inline (this: *PxConstraint, linear: *PxVec3, angular: *PxVec3) { this.pxconstraint_vtable.getForce(this, linear, angular); }

    PxConstraint_isValid :: inline (this: *PxConstraint) -> bool { return this.pxconstraint_vtable.isValid(this); }

    PxConstraint_setBreakForce :: inline (this: *PxConstraint, linear: PxReal, angular: PxReal) { this.pxconstraint_vtable.setBreakForce(this, linear, angular); }

    PxConstraint_getBreakForce :: inline (this: *PxConstraint, linear: *PxReal, angular: *PxReal) { this.pxconstraint_vtable.getBreakForce(this, linear, angular); }

    PxConstraint_setMinResponseThreshold :: inline (this: *PxConstraint, threshold: PxReal) { this.pxconstraint_vtable.setMinResponseThreshold(this, threshold); }

    PxConstraint_getMinResponseThreshold :: inline (this: *PxConstraint) -> PxReal { return this.pxconstraint_vtable.getMinResponseThreshold(this); }

    PxConstraint_getExternalReference :: inline (this: *PxConstraint, typeID: *PxU32) -> *void { return this.pxconstraint_vtable.getExternalReference(this, typeID); }

    PxConstraint_setConstraintFunctions :: inline (this: *PxConstraint, connector: *PxConstraintConnector, shaders: *PxConstraintShaderTable) { this.pxconstraint_vtable.setConstraintFunctions(this, connector, shaders); }

    vtable :: (obj: *PxConstraint) -> *PxConstraint_VTable { return obj.pxconstraint_vtable; }

    #run {if true then return;
        assert(size_of(type_of(PxConstraint.pxbase)) == 16, "PxConstraint.pxbase has unexpected size % instead of 16", size_of(type_of(PxConstraint.pxbase)));
        assert(size_of(PxConstraint) == 16, "PxConstraint has size % instead of 16", size_of(PxConstraint));
    }

    PxMassModificationProps :: struct {
        mInvMassScale0:    PxReal;
        mInvInertiaScale0: PxReal;
        mInvMassScale1:    PxReal;
        mInvInertiaScale1: PxReal;
    }
    #run {if true then return;
        instance: PxMassModificationProps;
        assert(((cast(*void)(*instance.mInvMassScale0)) - cast(*void)(*instance)) == 0, "PxMassModificationProps.mInvMassScale0 has unexpected offset % instead of 0", ((cast(*void)(*instance.mInvMassScale0)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxMassModificationProps.mInvMassScale0)) == 4, "PxMassModificationProps.mInvMassScale0 has unexpected size % instead of 4", size_of(type_of(PxMassModificationProps.mInvMassScale0)));
        assert(((cast(*void)(*instance.mInvInertiaScale0)) - cast(*void)(*instance)) == 4, "PxMassModificationProps.mInvInertiaScale0 has unexpected offset % instead of 4", ((cast(*void)(*instance.mInvInertiaScale0)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxMassModificationProps.mInvInertiaScale0)) == 4, "PxMassModificationProps.mInvInertiaScale0 has unexpected size % instead of 4", size_of(type_of(PxMassModificationProps.mInvInertiaScale0)));
        assert(((cast(*void)(*instance.mInvMassScale1)) - cast(*void)(*instance)) == 8, "PxMassModificationProps.mInvMassScale1 has unexpected offset % instead of 8", ((cast(*void)(*instance.mInvMassScale1)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxMassModificationProps.mInvMassScale1)) == 4, "PxMassModificationProps.mInvMassScale1 has unexpected size % instead of 4", size_of(type_of(PxMassModificationProps.mInvMassScale1)));
        assert(((cast(*void)(*instance.mInvInertiaScale1)) - cast(*void)(*instance)) == 12, "PxMassModificationProps.mInvInertiaScale1 has unexpected offset % instead of 12", ((cast(*void)(*instance.mInvInertiaScale1)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxMassModificationProps.mInvInertiaScale1)) == 4, "PxMassModificationProps.mInvInertiaScale1 has unexpected size % instead of 4", size_of(type_of(PxMassModificationProps.mInvInertiaScale1)));
        assert(size_of(PxMassModificationProps) == 16, "PxMassModificationProps has size % instead of 16", size_of(PxMassModificationProps));
    }

    /**
    \brief Header for contact patch where all points share same material and normal
    */
    PxContactPatch :: struct {
        PxContactPatchFlags :: enum s32 {
            HAS_FACE_INDICES            :: 1;
            MODIFIABLE                  :: 2;
            FORCE_NO_RESPONSE           :: 4;
            HAS_MODIFIED_MASS_RATIOS    :: 8;
            HAS_TARGET_VELOCITY         :: 16;
            HAS_MAX_IMPULSE             :: 32;
            REGENERATE_PATCHES          :: 64;

            COMPRESSED_MODIFIED_CONTACT :: 128;

            eHAS_FACE_INDICES            :: HAS_FACE_INDICES;
            eMODIFIABLE                  :: MODIFIABLE;
            eFORCE_NO_RESPONSE           :: FORCE_NO_RESPONSE;
            eHAS_MODIFIED_MASS_RATIOS    :: HAS_MODIFIED_MASS_RATIOS;
            eHAS_TARGET_VELOCITY         :: HAS_TARGET_VELOCITY;
            eHAS_MAX_IMPULSE             :: HAS_MAX_IMPULSE;
            eREGENERATE_PATCHES          :: REGENERATE_PATCHES;

            eCOMPRESSED_MODIFIED_CONTACT :: COMPRESSED_MODIFIED_CONTACT;
        }

        mMassModification: PxMassModificationProps;

        normal:            PxVec3;

        restitution:       PxReal; //32

        dynamicFriction:   PxReal; //36
        staticFriction:    PxReal; //40
        startContactIndex: PxU8; //41
        nbContacts:        PxU8; //42  //Can be a U8

        materialFlags:     PxU8; //43  //Can be a U16
        internalFlags:     PxU8; //44  //Can be a U16
        materialIndex0:    PxU16; //46  //Can be a U16
        materialIndex1:    PxU16; //48  //Can be a U16
    }
    #run {if true then return;
        instance: PxContactPatch;
        assert(((cast(*void)(*instance.mMassModification)) - cast(*void)(*instance)) == 0, "PxContactPatch.mMassModification has unexpected offset % instead of 0", ((cast(*void)(*instance.mMassModification)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactPatch.mMassModification)) == 16, "PxContactPatch.mMassModification has unexpected size % instead of 16", size_of(type_of(PxContactPatch.mMassModification)));
        assert(((cast(*void)(*instance.normal)) - cast(*void)(*instance)) == 16, "PxContactPatch.normal has unexpected offset % instead of 16", ((cast(*void)(*instance.normal)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactPatch.normal)) == 12, "PxContactPatch.normal has unexpected size % instead of 12", size_of(type_of(PxContactPatch.normal)));
        assert(((cast(*void)(*instance.restitution)) - cast(*void)(*instance)) == 28, "PxContactPatch.restitution has unexpected offset % instead of 28", ((cast(*void)(*instance.restitution)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactPatch.restitution)) == 4, "PxContactPatch.restitution has unexpected size % instead of 4", size_of(type_of(PxContactPatch.restitution)));
        assert(((cast(*void)(*instance.dynamicFriction)) - cast(*void)(*instance)) == 32, "PxContactPatch.dynamicFriction has unexpected offset % instead of 32", ((cast(*void)(*instance.dynamicFriction)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactPatch.dynamicFriction)) == 4, "PxContactPatch.dynamicFriction has unexpected size % instead of 4", size_of(type_of(PxContactPatch.dynamicFriction)));
        assert(((cast(*void)(*instance.staticFriction)) - cast(*void)(*instance)) == 36, "PxContactPatch.staticFriction has unexpected offset % instead of 36", ((cast(*void)(*instance.staticFriction)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactPatch.staticFriction)) == 4, "PxContactPatch.staticFriction has unexpected size % instead of 4", size_of(type_of(PxContactPatch.staticFriction)));
        assert(((cast(*void)(*instance.startContactIndex)) - cast(*void)(*instance)) == 40, "PxContactPatch.startContactIndex has unexpected offset % instead of 40", ((cast(*void)(*instance.startContactIndex)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactPatch.startContactIndex)) == 1, "PxContactPatch.startContactIndex has unexpected size % instead of 1", size_of(type_of(PxContactPatch.startContactIndex)));
        assert(((cast(*void)(*instance.nbContacts)) - cast(*void)(*instance)) == 41, "PxContactPatch.nbContacts has unexpected offset % instead of 41", ((cast(*void)(*instance.nbContacts)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactPatch.nbContacts)) == 1, "PxContactPatch.nbContacts has unexpected size % instead of 1", size_of(type_of(PxContactPatch.nbContacts)));
        assert(((cast(*void)(*instance.materialFlags)) - cast(*void)(*instance)) == 42, "PxContactPatch.materialFlags has unexpected offset % instead of 42", ((cast(*void)(*instance.materialFlags)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactPatch.materialFlags)) == 1, "PxContactPatch.materialFlags has unexpected size % instead of 1", size_of(type_of(PxContactPatch.materialFlags)));
        assert(((cast(*void)(*instance.internalFlags)) - cast(*void)(*instance)) == 43, "PxContactPatch.internalFlags has unexpected offset % instead of 43", ((cast(*void)(*instance.internalFlags)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactPatch.internalFlags)) == 1, "PxContactPatch.internalFlags has unexpected size % instead of 1", size_of(type_of(PxContactPatch.internalFlags)));
        assert(((cast(*void)(*instance.materialIndex0)) - cast(*void)(*instance)) == 44, "PxContactPatch.materialIndex0 has unexpected offset % instead of 44", ((cast(*void)(*instance.materialIndex0)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactPatch.materialIndex0)) == 2, "PxContactPatch.materialIndex0 has unexpected size % instead of 2", size_of(type_of(PxContactPatch.materialIndex0)));
        assert(((cast(*void)(*instance.materialIndex1)) - cast(*void)(*instance)) == 46, "PxContactPatch.materialIndex1 has unexpected offset % instead of 46", ((cast(*void)(*instance.materialIndex1)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactPatch.materialIndex1)) == 2, "PxContactPatch.materialIndex1 has unexpected size % instead of 2", size_of(type_of(PxContactPatch.materialIndex1)));
        assert(size_of(PxContactPatch) == 48, "PxContactPatch has size % instead of 48", size_of(PxContactPatch));
    }

    /**
    \brief Contact point data including face (feature) indices
    */
    PxContact :: struct {
        contact:    PxVec3; //12

        separation: PxReal; //16
    }
    #run {if true then return;
        instance: PxContact;
        assert(((cast(*void)(*instance.contact)) - cast(*void)(*instance)) == 0, "PxContact.contact has unexpected offset % instead of 0", ((cast(*void)(*instance.contact)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContact.contact)) == 12, "PxContact.contact has unexpected size % instead of 12", size_of(type_of(PxContact.contact)));
        assert(((cast(*void)(*instance.separation)) - cast(*void)(*instance)) == 12, "PxContact.separation has unexpected offset % instead of 12", ((cast(*void)(*instance.separation)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContact.separation)) == 4, "PxContact.separation has unexpected size % instead of 4", size_of(type_of(PxContact.separation)));
        assert(size_of(PxContact) == 16, "PxContact has size % instead of 16", size_of(PxContact));
    }

    PxExtendedContact :: struct {
        #as using pxcontact: PxContact;

        targetVelocity: PxVec3;

        maxImpulse:     PxReal; //32
    }
    #run {if true then return;
        assert(size_of(type_of(PxExtendedContact.pxcontact)) == 16, "PxExtendedContact.pxcontact has unexpected size % instead of 16", size_of(type_of(PxExtendedContact.pxcontact)));
        instance: PxExtendedContact;
        assert(((cast(*void)(*instance.targetVelocity)) - cast(*void)(*instance)) == 16, "PxExtendedContact.targetVelocity has unexpected offset % instead of 16", ((cast(*void)(*instance.targetVelocity)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxExtendedContact.targetVelocity)) == 12, "PxExtendedContact.targetVelocity has unexpected size % instead of 12", size_of(type_of(PxExtendedContact.targetVelocity)));
        assert(((cast(*void)(*instance.maxImpulse)) - cast(*void)(*instance)) == 28, "PxExtendedContact.maxImpulse has unexpected offset % instead of 28", ((cast(*void)(*instance.maxImpulse)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxExtendedContact.maxImpulse)) == 4, "PxExtendedContact.maxImpulse has unexpected size % instead of 4", size_of(type_of(PxExtendedContact.maxImpulse)));
        assert(size_of(PxExtendedContact) == 32, "PxExtendedContact has size % instead of 32", size_of(PxExtendedContact));
    }

    /**
    \brief A modifiable contact point. This has additional fields per-contact to permit modification by user.
    \note Not all fields are currently exposed to the user.
    */
    PxModifiableContact :: struct {
        #as using pxextendedcontact: PxExtendedContact;

        normal:          PxVec3;

        restitution:     PxReal; //48

        materialFlags:   PxU32; //52

        materialIndex0:  PxU16; //54

        materialIndex1:  PxU16; //56

        staticFriction:  PxReal; //60

        dynamicFriction: PxReal; //64
    }
    #run {if true then return;
        assert(size_of(type_of(PxModifiableContact.pxextendedcontact)) == 32, "PxModifiableContact.pxextendedcontact has unexpected size % instead of 32", size_of(type_of(PxModifiableContact.pxextendedcontact)));
        instance: PxModifiableContact;
        assert(((cast(*void)(*instance.normal)) - cast(*void)(*instance)) == 32, "PxModifiableContact.normal has unexpected offset % instead of 32", ((cast(*void)(*instance.normal)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxModifiableContact.normal)) == 12, "PxModifiableContact.normal has unexpected size % instead of 12", size_of(type_of(PxModifiableContact.normal)));
        assert(((cast(*void)(*instance.restitution)) - cast(*void)(*instance)) == 44, "PxModifiableContact.restitution has unexpected offset % instead of 44", ((cast(*void)(*instance.restitution)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxModifiableContact.restitution)) == 4, "PxModifiableContact.restitution has unexpected size % instead of 4", size_of(type_of(PxModifiableContact.restitution)));
        assert(((cast(*void)(*instance.materialFlags)) - cast(*void)(*instance)) == 48, "PxModifiableContact.materialFlags has unexpected offset % instead of 48", ((cast(*void)(*instance.materialFlags)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxModifiableContact.materialFlags)) == 4, "PxModifiableContact.materialFlags has unexpected size % instead of 4", size_of(type_of(PxModifiableContact.materialFlags)));
        assert(((cast(*void)(*instance.materialIndex0)) - cast(*void)(*instance)) == 52, "PxModifiableContact.materialIndex0 has unexpected offset % instead of 52", ((cast(*void)(*instance.materialIndex0)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxModifiableContact.materialIndex0)) == 2, "PxModifiableContact.materialIndex0 has unexpected size % instead of 2", size_of(type_of(PxModifiableContact.materialIndex0)));
        assert(((cast(*void)(*instance.materialIndex1)) - cast(*void)(*instance)) == 54, "PxModifiableContact.materialIndex1 has unexpected offset % instead of 54", ((cast(*void)(*instance.materialIndex1)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxModifiableContact.materialIndex1)) == 2, "PxModifiableContact.materialIndex1 has unexpected size % instead of 2", size_of(type_of(PxModifiableContact.materialIndex1)));
        assert(((cast(*void)(*instance.staticFriction)) - cast(*void)(*instance)) == 56, "PxModifiableContact.staticFriction has unexpected offset % instead of 56", ((cast(*void)(*instance.staticFriction)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxModifiableContact.staticFriction)) == 4, "PxModifiableContact.staticFriction has unexpected size % instead of 4", size_of(type_of(PxModifiableContact.staticFriction)));
        assert(((cast(*void)(*instance.dynamicFriction)) - cast(*void)(*instance)) == 60, "PxModifiableContact.dynamicFriction has unexpected offset % instead of 60", ((cast(*void)(*instance.dynamicFriction)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxModifiableContact.dynamicFriction)) == 4, "PxModifiableContact.dynamicFriction has unexpected size % instead of 4", size_of(type_of(PxModifiableContact.dynamicFriction)));
        assert(size_of(PxModifiableContact) == 64, "PxModifiableContact has size % instead of 64", size_of(PxModifiableContact));
    }

    /**
    \brief A class to iterate over a compressed contact stream. This supports read-only access to the various contact formats.
    */
    PxContactStreamIterator :: struct {
        StreamFormat :: enum s32 {
            SIMPLE_STREAM                :: 0;
            MODIFIABLE_STREAM            :: 1;
            COMPRESSED_MODIFIABLE_STREAM :: 2;

            eSIMPLE_STREAM                :: SIMPLE_STREAM;
            eMODIFIABLE_STREAM            :: MODIFIABLE_STREAM;
            eCOMPRESSED_MODIFIABLE_STREAM :: COMPRESSED_MODIFIABLE_STREAM;
        }

        /**
        \brief Utility zero vector to optimize functions returning zero vectors when a certain flag isn't set.
        \note This allows us to return by reference instead of having to return by value. Returning by value will go via memory (registers -> stack -> registers), which can
        cause performance issues on certain platforms.
        */
        zero:                   PxVec3;

        /**
        \brief The patch headers.
        */
        patch:                  *PxContactPatch;

        /**
        \brief The contacts
        */
        contact:                *PxContact;

        /**
        \brief The contact triangle face index
        */
        faceIndice:             *PxU32;

        /**
        \brief The total number of patches in this contact stream
        */
        totalPatches:           PxU32;

        /**
        \brief The total number of contact points in this stream
        */
        totalContacts:          PxU32;

        /**
        \brief The current contact index
        */
        nextContactIndex:       PxU32;

        /**
        \brief The current patch Index
        */
        nextPatchIndex:         PxU32;

        /*
        \brief Size of contact patch header
        \note This varies whether the patch is modifiable or not.
        */
        contactPatchHeaderSize: PxU32;

        /**
        \brief Contact point size
        \note This varies whether the patch has feature indices or is modifiable.
        */
        contactPointSize:       PxU32;

        /**
        \brief The stream format
        */
        mStreamFormat:          StreamFormat;

        /**
        \brief Indicates whether this stream is notify-only or not.
        */
        forceNoResponse:        PxU32;

        pointStepped:           bool;

        hasFaceIndices:         PxU32;

        /**
        \brief Constructor
        */
        Constructor :: (this: *PxContactStreamIterator, contactPatches: *PxU8, contactPoints: *PxU8, contactFaceIndices: *PxU32, nbPatches: PxU32, nbContacts: PxU32) -> void #cpp_method #foreign physx_lib "??0PxContactStreamIterator@physx@@QEAA@PEBE0PEBIII@Z";

        /**
        \brief Returns whether there are more patches in this stream.
        \return Whether there are more patches in this stream.
        */
        hasNextPatch :: (this: *PxContactStreamIterator) -> bool #cpp_method #foreign physx_lib "?hasNextPatch@PxContactStreamIterator@physx@@QEBA_NXZ";

        /**
        \brief Returns the total contact count.
        \return Total contact count.
        */
        getTotalContactCount :: (this: *PxContactStreamIterator) -> PxU32 #cpp_method #foreign physx_lib "?getTotalContactCount@PxContactStreamIterator@physx@@QEBAIXZ";

        getTotalPatchCount :: (this: *PxContactStreamIterator) -> PxU32 #cpp_method #foreign physx_lib "?getTotalPatchCount@PxContactStreamIterator@physx@@QEBAIXZ";

        /**
        \brief Advances iterator to next contact patch.
        */
        nextPatch :: (this: *PxContactStreamIterator) -> void #cpp_method #foreign physx_lib "?nextPatch@PxContactStreamIterator@physx@@QEAAXXZ";

        /**
        \brief Returns if the current patch has more contacts.
        \return If there are more contacts in the current patch.
        */
        hasNextContact :: (this: *PxContactStreamIterator) -> bool #cpp_method #foreign physx_lib "?hasNextContact@PxContactStreamIterator@physx@@QEBA_NXZ";

        /**
        \brief Advances to the next contact in the patch.
        */
        nextContact :: (this: *PxContactStreamIterator) -> void #cpp_method #foreign physx_lib "?nextContact@PxContactStreamIterator@physx@@QEAAXXZ";

        /**
        \brief Gets the current contact's normal
        \return The current contact's normal.
        */
        getContactNormal :: (this: *PxContactStreamIterator) -> *PxVec3 #cpp_method #foreign physx_lib "?getContactNormal@PxContactStreamIterator@physx@@QEBAAEBVPxVec3@2@XZ";

        /**
        \brief Gets the inverse mass scale for body 0.
        \return The inverse mass scale for body 0.
        */
        getInvMassScale0 :: (this: *PxContactStreamIterator) -> PxReal #cpp_method #foreign physx_lib "?getInvMassScale0@PxContactStreamIterator@physx@@QEBAMXZ";

        /**
        \brief Gets the inverse mass scale for body 1.
        \return The inverse mass scale for body 1.
        */
        getInvMassScale1 :: (this: *PxContactStreamIterator) -> PxReal #cpp_method #foreign physx_lib "?getInvMassScale1@PxContactStreamIterator@physx@@QEBAMXZ";

        /**
        \brief Gets the inverse inertia scale for body 0.
        \return The inverse inertia scale for body 0.
        */
        getInvInertiaScale0 :: (this: *PxContactStreamIterator) -> PxReal #cpp_method #foreign physx_lib "?getInvInertiaScale0@PxContactStreamIterator@physx@@QEBAMXZ";

        /**
        \brief Gets the inverse inertia scale for body 1.
        \return The inverse inertia scale for body 1.
        */
        getInvInertiaScale1 :: (this: *PxContactStreamIterator) -> PxReal #cpp_method #foreign physx_lib "?getInvInertiaScale1@PxContactStreamIterator@physx@@QEBAMXZ";

        /**
        \brief Gets the contact's max impulse.
        \return The contact's max impulse.
        */
        getMaxImpulse :: (this: *PxContactStreamIterator) -> PxReal #cpp_method #foreign physx_lib "?getMaxImpulse@PxContactStreamIterator@physx@@QEBAMXZ";

        /**
        \brief Gets the contact's target velocity.
        \return The contact's target velocity.
        */
        getTargetVel :: (this: *PxContactStreamIterator) -> *PxVec3 #cpp_method #foreign physx_lib "?getTargetVel@PxContactStreamIterator@physx@@QEBAAEBVPxVec3@2@XZ";

        /**
        \brief Gets the contact's contact point.
        \return The contact's contact point.
        */
        getContactPoint :: (this: *PxContactStreamIterator) -> *PxVec3 #cpp_method #foreign physx_lib "?getContactPoint@PxContactStreamIterator@physx@@QEBAAEBVPxVec3@2@XZ";

        /**
        \brief Gets the contact's separation.
        \return The contact's separation.
        */
        getSeparation :: (this: *PxContactStreamIterator) -> PxReal #cpp_method #foreign physx_lib "?getSeparation@PxContactStreamIterator@physx@@QEBAMXZ";

        /**
        \brief Gets the contact's face index for shape 0.
        \return The contact's face index for shape 0.
        */
        getFaceIndex0 :: (this: *PxContactStreamIterator) -> PxU32 #cpp_method #foreign physx_lib "?getFaceIndex0@PxContactStreamIterator@physx@@QEBAIXZ";

        /**
        \brief Gets the contact's face index for shape 1.
        \return The contact's face index for shape 1.
        */
        getFaceIndex1 :: (this: *PxContactStreamIterator) -> PxU32 #cpp_method #foreign physx_lib "?getFaceIndex1@PxContactStreamIterator@physx@@QEBAIXZ";

        /**
        \brief Gets the contact's static friction coefficient.
        \return The contact's static friction coefficient.
        */
        getStaticFriction :: (this: *PxContactStreamIterator) -> PxReal #cpp_method #foreign physx_lib "?getStaticFriction@PxContactStreamIterator@physx@@QEBAMXZ";

        /**
        \brief Gets the contact's static dynamic coefficient.
        \return The contact's static dynamic coefficient.
        */
        getDynamicFriction :: (this: *PxContactStreamIterator) -> PxReal #cpp_method #foreign physx_lib "?getDynamicFriction@PxContactStreamIterator@physx@@QEBAMXZ";

        /**
        \brief Gets the contact's restitution coefficient.
        \return The contact's restitution coefficient.
        */
        getRestitution :: (this: *PxContactStreamIterator) -> PxReal #cpp_method #foreign physx_lib "?getRestitution@PxContactStreamIterator@physx@@QEBAMXZ";

        /**
        \brief Gets the contact's material flags.
        \return The contact's material flags.
        */
        getMaterialFlags :: (this: *PxContactStreamIterator) -> PxU32 #cpp_method #foreign physx_lib "?getMaterialFlags@PxContactStreamIterator@physx@@QEBAIXZ";

        /**
        \brief Gets the contact's material index for shape 0.
        \return The contact's material index for shape 0.
        */
        getMaterialIndex0 :: (this: *PxContactStreamIterator) -> PxU16 #cpp_method #foreign physx_lib "?getMaterialIndex0@PxContactStreamIterator@physx@@QEBAGXZ";

        /**
        \brief Gets the contact's material index for shape 1.
        \return The contact's material index for shape 1.
        */
        getMaterialIndex1 :: (this: *PxContactStreamIterator) -> PxU16 #cpp_method #foreign physx_lib "?getMaterialIndex1@PxContactStreamIterator@physx@@QEBAGXZ";

        /**
        \brief Advances the contact stream iterator to a specific contact index.
        */
        advanceToIndex :: (this: *PxContactStreamIterator, initialIndex: PxU32) -> bool #cpp_method #foreign physx_lib "?advanceToIndex@PxContactStreamIterator@physx@@QEAA_NI@Z";

        /**
        \brief Internal helper
        */
        getContactPatch :: (this: *PxContactStreamIterator) -> *PxContactPatch #cpp_method #foreign physx_lib "?getContactPatch@PxContactStreamIterator@physx@@AEBAAEBUPxContactPatch@2@XZ";

        getExtendedContact :: (this: *PxContactStreamIterator) -> *PxExtendedContact #cpp_method #foreign physx_lib "?getExtendedContact@PxContactStreamIterator@physx@@AEBAAEBUPxExtendedContact@2@XZ";
    }
    #run {if true then return;
        instance: PxContactStreamIterator;
        assert(((cast(*void)(*instance.zero)) - cast(*void)(*instance)) == 0, "PxContactStreamIterator.zero has unexpected offset % instead of 0", ((cast(*void)(*instance.zero)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactStreamIterator.zero)) == 12, "PxContactStreamIterator.zero has unexpected size % instead of 12", size_of(type_of(PxContactStreamIterator.zero)));
        assert(((cast(*void)(*instance.patch)) - cast(*void)(*instance)) == 16, "PxContactStreamIterator.patch has unexpected offset % instead of 16", ((cast(*void)(*instance.patch)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactStreamIterator.patch)) == 8, "PxContactStreamIterator.patch has unexpected size % instead of 8", size_of(type_of(PxContactStreamIterator.patch)));
        assert(((cast(*void)(*instance.contact)) - cast(*void)(*instance)) == 24, "PxContactStreamIterator.contact has unexpected offset % instead of 24", ((cast(*void)(*instance.contact)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactStreamIterator.contact)) == 8, "PxContactStreamIterator.contact has unexpected size % instead of 8", size_of(type_of(PxContactStreamIterator.contact)));
        assert(((cast(*void)(*instance.faceIndice)) - cast(*void)(*instance)) == 32, "PxContactStreamIterator.faceIndice has unexpected offset % instead of 32", ((cast(*void)(*instance.faceIndice)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactStreamIterator.faceIndice)) == 8, "PxContactStreamIterator.faceIndice has unexpected size % instead of 8", size_of(type_of(PxContactStreamIterator.faceIndice)));
        assert(((cast(*void)(*instance.totalPatches)) - cast(*void)(*instance)) == 40, "PxContactStreamIterator.totalPatches has unexpected offset % instead of 40", ((cast(*void)(*instance.totalPatches)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactStreamIterator.totalPatches)) == 4, "PxContactStreamIterator.totalPatches has unexpected size % instead of 4", size_of(type_of(PxContactStreamIterator.totalPatches)));
        assert(((cast(*void)(*instance.totalContacts)) - cast(*void)(*instance)) == 44, "PxContactStreamIterator.totalContacts has unexpected offset % instead of 44", ((cast(*void)(*instance.totalContacts)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactStreamIterator.totalContacts)) == 4, "PxContactStreamIterator.totalContacts has unexpected size % instead of 4", size_of(type_of(PxContactStreamIterator.totalContacts)));
        assert(((cast(*void)(*instance.nextContactIndex)) - cast(*void)(*instance)) == 48, "PxContactStreamIterator.nextContactIndex has unexpected offset % instead of 48", ((cast(*void)(*instance.nextContactIndex)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactStreamIterator.nextContactIndex)) == 4, "PxContactStreamIterator.nextContactIndex has unexpected size % instead of 4", size_of(type_of(PxContactStreamIterator.nextContactIndex)));
        assert(((cast(*void)(*instance.nextPatchIndex)) - cast(*void)(*instance)) == 52, "PxContactStreamIterator.nextPatchIndex has unexpected offset % instead of 52", ((cast(*void)(*instance.nextPatchIndex)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactStreamIterator.nextPatchIndex)) == 4, "PxContactStreamIterator.nextPatchIndex has unexpected size % instead of 4", size_of(type_of(PxContactStreamIterator.nextPatchIndex)));
        assert(((cast(*void)(*instance.contactPatchHeaderSize)) - cast(*void)(*instance)) == 56, "PxContactStreamIterator.contactPatchHeaderSize has unexpected offset % instead of 56", ((cast(*void)(*instance.contactPatchHeaderSize)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactStreamIterator.contactPatchHeaderSize)) == 4, "PxContactStreamIterator.contactPatchHeaderSize has unexpected size % instead of 4", size_of(type_of(PxContactStreamIterator.contactPatchHeaderSize)));
        assert(((cast(*void)(*instance.contactPointSize)) - cast(*void)(*instance)) == 60, "PxContactStreamIterator.contactPointSize has unexpected offset % instead of 60", ((cast(*void)(*instance.contactPointSize)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactStreamIterator.contactPointSize)) == 4, "PxContactStreamIterator.contactPointSize has unexpected size % instead of 4", size_of(type_of(PxContactStreamIterator.contactPointSize)));
        assert(((cast(*void)(*instance.mStreamFormat)) - cast(*void)(*instance)) == 64, "PxContactStreamIterator.mStreamFormat has unexpected offset % instead of 64", ((cast(*void)(*instance.mStreamFormat)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactStreamIterator.mStreamFormat)) == 4, "PxContactStreamIterator.mStreamFormat has unexpected size % instead of 4", size_of(type_of(PxContactStreamIterator.mStreamFormat)));
        assert(((cast(*void)(*instance.forceNoResponse)) - cast(*void)(*instance)) == 68, "PxContactStreamIterator.forceNoResponse has unexpected offset % instead of 68", ((cast(*void)(*instance.forceNoResponse)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactStreamIterator.forceNoResponse)) == 4, "PxContactStreamIterator.forceNoResponse has unexpected size % instead of 4", size_of(type_of(PxContactStreamIterator.forceNoResponse)));
        assert(((cast(*void)(*instance.pointStepped)) - cast(*void)(*instance)) == 72, "PxContactStreamIterator.pointStepped has unexpected offset % instead of 72", ((cast(*void)(*instance.pointStepped)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactStreamIterator.pointStepped)) == 1, "PxContactStreamIterator.pointStepped has unexpected size % instead of 1", size_of(type_of(PxContactStreamIterator.pointStepped)));
        assert(((cast(*void)(*instance.hasFaceIndices)) - cast(*void)(*instance)) == 76, "PxContactStreamIterator.hasFaceIndices has unexpected offset % instead of 76", ((cast(*void)(*instance.hasFaceIndices)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactStreamIterator.hasFaceIndices)) == 4, "PxContactStreamIterator.hasFaceIndices has unexpected size % instead of 4", size_of(type_of(PxContactStreamIterator.hasFaceIndices)));
        assert(size_of(PxContactStreamIterator) == 80, "PxContactStreamIterator has size % instead of 80", size_of(PxContactStreamIterator));
    }

    /**
    \brief An array of contact points, as passed to contact modification.

    The word 'set' in the name does not imply that duplicates are filtered in any
    way.  This initial set of contacts does potentially get reduced to a smaller
    set before being passed to the solver.

    You can use the accessors to read and write contact properties.  The number of
    contacts is immutable, other than being able to disable contacts using ignore().

    @see PxContactModifyCallback, PxModifiableContact
    */
    PxContactSet :: struct {
        /**
        \brief Get the position of a specific contact point in the set.

        @see PxModifiableContact.point
        */
        getPoint :: (this: *PxContactSet, i: PxU32) -> *PxVec3 #cpp_method #foreign physx_lib "?getPoint@PxContactSet@physx@@QEBAAEBVPxVec3@2@I@Z";

        /**
        \brief Alter the position of a specific contact point in the set.

        @see PxModifiableContact.point
        */
        setPoint :: (this: *PxContactSet, i: PxU32, p: *PxVec3) -> void #cpp_method #foreign physx_lib "?setPoint@PxContactSet@physx@@QEAAXIAEBVPxVec3@2@@Z";
        setPoint :: (this: *PxContactSet, i: PxU32, p: PxVec3) #no_context {
            setPoint(this, i, *p);
        }

        /**
        \brief Get the contact normal of a specific contact point in the set.

        @see PxModifiableContact.normal
        */
        getNormal :: (this: *PxContactSet, i: PxU32) -> *PxVec3 #cpp_method #foreign physx_lib "?getNormal@PxContactSet@physx@@QEBAAEBVPxVec3@2@I@Z";

        /**
        \brief Alter the contact normal of a specific contact point in the set.

        \note Changing the normal can cause contact points to be ignored.

        @see PxModifiableContact.normal
        */
        setNormal :: (this: *PxContactSet, i: PxU32, n: *PxVec3) -> void #cpp_method #foreign physx_lib "?setNormal@PxContactSet@physx@@QEAAXIAEBVPxVec3@2@@Z";
        setNormal :: (this: *PxContactSet, i: PxU32, n: PxVec3) #no_context {
            setNormal(this, i, *n);
        }

        /**
        \brief Get the separation of a specific contact point in the set.

        @see PxModifiableContact.separation
        */
        getSeparation :: (this: *PxContactSet, i: PxU32) -> PxReal #cpp_method #foreign physx_lib "?getSeparation@PxContactSet@physx@@QEBAMI@Z";

        /**
        \brief Alter the separation of a specific contact point in the set.

        @see PxModifiableContact.separation
        */
        setSeparation :: (this: *PxContactSet, i: PxU32, s: PxReal) -> void #cpp_method #foreign physx_lib "?setSeparation@PxContactSet@physx@@QEAAXIM@Z";

        /**
        \brief Get the target velocity of a specific contact point in the set.

        @see PxModifiableContact.targetVelocity

        */
        getTargetVelocity :: (this: *PxContactSet, i: PxU32) -> *PxVec3 #cpp_method #foreign physx_lib "?getTargetVelocity@PxContactSet@physx@@QEBAAEBVPxVec3@2@I@Z";

        /**
        \brief Alter the target velocity of a specific contact point in the set.

        @see PxModifiableContact.targetVelocity
        */
        setTargetVelocity :: (this: *PxContactSet, i: PxU32, v: *PxVec3) -> void #cpp_method #foreign physx_lib "?setTargetVelocity@PxContactSet@physx@@QEAAXIAEBVPxVec3@2@@Z";
        setTargetVelocity :: (this: *PxContactSet, i: PxU32, v: PxVec3) #no_context {
            setTargetVelocity(this, i, *v);
        }

        /**
        \brief Get the face index with respect to the first shape of the pair for a specific contact point in the set.

        @see PxModifiableContact.internalFaceIndex0
        */
        getInternalFaceIndex0 :: (this: *PxContactSet, i: PxU32) -> PxU32 #cpp_method #foreign physx_lib "?getInternalFaceIndex0@PxContactSet@physx@@QEAAII@Z";

        /**
        \brief Get the face index with respect to the second shape of the pair for a specific contact point in the set.

        @see PxModifiableContact.internalFaceIndex1
        */
        getInternalFaceIndex1 :: (this: *PxContactSet, i: PxU32) -> PxU32 #cpp_method #foreign physx_lib "?getInternalFaceIndex1@PxContactSet@physx@@QEAAII@Z";

        /**
        \brief Get the maximum impulse for a specific contact point in the set.

        @see PxModifiableContact.maxImpulse
        */
        getMaxImpulse :: (this: *PxContactSet, i: PxU32) -> PxReal #cpp_method #foreign physx_lib "?getMaxImpulse@PxContactSet@physx@@QEBAMI@Z";

        /**
        \brief Alter the maximum impulse for a specific contact point in the set.

        \note Must be nonnegative. If set to zero, the contact point will be ignored

        @see PxModifiableContact.maxImpulse
        */
        setMaxImpulse :: (this: *PxContactSet, i: PxU32, s: PxReal) -> void #cpp_method #foreign physx_lib "?setMaxImpulse@PxContactSet@physx@@QEAAXIM@Z";

        /**
        \brief Get the restitution coefficient for a specific contact point in the set.

        @see PxModifiableContact.restitution
        */
        getRestitution :: (this: *PxContactSet, i: PxU32) -> PxReal #cpp_method #foreign physx_lib "?getRestitution@PxContactSet@physx@@QEBAMI@Z";

        /**
        \brief Alter the restitution coefficient for a specific contact point in the set.

        \note Valid ranges [0,1]

        @see PxModifiableContact.restitution
        */
        setRestitution :: (this: *PxContactSet, i: PxU32, r: PxReal) -> void #cpp_method #foreign physx_lib "?setRestitution@PxContactSet@physx@@QEAAXIM@Z";

        /**
        \brief Get the static friction coefficient for a specific contact point in the set.

        @see PxModifiableContact.staticFriction
        */
        getStaticFriction :: (this: *PxContactSet, i: PxU32) -> PxReal #cpp_method #foreign physx_lib "?getStaticFriction@PxContactSet@physx@@QEBAMI@Z";

        /**
        \brief Alter the static friction coefficient for a specific contact point in the set.

        @see PxModifiableContact.staticFriction
        */
        setStaticFriction :: (this: *PxContactSet, i: PxU32, f: PxReal) -> void #cpp_method #foreign physx_lib "?setStaticFriction@PxContactSet@physx@@QEAAXIM@Z";

        /**
        \brief Get the static friction coefficient for a specific contact point in the set.

        @see PxModifiableContact.dynamicFriction
        */
        getDynamicFriction :: (this: *PxContactSet, i: PxU32) -> PxReal #cpp_method #foreign physx_lib "?getDynamicFriction@PxContactSet@physx@@QEBAMI@Z";

        /**
        \brief Alter the static dynamic coefficient for a specific contact point in the set.

        @see PxModifiableContact.dynamic
        */
        setDynamicFriction :: (this: *PxContactSet, i: PxU32, f: PxReal) -> void #cpp_method #foreign physx_lib "?setDynamicFriction@PxContactSet@physx@@QEAAXIM@Z";

        /**
        \brief Ignore the contact point.

        If a contact point is ignored then no force will get applied at this point. This can be used to disable collision in certain areas of a shape, for example.
        */
        ignore :: (this: *PxContactSet, i: PxU32) -> void #cpp_method #foreign physx_lib "?ignore@PxContactSet@physx@@QEAAXI@Z";

        /**
        \brief The number of contact points in the set.
        */
        size :: (this: *PxContactSet) -> PxU32 #cpp_method #foreign physx_lib "?size@PxContactSet@physx@@QEBAIXZ";

        /**
        \brief Returns the invMassScale of body 0

        A value < 1.0 makes this contact treat the body as if it had larger mass. A value of 0.f makes this contact
        treat the body as if it had infinite mass. Any value > 1.f makes this contact treat the body as if it had smaller mass.
        */
        getInvMassScale0 :: (this: *PxContactSet) -> PxReal #cpp_method #foreign physx_lib "?getInvMassScale0@PxContactSet@physx@@QEBAMXZ";

        /**
        \brief Returns the invMassScale of body 1

        A value < 1.0 makes this contact treat the body as if it had larger mass. A value of 0.f makes this contact
        treat the body as if it had infinite mass. Any value > 1.f makes this contact treat the body as if it had smaller mass.
        */
        getInvMassScale1 :: (this: *PxContactSet) -> PxReal #cpp_method #foreign physx_lib "?getInvMassScale1@PxContactSet@physx@@QEBAMXZ";

        /**
        \brief Returns the invInertiaScale of body 0

        A value < 1.0 makes this contact treat the body as if it had larger inertia. A value of 0.f makes this contact
        treat the body as if it had infinite inertia. Any value > 1.f makes this contact treat the body as if it had smaller inertia.
        */
        getInvInertiaScale0 :: (this: *PxContactSet) -> PxReal #cpp_method #foreign physx_lib "?getInvInertiaScale0@PxContactSet@physx@@QEBAMXZ";

        /**
        \brief Returns the invInertiaScale of body 1

        A value < 1.0 makes this contact treat the body as if it had larger inertia. A value of 0.f makes this contact
        treat the body as if it had infinite inertia. Any value > 1.f makes this contact treat the body as if it had smaller inertia.
        */
        getInvInertiaScale1 :: (this: *PxContactSet) -> PxReal #cpp_method #foreign physx_lib "?getInvInertiaScale1@PxContactSet@physx@@QEBAMXZ";

        /**
        \brief Sets the invMassScale of body 0

        This can be set to any value in the range [0, PX_MAX_F32). A value < 1.0 makes this contact treat the body as if it had larger mass. A value of 0.f makes this contact
        treat the body as if it had infinite mass. Any value > 1.f makes this contact treat the body as if it had smaller mass.
        */
        setInvMassScale0 :: (this: *PxContactSet, scale: PxReal) -> void #cpp_method #foreign physx_lib "?setInvMassScale0@PxContactSet@physx@@QEAAXM@Z";

        /**
        \brief Sets the invMassScale of body 1

        This can be set to any value in the range [0, PX_MAX_F32). A value < 1.0 makes this contact treat the body as if it had larger mass. A value of 0.f makes this contact
        treat the body as if it had infinite mass. Any value > 1.f makes this contact treat the body as if it had smaller mass.
        */
        setInvMassScale1 :: (this: *PxContactSet, scale: PxReal) -> void #cpp_method #foreign physx_lib "?setInvMassScale1@PxContactSet@physx@@QEAAXM@Z";

        /**
        \brief Sets the invInertiaScale of body 0

        This can be set to any value in the range [0, PX_MAX_F32). A value < 1.0 makes this contact treat the body as if it had larger inertia. A value of 0.f makes this contact
        treat the body as if it had infinite inertia. Any value > 1.f makes this contact treat the body as if it had smaller inertia.
        */
        setInvInertiaScale0 :: (this: *PxContactSet, scale: PxReal) -> void #cpp_method #foreign physx_lib "?setInvInertiaScale0@PxContactSet@physx@@QEAAXM@Z";

        /**
        \brief Sets the invInertiaScale of body 1

        This can be set to any value in the range [0, PX_MAX_F32). A value < 1.0 makes this contact treat the body as if it had larger inertia. A value of 0.f makes this contact
        treat the body as if it had infinite inertia. Any value > 1.f makes this contact treat the body as if it had smaller inertia.
        */
        setInvInertiaScale1 :: (this: *PxContactSet, scale: PxReal) -> void #cpp_method #foreign physx_lib "?setInvInertiaScale1@PxContactSet@physx@@QEAAXM@Z";

        getPatch :: (this: *PxContactSet) -> *PxContactPatch #cpp_method #foreign physx_lib "?getPatch@PxContactSet@physx@@IEBAPEAUPxContactPatch@2@XZ";

        mCount:    PxU32; //!< Number of contact points in the set
        mContacts: *PxModifiableContact; //!< The contact points of the set
    }
    #run {if true then return;
        instance: PxContactSet;
        assert(((cast(*void)(*instance.mCount)) - cast(*void)(*instance)) == 0, "PxContactSet.mCount has unexpected offset % instead of 0", ((cast(*void)(*instance.mCount)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactSet.mCount)) == 4, "PxContactSet.mCount has unexpected size % instead of 4", size_of(type_of(PxContactSet.mCount)));
        assert(((cast(*void)(*instance.mContacts)) - cast(*void)(*instance)) == 8, "PxContactSet.mContacts has unexpected offset % instead of 8", ((cast(*void)(*instance.mContacts)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactSet.mContacts)) == 8, "PxContactSet.mContacts has unexpected size % instead of 8", size_of(type_of(PxContactSet.mContacts)));
        assert(size_of(PxContactSet) == 16, "PxContactSet has size % instead of 16", size_of(PxContactSet));
    }

    /**
    \brief An array of instances of this class is passed to PxContactModifyCallback::onContactModify().

    @see PxContactModifyCallback
    */
    PxContactModifyPair :: struct {
        /**
        \brief The actors which make up the pair in contact.

        Note that these are the actors as seen by the simulation, and may have been deleted since the simulation step started.
        */
        actor:     [2] *PxRigidActor;

        /**
        \brief The shapes which make up the pair in contact.

        Note that these are the shapes as seen by the simulation, and may have been deleted since the simulation step started.
        */
        shape:     [2] *PxShape;

        /**
        \brief The shape to world transforms of the two shapes.

        These are the transforms as the simulation engine sees them, and may have been modified by the application
        since the simulation step started.

        */
        transform: [2] PxTransform;

        /**
        \brief An array of contact points between these two shapes.
        */
        contacts:  PxContactSet;
    }
    #run {if true then return;
        instance: PxContactModifyPair;
        assert(((cast(*void)(*instance.actor)) - cast(*void)(*instance)) == 0, "PxContactModifyPair.actor has unexpected offset % instead of 0", ((cast(*void)(*instance.actor)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactModifyPair.actor)) == 16, "PxContactModifyPair.actor has unexpected size % instead of 16", size_of(type_of(PxContactModifyPair.actor)));
        assert(((cast(*void)(*instance.shape)) - cast(*void)(*instance)) == 16, "PxContactModifyPair.shape has unexpected offset % instead of 16", ((cast(*void)(*instance.shape)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactModifyPair.shape)) == 16, "PxContactModifyPair.shape has unexpected size % instead of 16", size_of(type_of(PxContactModifyPair.shape)));
        assert(((cast(*void)(*instance.transform)) - cast(*void)(*instance)) == 32, "PxContactModifyPair.transform has unexpected offset % instead of 32", ((cast(*void)(*instance.transform)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactModifyPair.transform)) == 56, "PxContactModifyPair.transform has unexpected size % instead of 56", size_of(type_of(PxContactModifyPair.transform)));
        assert(((cast(*void)(*instance.contacts)) - cast(*void)(*instance)) == 88, "PxContactModifyPair.contacts has unexpected offset % instead of 88", ((cast(*void)(*instance.contacts)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactModifyPair.contacts)) == 16, "PxContactModifyPair.contacts has unexpected size % instead of 16", size_of(type_of(PxContactModifyPair.contacts)));
        assert(size_of(PxContactModifyPair) == 104, "PxContactModifyPair has size % instead of 104", size_of(PxContactModifyPair));
    }

    /**
    \brief An interface class that the user can implement in order to modify contact constraints.

    <b>Threading:</b> It is <b>necessary</b> to make this class thread safe as it will be called in the context of the
    simulation thread. It might also be necessary to make it reentrant, since some calls can be made by multi-threaded
    parts of the physics engine.

    You can enable the use of this contact modification callback by raising the flag PxPairFlag::eMODIFY_CONTACTS in
    the filter shader/callback (see #PxSimulationFilterShader) for a pair of rigid body objects.

    Please note:
    + Raising the contact modification flag will not wake the actors up automatically.
    + It is not possible to turn off the performance degradation by simply removing the callback from the scene, the
    filter shader/callback has to be used to clear the contact modification flag.
    + The contacts will only be reported as long as the actors are awake. There will be no callbacks while the actors are sleeping.

    @see PxScene.setContactModifyCallback() PxScene.getContactModifyCallback()
    */
    PxContactModifyCallback :: struct {
        vtable: *PxContactModifyCallback_VTable;
    }
    PxContactModifyCallback_VTable :: struct #type_info_none {
        onContactModify: (this: *PxContactModifyCallback, pairs: *PxContactModifyPair, count: PxU32) -> void #cpp_method;

        Destructor: (this: *PxContactModifyCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxContactModifyCallback_onContactModify :: inline (this: *PxContactModifyCallback, pairs: *PxContactModifyPair, count: PxU32) { this.vtable.onContactModify(this, pairs, count); }

    PxContactModifyCallback_Destructor :: inline (this: *PxContactModifyCallback, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxContactModifyCallback) -> *PxContactModifyCallback_VTable { return obj.vtable; }

    #run {if true then return;
        assert(size_of(PxContactModifyCallback) == 8, "PxContactModifyCallback has size % instead of 8", size_of(PxContactModifyCallback));
    }

    /**
    \brief An interface class that the user can implement in order to modify CCD contact constraints.

    <b>Threading:</b> It is <b>necessary</b> to make this class thread safe as it will be called in the context of the
    simulation thread. It might also be necessary to make it reentrant, since some calls can be made by multi-threaded
    parts of the physics engine.

    You can enable the use of this contact modification callback by raising the flag PxPairFlag::eMODIFY_CONTACTS in
    the filter shader/callback (see #PxSimulationFilterShader) for a pair of rigid body objects.

    Please note:
    + Raising the contact modification flag will not wake the actors up automatically.
    + It is not possible to turn off the performance degradation by simply removing the callback from the scene, the
    filter shader/callback has to be used to clear the contact modification flag.
    + The contacts will only be reported as long as the actors are awake. There will be no callbacks while the actors are sleeping.

    @see PxScene.setContactModifyCallback() PxScene.getContactModifyCallback()
    */
    PxCCDContactModifyCallback :: struct {
        vtable: *PxCCDContactModifyCallback_VTable;
    }
    PxCCDContactModifyCallback_VTable :: struct #type_info_none {
        onCCDContactModify: (this: *PxCCDContactModifyCallback, pairs: *PxContactModifyPair, count: PxU32) -> void #cpp_method;

        Destructor: (this: *PxCCDContactModifyCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxCCDContactModifyCallback_onCCDContactModify :: inline (this: *PxCCDContactModifyCallback, pairs: *PxContactModifyPair, count: PxU32) { this.vtable.onCCDContactModify(this, pairs, count); }

    PxCCDContactModifyCallback_Destructor :: inline (this: *PxCCDContactModifyCallback, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxCCDContactModifyCallback) -> *PxCCDContactModifyCallback_VTable { return obj.vtable; }

    #run {if true then return;
        assert(size_of(PxCCDContactModifyCallback) == 8, "PxCCDContactModifyCallback has size % instead of 8", size_of(PxCCDContactModifyCallback));
    }

    /**
    \brief Flags specifying deletion event types.

    @see PxDeletionListener::onRelease PxPhysics.registerDeletionListener()
    */
    PxDeletionEventFlag :: struct {
        Enum :: enum s32 {
            USER_RELEASE   :: 1;
            MEMORY_RELEASE :: 2;

            eUSER_RELEASE   :: USER_RELEASE;
            eMEMORY_RELEASE :: MEMORY_RELEASE;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxDeletionEventFlag) == 1, "PxDeletionEventFlag has size % instead of 1", size_of(PxDeletionEventFlag));
    }

    /**
    \brief Collection of set bits defined in PxDeletionEventFlag.

    @see PxDeletionEventFlag
    */
    PxDeletionEventFlags :: PxFlags(PxDeletionEventFlag.Enum, PxU8);

    /**
    \brief interface to get notification on object deletion

    */
    PxDeletionListener :: struct {
        vtable: *PxDeletionListener_VTable;
    }
    PxDeletionListener_VTable :: struct #type_info_none {
        onRelease: (this: *PxDeletionListener, observed: *PxBase, userData: *void, deletionEvent: PxDeletionEventFlag.Enum) -> void #cpp_method;

        Destructor: (this: *PxDeletionListener, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxDeletionListener_onRelease :: inline (this: *PxDeletionListener, observed: *PxBase, userData: *void, deletionEvent: PxDeletionEventFlag.Enum) { this.vtable.onRelease(this, observed, userData, deletionEvent); }

    PxDeletionListener_Destructor :: inline (this: *PxDeletionListener, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxDeletionListener) -> *PxDeletionListener_VTable { return obj.vtable; }

    #run {if true then return;
        assert(size_of(PxDeletionListener) == 8, "PxDeletionListener has size % instead of 8", size_of(PxDeletionListener));
    }

    PxDataAccessFlag :: struct {
        Enum :: enum s32 {
            READABLE :: 1;
            WRITABLE :: 2;
            DEVICE   :: 4;

            eREADABLE :: READABLE;
            eWRITABLE :: WRITABLE;
            eDEVICE   :: DEVICE;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxDataAccessFlag) == 1, "PxDataAccessFlag has size % instead of 1", size_of(PxDataAccessFlag));
    }

    /**
    \brief collection of set bits defined in PxDataAccessFlag.

    @see PxDataAccessFlag
    */
    PxDataAccessFlags :: PxFlags(PxDataAccessFlag.Enum, PxU8);

    /**
    \brief Parent class for bulk data that is shared between the SDK and the application.
    */
    PxLockedData :: struct {
        vtable: *PxLockedData_VTable;
    }
    PxLockedData_VTable :: struct #type_info_none {
        getDataAccessFlags: (this: *PxLockedData) -> PxDataAccessFlags #cpp_method;

        unlock: (this: *PxLockedData) -> void #cpp_method;

        Destructor: (this: *PxLockedData, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxLockedData_getDataAccessFlags :: inline (this: *PxLockedData) -> PxDataAccessFlags { return this.vtable.getDataAccessFlags(this); }

    PxLockedData_unlock :: inline (this: *PxLockedData) { this.vtable.unlock(this); }

    PxLockedData_Destructor :: inline (this: *PxLockedData, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxLockedData) -> *PxLockedData_VTable { return obj.vtable; }

    #run {if true then return;
        assert(size_of(PxLockedData) == 8, "PxLockedData has size % instead of 8", size_of(PxLockedData));
    }

    /**
    \brief Flags which control the behavior of a material.

    @see PxMaterial
    */
    PxMaterialFlag :: struct {
        Enum :: enum s32 {
            DISABLE_FRICTION        :: 1;

            DISABLE_STRONG_FRICTION :: 2;

            IMPROVED_PATCH_FRICTION :: 4;

            eDISABLE_FRICTION        :: DISABLE_FRICTION;

            eDISABLE_STRONG_FRICTION :: DISABLE_STRONG_FRICTION;

            eIMPROVED_PATCH_FRICTION :: IMPROVED_PATCH_FRICTION;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxMaterialFlag) == 1, "PxMaterialFlag has size % instead of 1", size_of(PxMaterialFlag));
    }

    /**
    \brief collection of set bits defined in PxMaterialFlag.

    @see PxMaterialFlag
    */
    PxMaterialFlags :: PxFlags(PxMaterialFlag.Enum, PxU16);

    /**
    \brief enumeration that determines the way in which two material properties will be combined to yield a friction or restitution coefficient for a collision.

    When two actors come in contact with each other, they each have materials with various coefficients, but we only need a single set of coefficients for the pair.

    Physics doesn't have any inherent combinations because the coefficients are determined empirically on a case by case
    basis. However, simulating this with a pairwise lookup table is often impractical.

    For this reason the following combine behaviors are available:

    eAVERAGE
    eMIN
    eMULTIPLY
    eMAX

    The effective combine mode for the pair is maximum(material0.combineMode, material1.combineMode).

    @see PxMaterial.setFrictionCombineMode() PxMaterial.getFrictionCombineMode() PxMaterial.setRestitutionCombineMode() PxMaterial.getFrictionCombineMode()
    */
    PxCombineMode :: struct {
        Enum :: enum s32 {
            AVERAGE  :: 0;
            MIN      :: 1;
            MULTIPLY :: 2;
            MAX      :: 3;
            N_VALUES :: 4;
            PAD_32   :: 2147483647;

            eAVERAGE  :: AVERAGE;
            eMIN      :: MIN;
            eMULTIPLY :: MULTIPLY;
            eMAX      :: MAX;
            eN_VALUES :: N_VALUES;
            ePAD_32   :: PAD_32;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxCombineMode) == 1, "PxCombineMode has size % instead of 1", size_of(PxCombineMode));
    }

    /**
    \brief Material class to represent a set of surface properties.

    @see PxPhysics.createMaterial
    */
    PxMaterial :: struct {
        #as using pxbase: PxBase;

        userData: *void; //!< user can assign this to whatever, usually to create a 1:1 relationship with a user object.
        #place pxbase; pxmaterial_vtable: *PxMaterial_VTable;
    }
    PxMaterial_VTable :: struct #type_info_none {
        using pxbase: PxBase_VTable;
        getReferenceCount: (this: *PxMaterial) -> PxU32 #cpp_method;

        acquireReference: (this: *PxMaterial) -> void #cpp_method;

        setDynamicFriction: (this: *PxMaterial, coef: PxReal) -> void #cpp_method;

        getDynamicFriction: (this: *PxMaterial) -> PxReal #cpp_method;

        setStaticFriction: (this: *PxMaterial, coef: PxReal) -> void #cpp_method;

        getStaticFriction: (this: *PxMaterial) -> PxReal #cpp_method;

        setRestitution: (this: *PxMaterial, rest: PxReal) -> void #cpp_method;

        getRestitution: (this: *PxMaterial) -> PxReal #cpp_method;

        setFlag: (this: *PxMaterial, flag: PxMaterialFlag.Enum, unknown0: bool) -> void #cpp_method;

        setFlags: (this: *PxMaterial, inFlags: PxMaterialFlags) -> void #cpp_method;

        getFlags: (this: *PxMaterial) -> PxMaterialFlags #cpp_method;

        setFrictionCombineMode: (this: *PxMaterial, combMode: PxCombineMode.Enum) -> void #cpp_method;

        getFrictionCombineMode: (this: *PxMaterial) -> PxCombineMode.Enum #cpp_method;

        setRestitutionCombineMode: (this: *PxMaterial, combMode: PxCombineMode.Enum) -> void #cpp_method;

        getRestitutionCombineMode: (this: *PxMaterial) -> PxCombineMode.Enum #cpp_method;
    }

    PxMaterial_getReferenceCount :: inline (this: *PxMaterial) -> PxU32 { return this.pxmaterial_vtable.getReferenceCount(this); }

    PxMaterial_acquireReference :: inline (this: *PxMaterial) { this.pxmaterial_vtable.acquireReference(this); }

    PxMaterial_setDynamicFriction :: inline (this: *PxMaterial, coef: PxReal) { this.pxmaterial_vtable.setDynamicFriction(this, coef); }

    PxMaterial_getDynamicFriction :: inline (this: *PxMaterial) -> PxReal { return this.pxmaterial_vtable.getDynamicFriction(this); }

    PxMaterial_setStaticFriction :: inline (this: *PxMaterial, coef: PxReal) { this.pxmaterial_vtable.setStaticFriction(this, coef); }

    PxMaterial_getStaticFriction :: inline (this: *PxMaterial) -> PxReal { return this.pxmaterial_vtable.getStaticFriction(this); }

    PxMaterial_setRestitution :: inline (this: *PxMaterial, rest: PxReal) { this.pxmaterial_vtable.setRestitution(this, rest); }

    PxMaterial_getRestitution :: inline (this: *PxMaterial) -> PxReal { return this.pxmaterial_vtable.getRestitution(this); }

    PxMaterial_setFlag :: inline (this: *PxMaterial, flag: PxMaterialFlag.Enum, unknown0: bool) { this.pxmaterial_vtable.setFlag(this, flag, unknown0); }

    PxMaterial_setFlags :: inline (this: *PxMaterial, inFlags: PxMaterialFlags) { this.pxmaterial_vtable.setFlags(this, inFlags); }

    PxMaterial_getFlags :: inline (this: *PxMaterial) -> PxMaterialFlags { return this.pxmaterial_vtable.getFlags(this); }

    PxMaterial_setFrictionCombineMode :: inline (this: *PxMaterial, combMode: PxCombineMode.Enum) { this.pxmaterial_vtable.setFrictionCombineMode(this, combMode); }

    PxMaterial_getFrictionCombineMode :: inline (this: *PxMaterial) -> PxCombineMode.Enum { return this.pxmaterial_vtable.getFrictionCombineMode(this); }

    PxMaterial_setRestitutionCombineMode :: inline (this: *PxMaterial, combMode: PxCombineMode.Enum) { this.pxmaterial_vtable.setRestitutionCombineMode(this, combMode); }

    PxMaterial_getRestitutionCombineMode :: inline (this: *PxMaterial) -> PxCombineMode.Enum { return this.pxmaterial_vtable.getRestitutionCombineMode(this); }

    vtable :: (obj: *PxMaterial) -> *PxMaterial_VTable { return obj.pxmaterial_vtable; }

    #run {if true then return;
        assert(size_of(type_of(PxMaterial.pxbase)) == 16, "PxMaterial.pxbase has unexpected size % instead of 16", size_of(type_of(PxMaterial.pxbase)));
        instance: PxMaterial;
        assert(((cast(*void)(*instance.userData)) - cast(*void)(*instance)) == 16, "PxMaterial.userData has unexpected offset % instead of 16", ((cast(*void)(*instance.userData)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxMaterial.userData)) == 8, "PxMaterial.userData has unexpected size % instead of 8", size_of(type_of(PxMaterial.userData)));
        assert(size_of(PxMaterial) == 24, "PxMaterial has size % instead of 24", size_of(PxMaterial));
    }

    /**
    \brief Abstract singleton factory class used for instancing objects in the Physics SDK.

    In addition you can use PxPhysics to set global parameters which will effect all scenes and create
    objects that can be shared across multiple scenes.

    You can get an instance of this class by calling PxCreateBasePhysics() or PxCreatePhysics() with pre-registered modules.

    @see PxCreatePhysics() PxCreateBasePhysics() PxScene PxVisualizationParameter
    */
    PxPhysics :: struct {
        vtable: *PxPhysics_VTable;
        /**
        \brief Creates a shape which may be attached to multiple actors

        The shape will be created with a reference count of 1.

        \param	[in] geometry		The geometry for the shape
        \param	[in] material		The material for the shape
        \param	[in] isExclusive	Whether this shape is exclusive to a single actor or maybe be shared
        \param	[in] shapeFlags		The PxShapeFlags to be set

        Shared shapes are not mutable when they are attached to an actor

        @see PxShape
        */
        createShape :: (this: *PxPhysics, geometry: *PxGeometry, material: *PxMaterial, isExclusive := false, shapeFlags: PxShapeFlags) -> *PxShape #cpp_method #foreign physx_lib "?createShape@PxPhysics@physx@@QEAAPEAVPxShape@2@AEBVPxGeometry@2@AEBVPxMaterial@2@_NV?$PxFlags@W4Enum@PxShapeFlag@physx@@E@2@@Z";
        createShape :: (this: *PxPhysics, geometry: PxGeometry, material: PxMaterial, isExclusive := false, shapeFlags: PxShapeFlags) -> *PxShape #no_context {
            return createShape(this, *geometry, *material, isExclusive, shapeFlags);
        }
    }
    PxPhysics_VTable :: struct #type_info_none {
        Destructor: (this: *PxPhysics, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

        release: (this: *PxPhysics) -> void #cpp_method;

        getFoundation: (this: *PxPhysics) -> *PxFoundation #cpp_method;

        createAggregate: (this: *PxPhysics, maxSize: PxU32, enableSelfCollision: bool) -> *PxAggregate #cpp_method;

        getTolerancesScale: (this: *PxPhysics) -> *PxTolerancesScale #cpp_method;

        createTriangleMesh: (this: *PxPhysics, stream: *PxInputStream) -> *PxTriangleMesh #cpp_method;

        getNbTriangleMeshes: (this: *PxPhysics) -> PxU32 #cpp_method;

        getTriangleMeshes: (this: *PxPhysics, userBuffer: **PxTriangleMesh, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        createHeightField: (this: *PxPhysics, stream: *PxInputStream) -> *PxHeightField #cpp_method;

        getNbHeightFields: (this: *PxPhysics) -> PxU32 #cpp_method;

        getHeightFields: (this: *PxPhysics, userBuffer: **PxHeightField, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        createConvexMesh: (this: *PxPhysics, stream: *PxInputStream) -> *PxConvexMesh #cpp_method;

        getNbConvexMeshes: (this: *PxPhysics) -> PxU32 #cpp_method;

        getConvexMeshes: (this: *PxPhysics, userBuffer: **PxConvexMesh, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        createBVHStructure: (this: *PxPhysics, stream: *PxInputStream) -> *PxBVHStructure #cpp_method;

        getNbBVHStructures: (this: *PxPhysics) -> PxU32 #cpp_method;

        getBVHStructures: (this: *PxPhysics, userBuffer: **PxBVHStructure, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        createScene: (this: *PxPhysics, sceneDesc: *PxSceneDesc) -> *PxScene #cpp_method;

        getNbScenes: (this: *PxPhysics) -> PxU32 #cpp_method;

        getScenes: (this: *PxPhysics, userBuffer: **PxScene, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        createRigidStatic: (this: *PxPhysics, pose: *PxTransform) -> *PxRigidStatic #cpp_method;

        createRigidDynamic: (this: *PxPhysics, pose: *PxTransform) -> *PxRigidDynamic #cpp_method;

        createPruningStructure: (this: *PxPhysics, actors: **PxRigidActor, nbActors: PxU32) -> *PxPruningStructure #cpp_method;

        createShape: (this: *PxPhysics, geometry: *PxGeometry, materials: **PxMaterial, materialCount: PxU16, isExclusive := false, shapeFlags: PxShapeFlags) -> *PxShape #cpp_method;

        getNbShapes: (this: *PxPhysics) -> PxU32 #cpp_method;

        getShapes: (this: *PxPhysics, userBuffer: **PxShape, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        createConstraint: (this: *PxPhysics, actor0: *PxRigidActor, actor1: *PxRigidActor, connector: *PxConstraintConnector, shaders: *PxConstraintShaderTable, dataSize: PxU32) -> *PxConstraint #cpp_method;

        createArticulation: (this: *PxPhysics) -> *PxArticulation #cpp_method;

        createArticulationReducedCoordinate: (this: *PxPhysics) -> *PxArticulationReducedCoordinate #cpp_method;

        createMaterial: (this: *PxPhysics, staticFriction: PxReal, dynamicFriction: PxReal, restitution: PxReal) -> *PxMaterial #cpp_method;

        getNbMaterials: (this: *PxPhysics) -> PxU32 #cpp_method;

        getMaterials: (this: *PxPhysics, userBuffer: **PxMaterial, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        registerDeletionListener: (this: *PxPhysics, observer: *PxDeletionListener, deletionEvents: *PxDeletionEventFlags, restrictedObjectSet := false) -> void #cpp_method;

        unregisterDeletionListener: (this: *PxPhysics, observer: *PxDeletionListener) -> void #cpp_method;

        registerDeletionListenerObjects: (this: *PxPhysics, observer: *PxDeletionListener, observables: **PxBase, observableCount: PxU32) -> void #cpp_method;

        unregisterDeletionListenerObjects: (this: *PxPhysics, observer: *PxDeletionListener, observables: **PxBase, observableCount: PxU32) -> void #cpp_method;

        getPhysicsInsertionCallback: (this: *PxPhysics) -> *PxPhysicsInsertionCallback #cpp_method;
    }

    PxPhysics_Destructor :: inline (this: *PxPhysics, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    PxPhysics_release :: inline (this: *PxPhysics) { this.vtable.release(this); }

    PxPhysics_getFoundation :: inline (this: *PxPhysics) -> *PxFoundation { return this.vtable.getFoundation(this); }

    PxPhysics_createAggregate :: inline (this: *PxPhysics, maxSize: PxU32, enableSelfCollision: bool) -> *PxAggregate { return this.vtable.createAggregate(this, maxSize, enableSelfCollision); }

    PxPhysics_getTolerancesScale :: inline (this: *PxPhysics) -> *PxTolerancesScale { return this.vtable.getTolerancesScale(this); }

    PxPhysics_createTriangleMesh :: inline (this: *PxPhysics, stream: *PxInputStream) -> *PxTriangleMesh { return this.vtable.createTriangleMesh(this, stream); }

    PxPhysics_getNbTriangleMeshes :: inline (this: *PxPhysics) -> PxU32 { return this.vtable.getNbTriangleMeshes(this); }

    PxPhysics_getTriangleMeshes :: inline (this: *PxPhysics, userBuffer: **PxTriangleMesh, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.vtable.getTriangleMeshes(this, userBuffer, bufferSize, startIndex); }

    PxPhysics_createHeightField :: inline (this: *PxPhysics, stream: *PxInputStream) -> *PxHeightField { return this.vtable.createHeightField(this, stream); }

    PxPhysics_getNbHeightFields :: inline (this: *PxPhysics) -> PxU32 { return this.vtable.getNbHeightFields(this); }

    PxPhysics_getHeightFields :: inline (this: *PxPhysics, userBuffer: **PxHeightField, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.vtable.getHeightFields(this, userBuffer, bufferSize, startIndex); }

    PxPhysics_createConvexMesh :: inline (this: *PxPhysics, stream: *PxInputStream) -> *PxConvexMesh { return this.vtable.createConvexMesh(this, stream); }

    PxPhysics_getNbConvexMeshes :: inline (this: *PxPhysics) -> PxU32 { return this.vtable.getNbConvexMeshes(this); }

    PxPhysics_getConvexMeshes :: inline (this: *PxPhysics, userBuffer: **PxConvexMesh, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.vtable.getConvexMeshes(this, userBuffer, bufferSize, startIndex); }

    PxPhysics_createBVHStructure :: inline (this: *PxPhysics, stream: *PxInputStream) -> *PxBVHStructure { return this.vtable.createBVHStructure(this, stream); }

    PxPhysics_getNbBVHStructures :: inline (this: *PxPhysics) -> PxU32 { return this.vtable.getNbBVHStructures(this); }

    PxPhysics_getBVHStructures :: inline (this: *PxPhysics, userBuffer: **PxBVHStructure, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.vtable.getBVHStructures(this, userBuffer, bufferSize, startIndex); }

    PxPhysics_createScene :: inline (this: *PxPhysics, sceneDesc: *PxSceneDesc) -> *PxScene { return this.vtable.createScene(this, sceneDesc); }

    PxPhysics_getNbScenes :: inline (this: *PxPhysics) -> PxU32 { return this.vtable.getNbScenes(this); }

    PxPhysics_getScenes :: inline (this: *PxPhysics, userBuffer: **PxScene, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.vtable.getScenes(this, userBuffer, bufferSize, startIndex); }

    PxPhysics_createRigidStatic :: inline (this: *PxPhysics, pose: *PxTransform) -> *PxRigidStatic { return this.vtable.createRigidStatic(this, pose); }

    PxPhysics_createRigidDynamic :: inline (this: *PxPhysics, pose: *PxTransform) -> *PxRigidDynamic { return this.vtable.createRigidDynamic(this, pose); }

    PxPhysics_createPruningStructure :: inline (this: *PxPhysics, actors: **PxRigidActor, nbActors: PxU32) -> *PxPruningStructure { return this.vtable.createPruningStructure(this, actors, nbActors); }

    PxPhysics_createShape :: inline (this: *PxPhysics, geometry: *PxGeometry, materials: **PxMaterial, materialCount: PxU16, isExclusive := false, shapeFlags: PxShapeFlags) -> *PxShape { return this.vtable.createShape(this, geometry, materials, materialCount, isExclusive, shapeFlags); }

    PxPhysics_getNbShapes :: inline (this: *PxPhysics) -> PxU32 { return this.vtable.getNbShapes(this); }

    PxPhysics_getShapes :: inline (this: *PxPhysics, userBuffer: **PxShape, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.vtable.getShapes(this, userBuffer, bufferSize, startIndex); }

    PxPhysics_createConstraint :: inline (this: *PxPhysics, actor0: *PxRigidActor, actor1: *PxRigidActor, connector: *PxConstraintConnector, shaders: *PxConstraintShaderTable, dataSize: PxU32) -> *PxConstraint { return this.vtable.createConstraint(this, actor0, actor1, connector, shaders, dataSize); }

    PxPhysics_createArticulation :: inline (this: *PxPhysics) -> *PxArticulation { return this.vtable.createArticulation(this); }

    PxPhysics_createArticulationReducedCoordinate :: inline (this: *PxPhysics) -> *PxArticulationReducedCoordinate { return this.vtable.createArticulationReducedCoordinate(this); }

    PxPhysics_createMaterial :: inline (this: *PxPhysics, staticFriction: PxReal, dynamicFriction: PxReal, restitution: PxReal) -> *PxMaterial { return this.vtable.createMaterial(this, staticFriction, dynamicFriction, restitution); }

    PxPhysics_getNbMaterials :: inline (this: *PxPhysics) -> PxU32 { return this.vtable.getNbMaterials(this); }

    PxPhysics_getMaterials :: inline (this: *PxPhysics, userBuffer: **PxMaterial, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.vtable.getMaterials(this, userBuffer, bufferSize, startIndex); }

    PxPhysics_registerDeletionListener :: inline (this: *PxPhysics, observer: *PxDeletionListener, deletionEvents: *PxDeletionEventFlags, restrictedObjectSet := false) { this.vtable.registerDeletionListener(this, observer, deletionEvents, restrictedObjectSet); }

    PxPhysics_unregisterDeletionListener :: inline (this: *PxPhysics, observer: *PxDeletionListener) { this.vtable.unregisterDeletionListener(this, observer); }

    PxPhysics_registerDeletionListenerObjects :: inline (this: *PxPhysics, observer: *PxDeletionListener, observables: **PxBase, observableCount: PxU32) { this.vtable.registerDeletionListenerObjects(this, observer, observables, observableCount); }

    PxPhysics_unregisterDeletionListenerObjects :: inline (this: *PxPhysics, observer: *PxDeletionListener, observables: **PxBase, observableCount: PxU32) { this.vtable.unregisterDeletionListenerObjects(this, observer, observables, observableCount); }

    PxPhysics_getPhysicsInsertionCallback :: inline (this: *PxPhysics) -> *PxPhysicsInsertionCallback { return this.vtable.getPhysicsInsertionCallback(this); }

    vtable :: (obj: *PxPhysics) -> *PxPhysics_VTable { return obj.vtable; }

    #run {if true then return;
        assert(size_of(PxPhysics) == 8, "PxPhysics has size % instead of 8", size_of(PxPhysics));
    }

    /**
    \brief Collection of flags providing a mechanism to lock motion along/around a specific axis.

    @see PxRigidDynamic.setRigidDynamicLockFlag(), PxRigidBody.getRigidDynamicLockFlags()
    */
    PxRigidDynamicLockFlag :: struct {
        Enum :: enum s32 {
            LINEAR_X  :: 1;
            LINEAR_Y  :: 2;
            LINEAR_Z  :: 4;
            ANGULAR_X :: 8;
            ANGULAR_Y :: 16;
            ANGULAR_Z :: 32;

            eLOCK_LINEAR_X  :: LINEAR_X;
            eLOCK_LINEAR_Y  :: LINEAR_Y;
            eLOCK_LINEAR_Z  :: LINEAR_Z;
            eLOCK_ANGULAR_X :: ANGULAR_X;
            eLOCK_ANGULAR_Y :: ANGULAR_Y;
            eLOCK_ANGULAR_Z :: ANGULAR_Z;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxRigidDynamicLockFlag) == 1, "PxRigidDynamicLockFlag has size % instead of 1", size_of(PxRigidDynamicLockFlag));
    }

    PxRigidDynamicLockFlags :: PxFlags(PxRigidDynamicLockFlag.Enum, PxU8);

    /**
    \brief PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK.

    <h3>Creation</h3>
    Instances of this class are created by calling #PxPhysics::createRigidDynamic() and deleted with #release().


    <h3>Visualizations</h3>
    \li #PxVisualizationParameter::eACTOR_AXES
    \li #PxVisualizationParameter::eBODY_AXES
    \li #PxVisualizationParameter::eBODY_MASS_AXES
    \li #PxVisualizationParameter::eBODY_LIN_VELOCITY
    \li #PxVisualizationParameter::eBODY_ANG_VELOCITY

    @see PxRigidBody  PxPhysics.createRigidDynamic()  release()
    */
    PxRigidDynamic :: struct {
        #as using pxrigidbody: PxRigidBody;
        #place pxrigidbody; pxrigiddynamic_vtable: *PxRigidDynamic_VTable;
    }
    PxRigidDynamic_VTable :: struct #type_info_none {
        using pxrigidbody: PxRigidBody_VTable;
        setKinematicTarget: (this: *PxRigidDynamic, destination: *PxTransform) -> void #cpp_method;

        getKinematicTarget: (this: *PxRigidDynamic, target: *PxTransform) -> bool #cpp_method;

        isSleeping: (this: *PxRigidDynamic) -> bool #cpp_method;

        setSleepThreshold: (this: *PxRigidDynamic, threshold: PxReal) -> void #cpp_method;

        getSleepThreshold: (this: *PxRigidDynamic) -> PxReal #cpp_method;

        setStabilizationThreshold: (this: *PxRigidDynamic, threshold: PxReal) -> void #cpp_method;

        getStabilizationThreshold: (this: *PxRigidDynamic) -> PxReal #cpp_method;

        getRigidDynamicLockFlags: (this: *PxRigidDynamic) -> PxRigidDynamicLockFlags #cpp_method;

        setRigidDynamicLockFlag: (this: *PxRigidDynamic, flag: PxRigidDynamicLockFlag.Enum, value: bool) -> void #cpp_method;
        setRigidDynamicLockFlags: (this: *PxRigidDynamic, flags: PxRigidDynamicLockFlags) -> void #cpp_method;

        setWakeCounter: (this: *PxRigidDynamic, wakeCounterValue: PxReal) -> void #cpp_method;

        getWakeCounter: (this: *PxRigidDynamic) -> PxReal #cpp_method;

        wakeUp: (this: *PxRigidDynamic) -> void #cpp_method;

        putToSleep: (this: *PxRigidDynamic) -> void #cpp_method;

        setSolverIterationCounts: (this: *PxRigidDynamic, minPositionIters: PxU32, minVelocityIters: PxU32 = 1) -> void #cpp_method;

        getSolverIterationCounts: (this: *PxRigidDynamic, minPositionIters: *PxU32, minVelocityIters: *PxU32) -> void #cpp_method;

        getContactReportThreshold: (this: *PxRigidDynamic) -> PxReal #cpp_method;

        setContactReportThreshold: (this: *PxRigidDynamic, threshold: PxReal) -> void #cpp_method;
    }

    PxRigidDynamic_setKinematicTarget :: inline (this: *PxRigidDynamic, destination: *PxTransform) { this.pxrigiddynamic_vtable.setKinematicTarget(this, destination); }

    PxRigidDynamic_getKinematicTarget :: inline (this: *PxRigidDynamic, target: *PxTransform) -> bool { return this.pxrigiddynamic_vtable.getKinematicTarget(this, target); }

    PxRigidDynamic_isSleeping :: inline (this: *PxRigidDynamic) -> bool { return this.pxrigiddynamic_vtable.isSleeping(this); }

    PxRigidDynamic_setSleepThreshold :: inline (this: *PxRigidDynamic, threshold: PxReal) { this.pxrigiddynamic_vtable.setSleepThreshold(this, threshold); }

    PxRigidDynamic_getSleepThreshold :: inline (this: *PxRigidDynamic) -> PxReal { return this.pxrigiddynamic_vtable.getSleepThreshold(this); }

    PxRigidDynamic_setStabilizationThreshold :: inline (this: *PxRigidDynamic, threshold: PxReal) { this.pxrigiddynamic_vtable.setStabilizationThreshold(this, threshold); }

    PxRigidDynamic_getStabilizationThreshold :: inline (this: *PxRigidDynamic) -> PxReal { return this.pxrigiddynamic_vtable.getStabilizationThreshold(this); }

    PxRigidDynamic_getRigidDynamicLockFlags :: inline (this: *PxRigidDynamic) -> PxRigidDynamicLockFlags { return this.pxrigiddynamic_vtable.getRigidDynamicLockFlags(this); }

    PxRigidDynamic_setRigidDynamicLockFlag :: inline (this: *PxRigidDynamic, flag: PxRigidDynamicLockFlag.Enum, value: bool) { this.pxrigiddynamic_vtable.setRigidDynamicLockFlag(this, flag, value); }
    PxRigidDynamic_setRigidDynamicLockFlags :: inline (this: *PxRigidDynamic, flags: PxRigidDynamicLockFlags) { this.pxrigiddynamic_vtable.setRigidDynamicLockFlags(this, flags); }

    PxRigidDynamic_setWakeCounter :: inline (this: *PxRigidDynamic, wakeCounterValue: PxReal) { this.pxrigiddynamic_vtable.setWakeCounter(this, wakeCounterValue); }

    PxRigidDynamic_getWakeCounter :: inline (this: *PxRigidDynamic) -> PxReal { return this.pxrigiddynamic_vtable.getWakeCounter(this); }

    PxRigidDynamic_wakeUp :: inline (this: *PxRigidDynamic) { this.pxrigiddynamic_vtable.wakeUp(this); }

    PxRigidDynamic_putToSleep :: inline (this: *PxRigidDynamic) { this.pxrigiddynamic_vtable.putToSleep(this); }

    PxRigidDynamic_setSolverIterationCounts :: inline (this: *PxRigidDynamic, minPositionIters: PxU32, minVelocityIters: PxU32 = 1) { this.pxrigiddynamic_vtable.setSolverIterationCounts(this, minPositionIters, minVelocityIters); }

    PxRigidDynamic_getSolverIterationCounts :: inline (this: *PxRigidDynamic, minPositionIters: *PxU32, minVelocityIters: *PxU32) { this.pxrigiddynamic_vtable.getSolverIterationCounts(this, minPositionIters, minVelocityIters); }

    PxRigidDynamic_getContactReportThreshold :: inline (this: *PxRigidDynamic) -> PxReal { return this.pxrigiddynamic_vtable.getContactReportThreshold(this); }

    PxRigidDynamic_setContactReportThreshold :: inline (this: *PxRigidDynamic, threshold: PxReal) { this.pxrigiddynamic_vtable.setContactReportThreshold(this, threshold); }

    vtable :: (obj: *PxRigidDynamic) -> *PxRigidDynamic_VTable { return obj.pxrigiddynamic_vtable; }

    #run {if true then return;
        assert(size_of(type_of(PxRigidDynamic.pxrigidbody)) == 24, "PxRigidDynamic.pxrigidbody has unexpected size % instead of 24", size_of(type_of(PxRigidDynamic.pxrigidbody)));
        assert(size_of(PxRigidDynamic) == 24, "PxRigidDynamic has size % instead of 24", size_of(PxRigidDynamic));
    }

    /**
    \brief PxRigidStatic represents a static rigid body simulation object in the physics SDK.

    PxRigidStatic objects are static rigid physics entities. They shall be used to define solid objects which are fixed in the world.

    <h3>Creation</h3>
    Instances of this class are created by calling #PxPhysics::createRigidStatic() and deleted with #release().

    <h3>Visualizations</h3>
    \li #PxVisualizationParameter::eACTOR_AXES

    @see PxRigidActor  PxPhysics.createRigidStatic()  release()
    */
    PxRigidStatic :: struct {
        #as using pxrigidactor: PxRigidActor;
    }
    #run {if true then return;
        assert(size_of(type_of(PxRigidStatic.pxrigidactor)) == 24, "PxRigidStatic.pxrigidactor has unexpected size % instead of 24", size_of(type_of(PxRigidStatic.pxrigidactor)));
        assert(size_of(PxRigidStatic) == 24, "PxRigidStatic has size % instead of 24", size_of(PxRigidStatic));
    }

    /**
    \brief Debug visualization parameters.

    #PxVisualizationParameter::eSCALE is the master switch for enabling visualization, please read the corresponding documentation
    for further details.

    @see PxScene.setVisualizationParameter() PxScene.getVisualizationParameter() PxScene.getRenderBuffer()
    */
    PxVisualizationParameter :: struct {
        Enum :: enum s32 {
            SCALE                      :: 0;

            WORLD_AXES                 :: 1;

            BODY_AXES                  :: 2;

            BODY_MASS_AXES             :: 3;

            BODY_LIN_VELOCITY          :: 4;

            BODY_ANG_VELOCITY          :: 5;

            CONTACT_POINT              :: 6;

            CONTACT_NORMAL             :: 7;

            CONTACT_ERROR              :: 8;

            CONTACT_FORCE              :: 9;

            ACTOR_AXES                 :: 10;

            COLLISION_AABBS            :: 11;

            COLLISION_SHAPES           :: 12;

            COLLISION_AXES             :: 13;

            COLLISION_COMPOUNDS        :: 14;

            COLLISION_FNORMALS         :: 15;

            COLLISION_EDGES            :: 16;

            COLLISION_STATIC           :: 17;

            COLLISION_DYNAMIC          :: 18;

            DEPRECATED_COLLISION_PAIRS :: 19;

            JOINT_LOCAL_FRAMES         :: 20;

            JOINT_LIMITS               :: 21;

            CULL_BOX                   :: 22;

            MBP_REGIONS                :: 23;

            NUM_VALUES                 :: 24;

            FORCE_DWORD                :: 2147483647;

            eSCALE                      :: SCALE;

            eWORLD_AXES                 :: WORLD_AXES;

            eBODY_AXES                  :: BODY_AXES;

            eBODY_MASS_AXES             :: BODY_MASS_AXES;

            eBODY_LIN_VELOCITY          :: BODY_LIN_VELOCITY;

            eBODY_ANG_VELOCITY          :: BODY_ANG_VELOCITY;

            eCONTACT_POINT              :: CONTACT_POINT;

            eCONTACT_NORMAL             :: CONTACT_NORMAL;

            eCONTACT_ERROR              :: CONTACT_ERROR;

            eCONTACT_FORCE              :: CONTACT_FORCE;

            eACTOR_AXES                 :: ACTOR_AXES;

            eCOLLISION_AABBS            :: COLLISION_AABBS;

            eCOLLISION_SHAPES           :: COLLISION_SHAPES;

            eCOLLISION_AXES             :: COLLISION_AXES;

            eCOLLISION_COMPOUNDS        :: COLLISION_COMPOUNDS;

            eCOLLISION_FNORMALS         :: COLLISION_FNORMALS;

            eCOLLISION_EDGES            :: COLLISION_EDGES;

            eCOLLISION_STATIC           :: COLLISION_STATIC;

            eCOLLISION_DYNAMIC          :: COLLISION_DYNAMIC;

            eDEPRECATED_COLLISION_PAIRS :: DEPRECATED_COLLISION_PAIRS;

            eJOINT_LOCAL_FRAMES         :: JOINT_LOCAL_FRAMES;

            eJOINT_LIMITS               :: JOINT_LIMITS;

            eCULL_BOX                   :: CULL_BOX;

            eMBP_REGIONS                :: MBP_REGIONS;

            eNUM_VALUES                 :: NUM_VALUES;

            eFORCE_DWORD                :: FORCE_DWORD;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxVisualizationParameter) == 1, "PxVisualizationParameter has size % instead of 1", size_of(PxVisualizationParameter));
    }

    /**
    \brief Broad phase algorithm used in the simulation

    eSAP is a good generic choice with great performance when many objects are sleeping. Performance
    can degrade significantly though, when all objects are moving, or when large numbers of objects
    are added to or removed from the broad phase. This algorithm does not need world bounds to be
    defined in order to work.

    eMBP is an alternative broad phase algorithm that does not suffer from the same performance
    issues as eSAP when all objects are moving or when inserting large numbers of objects. However
    its generic performance when many objects are sleeping might be inferior to eSAP, and it requires
    users to define world bounds in order to work.

    eABP is a revisited implementation of MBP, which automatically manages broad-phase regions.
    It offers the convenience of eSAP (no need to define world bounds or regions) and the performance
    of eMBP when a lot of objects are moving. While eSAP can remain faster when most objects are
    sleeping and eMBP can remain faster when it uses a large number of properly-defined regions,
    eABP often gives the best performance on average and the best memory usage.
    */
    PxBroadPhaseType :: struct {
        Enum :: enum s32 {
            SAP  :: 0;
            MBP  :: 1;
            ABP  :: 2;
            GPU  :: 3;

            LAST :: 4;

            eSAP  :: SAP;
            eMBP  :: MBP;
            eABP  :: ABP;
            eGPU  :: GPU;

            eLAST :: LAST;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxBroadPhaseType) == 1, "PxBroadPhaseType has size % instead of 1", size_of(PxBroadPhaseType));
    }

    /**
    \brief Broad-phase callback to receive broad-phase related events.

    Each broadphase callback object is associated with a PxClientID. It is possible to register different
    callbacks for different clients. The callback functions are called this way:
    - for shapes/actors, the callback assigned to the actors' clients are used
    - for aggregates, the callbacks assigned to clients from aggregated actors  are used

    \note SDK state should not be modified from within the callbacks. In particular objects should not
    be created or destroyed. If state modification is needed then the changes should be stored to a buffer
    and performed after the simulation step.

    <b>Threading:</b> It is not necessary to make this class thread safe as it will only be called in the context of the
    user thread.

    @see PxSceneDesc PxScene.setBroadPhaseCallback() PxScene.getBroadPhaseCallback()
    */
    PxBroadPhaseCallback :: struct {
        vtable: *PxBroadPhaseCallback_VTable;
    }
    PxBroadPhaseCallback_VTable :: struct #type_info_none {
        Destructor: (this: *PxBroadPhaseCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

        onObjectOutOfBounds: (this: *PxBroadPhaseCallback, aggregate: *PxAggregate) -> void #cpp_method;

        onObjectOutOfBounds_1: (this: *PxBroadPhaseCallback, shape: /*reference*/ *PxShape, actor: /*reference*/ *PxActor) -> void #cpp_method;
    }

    PxBroadPhaseCallback_Destructor :: inline (this: *PxBroadPhaseCallback, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    PxBroadPhaseCallback_onObjectOutOfBounds :: inline (this: *PxBroadPhaseCallback, aggregate: /*reference*/ *PxAggregate) { this.vtable.onObjectOutOfBounds(this, aggregate); }

    PxBroadPhaseCallback_onObjectOutOfBounds_1 :: inline (this: *PxBroadPhaseCallback, shape: /*reference*/ *PxShape, actor: /*reference*/ *PxActor) { this.vtable.onObjectOutOfBounds_1(this, shape, actor); }

    vtable :: (obj: *PxBroadPhaseCallback) -> *PxBroadPhaseCallback_VTable { return obj.vtable; }

    #run {if true then return;
        assert(size_of(PxBroadPhaseCallback) == 8, "PxBroadPhaseCallback has size % instead of 8", size_of(PxBroadPhaseCallback));
    }

    /**
    \brief "Region of interest" for the broad-phase.

    This is currently only used for the PxBroadPhaseType::eMBP broad-phase, which requires zones or regions to be defined
    when the simulation starts in order to work. Regions can overlap and be added or removed at runtime, but at least one
    region needs to be defined when the scene is created.

    If objects that do no overlap any region are inserted into the scene, they will not be added to the broad-phase and
    thus collisions will be disabled for them. A PxBroadPhaseCallback out-of-bounds notification will be sent for each one
    of those objects.

    The total number of regions is limited by PxBroadPhaseCaps::maxNbRegions.

    The number of regions has a direct impact on performance and memory usage, so it is recommended to experiment with
    various settings to find the best combination for your game. A good default setup is to start with global bounds
    around the whole world, and subdivide these bounds into 4*4 regions. The PxBroadPhaseExt::createRegionsFromWorldBounds
    function can do that for you.

    @see PxBroadPhaseCallback PxBroadPhaseExt.createRegionsFromWorldBounds
    */
    PxBroadPhaseRegion :: struct {
        bounds:   PxBounds3; //!< Region's bounds
        userData: *void; //!< Region's user-provided data
    }
    #run {if true then return;
        instance: PxBroadPhaseRegion;
        assert(((cast(*void)(*instance.bounds)) - cast(*void)(*instance)) == 0, "PxBroadPhaseRegion.bounds has unexpected offset % instead of 0", ((cast(*void)(*instance.bounds)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxBroadPhaseRegion.bounds)) == 24, "PxBroadPhaseRegion.bounds has unexpected size % instead of 24", size_of(type_of(PxBroadPhaseRegion.bounds)));
        assert(((cast(*void)(*instance.userData)) - cast(*void)(*instance)) == 24, "PxBroadPhaseRegion.userData has unexpected offset % instead of 24", ((cast(*void)(*instance.userData)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxBroadPhaseRegion.userData)) == 8, "PxBroadPhaseRegion.userData has unexpected size % instead of 8", size_of(type_of(PxBroadPhaseRegion.userData)));
        assert(size_of(PxBroadPhaseRegion) == 32, "PxBroadPhaseRegion has size % instead of 32", size_of(PxBroadPhaseRegion));
    }

    /**
    \brief Information & stats structure for a region
    */
    PxBroadPhaseRegionInfo :: struct {
        region:           PxBroadPhaseRegion; //!< User-provided region data
        nbStaticObjects:  PxU32; //!< Number of static objects in the region
        nbDynamicObjects: PxU32; //!< Number of dynamic objects in the region
        active:           bool; //!< True if region is currently used, i.e. it has not been removed
        overlap:          bool; //!< True if region overlaps other regions (regions that are just touching are not considering overlapping)
    }
    #run {if true then return;
        instance: PxBroadPhaseRegionInfo;
        assert(((cast(*void)(*instance.region)) - cast(*void)(*instance)) == 0, "PxBroadPhaseRegionInfo.region has unexpected offset % instead of 0", ((cast(*void)(*instance.region)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxBroadPhaseRegionInfo.region)) == 32, "PxBroadPhaseRegionInfo.region has unexpected size % instead of 32", size_of(type_of(PxBroadPhaseRegionInfo.region)));
        assert(((cast(*void)(*instance.nbStaticObjects)) - cast(*void)(*instance)) == 32, "PxBroadPhaseRegionInfo.nbStaticObjects has unexpected offset % instead of 32", ((cast(*void)(*instance.nbStaticObjects)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxBroadPhaseRegionInfo.nbStaticObjects)) == 4, "PxBroadPhaseRegionInfo.nbStaticObjects has unexpected size % instead of 4", size_of(type_of(PxBroadPhaseRegionInfo.nbStaticObjects)));
        assert(((cast(*void)(*instance.nbDynamicObjects)) - cast(*void)(*instance)) == 36, "PxBroadPhaseRegionInfo.nbDynamicObjects has unexpected offset % instead of 36", ((cast(*void)(*instance.nbDynamicObjects)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxBroadPhaseRegionInfo.nbDynamicObjects)) == 4, "PxBroadPhaseRegionInfo.nbDynamicObjects has unexpected size % instead of 4", size_of(type_of(PxBroadPhaseRegionInfo.nbDynamicObjects)));
        assert(((cast(*void)(*instance.active)) - cast(*void)(*instance)) == 40, "PxBroadPhaseRegionInfo.active has unexpected offset % instead of 40", ((cast(*void)(*instance.active)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxBroadPhaseRegionInfo.active)) == 1, "PxBroadPhaseRegionInfo.active has unexpected size % instead of 1", size_of(type_of(PxBroadPhaseRegionInfo.active)));
        assert(((cast(*void)(*instance.overlap)) - cast(*void)(*instance)) == 41, "PxBroadPhaseRegionInfo.overlap has unexpected offset % instead of 41", ((cast(*void)(*instance.overlap)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxBroadPhaseRegionInfo.overlap)) == 1, "PxBroadPhaseRegionInfo.overlap has unexpected size % instead of 1", size_of(type_of(PxBroadPhaseRegionInfo.overlap)));
        assert(size_of(PxBroadPhaseRegionInfo) == 48, "PxBroadPhaseRegionInfo has size % instead of 48", size_of(PxBroadPhaseRegionInfo));
    }

    /**
    \brief Caps class for broad phase.
    */
    PxBroadPhaseCaps :: struct {
        maxNbRegions:          PxU32; //!< Max number of regions supported by the broad-phase
        maxNbObjects:          PxU32; //!< Max number of objects supported by the broad-phase
        needsPredefinedBounds: bool; //!< If true, broad-phase needs 'regions' to work
    }
    #run {if true then return;
        instance: PxBroadPhaseCaps;
        assert(((cast(*void)(*instance.maxNbRegions)) - cast(*void)(*instance)) == 0, "PxBroadPhaseCaps.maxNbRegions has unexpected offset % instead of 0", ((cast(*void)(*instance.maxNbRegions)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxBroadPhaseCaps.maxNbRegions)) == 4, "PxBroadPhaseCaps.maxNbRegions has unexpected size % instead of 4", size_of(type_of(PxBroadPhaseCaps.maxNbRegions)));
        assert(((cast(*void)(*instance.maxNbObjects)) - cast(*void)(*instance)) == 4, "PxBroadPhaseCaps.maxNbObjects has unexpected offset % instead of 4", ((cast(*void)(*instance.maxNbObjects)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxBroadPhaseCaps.maxNbObjects)) == 4, "PxBroadPhaseCaps.maxNbObjects has unexpected size % instead of 4", size_of(type_of(PxBroadPhaseCaps.maxNbObjects)));
        assert(((cast(*void)(*instance.needsPredefinedBounds)) - cast(*void)(*instance)) == 8, "PxBroadPhaseCaps.needsPredefinedBounds has unexpected offset % instead of 8", ((cast(*void)(*instance.needsPredefinedBounds)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxBroadPhaseCaps.needsPredefinedBounds)) == 1, "PxBroadPhaseCaps.needsPredefinedBounds has unexpected size % instead of 1", size_of(type_of(PxBroadPhaseCaps.needsPredefinedBounds)));
        assert(size_of(PxBroadPhaseCaps) == 12, "PxBroadPhaseCaps has size % instead of 12", size_of(PxBroadPhaseCaps));
    }

    /**
    \brief Pruning structure used to accelerate scene queries.

    eNONE uses a simple data structure that consumes less memory than the alternatives,
    but generally has slower query performance.

    eDYNAMIC_AABB_TREE usually provides the fastest queries. However there is a
    constant per-frame management cost associated with this structure. How much work should
    be done per frame can be tuned via the #PxSceneDesc::dynamicTreeRebuildRateHint
    parameter.

    eSTATIC_AABB_TREE is typically used for static objects. It is the same as the
    dynamic AABB tree, without the per-frame overhead. This can be a good choice for static
    objects, if no static objects are added, moved or removed after the scene has been
    created. If there is no such guarantee (e.g. when streaming parts of the world in and out),
    then the dynamic version is a better choice even for static objects.

    */
    PxPruningStructureType :: struct {
        Enum :: enum s32 {
            NONE              :: 0;
            DYNAMIC_AABB_TREE :: 1;
            STATIC_AABB_TREE  :: 2;

            LAST              :: 3;

            eNONE              :: NONE;
            eDYNAMIC_AABB_TREE :: DYNAMIC_AABB_TREE;
            eSTATIC_AABB_TREE  :: STATIC_AABB_TREE;

            eLAST              :: LAST;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxPruningStructureType) == 1, "PxPruningStructureType has size % instead of 1", size_of(PxPruningStructureType));
    }

    /**
    \brief Scene query update mode

    When PxScene::fetchResults is called it does scene query related work, with this enum it is possible to
    set what work is done during the fetchResults.

    FetchResults will sync changed bounds during simulation and update the scene query bounds in pruners, this work is mandatory.

    eCOMMIT_ENABLED_BUILD_ENABLED does allow to execute the new AABB tree build step during fetchResults, additionally the pruner commit is
    called where any changes are applied. During commit PhysX refits the dynamic scene query tree and if a new tree was built and
    the build finished the tree is swapped with current AABB tree.

    eCOMMIT_DISABLED_BUILD_ENABLED does allow to execute the new AABB tree build step during fetchResults. Pruner commit is not called,
    this means that refit will then occur during the first scene query following fetchResults, or may be forced by the method PxScene::flushSceneQueryUpdates().

    eCOMMIT_DISABLED_BUILD_DISABLED no further scene query work is executed. The scene queries update needs to be called manually, see PxScene::sceneQueriesUpdate.
    It is recommended to call PxScene::sceneQueriesUpdate right after fetchResults as the pruning structures are not updated.

    */
    PxSceneQueryUpdateMode :: struct {
        Enum :: enum s32 {
            ENABLED_COMMIT_ENABLED   :: 0;
            ENABLED_COMMIT_DISABLED  :: 1;
            DISABLED_COMMIT_DISABLED :: 2;

            eBUILD_ENABLED_COMMIT_ENABLED   :: ENABLED_COMMIT_ENABLED;
            eBUILD_ENABLED_COMMIT_DISABLED  :: ENABLED_COMMIT_DISABLED;
            eBUILD_DISABLED_COMMIT_DISABLED :: DISABLED_COMMIT_DISABLED;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxSceneQueryUpdateMode) == 1, "PxSceneQueryUpdateMode has size % instead of 1", size_of(PxSceneQueryUpdateMode));
    }

    /**
    \brief Enum for selecting the friction algorithm used for simulation.

    #PxFrictionType::ePATCH selects the patch friction model which typically leads to the most stable results at low solver iteration counts and is also quite inexpensive, as it uses only
    up to four scalar solver constraints per pair of touching objects.  The patch friction model is the same basic strong friction algorithm as PhysX 3.2 and before.

    #PxFrictionType::eONE_DIRECTIONAL is a simplification of the Coulomb friction model, in which the friction for a given point of contact is applied in the alternating tangent directions of
    the contact's normal.  This simplification allows us to reduce the number of iterations required for convergence but is not as accurate as the two directional model.

    #PxFrictionType::eTWO_DIRECTIONAL is identical to the one directional model, but it applies friction in both tangent directions simultaneously.  This hurts convergence a bit so it
    requires more solver iterations, but is more accurate.  Like the one directional model, it is applied at every contact point, which makes it potentially more expensive
    than patch friction for scenarios with many contact points.

    #PxFrictionType::eFRICTION_COUNT is the total numer of friction models supported by the SDK.
    */
    PxFrictionType :: struct {
        Enum :: enum s32 {
            PATCH           :: 0;
            ONE_DIRECTIONAL :: 1;
            TWO_DIRECTIONAL :: 2;
            FRICTION_COUNT  :: 3;

            ePATCH           :: PATCH;
            eONE_DIRECTIONAL :: ONE_DIRECTIONAL;
            eTWO_DIRECTIONAL :: TWO_DIRECTIONAL;
            eFRICTION_COUNT  :: FRICTION_COUNT;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxFrictionType) == 1, "PxFrictionType has size % instead of 1", size_of(PxFrictionType));
    }

    /**
    \brief Enum for selecting the type of solver used for the simulation.

    #PxSolverType::ePGS selects the default iterative sequential impulse solver. This is the same kind of solver used in PhysX 3.4 and earlier releases.

    #PxSolverType::eTGS selects a non linear iterative solver. This kind of solver can lead to improved convergence and handle large mass ratios, long chains and jointed systems better. It is slightly more expensive than the default solver and can introduce more energy to correct joint and contact errors.
    */
    PxSolverType :: struct {
        Enum :: enum s32 {
            PGS :: 0;
            TGS :: 1;

            ePGS :: PGS;
            eTGS :: TGS;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxSolverType) == 1, "PxSolverType has size % instead of 1", size_of(PxSolverType));
    }

    /**
    \brief flags for configuring properties of the scene

    @see PxScene
    */
    PxSceneFlag :: struct {
        Enum :: enum s32 {
            ENABLE_ACTIVE_ACTORS                  :: 1;

            ENABLE_CCD                            :: 2;

            DISABLE_CCD_RESWEEP                   :: 4;

            ADAPTIVE_FORCE                        :: 8;

            ENABLE_PCM                            :: 64;

            DISABLE_CONTACT_REPORT_BUFFER_RESIZE  :: 128;

            DISABLE_CONTACT_CACHE                 :: 256;

            REQUIRE_RW_LOCK                       :: 512;

            ENABLE_STABILIZATION                  :: 1024;

            ENABLE_AVERAGE_POINT                  :: 2048;

            EXCLUDE_KINEMATICS_FROM_ACTIVE_ACTORS :: 4096;

            ENABLE_GPU_DYNAMICS                   :: 8192;

            ENABLE_ENHANCED_DETERMINISM           :: 16384;

            ENABLE_FRICTION_EVERY_ITERATION       :: 32768;

            MUTABLE_FLAGS                         :: 4097;

            eENABLE_ACTIVE_ACTORS                  :: ENABLE_ACTIVE_ACTORS;

            eENABLE_CCD                            :: ENABLE_CCD;

            eDISABLE_CCD_RESWEEP                   :: DISABLE_CCD_RESWEEP;

            eADAPTIVE_FORCE                        :: ADAPTIVE_FORCE;

            eENABLE_PCM                            :: ENABLE_PCM;

            eDISABLE_CONTACT_REPORT_BUFFER_RESIZE  :: DISABLE_CONTACT_REPORT_BUFFER_RESIZE;

            eDISABLE_CONTACT_CACHE                 :: DISABLE_CONTACT_CACHE;

            eREQUIRE_RW_LOCK                       :: REQUIRE_RW_LOCK;

            eENABLE_STABILIZATION                  :: ENABLE_STABILIZATION;

            eENABLE_AVERAGE_POINT                  :: ENABLE_AVERAGE_POINT;

            eEXCLUDE_KINEMATICS_FROM_ACTIVE_ACTORS :: EXCLUDE_KINEMATICS_FROM_ACTIVE_ACTORS;

            eENABLE_GPU_DYNAMICS                   :: ENABLE_GPU_DYNAMICS;

            eENABLE_ENHANCED_DETERMINISM           :: ENABLE_ENHANCED_DETERMINISM;

            eENABLE_FRICTION_EVERY_ITERATION       :: ENABLE_FRICTION_EVERY_ITERATION;

            eMUTABLE_FLAGS                         :: MUTABLE_FLAGS;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxSceneFlag) == 1, "PxSceneFlag has size % instead of 1", size_of(PxSceneFlag));
    }

    /**
    \brief collection of set bits defined in PxSceneFlag.

    @see PxSceneFlag
    */
    PxSceneFlags :: PxFlags(PxSceneFlag.Enum, PxU32);
    // operator| :: (a: PxSceneFlag.Enum, b: PxSceneFlag.Enum) -> PxFlags(PxSceneFlag.Enum, PxU32) #foreign physx_lib "??Uphysx@@YA?AV?$PxFlags@W4Enum@PxSceneFlag@physx@@I@0@W4Enum@PxSceneFlag@0@0@Z";

    /**
    \brief Class used to retrieve limits(e.g. maximum number of bodies) for a scene. The limits
    are used as a hint to the size of the scene, not as a hard limit (i.e. it will be possible
    to create more objects than specified in the scene limits).

    0 indicates no limit. Using limits allows the SDK to preallocate various arrays, leading to
    less re-allocations and faster code at runtime.
    */
    PxSceneLimits :: struct {
        maxNbActors:             PxU32; //!< Expected maximum number of actors
        maxNbBodies:             PxU32; //!< Expected maximum number of dynamic rigid bodies
        maxNbStaticShapes:       PxU32; //!< Expected maximum number of static shapes
        maxNbDynamicShapes:      PxU32; //!< Expected maximum number of dynamic shapes
        maxNbAggregates:         PxU32; //!< Expected maximum number of aggregates
        maxNbConstraints:        PxU32; //!< Expected maximum number of constraint shaders
        maxNbRegions:            PxU32; //!< Expected maximum number of broad-phase regions
        maxNbBroadPhaseOverlaps: PxU32; //!< Expected maximum number of broad-phase overlaps

        /**
        \brief constructor sets to default
        */
        Constructor :: (this: *PxSceneLimits) -> void #cpp_method #foreign physx_lib "??0PxSceneLimits@physx@@QEAA@XZ";

        /**
        \brief (re)sets the structure to the default
        */
        setToDefault :: (this: *PxSceneLimits) -> void #cpp_method #foreign physx_lib "?setToDefault@PxSceneLimits@physx@@QEAAXXZ";

        /**
        \brief Returns true if the descriptor is valid.
        \return true if the current settings are valid.
        */
        isValid :: (this: *PxSceneLimits) -> bool #cpp_method #foreign physx_lib "?isValid@PxSceneLimits@physx@@QEBA_NXZ";
    }
    #run {if true then return;
        instance: PxSceneLimits;
        assert(((cast(*void)(*instance.maxNbActors)) - cast(*void)(*instance)) == 0, "PxSceneLimits.maxNbActors has unexpected offset % instead of 0", ((cast(*void)(*instance.maxNbActors)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSceneLimits.maxNbActors)) == 4, "PxSceneLimits.maxNbActors has unexpected size % instead of 4", size_of(type_of(PxSceneLimits.maxNbActors)));
        assert(((cast(*void)(*instance.maxNbBodies)) - cast(*void)(*instance)) == 4, "PxSceneLimits.maxNbBodies has unexpected offset % instead of 4", ((cast(*void)(*instance.maxNbBodies)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSceneLimits.maxNbBodies)) == 4, "PxSceneLimits.maxNbBodies has unexpected size % instead of 4", size_of(type_of(PxSceneLimits.maxNbBodies)));
        assert(((cast(*void)(*instance.maxNbStaticShapes)) - cast(*void)(*instance)) == 8, "PxSceneLimits.maxNbStaticShapes has unexpected offset % instead of 8", ((cast(*void)(*instance.maxNbStaticShapes)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSceneLimits.maxNbStaticShapes)) == 4, "PxSceneLimits.maxNbStaticShapes has unexpected size % instead of 4", size_of(type_of(PxSceneLimits.maxNbStaticShapes)));
        assert(((cast(*void)(*instance.maxNbDynamicShapes)) - cast(*void)(*instance)) == 12, "PxSceneLimits.maxNbDynamicShapes has unexpected offset % instead of 12", ((cast(*void)(*instance.maxNbDynamicShapes)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSceneLimits.maxNbDynamicShapes)) == 4, "PxSceneLimits.maxNbDynamicShapes has unexpected size % instead of 4", size_of(type_of(PxSceneLimits.maxNbDynamicShapes)));
        assert(((cast(*void)(*instance.maxNbAggregates)) - cast(*void)(*instance)) == 16, "PxSceneLimits.maxNbAggregates has unexpected offset % instead of 16", ((cast(*void)(*instance.maxNbAggregates)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSceneLimits.maxNbAggregates)) == 4, "PxSceneLimits.maxNbAggregates has unexpected size % instead of 4", size_of(type_of(PxSceneLimits.maxNbAggregates)));
        assert(((cast(*void)(*instance.maxNbConstraints)) - cast(*void)(*instance)) == 20, "PxSceneLimits.maxNbConstraints has unexpected offset % instead of 20", ((cast(*void)(*instance.maxNbConstraints)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSceneLimits.maxNbConstraints)) == 4, "PxSceneLimits.maxNbConstraints has unexpected size % instead of 4", size_of(type_of(PxSceneLimits.maxNbConstraints)));
        assert(((cast(*void)(*instance.maxNbRegions)) - cast(*void)(*instance)) == 24, "PxSceneLimits.maxNbRegions has unexpected offset % instead of 24", ((cast(*void)(*instance.maxNbRegions)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSceneLimits.maxNbRegions)) == 4, "PxSceneLimits.maxNbRegions has unexpected size % instead of 4", size_of(type_of(PxSceneLimits.maxNbRegions)));
        assert(((cast(*void)(*instance.maxNbBroadPhaseOverlaps)) - cast(*void)(*instance)) == 28, "PxSceneLimits.maxNbBroadPhaseOverlaps has unexpected offset % instead of 28", ((cast(*void)(*instance.maxNbBroadPhaseOverlaps)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSceneLimits.maxNbBroadPhaseOverlaps)) == 4, "PxSceneLimits.maxNbBroadPhaseOverlaps has unexpected size % instead of 4", size_of(type_of(PxSceneLimits.maxNbBroadPhaseOverlaps)));
        assert(size_of(PxSceneLimits) == 32, "PxSceneLimits has size % instead of 32", size_of(PxSceneLimits));
    }

    //#if PX_SUPPORT_GPU_PHYSX
    /**
    \brief Sizes of pre-allocated buffers use for GPU dynamics
    */
    PxgDynamicsMemoryConfig :: struct {
        constraintBufferCapacity: PxU32; //!< Capacity of constraint buffer allocated in GPU global memory
        contactBufferCapacity:    PxU32; //!< Capacity of contact buffer allocated in GPU global memory
        tempBufferCapacity:       PxU32; //!< Capacity of temp buffer allocated in pinned host memory.
        contactStreamSize:        PxU32; //!< Size of contact stream buffer allocated in pinned host memory. This is double-buffered so total allocation size = 2* contactStreamCapacity * sizeof(PxContact).
        patchStreamSize:          PxU32; //!< Size of the contact patch stream buffer allocated in pinned host memory. This is double-buffered so total allocation size = 2 * patchStreamCapacity * sizeof(PxContactPatch).
        forceStreamCapacity:      PxU32; //!< Capacity of force buffer allocated in pinned host memory.
        heapCapacity:             PxU32; //!< Initial capacity of the GPU and pinned host memory heaps. Additional memory will be allocated if more memory is required.
        foundLostPairsCapacity:   PxU32; //!< Capacity of found and lost buffers allocated in GPU global memory. This is used for the found/lost pair reports in the BP.

        Constructor :: (this: *PxgDynamicsMemoryConfig) -> void #cpp_method #foreign physx_lib "??0PxgDynamicsMemoryConfig@physx@@QEAA@XZ";
    }
    #run {if true then return;
        instance: PxgDynamicsMemoryConfig;
        assert(((cast(*void)(*instance.constraintBufferCapacity)) - cast(*void)(*instance)) == 0, "PxgDynamicsMemoryConfig.constraintBufferCapacity has unexpected offset % instead of 0", ((cast(*void)(*instance.constraintBufferCapacity)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxgDynamicsMemoryConfig.constraintBufferCapacity)) == 4, "PxgDynamicsMemoryConfig.constraintBufferCapacity has unexpected size % instead of 4", size_of(type_of(PxgDynamicsMemoryConfig.constraintBufferCapacity)));
        assert(((cast(*void)(*instance.contactBufferCapacity)) - cast(*void)(*instance)) == 4, "PxgDynamicsMemoryConfig.contactBufferCapacity has unexpected offset % instead of 4", ((cast(*void)(*instance.contactBufferCapacity)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxgDynamicsMemoryConfig.contactBufferCapacity)) == 4, "PxgDynamicsMemoryConfig.contactBufferCapacity has unexpected size % instead of 4", size_of(type_of(PxgDynamicsMemoryConfig.contactBufferCapacity)));
        assert(((cast(*void)(*instance.tempBufferCapacity)) - cast(*void)(*instance)) == 8, "PxgDynamicsMemoryConfig.tempBufferCapacity has unexpected offset % instead of 8", ((cast(*void)(*instance.tempBufferCapacity)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxgDynamicsMemoryConfig.tempBufferCapacity)) == 4, "PxgDynamicsMemoryConfig.tempBufferCapacity has unexpected size % instead of 4", size_of(type_of(PxgDynamicsMemoryConfig.tempBufferCapacity)));
        assert(((cast(*void)(*instance.contactStreamSize)) - cast(*void)(*instance)) == 12, "PxgDynamicsMemoryConfig.contactStreamSize has unexpected offset % instead of 12", ((cast(*void)(*instance.contactStreamSize)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxgDynamicsMemoryConfig.contactStreamSize)) == 4, "PxgDynamicsMemoryConfig.contactStreamSize has unexpected size % instead of 4", size_of(type_of(PxgDynamicsMemoryConfig.contactStreamSize)));
        assert(((cast(*void)(*instance.patchStreamSize)) - cast(*void)(*instance)) == 16, "PxgDynamicsMemoryConfig.patchStreamSize has unexpected offset % instead of 16", ((cast(*void)(*instance.patchStreamSize)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxgDynamicsMemoryConfig.patchStreamSize)) == 4, "PxgDynamicsMemoryConfig.patchStreamSize has unexpected size % instead of 4", size_of(type_of(PxgDynamicsMemoryConfig.patchStreamSize)));
        assert(((cast(*void)(*instance.forceStreamCapacity)) - cast(*void)(*instance)) == 20, "PxgDynamicsMemoryConfig.forceStreamCapacity has unexpected offset % instead of 20", ((cast(*void)(*instance.forceStreamCapacity)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxgDynamicsMemoryConfig.forceStreamCapacity)) == 4, "PxgDynamicsMemoryConfig.forceStreamCapacity has unexpected size % instead of 4", size_of(type_of(PxgDynamicsMemoryConfig.forceStreamCapacity)));
        assert(((cast(*void)(*instance.heapCapacity)) - cast(*void)(*instance)) == 24, "PxgDynamicsMemoryConfig.heapCapacity has unexpected offset % instead of 24", ((cast(*void)(*instance.heapCapacity)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxgDynamicsMemoryConfig.heapCapacity)) == 4, "PxgDynamicsMemoryConfig.heapCapacity has unexpected size % instead of 4", size_of(type_of(PxgDynamicsMemoryConfig.heapCapacity)));
        assert(((cast(*void)(*instance.foundLostPairsCapacity)) - cast(*void)(*instance)) == 28, "PxgDynamicsMemoryConfig.foundLostPairsCapacity has unexpected offset % instead of 28", ((cast(*void)(*instance.foundLostPairsCapacity)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxgDynamicsMemoryConfig.foundLostPairsCapacity)) == 4, "PxgDynamicsMemoryConfig.foundLostPairsCapacity has unexpected size % instead of 4", size_of(type_of(PxgDynamicsMemoryConfig.foundLostPairsCapacity)));
        assert(size_of(PxgDynamicsMemoryConfig) == 32, "PxgDynamicsMemoryConfig has size % instead of 32", size_of(PxgDynamicsMemoryConfig));
    }

    /**
    \brief Descriptor class for scenes. See #PxScene.

    This struct must be initialized with the same PxTolerancesScale values used to initialize PxPhysics.

    @see PxScene PxPhysics.createScene PxTolerancesScale
    */
    PxSceneDesc :: struct {
        /**
        \brief Gravity vector.

        <b>Range:</b> force vector<br>
        <b>Default:</b> Zero

        @see PxScene.setGravity()

        When setting gravity, you should probably also set bounce threshold.
        */
        gravity:                       PxVec3;

        /**
        \brief Possible notification callback.

        <b>Default:</b> NULL

        @see PxSimulationEventCallback PxScene.setSimulationEventCallback() PxScene.getSimulationEventCallback()
        */
        simulationEventCallback:       *PxSimulationEventCallback;

        /**
        \brief Possible asynchronous callback for contact modification.

        <b>Default:</b> NULL

        @see PxContactModifyCallback PxScene.setContactModifyCallback() PxScene.getContactModifyCallback()
        */
        contactModifyCallback:         *PxContactModifyCallback;

        /**
        \brief Possible asynchronous callback for contact modification.

        <b>Default:</b> NULL

        @see PxContactModifyCallback PxScene.setContactModifyCallback() PxScene.getContactModifyCallback()
        */
        ccdContactModifyCallback:      *PxCCDContactModifyCallback;

        /**
        \brief Shared global filter data which will get passed into the filter shader.

        \note The provided data will get copied to internal buffers and this copy will be used for filtering calls.

        <b>Default:</b> NULL

        @see PxSimulationFilterShader PxScene::setFilterShaderData()
        */
        filterShaderData:              *void;

        /**
        \brief Size (in bytes) of the shared global filter data #filterShaderData.

        <b>Default:</b> 0

        @see PxSimulationFilterShader filterShaderData
        */
        filterShaderDataSize:          PxU32;

        /**
        \brief The custom filter shader to use for collision filtering.

        \note This parameter is compulsory. If you don't want to define your own filter shader you can
        use the default shader #PxDefaultSimulationFilterShader which can be found in the PhysX extensions
        library.

        @see PxSimulationFilterShader
        */
        filterShader:                  PxSimulationFilterShader;

        /**
        \brief A custom collision filter callback which can be used to implement more complex filtering operations which need
        access to the simulation state, for example.

        <b>Default:</b> NULL

        @see PxSimulationFilterCallback
        */
        filterCallback:                *PxSimulationFilterCallback;

        /**
        \brief Filtering mode for kinematic-kinematic pairs in the broadphase.

        <b>Default:</b> PxPairFilteringMode::eDEFAULT

        @see PxPairFilteringMode
        */
        kineKineFilteringMode:         PxPairFilteringMode.Enum;

        /**
        \brief Filtering mode for static-kinematic pairs in the broadphase.

        <b>Default:</b> PxPairFilteringMode::eDEFAULT

        @see PxPairFilteringMode
        */
        staticKineFilteringMode:       PxPairFilteringMode.Enum;

        /**
        \brief Selects the broad-phase algorithm to use.

        <b>Default:</b> PxBroadPhaseType::eABP

        @see PxBroadPhaseType
        */
        broadPhaseType:                PxBroadPhaseType.Enum;

        /**
        \brief Broad-phase callback

        <b>Default:</b> NULL

        @see PxBroadPhaseCallback
        */
        broadPhaseCallback:            *PxBroadPhaseCallback;

        /**
        \brief Expected scene limits.

        @see PxSceneLimits
        */
        limits:                        PxSceneLimits;

        /**
        \brief Selects the friction algorithm to use for simulation.

        \note frictionType cannot be modified after the first call to any of PxScene::simulate, PxScene::solve and PxScene::collide

        @see PxFrictionType
        <b>Default:</b> PxFrictionType::ePATCH

        @see PxScene::setFrictionType, PxScene::getFrictionType
        */
        frictionType:                  PxFrictionType.Enum;

        /**
        \brief Selects the solver algorithm to use.

        <b>Default:</b> PxSolverType::ePGS

        @see PxSolverType
        */
        solverType:                    PxSolverType.Enum;

        /**
        \brief A contact with a relative velocity below this will not bounce. A typical value for simulation.
        stability is about 0.2 * gravity.

        <b>Range:</b> [0, PX_MAX_F32)<br>
        <b>Default:</b> 0.2 * PxTolerancesScale::speed

        @see PxMaterial
        */
        bounceThresholdVelocity:       PxReal;

        /**
        \brief A threshold of contact separation distance used to decide if a contact point will experience friction forces.

        \note If the separation distance of a contact point is greater than the threshold then the contact point will not experience friction forces.

        \note If the aggregated contact offset of a pair of shapes is large it might be desirable to neglect friction
        for contact points whose separation distance is sufficiently large that the shape surfaces are clearly separated.

        \note This parameter can be used to tune the separation distance of contact points at which friction starts to have an effect.

        <b>Range:</b> [0, PX_MAX_F32)<br>
        <b>Default:</b> 0.04 * PxTolerancesScale::length
        */
        frictionOffsetThreshold:       PxReal;

        /**
        \brief A threshold for speculative CCD. Used to control whether bias, restitution or a combination of the two are used to resolve the contacts.

        \note This only has any effect on contacting pairs where one of the bodies has PxRigidBodyFlag::eENABLE_SPECULATIVE_CCD raised.

        <b>Range:</b> [0, PX_MAX_F32)<br>
        <b>Default:</b> 0.04 * PxTolerancesScale::length
        */
        ccdMaxSeparation:              PxReal;

        /**
        \brief A slop value used to zero contact offsets from the body's COM on an axis if the offset along that axis is smaller than this threshold. Can be used to compensate
        for small numerical errors in contact generation.

        <b>Range:</b> [0, PX_MAX_F32)<br>
        <b>Default:</b> 0.0
        */
        solverOffsetSlop:              PxReal;

        /**
        \brief Flags used to select scene options.

        @see PxSceneFlag PxSceneFlags
        */
        flags:                         PxSceneFlags;

        /**
        \brief The CPU task dispatcher for the scene.

        See PxCpuDispatcher, PxScene::getCpuDispatcher
        */
        cpuDispatcher:                 *PxCpuDispatcher;

        /**
        \brief The CUDA context manager for the scene.

        <b>Platform specific:</b> Applies to PC GPU only.

        See PxCudaContextManager, PxScene::getCudaContextManager
        */
        cudaContextManager:            *PxCudaContextManager;

        /**
        \brief Defines the structure used to store static objects.

        \note Only PxPruningStructureType::eSTATIC_AABB_TREE and PxPruningStructureType::eDYNAMIC_AABB_TREE are allowed here.
        */
        staticStructure:               PxPruningStructureType.Enum;

        /**
        \brief Defines the structure used to store dynamic objects.
        */
        dynamicStructure:              PxPruningStructureType.Enum;

        /**
        \brief Hint for how much work should be done per simulation frame to rebuild the pruning structure.

        This parameter gives a hint on the distribution of the workload for rebuilding the dynamic AABB tree
        pruning structure #PxPruningStructureType::eDYNAMIC_AABB_TREE. It specifies the desired number of simulation frames
        the rebuild process should take. Higher values will decrease the workload per frame but the pruning
        structure will get more and more outdated the longer the rebuild takes (which can make
        scene queries less efficient).

        \note Only used for #PxPruningStructureType::eDYNAMIC_AABB_TREE pruning structure.

        \note This parameter gives only a hint. The rebuild process might still take more or less time depending on the
        number of objects involved.

        <b>Range:</b> [4, PX_MAX_U32)<br>
        <b>Default:</b> 100
        */
        dynamicTreeRebuildRateHint:    PxU32;

        /**
        \brief Defines the scene query update mode.
        <b>Default:</b> PxSceneQueryUpdateMode::eBUILD_ENABLED_COMMIT_ENABLED
        */
        sceneQueryUpdateMode:          PxSceneQueryUpdateMode.Enum;

        /**
        \brief Will be copied to PxScene::userData.

        <b>Default:</b> NULL
        */
        userData:                      *void;

        /**
        \brief Defines the number of actors required to spawn a separate rigid body solver island task chain.

        This parameter defines the minimum number of actors required to spawn a separate rigid body solver task chain. Setting a low value
        will potentially cause more task chains to be generated. This may result in the overhead of spawning tasks can become a limiting performance factor.
        Setting a high value will potentially cause fewer islands to be generated. This may reduce thread scaling (fewer task chains spawned) and may
        detrimentally affect performance if some bodies in the scene have large solver iteration counts because all constraints in a given island are solved by the
        maximum number of solver iterations requested by any body in the island.

        Note that a rigid body solver task chain is spawned as soon as either a sufficient number of rigid bodies or articulations are batched together.

        <b>Default:</b> 128

        @see PxScene.setSolverBatchSize() PxScene.getSolverBatchSize()
        */
        solverBatchSize:               PxU32;

        /**
        \brief Defines the number of articulations required to spawn a separate rigid body solver island task chain.

        This parameter defines the minimum number of articulations required to spawn a separate rigid body solver task chain. Setting a low value
        will potentially cause more task chains to be generated. This may result in the overhead of spawning tasks can become a limiting performance factor.
        Setting a high value will potentially cause fewer islands to be generated. This may reduce thread scaling (fewer task chains spawned) and may
        detrimentally affect performance if some bodies in the scene have large solver iteration counts because all constraints in a given island are solved by the
        maximum number of solver iterations requested by any body in the island.

        Note that a rigid body solver task chain is spawned as soon as either a sufficient number of rigid bodies or articulations are batched together.

        <b>Default:</b> 128

        @see PxScene.setSolverArticulationBatchSize() PxScene.getSolverArticulationBatchSize()
        */
        solverArticulationBatchSize:   PxU32;

        /**
        \brief Setting to define the number of 16K blocks that will be initially reserved to store contact, friction, and contact cache data.
        This is the number of 16K memory blocks that will be automatically allocated from the user allocator when the scene is instantiated. Further 16k
        memory blocks may be allocated during the simulation up to maxNbContactDataBlocks.

        \note This value cannot be larger than maxNbContactDataBlocks because that defines the maximum number of 16k blocks that can be allocated by the SDK.

        <b>Default:</b> 0

        <b>Range:</b> [0, PX_MAX_U32]<br>

        @see PxPhysics::createScene PxScene::setNbContactDataBlocks
        */
        nbContactDataBlocks:           PxU32;

        /**
        \brief Setting to define the maximum number of 16K blocks that can be allocated to store contact, friction, and contact cache data.
        As the complexity of a scene increases, the SDK may require to allocate new 16k blocks in addition to the blocks it has already
        allocated. This variable controls the maximum number of blocks that the SDK can allocate.

        In the case that the scene is sufficiently complex that all the permitted 16K blocks are used, contacts will be dropped and
        a warning passed to the error stream.

        If a warning is reported to the error stream to indicate the number of 16K blocks is insufficient for the scene complexity
        then the choices are either (i) re-tune the number of 16K data blocks until a number is found that is sufficient for the scene complexity,
        (ii) to simplify the scene or (iii) to opt to not increase the memory requirements of physx and accept some dropped contacts.

        <b>Default:</b> 65536

        <b>Range:</b> [0, PX_MAX_U32]<br>

        @see nbContactDataBlocks PxScene::setNbContactDataBlocks
        */
        maxNbContactDataBlocks:        PxU32;

        /**
        \brief The maximum bias coefficient used in the constraint solver

        When geometric errors are found in the constraint solver, either as a result of shapes penetrating
        or joints becoming separated or violating limits, a bias is introduced in the solver position iterations
        to correct these errors. This bias is proportional to 1/dt, meaning that the bias becomes increasingly
        strong as the time-step passed to PxScene::simulate(...) becomes smaller. This coefficient allows the
        application to restrict how large the bias coefficient is, to reduce how violent error corrections are.
        This can improve simulation quality in cases where either variable time-steps or extremely small time-steps
        are used.

        <b>Default:</b> PX_MAX_F32

        <b> Range</b> [0, PX_MAX_F32] <br>

        */
        maxBiasCoefficient:            PxReal;

        /**
        \brief Size of the contact report stream (in bytes).

        The contact report stream buffer is used during the simulation to store all the contact reports.
        If the size is not sufficient, the buffer will grow by a factor of two.
        It is possible to disable the buffer growth by setting the flag PxSceneFlag::eDISABLE_CONTACT_REPORT_BUFFER_RESIZE.
        In that case the buffer will not grow but contact reports not stored in the buffer will not get sent in the contact report callbacks.

        <b>Default:</b> 8192

        <b>Range:</b> (0, PX_MAX_U32]<br>

        */
        contactReportStreamBufferSize: PxU32;

        /**
        \brief Maximum number of CCD passes

        The CCD performs multiple passes, where each pass every object advances to its time of first impact. This value defines how many passes the CCD system should perform.

        \note The CCD system is a multi-pass best-effort conservative advancement approach. After the defined number of passes has been completed, any remaining time is dropped.
        \note This defines the maximum number of passes the CCD can perform. It may perform fewer if additional passes are not necessary.

        <b>Default:</b> 1
        <b>Range:</b> [1, PX_MAX_U32]<br>
        */
        ccdMaxPasses:                  PxU32;

        /**
        \brief CCD threshold

        CCD performs sweeps against shapes if and only if the relative motion of the shapes is fast-enough that a collision would be missed
        by the discrete contact generation. However, in some circumstances, e.g. when the environment is constructed from large convex shapes, this
        approach may produce undesired simulation artefacts. This parameter defines the minimum relative motion that would be required to force CCD between shapes.
        The smaller of this value and the sum of the thresholds calculated for the shapes involved will be used.

        \note It is not advisable to set this to a very small value as this may lead to CCD "jamming" and detrimentally effect performance. This value should be at least larger than the translation caused by a single frame's gravitational effect

        <b>Default:</b> PX_MAX_F32
        <b>Range:</b> [Eps, PX_MAX_F32]<br>
        */
        ccdThreshold:                  PxReal;

        /**
        \brief The wake counter reset value

        Calling wakeUp() on objects which support sleeping will set their wake counter value to the specified reset value.

        <b>Range:</b> (0, PX_MAX_F32)<br>
        <b>Default:</b> 0.4 (which corresponds to 20 frames for a time step of 0.02)

        @see PxRigidDynamic::wakeUp() PxArticulationBase::wakeUp()
        */
        wakeCounterResetValue:         PxReal;

        /**
        \brief The bounds used to sanity check user-set positions of actors and articulation links

        These bounds are used to check the position values of rigid actors inserted into the scene, and positions set for rigid actors
        already within the scene.

        <b>Range:</b> any valid PxBounds3 <br>
        <b>Default:</b> (-PX_MAX_BOUNDS_EXTENTS, PX_MAX_BOUNDS_EXTENTS) on each axis
        */
        sanityBounds:                  PxBounds3;

        /**
        \brief The pre-allocations performed in the GPU dynamics pipeline.
        */
        gpuDynamicsConfig:             PxgDynamicsMemoryConfig;

        /**
        \brief Limitation for the partitions in the GPU dynamics pipeline.
        This variable must be power of 2.
        A value greater than 32 is currently not supported.
        <b>Range:</b> (1, 32)<br>
        */
        gpuMaxNumPartitions:           PxU32;

        /**
        \brief Defines which compute version the GPU dynamics should target. DO NOT MODIFY
        */
        gpuComputeVersion:             PxU32;

        /**
        \cond
        */
        // For internal use only
        tolerancesScale:               PxTolerancesScale;

        /**
        \brief constructor sets to default.

        \param[in] scale scale values for the tolerances in the scene, these must be the same values passed into
        PxCreatePhysics(). The affected tolerances are bounceThresholdVelocity and frictionOffsetThreshold.

        @see PxCreatePhysics() PxTolerancesScale bounceThresholdVelocity frictionOffsetThreshold
        */
        Constructor :: (this: *PxSceneDesc, scale: *PxTolerancesScale) -> void #cpp_method #foreign physx_lib "??0PxSceneDesc@physx@@QEAA@AEBVPxTolerancesScale@1@@Z";
        Constructor :: (this: *PxSceneDesc, scale: PxTolerancesScale) #no_context {
            Constructor(this, *scale);
        }

        /**
        \brief (re)sets the structure to the default.

        \param[in] scale scale values for the tolerances in the scene, these must be the same values passed into
        PxCreatePhysics(). The affected tolerances are bounceThresholdVelocity and frictionOffsetThreshold.

        @see PxCreatePhysics() PxTolerancesScale bounceThresholdVelocity frictionOffsetThreshold
        */
        setToDefault :: (this: *PxSceneDesc, scale: *PxTolerancesScale) -> void #cpp_method #foreign physx_lib "?setToDefault@PxSceneDesc@physx@@QEAAXAEBVPxTolerancesScale@2@@Z";
        setToDefault :: (this: *PxSceneDesc, scale: PxTolerancesScale) #no_context {
            setToDefault(this, *scale);
        }

        /**
        \brief Returns true if the descriptor is valid.
        \return true if the current settings are valid.
        */
        isValid :: (this: *PxSceneDesc) -> bool #cpp_method #foreign physx_lib "?isValid@PxSceneDesc@physx@@QEBA_NXZ";

        /**
        \cond
        */
        // For internal use only
        getTolerancesScale :: (this: *PxSceneDesc) -> *PxTolerancesScale #cpp_method #foreign physx_lib "?getTolerancesScale@PxSceneDesc@physx@@QEBAAEBVPxTolerancesScale@2@XZ";
    }
    #run {if true then return;
        instance: PxSceneDesc;
        assert(((cast(*void)(*instance.gravity)) - cast(*void)(*instance)) == 0, "PxSceneDesc.gravity has unexpected offset % instead of 0", ((cast(*void)(*instance.gravity)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSceneDesc.gravity)) == 12, "PxSceneDesc.gravity has unexpected size % instead of 12", size_of(type_of(PxSceneDesc.gravity)));
        assert(((cast(*void)(*instance.simulationEventCallback)) - cast(*void)(*instance)) == 16, "PxSceneDesc.simulationEventCallback has unexpected offset % instead of 16", ((cast(*void)(*instance.simulationEventCallback)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSceneDesc.simulationEventCallback)) == 8, "PxSceneDesc.simulationEventCallback has unexpected size % instead of 8", size_of(type_of(PxSceneDesc.simulationEventCallback)));
        assert(((cast(*void)(*instance.contactModifyCallback)) - cast(*void)(*instance)) == 24, "PxSceneDesc.contactModifyCallback has unexpected offset % instead of 24", ((cast(*void)(*instance.contactModifyCallback)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSceneDesc.contactModifyCallback)) == 8, "PxSceneDesc.contactModifyCallback has unexpected size % instead of 8", size_of(type_of(PxSceneDesc.contactModifyCallback)));
        assert(((cast(*void)(*instance.ccdContactModifyCallback)) - cast(*void)(*instance)) == 32, "PxSceneDesc.ccdContactModifyCallback has unexpected offset % instead of 32", ((cast(*void)(*instance.ccdContactModifyCallback)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSceneDesc.ccdContactModifyCallback)) == 8, "PxSceneDesc.ccdContactModifyCallback has unexpected size % instead of 8", size_of(type_of(PxSceneDesc.ccdContactModifyCallback)));
        assert(((cast(*void)(*instance.filterShaderData)) - cast(*void)(*instance)) == 40, "PxSceneDesc.filterShaderData has unexpected offset % instead of 40", ((cast(*void)(*instance.filterShaderData)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSceneDesc.filterShaderData)) == 8, "PxSceneDesc.filterShaderData has unexpected size % instead of 8", size_of(type_of(PxSceneDesc.filterShaderData)));
        assert(((cast(*void)(*instance.filterShaderDataSize)) - cast(*void)(*instance)) == 48, "PxSceneDesc.filterShaderDataSize has unexpected offset % instead of 48", ((cast(*void)(*instance.filterShaderDataSize)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSceneDesc.filterShaderDataSize)) == 4, "PxSceneDesc.filterShaderDataSize has unexpected size % instead of 4", size_of(type_of(PxSceneDesc.filterShaderDataSize)));
        assert(((cast(*void)(*instance.filterShader)) - cast(*void)(*instance)) == 56, "PxSceneDesc.filterShader has unexpected offset % instead of 56", ((cast(*void)(*instance.filterShader)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSceneDesc.filterShader)) == 8, "PxSceneDesc.filterShader has unexpected size % instead of 8", size_of(type_of(PxSceneDesc.filterShader)));
        assert(((cast(*void)(*instance.filterCallback)) - cast(*void)(*instance)) == 64, "PxSceneDesc.filterCallback has unexpected offset % instead of 64", ((cast(*void)(*instance.filterCallback)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSceneDesc.filterCallback)) == 8, "PxSceneDesc.filterCallback has unexpected size % instead of 8", size_of(type_of(PxSceneDesc.filterCallback)));
        assert(((cast(*void)(*instance.kineKineFilteringMode)) - cast(*void)(*instance)) == 72, "PxSceneDesc.kineKineFilteringMode has unexpected offset % instead of 72", ((cast(*void)(*instance.kineKineFilteringMode)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSceneDesc.kineKineFilteringMode)) == 4, "PxSceneDesc.kineKineFilteringMode has unexpected size % instead of 4", size_of(type_of(PxSceneDesc.kineKineFilteringMode)));
        assert(((cast(*void)(*instance.staticKineFilteringMode)) - cast(*void)(*instance)) == 76, "PxSceneDesc.staticKineFilteringMode has unexpected offset % instead of 76", ((cast(*void)(*instance.staticKineFilteringMode)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSceneDesc.staticKineFilteringMode)) == 4, "PxSceneDesc.staticKineFilteringMode has unexpected size % instead of 4", size_of(type_of(PxSceneDesc.staticKineFilteringMode)));
        assert(((cast(*void)(*instance.broadPhaseType)) - cast(*void)(*instance)) == 80, "PxSceneDesc.broadPhaseType has unexpected offset % instead of 80", ((cast(*void)(*instance.broadPhaseType)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSceneDesc.broadPhaseType)) == 4, "PxSceneDesc.broadPhaseType has unexpected size % instead of 4", size_of(type_of(PxSceneDesc.broadPhaseType)));
        assert(((cast(*void)(*instance.broadPhaseCallback)) - cast(*void)(*instance)) == 88, "PxSceneDesc.broadPhaseCallback has unexpected offset % instead of 88", ((cast(*void)(*instance.broadPhaseCallback)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSceneDesc.broadPhaseCallback)) == 8, "PxSceneDesc.broadPhaseCallback has unexpected size % instead of 8", size_of(type_of(PxSceneDesc.broadPhaseCallback)));
        assert(((cast(*void)(*instance.limits)) - cast(*void)(*instance)) == 96, "PxSceneDesc.limits has unexpected offset % instead of 96", ((cast(*void)(*instance.limits)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSceneDesc.limits)) == 32, "PxSceneDesc.limits has unexpected size % instead of 32", size_of(type_of(PxSceneDesc.limits)));
        assert(((cast(*void)(*instance.frictionType)) - cast(*void)(*instance)) == 128, "PxSceneDesc.frictionType has unexpected offset % instead of 128", ((cast(*void)(*instance.frictionType)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSceneDesc.frictionType)) == 4, "PxSceneDesc.frictionType has unexpected size % instead of 4", size_of(type_of(PxSceneDesc.frictionType)));
        assert(((cast(*void)(*instance.solverType)) - cast(*void)(*instance)) == 132, "PxSceneDesc.solverType has unexpected offset % instead of 132", ((cast(*void)(*instance.solverType)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSceneDesc.solverType)) == 4, "PxSceneDesc.solverType has unexpected size % instead of 4", size_of(type_of(PxSceneDesc.solverType)));
        assert(((cast(*void)(*instance.bounceThresholdVelocity)) - cast(*void)(*instance)) == 136, "PxSceneDesc.bounceThresholdVelocity has unexpected offset % instead of 136", ((cast(*void)(*instance.bounceThresholdVelocity)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSceneDesc.bounceThresholdVelocity)) == 4, "PxSceneDesc.bounceThresholdVelocity has unexpected size % instead of 4", size_of(type_of(PxSceneDesc.bounceThresholdVelocity)));
        assert(((cast(*void)(*instance.frictionOffsetThreshold)) - cast(*void)(*instance)) == 140, "PxSceneDesc.frictionOffsetThreshold has unexpected offset % instead of 140", ((cast(*void)(*instance.frictionOffsetThreshold)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSceneDesc.frictionOffsetThreshold)) == 4, "PxSceneDesc.frictionOffsetThreshold has unexpected size % instead of 4", size_of(type_of(PxSceneDesc.frictionOffsetThreshold)));
        assert(((cast(*void)(*instance.ccdMaxSeparation)) - cast(*void)(*instance)) == 144, "PxSceneDesc.ccdMaxSeparation has unexpected offset % instead of 144", ((cast(*void)(*instance.ccdMaxSeparation)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSceneDesc.ccdMaxSeparation)) == 4, "PxSceneDesc.ccdMaxSeparation has unexpected size % instead of 4", size_of(type_of(PxSceneDesc.ccdMaxSeparation)));
        assert(((cast(*void)(*instance.solverOffsetSlop)) - cast(*void)(*instance)) == 148, "PxSceneDesc.solverOffsetSlop has unexpected offset % instead of 148", ((cast(*void)(*instance.solverOffsetSlop)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSceneDesc.solverOffsetSlop)) == 4, "PxSceneDesc.solverOffsetSlop has unexpected size % instead of 4", size_of(type_of(PxSceneDesc.solverOffsetSlop)));
        assert(((cast(*void)(*instance.flags)) - cast(*void)(*instance)) == 152, "PxSceneDesc.flags has unexpected offset % instead of 152", ((cast(*void)(*instance.flags)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSceneDesc.flags)) == 4, "PxSceneDesc.flags has unexpected size % instead of 4", size_of(type_of(PxSceneDesc.flags)));
        assert(((cast(*void)(*instance.cpuDispatcher)) - cast(*void)(*instance)) == 160, "PxSceneDesc.cpuDispatcher has unexpected offset % instead of 160", ((cast(*void)(*instance.cpuDispatcher)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSceneDesc.cpuDispatcher)) == 8, "PxSceneDesc.cpuDispatcher has unexpected size % instead of 8", size_of(type_of(PxSceneDesc.cpuDispatcher)));
        assert(((cast(*void)(*instance.cudaContextManager)) - cast(*void)(*instance)) == 168, "PxSceneDesc.cudaContextManager has unexpected offset % instead of 168", ((cast(*void)(*instance.cudaContextManager)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSceneDesc.cudaContextManager)) == 8, "PxSceneDesc.cudaContextManager has unexpected size % instead of 8", size_of(type_of(PxSceneDesc.cudaContextManager)));
        assert(((cast(*void)(*instance.staticStructure)) - cast(*void)(*instance)) == 176, "PxSceneDesc.staticStructure has unexpected offset % instead of 176", ((cast(*void)(*instance.staticStructure)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSceneDesc.staticStructure)) == 4, "PxSceneDesc.staticStructure has unexpected size % instead of 4", size_of(type_of(PxSceneDesc.staticStructure)));
        assert(((cast(*void)(*instance.dynamicStructure)) - cast(*void)(*instance)) == 180, "PxSceneDesc.dynamicStructure has unexpected offset % instead of 180", ((cast(*void)(*instance.dynamicStructure)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSceneDesc.dynamicStructure)) == 4, "PxSceneDesc.dynamicStructure has unexpected size % instead of 4", size_of(type_of(PxSceneDesc.dynamicStructure)));
        assert(((cast(*void)(*instance.dynamicTreeRebuildRateHint)) - cast(*void)(*instance)) == 184, "PxSceneDesc.dynamicTreeRebuildRateHint has unexpected offset % instead of 184", ((cast(*void)(*instance.dynamicTreeRebuildRateHint)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSceneDesc.dynamicTreeRebuildRateHint)) == 4, "PxSceneDesc.dynamicTreeRebuildRateHint has unexpected size % instead of 4", size_of(type_of(PxSceneDesc.dynamicTreeRebuildRateHint)));
        assert(((cast(*void)(*instance.sceneQueryUpdateMode)) - cast(*void)(*instance)) == 188, "PxSceneDesc.sceneQueryUpdateMode has unexpected offset % instead of 188", ((cast(*void)(*instance.sceneQueryUpdateMode)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSceneDesc.sceneQueryUpdateMode)) == 4, "PxSceneDesc.sceneQueryUpdateMode has unexpected size % instead of 4", size_of(type_of(PxSceneDesc.sceneQueryUpdateMode)));
        assert(((cast(*void)(*instance.userData)) - cast(*void)(*instance)) == 192, "PxSceneDesc.userData has unexpected offset % instead of 192", ((cast(*void)(*instance.userData)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSceneDesc.userData)) == 8, "PxSceneDesc.userData has unexpected size % instead of 8", size_of(type_of(PxSceneDesc.userData)));
        assert(((cast(*void)(*instance.solverBatchSize)) - cast(*void)(*instance)) == 200, "PxSceneDesc.solverBatchSize has unexpected offset % instead of 200", ((cast(*void)(*instance.solverBatchSize)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSceneDesc.solverBatchSize)) == 4, "PxSceneDesc.solverBatchSize has unexpected size % instead of 4", size_of(type_of(PxSceneDesc.solverBatchSize)));
        assert(((cast(*void)(*instance.solverArticulationBatchSize)) - cast(*void)(*instance)) == 204, "PxSceneDesc.solverArticulationBatchSize has unexpected offset % instead of 204", ((cast(*void)(*instance.solverArticulationBatchSize)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSceneDesc.solverArticulationBatchSize)) == 4, "PxSceneDesc.solverArticulationBatchSize has unexpected size % instead of 4", size_of(type_of(PxSceneDesc.solverArticulationBatchSize)));
        assert(((cast(*void)(*instance.nbContactDataBlocks)) - cast(*void)(*instance)) == 208, "PxSceneDesc.nbContactDataBlocks has unexpected offset % instead of 208", ((cast(*void)(*instance.nbContactDataBlocks)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSceneDesc.nbContactDataBlocks)) == 4, "PxSceneDesc.nbContactDataBlocks has unexpected size % instead of 4", size_of(type_of(PxSceneDesc.nbContactDataBlocks)));
        assert(((cast(*void)(*instance.maxNbContactDataBlocks)) - cast(*void)(*instance)) == 212, "PxSceneDesc.maxNbContactDataBlocks has unexpected offset % instead of 212", ((cast(*void)(*instance.maxNbContactDataBlocks)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSceneDesc.maxNbContactDataBlocks)) == 4, "PxSceneDesc.maxNbContactDataBlocks has unexpected size % instead of 4", size_of(type_of(PxSceneDesc.maxNbContactDataBlocks)));
        assert(((cast(*void)(*instance.maxBiasCoefficient)) - cast(*void)(*instance)) == 216, "PxSceneDesc.maxBiasCoefficient has unexpected offset % instead of 216", ((cast(*void)(*instance.maxBiasCoefficient)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSceneDesc.maxBiasCoefficient)) == 4, "PxSceneDesc.maxBiasCoefficient has unexpected size % instead of 4", size_of(type_of(PxSceneDesc.maxBiasCoefficient)));
        assert(((cast(*void)(*instance.contactReportStreamBufferSize)) - cast(*void)(*instance)) == 220, "PxSceneDesc.contactReportStreamBufferSize has unexpected offset % instead of 220", ((cast(*void)(*instance.contactReportStreamBufferSize)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSceneDesc.contactReportStreamBufferSize)) == 4, "PxSceneDesc.contactReportStreamBufferSize has unexpected size % instead of 4", size_of(type_of(PxSceneDesc.contactReportStreamBufferSize)));
        assert(((cast(*void)(*instance.ccdMaxPasses)) - cast(*void)(*instance)) == 224, "PxSceneDesc.ccdMaxPasses has unexpected offset % instead of 224", ((cast(*void)(*instance.ccdMaxPasses)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSceneDesc.ccdMaxPasses)) == 4, "PxSceneDesc.ccdMaxPasses has unexpected size % instead of 4", size_of(type_of(PxSceneDesc.ccdMaxPasses)));
        assert(((cast(*void)(*instance.ccdThreshold)) - cast(*void)(*instance)) == 228, "PxSceneDesc.ccdThreshold has unexpected offset % instead of 228", ((cast(*void)(*instance.ccdThreshold)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSceneDesc.ccdThreshold)) == 4, "PxSceneDesc.ccdThreshold has unexpected size % instead of 4", size_of(type_of(PxSceneDesc.ccdThreshold)));
        assert(((cast(*void)(*instance.wakeCounterResetValue)) - cast(*void)(*instance)) == 232, "PxSceneDesc.wakeCounterResetValue has unexpected offset % instead of 232", ((cast(*void)(*instance.wakeCounterResetValue)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSceneDesc.wakeCounterResetValue)) == 4, "PxSceneDesc.wakeCounterResetValue has unexpected size % instead of 4", size_of(type_of(PxSceneDesc.wakeCounterResetValue)));
        assert(((cast(*void)(*instance.sanityBounds)) - cast(*void)(*instance)) == 236, "PxSceneDesc.sanityBounds has unexpected offset % instead of 236", ((cast(*void)(*instance.sanityBounds)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSceneDesc.sanityBounds)) == 24, "PxSceneDesc.sanityBounds has unexpected size % instead of 24", size_of(type_of(PxSceneDesc.sanityBounds)));
        assert(((cast(*void)(*instance.gpuDynamicsConfig)) - cast(*void)(*instance)) == 260, "PxSceneDesc.gpuDynamicsConfig has unexpected offset % instead of 260", ((cast(*void)(*instance.gpuDynamicsConfig)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSceneDesc.gpuDynamicsConfig)) == 32, "PxSceneDesc.gpuDynamicsConfig has unexpected size % instead of 32", size_of(type_of(PxSceneDesc.gpuDynamicsConfig)));
        assert(((cast(*void)(*instance.gpuMaxNumPartitions)) - cast(*void)(*instance)) == 292, "PxSceneDesc.gpuMaxNumPartitions has unexpected offset % instead of 292", ((cast(*void)(*instance.gpuMaxNumPartitions)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSceneDesc.gpuMaxNumPartitions)) == 4, "PxSceneDesc.gpuMaxNumPartitions has unexpected size % instead of 4", size_of(type_of(PxSceneDesc.gpuMaxNumPartitions)));
        assert(((cast(*void)(*instance.gpuComputeVersion)) - cast(*void)(*instance)) == 296, "PxSceneDesc.gpuComputeVersion has unexpected offset % instead of 296", ((cast(*void)(*instance.gpuComputeVersion)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSceneDesc.gpuComputeVersion)) == 4, "PxSceneDesc.gpuComputeVersion has unexpected size % instead of 4", size_of(type_of(PxSceneDesc.gpuComputeVersion)));
        assert(((cast(*void)(*instance.tolerancesScale)) - cast(*void)(*instance)) == 300, "PxSceneDesc.tolerancesScale has unexpected offset % instead of 300", ((cast(*void)(*instance.tolerancesScale)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSceneDesc.tolerancesScale)) == 8, "PxSceneDesc.tolerancesScale has unexpected size % instead of 8", size_of(type_of(PxSceneDesc.tolerancesScale)));
        assert(size_of(PxSceneDesc) == 312, "PxSceneDesc has size % instead of 312", size_of(PxSceneDesc));
    }

    /**
    \brief Class used to retrieve statistics for a simulation step.

    @see PxScene::getSimulationStatistics()
    */
    PxSimulationStatistics :: struct {
        /**
        \brief Different types of rigid body collision pair statistics.
        @see getRbPairStats
        */
        RbPairStatsType :: enum s32 {
            DISCRETE_CONTACT_PAIRS :: 0;

            CCD_PAIRS              :: 1;

            MODIFIED_CONTACT_PAIRS :: 2;

            TRIGGER_PAIRS          :: 3;

            eDISCRETE_CONTACT_PAIRS :: DISCRETE_CONTACT_PAIRS;

            eCCD_PAIRS              :: CCD_PAIRS;

            eMODIFIED_CONTACT_PAIRS :: MODIFIED_CONTACT_PAIRS;

            eTRIGGER_PAIRS          :: TRIGGER_PAIRS;
        }

        //objects:
        /**
        \brief Number of active PxConstraint objects (joints etc.) for the current simulation step.
        */
        nbActiveConstraints:                 PxU32;

        /**
        \brief Number of active dynamic bodies for the current simulation step.

        \note Does not include active kinematic bodies
        */
        nbActiveDynamicBodies:               PxU32;

        /**
        \brief Number of active kinematic bodies for the current simulation step.

        \note Kinematic deactivation occurs at the end of the frame after the last call to PxRigidDynamic::setKinematicTarget() was called so kinematics that are
        deactivated in a given frame will be included by this counter.
        */
        nbActiveKinematicBodies:             PxU32;

        /**
        \brief Number of static bodies for the current simulation step.
        */
        nbStaticBodies:                      PxU32;

        /**
        \brief Number of dynamic bodies for the current simulation step.

        \note Includes inactive bodies and articulation links
        \note Does not include kinematic bodies
        */
        nbDynamicBodies:                     PxU32;

        /**
        \brief Number of kinematic bodies for the current simulation step.

        \note Includes inactive bodies
        */
        nbKinematicBodies:                   PxU32;

        /**
        \brief Number of shapes of each geometry type.
        */
        nbShapes:                            [7] PxU32;

        /**
        \brief Number of aggregates in the scene.
        */
        nbAggregates:                        PxU32;

        /**
        \brief Number of articulations in the scene.
        */
        nbArticulations:                     PxU32;

        //solver:
        /**
        \brief The number of 1D axis constraints(joints+contact) present in the current simulation step.
        */
        nbAxisSolverConstraints:             PxU32;

        /**
        \brief The size (in bytes) of the compressed contact stream in the current simulation step
        */
        compressedContactSize:               PxU32;

        /**
        \brief The total required size (in bytes) of the contact constraints in the current simulation step
        */
        requiredContactConstraintMemory:     PxU32;

        /**
        \brief The peak amount of memory (in bytes) that was allocated for constraints (this includes joints) in the current simulation step
        */
        peakConstraintMemory:                PxU32;

        //broadphase:
        /**
        \brief Get number of broadphase volumes added for the current simulation step.

        \return Number of broadphase volumes added.
        */
        getNbBroadPhaseAdds :: (this: *PxSimulationStatistics) -> PxU32 #cpp_method #foreign physx_lib "?getNbBroadPhaseAdds@PxSimulationStatistics@physx@@QEBAIXZ";

        /**
        \brief Get number of broadphase volumes removed for the current simulation step.

        \return Number of broadphase volumes removed.
        */
        getNbBroadPhaseRemoves :: (this: *PxSimulationStatistics) -> PxU32 #cpp_method #foreign physx_lib "?getNbBroadPhaseRemoves@PxSimulationStatistics@physx@@QEBAIXZ";

        //collisions:
        /**
        \brief Get number of shape collision pairs of a certain type processed for the current simulation step.

        There is an entry for each geometry pair type.

        \note entry[i][j] = entry[j][i], hence, if you want the sum of all pair
        types, you need to discard the symmetric entries

        \param[in] pairType The type of pair for which to get information
        \param[in] g0 The geometry type of one pair object
        \param[in] g1 The geometry type of the other pair object
        \return Number of processed pairs of the specified geometry types.
        */
        getRbPairStats :: (this: *PxSimulationStatistics, pairType: RbPairStatsType, g0: PxGeometryType.Enum, g1: PxGeometryType.Enum) -> PxU32 #cpp_method #foreign physx_lib "?getRbPairStats@PxSimulationStatistics@physx@@QEBAIW4RbPairStatsType@12@W4Enum@PxGeometryType@2@1@Z";

        /**
        \brief Total number of (non CCD) pairs reaching narrow phase
        */
        nbDiscreteContactPairsTotal:         PxU32;

        /**
        \brief Total number of (non CCD) pairs for which contacts are successfully cached (<=nbDiscreteContactPairsTotal)
        \note This includes pairs for which no contacts are generated, it still counts as a cache hit.
        */
        nbDiscreteContactPairsWithCacheHits: PxU32;

        /**
        \brief Total number of (non CCD) pairs for which at least 1 contact was generated (<=nbDiscreteContactPairsTotal)
        */
        nbDiscreteContactPairsWithContacts:  PxU32;

        /**
        \brief Number of new pairs found by BP this frame
        */
        nbNewPairs:                          PxU32;

        /**
        \brief Number of lost pairs from BP this frame
        */
        nbLostPairs:                         PxU32;

        /**
        \brief Number of new touches found by NP this frame
        */
        nbNewTouches:                        PxU32;

        /**
        \brief Number of lost touches from NP this frame
        */
        nbLostTouches:                       PxU32;

        /**
        \brief Number of partitions used by the solver this frame
        */
        nbPartitions:                        PxU32;

        Constructor :: (this: *PxSimulationStatistics) -> void #cpp_method #foreign physx_lib "??0PxSimulationStatistics@physx@@QEAA@XZ";

        //
        // We advise to not access these members directly. Use the provided accessor methods instead.
        //
        //broadphase:
        nbBroadPhaseAdds:                    PxU32;
        nbBroadPhaseRemoves:                 PxU32;

        //collisions:
        nbDiscreteContactPairs:              [7] [7] PxU32;
        nbCCDPairs:                          [7] [7] PxU32;
        nbModifiedContactPairs:              [7] [7] PxU32;
        nbTriggerPairs:                      [7] [7] PxU32;
    }
    #run {if true then return;
        instance: PxSimulationStatistics;
        assert(((cast(*void)(*instance.nbActiveConstraints)) - cast(*void)(*instance)) == 0, "PxSimulationStatistics.nbActiveConstraints has unexpected offset % instead of 0", ((cast(*void)(*instance.nbActiveConstraints)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSimulationStatistics.nbActiveConstraints)) == 4, "PxSimulationStatistics.nbActiveConstraints has unexpected size % instead of 4", size_of(type_of(PxSimulationStatistics.nbActiveConstraints)));
        assert(((cast(*void)(*instance.nbActiveDynamicBodies)) - cast(*void)(*instance)) == 4, "PxSimulationStatistics.nbActiveDynamicBodies has unexpected offset % instead of 4", ((cast(*void)(*instance.nbActiveDynamicBodies)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSimulationStatistics.nbActiveDynamicBodies)) == 4, "PxSimulationStatistics.nbActiveDynamicBodies has unexpected size % instead of 4", size_of(type_of(PxSimulationStatistics.nbActiveDynamicBodies)));
        assert(((cast(*void)(*instance.nbActiveKinematicBodies)) - cast(*void)(*instance)) == 8, "PxSimulationStatistics.nbActiveKinematicBodies has unexpected offset % instead of 8", ((cast(*void)(*instance.nbActiveKinematicBodies)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSimulationStatistics.nbActiveKinematicBodies)) == 4, "PxSimulationStatistics.nbActiveKinematicBodies has unexpected size % instead of 4", size_of(type_of(PxSimulationStatistics.nbActiveKinematicBodies)));
        assert(((cast(*void)(*instance.nbStaticBodies)) - cast(*void)(*instance)) == 12, "PxSimulationStatistics.nbStaticBodies has unexpected offset % instead of 12", ((cast(*void)(*instance.nbStaticBodies)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSimulationStatistics.nbStaticBodies)) == 4, "PxSimulationStatistics.nbStaticBodies has unexpected size % instead of 4", size_of(type_of(PxSimulationStatistics.nbStaticBodies)));
        assert(((cast(*void)(*instance.nbDynamicBodies)) - cast(*void)(*instance)) == 16, "PxSimulationStatistics.nbDynamicBodies has unexpected offset % instead of 16", ((cast(*void)(*instance.nbDynamicBodies)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSimulationStatistics.nbDynamicBodies)) == 4, "PxSimulationStatistics.nbDynamicBodies has unexpected size % instead of 4", size_of(type_of(PxSimulationStatistics.nbDynamicBodies)));
        assert(((cast(*void)(*instance.nbKinematicBodies)) - cast(*void)(*instance)) == 20, "PxSimulationStatistics.nbKinematicBodies has unexpected offset % instead of 20", ((cast(*void)(*instance.nbKinematicBodies)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSimulationStatistics.nbKinematicBodies)) == 4, "PxSimulationStatistics.nbKinematicBodies has unexpected size % instead of 4", size_of(type_of(PxSimulationStatistics.nbKinematicBodies)));
        assert(((cast(*void)(*instance.nbShapes)) - cast(*void)(*instance)) == 24, "PxSimulationStatistics.nbShapes has unexpected offset % instead of 24", ((cast(*void)(*instance.nbShapes)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSimulationStatistics.nbShapes)) == 28, "PxSimulationStatistics.nbShapes has unexpected size % instead of 28", size_of(type_of(PxSimulationStatistics.nbShapes)));
        assert(((cast(*void)(*instance.nbAggregates)) - cast(*void)(*instance)) == 52, "PxSimulationStatistics.nbAggregates has unexpected offset % instead of 52", ((cast(*void)(*instance.nbAggregates)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSimulationStatistics.nbAggregates)) == 4, "PxSimulationStatistics.nbAggregates has unexpected size % instead of 4", size_of(type_of(PxSimulationStatistics.nbAggregates)));
        assert(((cast(*void)(*instance.nbArticulations)) - cast(*void)(*instance)) == 56, "PxSimulationStatistics.nbArticulations has unexpected offset % instead of 56", ((cast(*void)(*instance.nbArticulations)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSimulationStatistics.nbArticulations)) == 4, "PxSimulationStatistics.nbArticulations has unexpected size % instead of 4", size_of(type_of(PxSimulationStatistics.nbArticulations)));
        assert(((cast(*void)(*instance.nbAxisSolverConstraints)) - cast(*void)(*instance)) == 60, "PxSimulationStatistics.nbAxisSolverConstraints has unexpected offset % instead of 60", ((cast(*void)(*instance.nbAxisSolverConstraints)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSimulationStatistics.nbAxisSolverConstraints)) == 4, "PxSimulationStatistics.nbAxisSolverConstraints has unexpected size % instead of 4", size_of(type_of(PxSimulationStatistics.nbAxisSolverConstraints)));
        assert(((cast(*void)(*instance.compressedContactSize)) - cast(*void)(*instance)) == 64, "PxSimulationStatistics.compressedContactSize has unexpected offset % instead of 64", ((cast(*void)(*instance.compressedContactSize)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSimulationStatistics.compressedContactSize)) == 4, "PxSimulationStatistics.compressedContactSize has unexpected size % instead of 4", size_of(type_of(PxSimulationStatistics.compressedContactSize)));
        assert(((cast(*void)(*instance.requiredContactConstraintMemory)) - cast(*void)(*instance)) == 68, "PxSimulationStatistics.requiredContactConstraintMemory has unexpected offset % instead of 68", ((cast(*void)(*instance.requiredContactConstraintMemory)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSimulationStatistics.requiredContactConstraintMemory)) == 4, "PxSimulationStatistics.requiredContactConstraintMemory has unexpected size % instead of 4", size_of(type_of(PxSimulationStatistics.requiredContactConstraintMemory)));
        assert(((cast(*void)(*instance.peakConstraintMemory)) - cast(*void)(*instance)) == 72, "PxSimulationStatistics.peakConstraintMemory has unexpected offset % instead of 72", ((cast(*void)(*instance.peakConstraintMemory)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSimulationStatistics.peakConstraintMemory)) == 4, "PxSimulationStatistics.peakConstraintMemory has unexpected size % instead of 4", size_of(type_of(PxSimulationStatistics.peakConstraintMemory)));
        assert(((cast(*void)(*instance.nbDiscreteContactPairsTotal)) - cast(*void)(*instance)) == 76, "PxSimulationStatistics.nbDiscreteContactPairsTotal has unexpected offset % instead of 76", ((cast(*void)(*instance.nbDiscreteContactPairsTotal)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSimulationStatistics.nbDiscreteContactPairsTotal)) == 4, "PxSimulationStatistics.nbDiscreteContactPairsTotal has unexpected size % instead of 4", size_of(type_of(PxSimulationStatistics.nbDiscreteContactPairsTotal)));
        assert(((cast(*void)(*instance.nbDiscreteContactPairsWithCacheHits)) - cast(*void)(*instance)) == 80, "PxSimulationStatistics.nbDiscreteContactPairsWithCacheHits has unexpected offset % instead of 80", ((cast(*void)(*instance.nbDiscreteContactPairsWithCacheHits)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSimulationStatistics.nbDiscreteContactPairsWithCacheHits)) == 4, "PxSimulationStatistics.nbDiscreteContactPairsWithCacheHits has unexpected size % instead of 4", size_of(type_of(PxSimulationStatistics.nbDiscreteContactPairsWithCacheHits)));
        assert(((cast(*void)(*instance.nbDiscreteContactPairsWithContacts)) - cast(*void)(*instance)) == 84, "PxSimulationStatistics.nbDiscreteContactPairsWithContacts has unexpected offset % instead of 84", ((cast(*void)(*instance.nbDiscreteContactPairsWithContacts)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSimulationStatistics.nbDiscreteContactPairsWithContacts)) == 4, "PxSimulationStatistics.nbDiscreteContactPairsWithContacts has unexpected size % instead of 4", size_of(type_of(PxSimulationStatistics.nbDiscreteContactPairsWithContacts)));
        assert(((cast(*void)(*instance.nbNewPairs)) - cast(*void)(*instance)) == 88, "PxSimulationStatistics.nbNewPairs has unexpected offset % instead of 88", ((cast(*void)(*instance.nbNewPairs)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSimulationStatistics.nbNewPairs)) == 4, "PxSimulationStatistics.nbNewPairs has unexpected size % instead of 4", size_of(type_of(PxSimulationStatistics.nbNewPairs)));
        assert(((cast(*void)(*instance.nbLostPairs)) - cast(*void)(*instance)) == 92, "PxSimulationStatistics.nbLostPairs has unexpected offset % instead of 92", ((cast(*void)(*instance.nbLostPairs)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSimulationStatistics.nbLostPairs)) == 4, "PxSimulationStatistics.nbLostPairs has unexpected size % instead of 4", size_of(type_of(PxSimulationStatistics.nbLostPairs)));
        assert(((cast(*void)(*instance.nbNewTouches)) - cast(*void)(*instance)) == 96, "PxSimulationStatistics.nbNewTouches has unexpected offset % instead of 96", ((cast(*void)(*instance.nbNewTouches)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSimulationStatistics.nbNewTouches)) == 4, "PxSimulationStatistics.nbNewTouches has unexpected size % instead of 4", size_of(type_of(PxSimulationStatistics.nbNewTouches)));
        assert(((cast(*void)(*instance.nbLostTouches)) - cast(*void)(*instance)) == 100, "PxSimulationStatistics.nbLostTouches has unexpected offset % instead of 100", ((cast(*void)(*instance.nbLostTouches)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSimulationStatistics.nbLostTouches)) == 4, "PxSimulationStatistics.nbLostTouches has unexpected size % instead of 4", size_of(type_of(PxSimulationStatistics.nbLostTouches)));
        assert(((cast(*void)(*instance.nbPartitions)) - cast(*void)(*instance)) == 104, "PxSimulationStatistics.nbPartitions has unexpected offset % instead of 104", ((cast(*void)(*instance.nbPartitions)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSimulationStatistics.nbPartitions)) == 4, "PxSimulationStatistics.nbPartitions has unexpected size % instead of 4", size_of(type_of(PxSimulationStatistics.nbPartitions)));
        assert(((cast(*void)(*instance.nbBroadPhaseAdds)) - cast(*void)(*instance)) == 108, "PxSimulationStatistics.nbBroadPhaseAdds has unexpected offset % instead of 108", ((cast(*void)(*instance.nbBroadPhaseAdds)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSimulationStatistics.nbBroadPhaseAdds)) == 4, "PxSimulationStatistics.nbBroadPhaseAdds has unexpected size % instead of 4", size_of(type_of(PxSimulationStatistics.nbBroadPhaseAdds)));
        assert(((cast(*void)(*instance.nbBroadPhaseRemoves)) - cast(*void)(*instance)) == 112, "PxSimulationStatistics.nbBroadPhaseRemoves has unexpected offset % instead of 112", ((cast(*void)(*instance.nbBroadPhaseRemoves)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSimulationStatistics.nbBroadPhaseRemoves)) == 4, "PxSimulationStatistics.nbBroadPhaseRemoves has unexpected size % instead of 4", size_of(type_of(PxSimulationStatistics.nbBroadPhaseRemoves)));
        assert(((cast(*void)(*instance.nbDiscreteContactPairs)) - cast(*void)(*instance)) == 116, "PxSimulationStatistics.nbDiscreteContactPairs has unexpected offset % instead of 116", ((cast(*void)(*instance.nbDiscreteContactPairs)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSimulationStatistics.nbDiscreteContactPairs)) == 196, "PxSimulationStatistics.nbDiscreteContactPairs has unexpected size % instead of 196", size_of(type_of(PxSimulationStatistics.nbDiscreteContactPairs)));
        assert(((cast(*void)(*instance.nbCCDPairs)) - cast(*void)(*instance)) == 312, "PxSimulationStatistics.nbCCDPairs has unexpected offset % instead of 312", ((cast(*void)(*instance.nbCCDPairs)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSimulationStatistics.nbCCDPairs)) == 196, "PxSimulationStatistics.nbCCDPairs has unexpected size % instead of 196", size_of(type_of(PxSimulationStatistics.nbCCDPairs)));
        assert(((cast(*void)(*instance.nbModifiedContactPairs)) - cast(*void)(*instance)) == 508, "PxSimulationStatistics.nbModifiedContactPairs has unexpected offset % instead of 508", ((cast(*void)(*instance.nbModifiedContactPairs)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSimulationStatistics.nbModifiedContactPairs)) == 196, "PxSimulationStatistics.nbModifiedContactPairs has unexpected size % instead of 196", size_of(type_of(PxSimulationStatistics.nbModifiedContactPairs)));
        assert(((cast(*void)(*instance.nbTriggerPairs)) - cast(*void)(*instance)) == 704, "PxSimulationStatistics.nbTriggerPairs has unexpected offset % instead of 704", ((cast(*void)(*instance.nbTriggerPairs)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSimulationStatistics.nbTriggerPairs)) == 196, "PxSimulationStatistics.nbTriggerPairs has unexpected size % instead of 196", size_of(type_of(PxSimulationStatistics.nbTriggerPairs)));
        assert(size_of(PxSimulationStatistics) == 900, "PxSimulationStatistics has size % instead of 900", size_of(PxSimulationStatistics));
    }

    /**
    \brief PVD scene Flags. They are disabled by default, and only works if PxPvdInstrumentationFlag::eDEBUG is set.
    */
    PxPvdSceneFlag :: struct {
        Enum :: enum s32 {
            CONTACTS     :: 1;
            SCENEQUERIES :: 2;
            CONSTRAINTS  :: 4;

            eTRANSMIT_CONTACTS     :: CONTACTS;
            eTRANSMIT_SCENEQUERIES :: SCENEQUERIES;
            eTRANSMIT_CONSTRAINTS  :: CONSTRAINTS;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxPvdSceneFlag) == 1, "PxPvdSceneFlag has size % instead of 1", size_of(PxPvdSceneFlag));
    }

    /**
    \brief Bitfield that contains a set of raised flags defined in PxPvdSceneFlag.

    @see PxPvdSceneFlag
    */
    PxPvdSceneFlags :: PxFlags(PxPvdSceneFlag.Enum, PxU8);

    /**
    \brief Special client for PxScene.
    It provides access to the PxPvdSceneFlag.
    It also provides simple user debug services that associated scene position such as immediate rendering and camera updates.
    */
    PxPvdSceneClient :: struct {
        vtable: *PxPvdSceneClient_VTable;
    }
    PxPvdSceneClient_VTable :: struct #type_info_none {
        setScenePvdFlag: (this: *PxPvdSceneClient, flag: PxPvdSceneFlag.Enum, value: bool) -> void #cpp_method;

        setScenePvdFlags: (this: *PxPvdSceneClient, flags: PxPvdSceneFlags) -> void #cpp_method;

        getScenePvdFlags: (this: *PxPvdSceneClient) -> PxPvdSceneFlags #cpp_method;

        updateCamera: (this: *PxPvdSceneClient, name: *u8, origin: *PxVec3, up: *PxVec3, target: *PxVec3) -> void #cpp_method;

        drawPoints: (this: *PxPvdSceneClient, points: *pvdsdk.PvdDebugPoint, count: PxU32) -> void #cpp_method;

        drawLines: (this: *PxPvdSceneClient, lines: *pvdsdk.PvdDebugLine, count: PxU32) -> void #cpp_method;

        drawTriangles: (this: *PxPvdSceneClient, triangles: *pvdsdk.PvdDebugTriangle, count: PxU32) -> void #cpp_method;

        drawText: (this: *PxPvdSceneClient, text: *pvdsdk.PvdDebugText) -> void #cpp_method;

        getClientInternal: (this: *PxPvdSceneClient) -> *pvdsdk.PvdClient #cpp_method;

        Destructor: (this: *PxPvdSceneClient, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxPvdSceneClient_setScenePvdFlag :: inline (this: *PxPvdSceneClient, flag: PxPvdSceneFlag.Enum, value: bool) { this.vtable.setScenePvdFlag(this, flag, value); }

    PxPvdSceneClient_setScenePvdFlags :: inline (this: *PxPvdSceneClient, flags: PxPvdSceneFlags) { this.vtable.setScenePvdFlags(this, flags); }

    PxPvdSceneClient_getScenePvdFlags :: inline (this: *PxPvdSceneClient) -> PxPvdSceneFlags { return this.vtable.getScenePvdFlags(this); }

    PxPvdSceneClient_updateCamera :: inline (this: *PxPvdSceneClient, name: *u8, origin: *PxVec3, up: *PxVec3, target: *PxVec3) { this.vtable.updateCamera(this, name, origin, up, target); }

    PxPvdSceneClient_drawPoints :: inline (this: *PxPvdSceneClient, points: *pvdsdk.PvdDebugPoint, count: PxU32) { this.vtable.drawPoints(this, points, count); }

    PxPvdSceneClient_drawLines :: inline (this: *PxPvdSceneClient, lines: *pvdsdk.PvdDebugLine, count: PxU32) { this.vtable.drawLines(this, lines, count); }

    PxPvdSceneClient_drawTriangles :: inline (this: *PxPvdSceneClient, triangles: *pvdsdk.PvdDebugTriangle, count: PxU32) { this.vtable.drawTriangles(this, triangles, count); }

    PxPvdSceneClient_drawText :: inline (this: *PxPvdSceneClient, text: *pvdsdk.PvdDebugText) { this.vtable.drawText(this, text); }

    PxPvdSceneClient_getClientInternal :: inline (this: *PxPvdSceneClient) -> *pvdsdk.PvdClient { return this.vtable.getClientInternal(this); }

    PxPvdSceneClient_Destructor :: inline (this: *PxPvdSceneClient, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxPvdSceneClient) -> *PxPvdSceneClient_VTable { return obj.vtable; }

    #run {if true then return;
        assert(size_of(PxPvdSceneClient) == 8, "PxPvdSceneClient has size % instead of 8", size_of(PxPvdSceneClient));
    }

    /**
    \brief Expresses the dominance relationship of a contact.
    For the time being only three settings are permitted:

    (1, 1), (0, 1), and (1, 0).

    @see getDominanceGroup() PxDominanceGroup PxScene::setDominanceGroupPair()
    */
    PxDominanceGroupPair :: struct {
        Constructor :: (this: *PxDominanceGroupPair, a: PxU8, b: PxU8) -> void #cpp_method #foreign physx_lib "??0PxDominanceGroupPair@physx@@QEAA@EE@Z";

        dominance0: PxU8;
        dominance1: PxU8;
    }
    #run {if true then return;
        instance: PxDominanceGroupPair;
        assert(((cast(*void)(*instance.dominance0)) - cast(*void)(*instance)) == 0, "PxDominanceGroupPair.dominance0 has unexpected offset % instead of 0", ((cast(*void)(*instance.dominance0)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxDominanceGroupPair.dominance0)) == 1, "PxDominanceGroupPair.dominance0 has unexpected size % instead of 1", size_of(type_of(PxDominanceGroupPair.dominance0)));
        assert(((cast(*void)(*instance.dominance1)) - cast(*void)(*instance)) == 1, "PxDominanceGroupPair.dominance1 has unexpected offset % instead of 1", ((cast(*void)(*instance.dominance1)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxDominanceGroupPair.dominance1)) == 1, "PxDominanceGroupPair.dominance1 has unexpected size % instead of 1", size_of(type_of(PxDominanceGroupPair.dominance1)));
        assert(size_of(PxDominanceGroupPair) == 2, "PxDominanceGroupPair has size % instead of 2", size_of(PxDominanceGroupPair));
    }

    /**
    \brief Identifies each type of actor for retrieving actors from a scene.

    \note #PxArticulationLink objects are not supported. Use the #PxArticulation object to retrieve all its links.

    @see PxScene::getActors(), PxScene::getNbActors()
    */
    PxActorTypeFlag :: struct {
        Enum :: enum s32 {
            STATIC  :: 1;

            DYNAMIC :: 2;

            eRIGID_STATIC  :: STATIC;

            eRIGID_DYNAMIC :: DYNAMIC;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxActorTypeFlag) == 1, "PxActorTypeFlag has size % instead of 1", size_of(PxActorTypeFlag));
    }

    /**
    \brief Collection of set bits defined in PxActorTypeFlag.

    @see PxActorTypeFlag
    */
    PxActorTypeFlags :: PxFlags(PxActorTypeFlag.Enum, PxU16);

    /**
    \brief single hit cache for scene queries.

    If a cache object is supplied to a scene query, the cached actor/shape pair is checked for intersection first.
    \note Filters are not executed for the cached shape.
    \note If intersection is found, the hit is treated as blocking.
    \note Typically actor and shape from the last PxHitCallback.block query result is used as a cached actor/shape pair.
    \note Using past touching hits as cache will produce incorrect behavior since the cached hit will always be treated as blocking.
    \note Cache is only used if no touch buffer was provided, for single nearest blocking hit queries and queries using eANY_HIT flag.
    \note if non-zero touch buffer was provided, cache will be ignored

    \note It is the user's responsibility to ensure that the shape and actor are valid, so care must be taken
    when deleting shapes to invalidate cached references.

    The faceIndex field is an additional hint for a mesh or height field which is not currently used.

    @see PxScene.raycast
    */
    PxQueryCache :: struct {
        /**
        \brief constructor sets to default
        */
        Constructor :: (this: *PxQueryCache) -> void #cpp_method #foreign physx_lib "??0PxQueryCache@physx@@QEAA@XZ";

        /**
        \brief constructor to set properties
        */
        Constructor :: (this: *PxQueryCache, s: *PxShape, findex: PxU32) -> void #cpp_method #foreign physx_lib "??0PxQueryCache@physx@@QEAA@PEAVPxShape@1@I@Z";

        shape:     *PxShape; //!< Shape to test for intersection first
        actor:     *PxRigidActor; //!< Actor to which the shape belongs
        faceIndex: PxU32; //!< Triangle index to test first - NOT CURRENTLY SUPPORTED
    }
    #run {if true then return;
        instance: PxQueryCache;
        assert(((cast(*void)(*instance.shape)) - cast(*void)(*instance)) == 0, "PxQueryCache.shape has unexpected offset % instead of 0", ((cast(*void)(*instance.shape)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxQueryCache.shape)) == 8, "PxQueryCache.shape has unexpected size % instead of 8", size_of(type_of(PxQueryCache.shape)));
        assert(((cast(*void)(*instance.actor)) - cast(*void)(*instance)) == 8, "PxQueryCache.actor has unexpected offset % instead of 8", ((cast(*void)(*instance.actor)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxQueryCache.actor)) == 8, "PxQueryCache.actor has unexpected size % instead of 8", size_of(type_of(PxQueryCache.actor)));
        assert(((cast(*void)(*instance.faceIndex)) - cast(*void)(*instance)) == 16, "PxQueryCache.faceIndex has unexpected offset % instead of 16", ((cast(*void)(*instance.faceIndex)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxQueryCache.faceIndex)) == 4, "PxQueryCache.faceIndex has unexpected size % instead of 4", size_of(type_of(PxQueryCache.faceIndex)));
        assert(size_of(PxQueryCache) == 24, "PxQueryCache has size % instead of 24", size_of(PxQueryCache));
    }

    /**
    \brief A scene is a collection of bodies and constraints which can interact.

    The scene simulates the behavior of these objects over time. Several scenes may exist
    at the same time, but each body or constraint is specific to a scene
    -- they may not be shared.

    @see PxSceneDesc PxPhysics.createScene() release()
    */
    PxScene :: struct {
        vtable: *PxScene_VTable;
        userData: *void; //!< user can assign this to whatever, usually to create a 1:1 relationship with a user object.
    }
    PxScene_VTable :: struct #type_info_none {
        Destructor: (this: *PxScene, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

        release: (this: *PxScene) -> void #cpp_method;

        setFlag: (this: *PxScene, flag: PxSceneFlag.Enum, value: bool) -> void #cpp_method;

        getFlags: (this: *PxScene) -> PxSceneFlags #cpp_method;

        setLimits: (this: *PxScene, limits: *PxSceneLimits) -> void #cpp_method;

        getLimits: (this: *PxScene) -> PxSceneLimits #cpp_method #cpp_return_type_is_non_pod;

        getPhysics: (this: *PxScene) -> *PxPhysics #cpp_method;

        getTimestamp: (this: *PxScene) -> PxU32 #cpp_method;

        addArticulation: (this: *PxScene, articulation: *PxArticulationBase) -> void #cpp_method;

        removeArticulation: (this: *PxScene, articulation: *PxArticulationBase, wakeOnLostTouch := true) -> void #cpp_method;

        addActor: (this: *PxScene, actor: *PxActor, bvhStructure: *PxBVHStructure = null) -> void #cpp_method;

        addActors: (this: *PxScene, pruningStructure: *PxPruningStructure) -> void #cpp_method;

        addActors_1: (this: *PxScene, actors: /*const*/ **PxActor, nbActors: PxU32) -> void #cpp_method;

        removeActor: (this: *PxScene, actor: *PxActor, wakeOnLostTouch := true) -> void #cpp_method;

        removeActors: (this: *PxScene, actors: **PxActor, nbActors: PxU32, wakeOnLostTouch := true) -> void #cpp_method;

        addAggregate: (this: *PxScene, aggregate: *PxAggregate) -> void #cpp_method;

        removeAggregate: (this: *PxScene, aggregate: *PxAggregate, wakeOnLostTouch := true) -> void #cpp_method;

        addCollection: (this: *PxScene, collection: *PxCollection) -> void #cpp_method;

        getNbActors: (this: *PxScene, types: PxActorTypeFlags) -> PxU32 #cpp_method;

        getActors: (this: *PxScene, types: PxActorTypeFlags, userBuffer: **PxActor, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        getActiveActors: (this: *PxScene, nbActorsOut: *PxU32) -> **PxActor #cpp_method;

        getNbArticulations: (this: *PxScene) -> PxU32 #cpp_method;

        getArticulations: (this: *PxScene, userBuffer: **PxArticulationBase, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        getNbConstraints: (this: *PxScene) -> PxU32 #cpp_method;

        getConstraints: (this: *PxScene, userBuffer: **PxConstraint, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        getNbAggregates: (this: *PxScene) -> PxU32 #cpp_method;

        getAggregates: (this: *PxScene, userBuffer: **PxAggregate, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        setDominanceGroupPair: (this: *PxScene, group1: PxDominanceGroup, group2: PxDominanceGroup, dominance: *PxDominanceGroupPair) -> void #cpp_method;

        getDominanceGroupPair: (this: *PxScene, group1: PxDominanceGroup, group2: PxDominanceGroup) -> PxDominanceGroupPair #cpp_method #cpp_return_type_is_non_pod;

        getCpuDispatcher: (this: *PxScene) -> *PxCpuDispatcher #cpp_method;

        getCudaContextManager: (this: *PxScene) -> *PxCudaContextManager #cpp_method;

        createClient: (this: *PxScene) -> PxClientID #cpp_method;

        setSimulationEventCallback: (this: *PxScene, callback: *PxSimulationEventCallback) -> void #cpp_method;

        getSimulationEventCallback: (this: *PxScene) -> *PxSimulationEventCallback #cpp_method;

        setContactModifyCallback: (this: *PxScene, callback: *PxContactModifyCallback) -> void #cpp_method;

        setCCDContactModifyCallback: (this: *PxScene, callback: *PxCCDContactModifyCallback) -> void #cpp_method;

        getContactModifyCallback: (this: *PxScene) -> *PxContactModifyCallback #cpp_method;

        getCCDContactModifyCallback: (this: *PxScene) -> *PxCCDContactModifyCallback #cpp_method;

        setBroadPhaseCallback: (this: *PxScene, callback: *PxBroadPhaseCallback) -> void #cpp_method;

        getBroadPhaseCallback: (this: *PxScene) -> *PxBroadPhaseCallback #cpp_method;

        setFilterShaderData: (this: *PxScene, data: *void, dataSize: PxU32) -> void #cpp_method;

        getFilterShaderData: (this: *PxScene) -> *void #cpp_method;

        getFilterShaderDataSize: (this: *PxScene) -> PxU32 #cpp_method;

        getFilterShader: (this: *PxScene) -> PxSimulationFilterShader #cpp_method;

        getFilterCallback: (this: *PxScene) -> *PxSimulationFilterCallback #cpp_method;

        resetFiltering: (this: *PxScene, actor: *PxRigidActor, shapes: **PxShape, shapeCount: PxU32) -> void #cpp_method;

        resetFiltering_1: (this: *PxScene, actor: /*reference*/ *PxActor) -> void #cpp_method;

        getKinematicKinematicFilteringMode: (this: *PxScene) -> PxPairFilteringMode.Enum #cpp_method;

        getStaticKinematicFilteringMode: (this: *PxScene) -> PxPairFilteringMode.Enum #cpp_method;

        simulate: (this: *PxScene, elapsedTime: PxReal, completionTask: *PxBaseTask = null, scratchMemBlock: *void = null, scratchMemBlockSize: PxU32 = 0, controlSimulation := true) -> void #cpp_method;

        advance: (this: *PxScene, completionTask: *PxBaseTask = null) -> void #cpp_method;

        collide: (this: *PxScene, elapsedTime: PxReal, completionTask: *PxBaseTask = null, scratchMemBlock: *void = null, scratchMemBlockSize: PxU32 = 0, controlSimulation := true) -> void #cpp_method;

        checkResults: (this: *PxScene, block := false) -> bool #cpp_method;

        fetchCollision: (this: *PxScene, block := false) -> bool #cpp_method;

        fetchResults: (this: *PxScene, block := false, errorState: *PxU32 = null) -> bool #cpp_method;

        fetchResultsStart: (this: *PxScene, contactPairs: **PxContactPairHeader, nbContactPairs: *PxU32, block := false) -> bool #cpp_method;

        processCallbacks: (this: *PxScene, continuation: *PxBaseTask) -> void #cpp_method;

        fetchResultsFinish: (this: *PxScene, errorState: *PxU32 = null) -> void #cpp_method;

        flushSimulation: (this: *PxScene, sendPendingReports := false) -> void #cpp_method;

        setGravity: (this: *PxScene, vec: *PxVec3) -> void #cpp_method;

        getGravity: (this: *PxScene) -> PxVec3 #cpp_method #cpp_return_type_is_non_pod;

        setBounceThresholdVelocity: (this: *PxScene, t: PxReal) -> void #cpp_method;

        getBounceThresholdVelocity: (this: *PxScene) -> PxReal #cpp_method;

        setCCDMaxPasses: (this: *PxScene, ccdMaxPasses: PxU32) -> void #cpp_method;

        getCCDMaxPasses: (this: *PxScene) -> PxU32 #cpp_method;

        getFrictionOffsetThreshold: (this: *PxScene) -> PxReal #cpp_method;

        setFrictionType: (this: *PxScene, frictionType: PxFrictionType.Enum) -> void #cpp_method;

        getFrictionType: (this: *PxScene) -> PxFrictionType.Enum #cpp_method;

        setVisualizationParameter: (this: *PxScene, param: PxVisualizationParameter.Enum, value: PxReal) -> bool #cpp_method;

        getVisualizationParameter: (this: *PxScene, paramEnum: PxVisualizationParameter.Enum) -> PxReal #cpp_method;

        setVisualizationCullingBox: (this: *PxScene, box: *PxBounds3) -> void #cpp_method;

        getVisualizationCullingBox: (this: *PxScene) -> PxBounds3 #cpp_method #cpp_return_type_is_non_pod;

        getRenderBuffer: (this: *PxScene) -> *PxRenderBuffer #cpp_method;

        getSimulationStatistics: (this: *PxScene, stats: *PxSimulationStatistics) -> void #cpp_method;

        getStaticStructure: (this: *PxScene) -> PxPruningStructureType.Enum #cpp_method;

        getDynamicStructure: (this: *PxScene) -> PxPruningStructureType.Enum #cpp_method;

        flushQueryUpdates: (this: *PxScene) -> void #cpp_method;

        createBatchQuery: (this: *PxScene, desc: *PxBatchQueryDesc) -> *PxBatchQuery #cpp_method;

        setDynamicTreeRebuildRateHint: (this: *PxScene, dynamicTreeRebuildRateHint: PxU32) -> void #cpp_method;

        getDynamicTreeRebuildRateHint: (this: *PxScene) -> PxU32 #cpp_method;

        forceDynamicTreeRebuild: (this: *PxScene, rebuildStaticStructure: bool, rebuildDynamicStructure: bool) -> void #cpp_method;

        setSceneQueryUpdateMode: (this: *PxScene, updateMode: PxSceneQueryUpdateMode.Enum) -> void #cpp_method;

        getSceneQueryUpdateMode: (this: *PxScene) -> PxSceneQueryUpdateMode.Enum #cpp_method;

        sceneQueriesUpdate: (this: *PxScene, completionTask: *PxBaseTask = null, controlSimulation := true) -> void #cpp_method;

        checkQueries: (this: *PxScene, block := false) -> bool #cpp_method;

        fetchQueries: (this: *PxScene, block := false) -> bool #cpp_method;

        raycast: (this: *PxScene, origin: *PxVec3, unitDir: *PxVec3, distance: PxReal, hitCall: *PxRaycastCallback, hitFlags: PxHitFlags, filterData: *PxQueryFilterData, filterCall: *PxQueryFilterCallback = null, cache: *PxQueryCache = null) -> bool #cpp_method;
        // raycast :: (this: *PxScene, origin: PxVec3, unitDir: PxVec3, distance: PxReal, hitCall: *PxRaycastCallback, hitFlags: PxHitFlags, filterData: PxQueryFilterData = PxQueryFilterData.{}, filterCall: *PxQueryFilterCallback = null, cache: *PxQueryCache = null) -> bool #no_context {
        //     return raycast(this, *origin, *unitDir, distance, hitCall, hitFlags, *filterData, filterCall, cache);
        // }

        sweep: (this: *PxScene, geometry: *PxGeometry, pose: *PxTransform, unitDir: *PxVec3, distance: PxReal, hitCall: *PxSweepCallback, hitFlags: PxHitFlags, filterData: *PxQueryFilterData, filterCall: *PxQueryFilterCallback = null, cache: *PxQueryCache = null, inflation: PxReal = 0.0) -> bool #cpp_method;
        // sweep :: (this: *PxScene, geometry: PxGeometry, pose: PxTransform, unitDir: PxVec3, distance: PxReal, hitCall: *PxSweepCallback, hitFlags: PxHitFlags, filterData: PxQueryFilterData = PxQueryFilterData.{}, filterCall: *PxQueryFilterCallback = null, cache: *PxQueryCache = null, inflation: PxReal = 0.0) -> bool #no_context {
        //     return sweep(this, *geometry, *pose, *unitDir, distance, hitCall, hitFlags, *filterData, filterCall, cache, inflation);
        // }

        overlap: (this: *PxScene, geometry: *PxGeometry, pose: *PxTransform, hitCall: *PxOverlapCallback, filterData: *PxQueryFilterData, filterCall: *PxQueryFilterCallback = null) -> bool #cpp_method;
        // overlap :: (this: *PxScene, geometry: PxGeometry, pose: PxTransform, hitCall: *PxOverlapCallback, filterData: PxQueryFilterData = PxQueryFilterData.{}, filterCall: *PxQueryFilterCallback = null) -> bool #no_context {
        //     return overlap(this, *geometry, *pose, hitCall, *filterData, filterCall);
        // }

        getSceneQueryStaticTimestamp: (this: *PxScene) -> PxU32 #cpp_method;

        getBroadPhaseType: (this: *PxScene) -> PxBroadPhaseType.Enum #cpp_method;

        getBroadPhaseCaps: (this: *PxScene, caps: *PxBroadPhaseCaps) -> bool #cpp_method;

        getNbBroadPhaseRegions: (this: *PxScene) -> PxU32 #cpp_method;

        getBroadPhaseRegions: (this: *PxScene, userBuffer: *PxBroadPhaseRegionInfo, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        addBroadPhaseRegion: (this: *PxScene, region: *PxBroadPhaseRegion, populateRegion := false) -> PxU32 #cpp_method;

        removeBroadPhaseRegion: (this: *PxScene, handle: PxU32) -> bool #cpp_method;

        getTaskManager: (this: *PxScene) -> *PxTaskManager #cpp_method;

        lockRead: (this: *PxScene, file: *u8 = null, line: PxU32 = 0) -> void #cpp_method;

        unlockRead: (this: *PxScene) -> void #cpp_method;

        lockWrite: (this: *PxScene, file: *u8 = null, line: PxU32 = 0) -> void #cpp_method;

        unlockWrite: (this: *PxScene) -> void #cpp_method;

        setNbContactDataBlocks: (this: *PxScene, numBlocks: PxU32) -> void #cpp_method;

        getNbContactDataBlocksUsed: (this: *PxScene) -> PxU32 #cpp_method;

        getMaxNbContactDataBlocksUsed: (this: *PxScene) -> PxU32 #cpp_method;

        getContactReportStreamBufferSize: (this: *PxScene) -> PxU32 #cpp_method;

        setSolverBatchSize: (this: *PxScene, solverBatchSize: PxU32) -> void #cpp_method;

        getSolverBatchSize: (this: *PxScene) -> PxU32 #cpp_method;

        setSolverArticulationBatchSize: (this: *PxScene, solverBatchSize: PxU32) -> void #cpp_method;

        getSolverArticulationBatchSize: (this: *PxScene) -> PxU32 #cpp_method;

        getWakeCounterResetValue: (this: *PxScene) -> PxReal #cpp_method;

        shiftOrigin: (this: *PxScene, shift: *PxVec3) -> void #cpp_method;

        getScenePvdClient: (this: *PxScene) -> *PxPvdSceneClient #cpp_method;
    }

    PxScene_Destructor :: inline (this: *PxScene, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    PxScene_release :: inline (this: *PxScene) { this.vtable.release(this); }

    PxScene_setFlag :: inline (this: *PxScene, flag: PxSceneFlag.Enum, value: bool) { this.vtable.setFlag(this, flag, value); }

    PxScene_getFlags :: inline (this: *PxScene) -> PxSceneFlags { return this.vtable.getFlags(this); }

    PxScene_setLimits :: inline (this: *PxScene, limits: *PxSceneLimits) { this.vtable.setLimits(this, limits); }

    PxScene_getLimits :: inline (this: *PxScene) -> PxSceneLimits { return this.vtable.getLimits(this); }

    PxScene_getPhysics :: inline (this: *PxScene) -> *PxPhysics { return this.vtable.getPhysics(this); }

    PxScene_getTimestamp :: inline (this: *PxScene) -> PxU32 { return this.vtable.getTimestamp(this); }

    PxScene_addArticulation :: inline (this: *PxScene, articulation: *PxArticulationBase) { this.vtable.addArticulation(this, articulation); }

    PxScene_removeArticulation :: inline (this: *PxScene, articulation: *PxArticulationBase, wakeOnLostTouch := true) { this.vtable.removeArticulation(this, articulation, wakeOnLostTouch); }

    PxScene_addActor :: inline (this: *PxScene, actor: *PxActor, bvhStructure: *PxBVHStructure = null) { this.vtable.addActor(this, actor, bvhStructure); }

    PxScene_addActors :: inline (this: *PxScene, pruningStructure: /*const reference*/ *PxPruningStructure) { this.vtable.addActors(this, pruningStructure); }

    PxScene_addActors_1 :: inline (this: *PxScene, actors: /*const*/ **PxActor, nbActors: PxU32) { this.vtable.addActors_1(this, actors, nbActors); }

    PxScene_removeActor :: inline (this: *PxScene, actor: *PxActor, wakeOnLostTouch := true) { this.vtable.removeActor(this, actor, wakeOnLostTouch); }

    PxScene_removeActors :: inline (this: *PxScene, actors: **PxActor, nbActors: PxU32, wakeOnLostTouch := true) { this.vtable.removeActors(this, actors, nbActors, wakeOnLostTouch); }

    PxScene_addAggregate :: inline (this: *PxScene, aggregate: *PxAggregate) { this.vtable.addAggregate(this, aggregate); }

    PxScene_removeAggregate :: inline (this: *PxScene, aggregate: *PxAggregate, wakeOnLostTouch := true) { this.vtable.removeAggregate(this, aggregate, wakeOnLostTouch); }

    PxScene_addCollection :: inline (this: *PxScene, collection: *PxCollection) { this.vtable.addCollection(this, collection); }

    PxScene_getNbActors :: inline (this: *PxScene, types: PxActorTypeFlags) -> PxU32 { return this.vtable.getNbActors(this, types); }

    PxScene_getActors :: inline (this: *PxScene, types: PxActorTypeFlags, userBuffer: **PxActor, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.vtable.getActors(this, types, userBuffer, bufferSize, startIndex); }

    PxScene_getActiveActors :: inline (this: *PxScene, nbActorsOut: *PxU32) -> **PxActor { return this.vtable.getActiveActors(this, nbActorsOut); }

    PxScene_getNbArticulations :: inline (this: *PxScene) -> PxU32 { return this.vtable.getNbArticulations(this); }

    PxScene_getArticulations :: inline (this: *PxScene, userBuffer: **PxArticulationBase, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.vtable.getArticulations(this, userBuffer, bufferSize, startIndex); }

    PxScene_getNbConstraints :: inline (this: *PxScene) -> PxU32 { return this.vtable.getNbConstraints(this); }

    PxScene_getConstraints :: inline (this: *PxScene, userBuffer: **PxConstraint, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.vtable.getConstraints(this, userBuffer, bufferSize, startIndex); }

    PxScene_getNbAggregates :: inline (this: *PxScene) -> PxU32 { return this.vtable.getNbAggregates(this); }

    PxScene_getAggregates :: inline (this: *PxScene, userBuffer: **PxAggregate, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.vtable.getAggregates(this, userBuffer, bufferSize, startIndex); }

    PxScene_setDominanceGroupPair :: inline (this: *PxScene, group1: PxDominanceGroup, group2: PxDominanceGroup, dominance: *PxDominanceGroupPair) { this.vtable.setDominanceGroupPair(this, group1, group2, dominance); }

    PxScene_getDominanceGroupPair :: inline (this: *PxScene, group1: PxDominanceGroup, group2: PxDominanceGroup) -> PxDominanceGroupPair { return this.vtable.getDominanceGroupPair(this, group1, group2); }

    PxScene_getCpuDispatcher :: inline (this: *PxScene) -> *PxCpuDispatcher { return this.vtable.getCpuDispatcher(this); }

    PxScene_getCudaContextManager :: inline (this: *PxScene) -> *PxCudaContextManager { return this.vtable.getCudaContextManager(this); }

    PxScene_createClient :: inline (this: *PxScene) -> PxClientID { return this.vtable.createClient(this); }

    PxScene_setSimulationEventCallback :: inline (this: *PxScene, callback: *PxSimulationEventCallback) { this.vtable.setSimulationEventCallback(this, callback); }

    PxScene_getSimulationEventCallback :: inline (this: *PxScene) -> *PxSimulationEventCallback { return this.vtable.getSimulationEventCallback(this); }

    PxScene_setContactModifyCallback :: inline (this: *PxScene, callback: *PxContactModifyCallback) { this.vtable.setContactModifyCallback(this, callback); }

    PxScene_setCCDContactModifyCallback :: inline (this: *PxScene, callback: *PxCCDContactModifyCallback) { this.vtable.setCCDContactModifyCallback(this, callback); }

    PxScene_getContactModifyCallback :: inline (this: *PxScene) -> *PxContactModifyCallback { return this.vtable.getContactModifyCallback(this); }

    PxScene_getCCDContactModifyCallback :: inline (this: *PxScene) -> *PxCCDContactModifyCallback { return this.vtable.getCCDContactModifyCallback(this); }

    PxScene_setBroadPhaseCallback :: inline (this: *PxScene, callback: *PxBroadPhaseCallback) { this.vtable.setBroadPhaseCallback(this, callback); }

    PxScene_getBroadPhaseCallback :: inline (this: *PxScene) -> *PxBroadPhaseCallback { return this.vtable.getBroadPhaseCallback(this); }

    PxScene_setFilterShaderData :: inline (this: *PxScene, data: *void, dataSize: PxU32) { this.vtable.setFilterShaderData(this, data, dataSize); }

    PxScene_getFilterShaderData :: inline (this: *PxScene) -> *void { return this.vtable.getFilterShaderData(this); }

    PxScene_getFilterShaderDataSize :: inline (this: *PxScene) -> PxU32 { return this.vtable.getFilterShaderDataSize(this); }

    PxScene_getFilterShader :: inline (this: *PxScene) -> PxSimulationFilterShader { return this.vtable.getFilterShader(this); }

    PxScene_getFilterCallback :: inline (this: *PxScene) -> *PxSimulationFilterCallback { return this.vtable.getFilterCallback(this); }

    PxScene_resetFiltering :: inline (this: *PxScene, actor: /*reference*/ *PxRigidActor, shapes: /*const*/ **PxShape, shapeCount: PxU32) { this.vtable.resetFiltering(this, actor, shapes, shapeCount); }

    PxScene_resetFiltering_1 :: inline (this: *PxScene, actor: /*reference*/ *PxActor) { this.vtable.resetFiltering_1(this, actor); }

    PxScene_getKinematicKinematicFilteringMode :: inline (this: *PxScene) -> PxPairFilteringMode.Enum { return this.vtable.getKinematicKinematicFilteringMode(this); }

    PxScene_getStaticKinematicFilteringMode :: inline (this: *PxScene) -> PxPairFilteringMode.Enum { return this.vtable.getStaticKinematicFilteringMode(this); }

    PxScene_simulate :: inline (this: *PxScene, elapsedTime: PxReal, completionTask: *PxBaseTask = null, scratchMemBlock: *void = null, scratchMemBlockSize: PxU32 = 0, controlSimulation := true) { this.vtable.simulate(this, elapsedTime, completionTask, scratchMemBlock, scratchMemBlockSize, controlSimulation); }

    PxScene_advance :: inline (this: *PxScene, completionTask: *PxBaseTask = null) { this.vtable.advance(this, completionTask); }

    PxScene_collide :: inline (this: *PxScene, elapsedTime: PxReal, completionTask: *PxBaseTask = null, scratchMemBlock: *void = null, scratchMemBlockSize: PxU32 = 0, controlSimulation := true) { this.vtable.collide(this, elapsedTime, completionTask, scratchMemBlock, scratchMemBlockSize, controlSimulation); }

    PxScene_checkResults :: inline (this: *PxScene, block := false) -> bool { return this.vtable.checkResults(this, block); }

    PxScene_fetchCollision :: inline (this: *PxScene, block := false) -> bool { return this.vtable.fetchCollision(this, block); }

    PxScene_fetchResults :: inline (this: *PxScene, block := false, errorState: *PxU32 = null) -> bool { return this.vtable.fetchResults(this, block, errorState); }

    PxScene_fetchResultsStart :: inline (this: *PxScene, contactPairs: **PxContactPairHeader, nbContactPairs: *PxU32, block := false) -> bool { return this.vtable.fetchResultsStart(this, contactPairs, nbContactPairs, block); }

    PxScene_processCallbacks :: inline (this: *PxScene, continuation: *PxBaseTask) { this.vtable.processCallbacks(this, continuation); }

    PxScene_fetchResultsFinish :: inline (this: *PxScene, errorState: *PxU32 = null) { this.vtable.fetchResultsFinish(this, errorState); }

    PxScene_flushSimulation :: inline (this: *PxScene, sendPendingReports := false) { this.vtable.flushSimulation(this, sendPendingReports); }

    PxScene_setGravity :: inline (this: *PxScene, vec: *PxVec3) { this.vtable.setGravity(this, vec); }

    PxScene_getGravity :: inline (this: *PxScene) -> PxVec3 { return this.vtable.getGravity(this); }

    PxScene_setBounceThresholdVelocity :: inline (this: *PxScene, t: PxReal) { this.vtable.setBounceThresholdVelocity(this, t); }

    PxScene_getBounceThresholdVelocity :: inline (this: *PxScene) -> PxReal { return this.vtable.getBounceThresholdVelocity(this); }

    PxScene_setCCDMaxPasses :: inline (this: *PxScene, ccdMaxPasses: PxU32) { this.vtable.setCCDMaxPasses(this, ccdMaxPasses); }

    PxScene_getCCDMaxPasses :: inline (this: *PxScene) -> PxU32 { return this.vtable.getCCDMaxPasses(this); }

    PxScene_getFrictionOffsetThreshold :: inline (this: *PxScene) -> PxReal { return this.vtable.getFrictionOffsetThreshold(this); }

    PxScene_setFrictionType :: inline (this: *PxScene, frictionType: PxFrictionType.Enum) { this.vtable.setFrictionType(this, frictionType); }

    PxScene_getFrictionType :: inline (this: *PxScene) -> PxFrictionType.Enum { return this.vtable.getFrictionType(this); }

    PxScene_setVisualizationParameter :: inline (this: *PxScene, param: PxVisualizationParameter.Enum, value: PxReal) -> bool { return this.vtable.setVisualizationParameter(this, param, value); }

    PxScene_getVisualizationParameter :: inline (this: *PxScene, paramEnum: PxVisualizationParameter.Enum) -> PxReal { return this.vtable.getVisualizationParameter(this, paramEnum); }

    PxScene_setVisualizationCullingBox :: inline (this: *PxScene, box: *PxBounds3) { this.vtable.setVisualizationCullingBox(this, box); }

    PxScene_getVisualizationCullingBox :: inline (this: *PxScene) -> PxBounds3 { return this.vtable.getVisualizationCullingBox(this); }

    PxScene_getRenderBuffer :: inline (this: *PxScene) -> *PxRenderBuffer { return this.vtable.getRenderBuffer(this); }

    PxScene_getSimulationStatistics :: inline (this: *PxScene, stats: *PxSimulationStatistics) { this.vtable.getSimulationStatistics(this, stats); }

    PxScene_getStaticStructure :: inline (this: *PxScene) -> PxPruningStructureType.Enum { return this.vtable.getStaticStructure(this); }

    PxScene_getDynamicStructure :: inline (this: *PxScene) -> PxPruningStructureType.Enum { return this.vtable.getDynamicStructure(this); }

    PxScene_flushQueryUpdates :: inline (this: *PxScene) { this.vtable.flushQueryUpdates(this); }

    PxScene_createBatchQuery :: inline (this: *PxScene, desc: *PxBatchQueryDesc) -> *PxBatchQuery { return this.vtable.createBatchQuery(this, desc); }

    PxScene_setDynamicTreeRebuildRateHint :: inline (this: *PxScene, dynamicTreeRebuildRateHint: PxU32) { this.vtable.setDynamicTreeRebuildRateHint(this, dynamicTreeRebuildRateHint); }

    PxScene_getDynamicTreeRebuildRateHint :: inline (this: *PxScene) -> PxU32 { return this.vtable.getDynamicTreeRebuildRateHint(this); }

    PxScene_forceDynamicTreeRebuild :: inline (this: *PxScene, rebuildStaticStructure: bool, rebuildDynamicStructure: bool) { this.vtable.forceDynamicTreeRebuild(this, rebuildStaticStructure, rebuildDynamicStructure); }

    PxScene_setSceneQueryUpdateMode :: inline (this: *PxScene, updateMode: PxSceneQueryUpdateMode.Enum) { this.vtable.setSceneQueryUpdateMode(this, updateMode); }

    PxScene_getSceneQueryUpdateMode :: inline (this: *PxScene) -> PxSceneQueryUpdateMode.Enum { return this.vtable.getSceneQueryUpdateMode(this); }

    PxScene_sceneQueriesUpdate :: inline (this: *PxScene, completionTask: *PxBaseTask = null, controlSimulation := true) { this.vtable.sceneQueriesUpdate(this, completionTask, controlSimulation); }

    PxScene_checkQueries :: inline (this: *PxScene, block := false) -> bool { return this.vtable.checkQueries(this, block); }

    PxScene_fetchQueries :: inline (this: *PxScene, block := false) -> bool { return this.vtable.fetchQueries(this, block); }

    PxScene_raycast :: inline (this: *PxScene, origin: *PxVec3, unitDir: *PxVec3, distance: PxReal, hitCall: *PxRaycastCallback, hitFlags: PxHitFlags, filterData: *PxQueryFilterData, filterCall: *PxQueryFilterCallback = null, cache: *PxQueryCache = null) -> bool { return this.vtable.raycast(this, origin, unitDir, distance, hitCall, hitFlags, filterData, filterCall, cache); }

    PxScene_sweep :: inline (this: *PxScene, geometry: *PxGeometry, pose: *PxTransform, unitDir: *PxVec3, distance: PxReal, hitCall: *PxSweepCallback, hitFlags: PxHitFlags, filterData: *PxQueryFilterData, filterCall: *PxQueryFilterCallback = null, cache: *PxQueryCache = null, inflation: PxReal = 0.0) -> bool { return this.vtable.sweep(this, geometry, pose, unitDir, distance, hitCall, hitFlags, filterData, filterCall, cache, inflation); }

    PxScene_overlap :: inline (this: *PxScene, geometry: *PxGeometry, pose: *PxTransform, hitCall: *PxOverlapCallback, filterData: *PxQueryFilterData, filterCall: *PxQueryFilterCallback = null) -> bool { return this.vtable.overlap(this, geometry, pose, hitCall, filterData, filterCall); }

    PxScene_getSceneQueryStaticTimestamp :: inline (this: *PxScene) -> PxU32 { return this.vtable.getSceneQueryStaticTimestamp(this); }

    PxScene_getBroadPhaseType :: inline (this: *PxScene) -> PxBroadPhaseType.Enum { return this.vtable.getBroadPhaseType(this); }

    PxScene_getBroadPhaseCaps :: inline (this: *PxScene, caps: *PxBroadPhaseCaps) -> bool { return this.vtable.getBroadPhaseCaps(this, caps); }

    PxScene_getNbBroadPhaseRegions :: inline (this: *PxScene) -> PxU32 { return this.vtable.getNbBroadPhaseRegions(this); }

    PxScene_getBroadPhaseRegions :: inline (this: *PxScene, userBuffer: *PxBroadPhaseRegionInfo, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.vtable.getBroadPhaseRegions(this, userBuffer, bufferSize, startIndex); }

    PxScene_addBroadPhaseRegion :: inline (this: *PxScene, region: *PxBroadPhaseRegion, populateRegion := false) -> PxU32 { return this.vtable.addBroadPhaseRegion(this, region, populateRegion); }

    PxScene_removeBroadPhaseRegion :: inline (this: *PxScene, handle: PxU32) -> bool { return this.vtable.removeBroadPhaseRegion(this, handle); }

    PxScene_getTaskManager :: inline (this: *PxScene) -> *PxTaskManager { return this.vtable.getTaskManager(this); }

    PxScene_lockRead :: inline (this: *PxScene, file: *u8 = null, line: PxU32 = 0) { this.vtable.lockRead(this, file, line); }

    PxScene_unlockRead :: inline (this: *PxScene) { this.vtable.unlockRead(this); }

    PxScene_lockWrite :: inline (this: *PxScene, file: *u8 = null, line: PxU32 = 0) { this.vtable.lockWrite(this, file, line); }

    PxScene_unlockWrite :: inline (this: *PxScene) { this.vtable.unlockWrite(this); }

    PxScene_setNbContactDataBlocks :: inline (this: *PxScene, numBlocks: PxU32) { this.vtable.setNbContactDataBlocks(this, numBlocks); }

    PxScene_getNbContactDataBlocksUsed :: inline (this: *PxScene) -> PxU32 { return this.vtable.getNbContactDataBlocksUsed(this); }

    PxScene_getMaxNbContactDataBlocksUsed :: inline (this: *PxScene) -> PxU32 { return this.vtable.getMaxNbContactDataBlocksUsed(this); }

    PxScene_getContactReportStreamBufferSize :: inline (this: *PxScene) -> PxU32 { return this.vtable.getContactReportStreamBufferSize(this); }

    PxScene_setSolverBatchSize :: inline (this: *PxScene, solverBatchSize: PxU32) { this.vtable.setSolverBatchSize(this, solverBatchSize); }

    PxScene_getSolverBatchSize :: inline (this: *PxScene) -> PxU32 { return this.vtable.getSolverBatchSize(this); }

    PxScene_setSolverArticulationBatchSize :: inline (this: *PxScene, solverBatchSize: PxU32) { this.vtable.setSolverArticulationBatchSize(this, solverBatchSize); }

    PxScene_getSolverArticulationBatchSize :: inline (this: *PxScene) -> PxU32 { return this.vtable.getSolverArticulationBatchSize(this); }

    PxScene_getWakeCounterResetValue :: inline (this: *PxScene) -> PxReal { return this.vtable.getWakeCounterResetValue(this); }

    PxScene_shiftOrigin :: inline (this: *PxScene, shift: *PxVec3) { this.vtable.shiftOrigin(this, shift); }

    PxScene_getScenePvdClient :: inline (this: *PxScene) -> *PxPvdSceneClient { return this.vtable.getScenePvdClient(this); }

    vtable :: (obj: *PxScene) -> *PxScene_VTable { return obj.vtable; }

    #run {
        instance: PxScene;
        assert(((cast(*void)(*instance.userData)) - cast(*void)(*instance)) == 8, "PxScene.userData has unexpected offset % instead of 8", ((cast(*void)(*instance.userData)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxScene.userData)) == 8, "PxScene.userData has unexpected size % instead of 8", size_of(type_of(PxScene.userData)));
        assert(size_of(PxScene) == 16, "PxScene has size % instead of 16", size_of(PxScene));
    }

    /**
    \brief RAII wrapper for the PxScene read lock.

    Use this class as follows to lock the scene for reading by the current thread
    for the duration of the enclosing scope:

    PxSceneReadLock lock(sceneRef);

    \see PxScene::lockRead(), PxScene::unlockRead(), PxSceneFlag::eREQUIRE_RW_LOCK
    */
    PxSceneReadLock :: struct {
        /**
        \brief Constructor
        \param scene The scene to lock for reading
        \param file Optional string for debugging purposes
        \param line Optional line number for debugging purposes
        */
        Constructor :: (this: *PxSceneReadLock, scene: *PxScene, file: *u8 = null, line: PxU32 = 0) -> void #cpp_method #foreign physx_lib "??0PxSceneReadLock@physx@@QEAA@AEAVPxScene@1@PEBDI@Z";

        Destructor :: (this: *PxSceneReadLock) -> void #cpp_method #foreign physx_lib "??1PxSceneReadLock@physx@@QEAA@XZ";

        mScene: *PxScene;
    }
    #run {if true then return;
        instance: PxSceneReadLock;
        assert(((cast(*void)(*instance.mScene)) - cast(*void)(*instance)) == 0, "PxSceneReadLock.mScene has unexpected offset % instead of 0", ((cast(*void)(*instance.mScene)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSceneReadLock.mScene)) == 8, "PxSceneReadLock.mScene has unexpected size % instead of 8", size_of(type_of(PxSceneReadLock.mScene)));
        assert(size_of(PxSceneReadLock) == 8, "PxSceneReadLock has size % instead of 8", size_of(PxSceneReadLock));
    }

    /**
    \brief RAII wrapper for the PxScene write lock.

    Use this class as follows to lock the scene for writing by the current thread
    for the duration of the enclosing scope:

    PxSceneWriteLock lock(sceneRef);

    \see PxScene::lockWrite(), PxScene::unlockWrite(), PxSceneFlag::eREQUIRE_RW_LOCK
    */
    PxSceneWriteLock :: struct {
        /**
        \brief Constructor
        \param scene The scene to lock for writing
        \param file Optional string for debugging purposes
        \param line Optional line number for debugging purposes
        */
        Constructor :: (this: *PxSceneWriteLock, scene: *PxScene, file: *u8 = null, line: PxU32 = 0) -> void #cpp_method #foreign physx_lib "??0PxSceneWriteLock@physx@@QEAA@AEAVPxScene@1@PEBDI@Z";

        Destructor :: (this: *PxSceneWriteLock) -> void #cpp_method #foreign physx_lib "??1PxSceneWriteLock@physx@@QEAA@XZ";

        mScene: *PxScene;
    }
    #run {if true then return;
        instance: PxSceneWriteLock;
        assert(((cast(*void)(*instance.mScene)) - cast(*void)(*instance)) == 0, "PxSceneWriteLock.mScene has unexpected offset % instead of 0", ((cast(*void)(*instance.mScene)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSceneWriteLock.mScene)) == 8, "PxSceneWriteLock.mScene has unexpected size % instead of 8", size_of(type_of(PxSceneWriteLock.mScene)));
        assert(size_of(PxSceneWriteLock) == 8, "PxSceneWriteLock has size % instead of 8", size_of(PxSceneWriteLock));
    }

    /**
    \brief Extra data item types for contact pairs.

    @see PxContactPairExtraDataItem.type
    */
    PxContactPairExtraDataType :: struct {
        Enum :: enum s32 {
            PRE_SOLVER_VELOCITY  :: 0;
            POST_SOLVER_VELOCITY :: 1;
            CONTACT_EVENT_POSE   :: 2;
            CONTACT_PAIR_INDEX   :: 3;

            ePRE_SOLVER_VELOCITY  :: PRE_SOLVER_VELOCITY;
            ePOST_SOLVER_VELOCITY :: POST_SOLVER_VELOCITY;
            eCONTACT_EVENT_POSE   :: CONTACT_EVENT_POSE;
            eCONTACT_PAIR_INDEX   :: CONTACT_PAIR_INDEX;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxContactPairExtraDataType) == 1, "PxContactPairExtraDataType has size % instead of 1", size_of(PxContactPairExtraDataType));
    }

    /**
    \brief Base class for items in the extra data stream of contact pairs

    @see PxContactPairHeader.extraDataStream
    */
    PxContactPairExtraDataItem :: struct {
        Constructor :: (this: *PxContactPairExtraDataItem) -> void #cpp_method #foreign physx_lib "??0PxContactPairExtraDataItem@physx@@QEAA@XZ";

        /**
        \brief The type of the extra data stream item
        */
        type: PxU8;
    }
    #run {if true then return;
        instance: PxContactPairExtraDataItem;
        assert(((cast(*void)(*instance.type)) - cast(*void)(*instance)) == 0, "PxContactPairExtraDataItem.type has unexpected offset % instead of 0", ((cast(*void)(*instance.type)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactPairExtraDataItem.type)) == 1, "PxContactPairExtraDataItem.type has unexpected size % instead of 1", size_of(type_of(PxContactPairExtraDataItem.type)));
        assert(size_of(PxContactPairExtraDataItem) == 1, "PxContactPairExtraDataItem has size % instead of 1", size_of(PxContactPairExtraDataItem));
    }

    /**
    \brief Velocities of the contact pair rigid bodies

    This struct is shared by multiple types of extra data items. The #type field allows to distinguish between them:
    \li PxContactPairExtraDataType::ePRE_SOLVER_VELOCITY: see #PxPairFlag::ePRE_SOLVER_VELOCITY
    \li PxContactPairExtraDataType::ePOST_SOLVER_VELOCITY: see #PxPairFlag::ePOST_SOLVER_VELOCITY

    \note For static rigid bodies, the velocities will be set to zero.

    @see PxContactPairHeader.extraDataStream
    */
    PxContactPairVelocity :: struct {
        #as using pxcontactpairextradataitem: PxContactPairExtraDataItem;

        Constructor :: (this: *PxContactPairVelocity) -> void #cpp_method #foreign physx_lib "??0PxContactPairVelocity@physx@@QEAA@XZ";

        /**
        \brief The linear velocity of the rigid bodies
        */
        linearVelocity:  [2] PxVec3;

        /**
        \brief The angular velocity of the rigid bodies
        */
        angularVelocity: [2] PxVec3;
    }
    #run {if true then return;
        assert(size_of(type_of(PxContactPairVelocity.pxcontactpairextradataitem)) == 1, "PxContactPairVelocity.pxcontactpairextradataitem has unexpected size % instead of 1", size_of(type_of(PxContactPairVelocity.pxcontactpairextradataitem)));
        instance: PxContactPairVelocity;
        assert(((cast(*void)(*instance.linearVelocity)) - cast(*void)(*instance)) == 4, "PxContactPairVelocity.linearVelocity has unexpected offset % instead of 4", ((cast(*void)(*instance.linearVelocity)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactPairVelocity.linearVelocity)) == 24, "PxContactPairVelocity.linearVelocity has unexpected size % instead of 24", size_of(type_of(PxContactPairVelocity.linearVelocity)));
        assert(((cast(*void)(*instance.angularVelocity)) - cast(*void)(*instance)) == 28, "PxContactPairVelocity.angularVelocity has unexpected offset % instead of 28", ((cast(*void)(*instance.angularVelocity)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactPairVelocity.angularVelocity)) == 24, "PxContactPairVelocity.angularVelocity has unexpected size % instead of 24", size_of(type_of(PxContactPairVelocity.angularVelocity)));
        assert(size_of(PxContactPairVelocity) == 52, "PxContactPairVelocity has size % instead of 52", size_of(PxContactPairVelocity));
    }

    /**
    \brief World space actor poses of the contact pair rigid bodies

    @see PxContactPairHeader.extraDataStream PxPairFlag::eCONTACT_EVENT_POSE
    */
    PxContactPairPose :: struct {
        #as using pxcontactpairextradataitem: PxContactPairExtraDataItem;

        Constructor :: (this: *PxContactPairPose) -> void #cpp_method #foreign physx_lib "??0PxContactPairPose@physx@@QEAA@XZ";

        /**
        \brief The world space pose of the rigid bodies
        */
        globalPose: [2] PxTransform;
    }
    #run {if true then return;
        assert(size_of(type_of(PxContactPairPose.pxcontactpairextradataitem)) == 1, "PxContactPairPose.pxcontactpairextradataitem has unexpected size % instead of 1", size_of(type_of(PxContactPairPose.pxcontactpairextradataitem)));
        instance: PxContactPairPose;
        assert(((cast(*void)(*instance.globalPose)) - cast(*void)(*instance)) == 4, "PxContactPairPose.globalPose has unexpected offset % instead of 4", ((cast(*void)(*instance.globalPose)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactPairPose.globalPose)) == 56, "PxContactPairPose.globalPose has unexpected size % instead of 56", size_of(type_of(PxContactPairPose.globalPose)));
        assert(size_of(PxContactPairPose) == 60, "PxContactPairPose has size % instead of 60", size_of(PxContactPairPose));
    }

    /**
    \brief Marker for the beginning of a new item set in the extra data stream.

    If CCD with multiple passes is enabled, then a fast moving object might bounce on and off the same
    object multiple times. Also, different shapes of the same actor might gain and lose contact with an other
    object over multiple passes. This marker allows to seperate the extra data items for each collision case, as well as
    distinguish the shape pair reports of different CCD passes.

    Example:
    Let us assume that an actor a0 with shapes s0_0 and s0_1 hits another actor a1 with shape s1.
    First s0_0 will hit s1, then a0 will slightly rotate and s0_1 will hit s1 while s0_0 will lose contact with s1.
    Furthermore, let us say that contact event pose information is requested as extra data.
    The extra data stream will look like this:

    PxContactPairIndexA | PxContactPairPoseA | PxContactPairIndexB | PxContactPairPoseB

    The corresponding array of PxContactPair events (see #PxSimulationEventCallback.onContact()) will look like this:

    PxContactPair(touch_found: s0_0, s1) | PxContactPair(touch_lost: s0_0, s1) | PxContactPair(touch_found: s0_1, s1)

    The #index of PxContactPairIndexA will point to the first entry in the PxContactPair array, for PxContactPairIndexB,
    #index will point to the third entry.

    @see PxContactPairHeader.extraDataStream
    */
    PxContactPairIndex :: struct {
        #as using pxcontactpairextradataitem: PxContactPairExtraDataItem;

        Constructor :: (this: *PxContactPairIndex) -> void #cpp_method #foreign physx_lib "??0PxContactPairIndex@physx@@QEAA@XZ";

        /**
        \brief The next item set in the extra data stream refers to the contact pairs starting at #index in the reported PxContactPair array.
        */
        index: PxU16;
    }
    #run {if true then return;
        assert(size_of(type_of(PxContactPairIndex.pxcontactpairextradataitem)) == 1, "PxContactPairIndex.pxcontactpairextradataitem has unexpected size % instead of 1", size_of(type_of(PxContactPairIndex.pxcontactpairextradataitem)));
        instance: PxContactPairIndex;
        assert(((cast(*void)(*instance.index)) - cast(*void)(*instance)) == 2, "PxContactPairIndex.index has unexpected offset % instead of 2", ((cast(*void)(*instance.index)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactPairIndex.index)) == 2, "PxContactPairIndex.index has unexpected size % instead of 2", size_of(type_of(PxContactPairIndex.index)));
        assert(size_of(PxContactPairIndex) == 4, "PxContactPairIndex has size % instead of 4", size_of(PxContactPairIndex));
    }

    /**
    \brief A class to iterate over a contact pair extra data stream.

    @see PxContactPairHeader.extraDataStream
    */
    PxContactPairExtraDataIterator :: struct {
        /**
        \brief Constructor
        \param[in] stream Pointer to the start of the stream.
        \param[in] size Size of the stream in bytes.
        */
        Constructor :: (this: *PxContactPairExtraDataIterator, stream: *PxU8, size: PxU32) -> void #cpp_method #foreign physx_lib "??0PxContactPairExtraDataIterator@physx@@QEAA@PEBEI@Z";

        /**
        \brief Advances the iterator to next set of extra data items.

        The contact pair extra data stream contains sets of items as requested by the corresponding #PxPairFlag flags
        #PxPairFlag::ePRE_SOLVER_VELOCITY, #PxPairFlag::ePOST_SOLVER_VELOCITY, #PxPairFlag::eCONTACT_EVENT_POSE. A set can contain one
        item of each plus the PxContactPairIndex item. This method parses the stream and points the iterator
        member variables to the corresponding items of the current set, if they are available. If CCD is not enabled,
        you should only get one set of items. If CCD with multiple passes is enabled, you might get more than one item
        set.

        \note Even though contact pair extra data is requested per shape pair, you will not get an item set per shape pair
        but one per actor pair. If, for example, an actor has two shapes and both collide with another actor, then
        there will only be one item set (since it applies to both shape pairs).

        \return True if there was another set of extra data items in the stream, else false.

        @see PxContactPairVelocity PxContactPairPose PxContactPairIndex
        */
        nextItemSet :: (this: *PxContactPairExtraDataIterator) -> bool #cpp_method #foreign physx_lib "?nextItemSet@PxContactPairExtraDataIterator@physx@@QEAA_NXZ";

        /**
        \brief Internal helper
        */
        clearDataPtrs :: (this: *PxContactPairExtraDataIterator) -> void #cpp_method #foreign physx_lib "?clearDataPtrs@PxContactPairExtraDataIterator@physx@@AEAAXXZ";

        /**
        \brief Current pointer in the stream.
        */
        currPtr:            *PxU8;

        /**
        \brief Pointer to the end of the stream.
        */
        endPtr:             *PxU8;

        /**
        \brief Pointer to the current pre solver velocity item in the stream. NULL if there is none.

        @see PxContactPairVelocity
        */
        preSolverVelocity:  *PxContactPairVelocity;

        /**
        \brief Pointer to the current post solver velocity item in the stream. NULL if there is none.

        @see PxContactPairVelocity
        */
        postSolverVelocity: *PxContactPairVelocity;

        /**
        \brief Pointer to the current contact event pose item in the stream. NULL if there is none.

        @see PxContactPairPose
        */
        eventPose:          *PxContactPairPose;

        /**
        \brief The contact pair index of the current item set in the stream.

        @see PxContactPairIndex
        */
        contactPairIndex:   PxU32;
    }
    #run {if true then return;
        instance: PxContactPairExtraDataIterator;
        assert(((cast(*void)(*instance.currPtr)) - cast(*void)(*instance)) == 0, "PxContactPairExtraDataIterator.currPtr has unexpected offset % instead of 0", ((cast(*void)(*instance.currPtr)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactPairExtraDataIterator.currPtr)) == 8, "PxContactPairExtraDataIterator.currPtr has unexpected size % instead of 8", size_of(type_of(PxContactPairExtraDataIterator.currPtr)));
        assert(((cast(*void)(*instance.endPtr)) - cast(*void)(*instance)) == 8, "PxContactPairExtraDataIterator.endPtr has unexpected offset % instead of 8", ((cast(*void)(*instance.endPtr)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactPairExtraDataIterator.endPtr)) == 8, "PxContactPairExtraDataIterator.endPtr has unexpected size % instead of 8", size_of(type_of(PxContactPairExtraDataIterator.endPtr)));
        assert(((cast(*void)(*instance.preSolverVelocity)) - cast(*void)(*instance)) == 16, "PxContactPairExtraDataIterator.preSolverVelocity has unexpected offset % instead of 16", ((cast(*void)(*instance.preSolverVelocity)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactPairExtraDataIterator.preSolverVelocity)) == 8, "PxContactPairExtraDataIterator.preSolverVelocity has unexpected size % instead of 8", size_of(type_of(PxContactPairExtraDataIterator.preSolverVelocity)));
        assert(((cast(*void)(*instance.postSolverVelocity)) - cast(*void)(*instance)) == 24, "PxContactPairExtraDataIterator.postSolverVelocity has unexpected offset % instead of 24", ((cast(*void)(*instance.postSolverVelocity)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactPairExtraDataIterator.postSolverVelocity)) == 8, "PxContactPairExtraDataIterator.postSolverVelocity has unexpected size % instead of 8", size_of(type_of(PxContactPairExtraDataIterator.postSolverVelocity)));
        assert(((cast(*void)(*instance.eventPose)) - cast(*void)(*instance)) == 32, "PxContactPairExtraDataIterator.eventPose has unexpected offset % instead of 32", ((cast(*void)(*instance.eventPose)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactPairExtraDataIterator.eventPose)) == 8, "PxContactPairExtraDataIterator.eventPose has unexpected size % instead of 8", size_of(type_of(PxContactPairExtraDataIterator.eventPose)));
        assert(((cast(*void)(*instance.contactPairIndex)) - cast(*void)(*instance)) == 40, "PxContactPairExtraDataIterator.contactPairIndex has unexpected offset % instead of 40", ((cast(*void)(*instance.contactPairIndex)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactPairExtraDataIterator.contactPairIndex)) == 4, "PxContactPairExtraDataIterator.contactPairIndex has unexpected size % instead of 4", size_of(type_of(PxContactPairExtraDataIterator.contactPairIndex)));
        assert(size_of(PxContactPairExtraDataIterator) == 48, "PxContactPairExtraDataIterator has size % instead of 48", size_of(PxContactPairExtraDataIterator));
    }

    /**
    \brief Collection of flags providing information on contact report pairs.

    @see PxContactPairHeader
    */
    PxContactPairHeaderFlag :: struct {
        Enum :: enum s32 {
            _0 :: 1;
            _1 :: 2;

            eREMOVED_ACTOR_0 :: _0;
            eREMOVED_ACTOR_1 :: _1;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxContactPairHeaderFlag) == 1, "PxContactPairHeaderFlag has size % instead of 1", size_of(PxContactPairHeaderFlag));
    }

    /**
    \brief Bitfield that contains a set of raised flags defined in PxContactPairHeaderFlag.

    @see PxContactPairHeaderFlag
    */
    PxContactPairHeaderFlags :: PxFlags(PxContactPairHeaderFlag.Enum, PxU16);

    /**
    \brief An Instance of this class is passed to PxSimulationEventCallback.onContact().

    @see PxSimulationEventCallback.onContact()
    */
    PxContactPairHeader :: struct {
        Constructor :: (this: *PxContactPairHeader) -> void #cpp_method #foreign physx_lib "??0PxContactPairHeader@physx@@QEAA@XZ";

        /**
        \brief The two actors of the notification shape pairs.

        \note The actor pointers might reference deleted actors. This will be the case if PxPairFlag::eNOTIFY_TOUCH_LOST
        or PxPairFlag::eNOTIFY_THRESHOLD_FORCE_LOST events were requested for the pair and one of the involved actors
        gets deleted or removed from the scene. Check the #flags member to see whether that is the case.
        Do not dereference a pointer to a deleted actor. The pointer to a deleted actor is only provided
        such that user data structures which might depend on the pointer value can be updated.

        @see PxActor
        */
        actors:              [2] *PxRigidActor;

        /**
        \brief Stream containing extra data as requested in the PxPairFlag flags of the simulation filter.

        This pointer is only valid if any kind of extra data information has been requested for the contact report pair (see #PxPairFlag::ePOST_SOLVER_VELOCITY etc.),
        else it will be NULL.

        @see PxPairFlag
        */
        extraDataStream:     *PxU8;

        /**
        \brief Size of the extra data stream [bytes]
        */
        extraDataStreamSize: PxU16;

        /**
        \brief Additional information on the contact report pair.

        @see PxContactPairHeaderFlag
        */
        flags:               PxContactPairHeaderFlags;

        /**
        \brief pointer to the contact pairs
        */
        pairs:               *PxContactPair;

        /**
        \brief number of contact pairs
        */
        nbPairs:             PxU32;
    }
    #run {if true then return;
        instance: PxContactPairHeader;
        assert(((cast(*void)(*instance.actors)) - cast(*void)(*instance)) == 0, "PxContactPairHeader.actors has unexpected offset % instead of 0", ((cast(*void)(*instance.actors)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactPairHeader.actors)) == 16, "PxContactPairHeader.actors has unexpected size % instead of 16", size_of(type_of(PxContactPairHeader.actors)));
        assert(((cast(*void)(*instance.extraDataStream)) - cast(*void)(*instance)) == 16, "PxContactPairHeader.extraDataStream has unexpected offset % instead of 16", ((cast(*void)(*instance.extraDataStream)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactPairHeader.extraDataStream)) == 8, "PxContactPairHeader.extraDataStream has unexpected size % instead of 8", size_of(type_of(PxContactPairHeader.extraDataStream)));
        assert(((cast(*void)(*instance.extraDataStreamSize)) - cast(*void)(*instance)) == 24, "PxContactPairHeader.extraDataStreamSize has unexpected offset % instead of 24", ((cast(*void)(*instance.extraDataStreamSize)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactPairHeader.extraDataStreamSize)) == 2, "PxContactPairHeader.extraDataStreamSize has unexpected size % instead of 2", size_of(type_of(PxContactPairHeader.extraDataStreamSize)));
        assert(((cast(*void)(*instance.flags)) - cast(*void)(*instance)) == 26, "PxContactPairHeader.flags has unexpected offset % instead of 26", ((cast(*void)(*instance.flags)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactPairHeader.flags)) == 2, "PxContactPairHeader.flags has unexpected size % instead of 2", size_of(type_of(PxContactPairHeader.flags)));
        assert(((cast(*void)(*instance.pairs)) - cast(*void)(*instance)) == 32, "PxContactPairHeader.pairs has unexpected offset % instead of 32", ((cast(*void)(*instance.pairs)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactPairHeader.pairs)) == 8, "PxContactPairHeader.pairs has unexpected size % instead of 8", size_of(type_of(PxContactPairHeader.pairs)));
        assert(((cast(*void)(*instance.nbPairs)) - cast(*void)(*instance)) == 40, "PxContactPairHeader.nbPairs has unexpected offset % instead of 40", ((cast(*void)(*instance.nbPairs)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactPairHeader.nbPairs)) == 4, "PxContactPairHeader.nbPairs has unexpected size % instead of 4", size_of(type_of(PxContactPairHeader.nbPairs)));
        assert(size_of(PxContactPairHeader) == 48, "PxContactPairHeader has size % instead of 48", size_of(PxContactPairHeader));
    }

    /**
    \brief Collection of flags providing information on contact report pairs.

    @see PxContactPair
    */
    PxContactPairFlag :: struct {
        Enum :: enum s32 {
            REMOVED_SHAPE_0               :: 1;

            REMOVED_SHAPE_1               :: 2;

            ACTOR_PAIR_HAS_FIRST_TOUCH    :: 4;

            ACTOR_PAIR_LOST_TOUCH         :: 8;

            INTERNAL_HAS_IMPULSES         :: 16;

            INTERNAL_CONTACTS_ARE_FLIPPED :: 32;

            eREMOVED_SHAPE_0               :: REMOVED_SHAPE_0;

            eREMOVED_SHAPE_1               :: REMOVED_SHAPE_1;

            eACTOR_PAIR_HAS_FIRST_TOUCH    :: ACTOR_PAIR_HAS_FIRST_TOUCH;

            eACTOR_PAIR_LOST_TOUCH         :: ACTOR_PAIR_LOST_TOUCH;

            eINTERNAL_HAS_IMPULSES         :: INTERNAL_HAS_IMPULSES;

            eINTERNAL_CONTACTS_ARE_FLIPPED :: INTERNAL_CONTACTS_ARE_FLIPPED;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxContactPairFlag) == 1, "PxContactPairFlag has size % instead of 1", size_of(PxContactPairFlag));
    }

    /**
    \brief Bitfield that contains a set of raised flags defined in PxContactPairFlag.

    @see PxContactPairFlag
    */
    PxContactPairFlags :: PxFlags(PxContactPairFlag.Enum, PxU16);

    /**
    \brief A contact point as used by contact notification
    */
    PxContactPairPoint :: struct {
        /**
        \brief The position of the contact point between the shapes, in world space.
        */
        position:           PxVec3;

        /**
        \brief The separation of the shapes at the contact point.  A negative separation denotes a penetration.
        */
        separation:         PxReal;

        /**
        \brief The normal of the contacting surfaces at the contact point. The normal direction points from the second shape to the first shape.
        */
        normal:             PxVec3;

        /**
        \brief The surface index of shape 0 at the contact point.  This is used to identify the surface material.
        */
        internalFaceIndex0: PxU32;

        /**
        \brief The impulse applied at the contact point, in world space. Divide by the simulation time step to get a force value.
        */
        impulse:            PxVec3;

        /**
        \brief The surface index of shape 1 at the contact point.  This is used to identify the surface material.
        */
        internalFaceIndex1: PxU32;
    }
    #run {if true then return;
        instance: PxContactPairPoint;
        assert(((cast(*void)(*instance.position)) - cast(*void)(*instance)) == 0, "PxContactPairPoint.position has unexpected offset % instead of 0", ((cast(*void)(*instance.position)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactPairPoint.position)) == 12, "PxContactPairPoint.position has unexpected size % instead of 12", size_of(type_of(PxContactPairPoint.position)));
        assert(((cast(*void)(*instance.separation)) - cast(*void)(*instance)) == 12, "PxContactPairPoint.separation has unexpected offset % instead of 12", ((cast(*void)(*instance.separation)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactPairPoint.separation)) == 4, "PxContactPairPoint.separation has unexpected size % instead of 4", size_of(type_of(PxContactPairPoint.separation)));
        assert(((cast(*void)(*instance.normal)) - cast(*void)(*instance)) == 16, "PxContactPairPoint.normal has unexpected offset % instead of 16", ((cast(*void)(*instance.normal)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactPairPoint.normal)) == 12, "PxContactPairPoint.normal has unexpected size % instead of 12", size_of(type_of(PxContactPairPoint.normal)));
        assert(((cast(*void)(*instance.internalFaceIndex0)) - cast(*void)(*instance)) == 28, "PxContactPairPoint.internalFaceIndex0 has unexpected offset % instead of 28", ((cast(*void)(*instance.internalFaceIndex0)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactPairPoint.internalFaceIndex0)) == 4, "PxContactPairPoint.internalFaceIndex0 has unexpected size % instead of 4", size_of(type_of(PxContactPairPoint.internalFaceIndex0)));
        assert(((cast(*void)(*instance.impulse)) - cast(*void)(*instance)) == 32, "PxContactPairPoint.impulse has unexpected offset % instead of 32", ((cast(*void)(*instance.impulse)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactPairPoint.impulse)) == 12, "PxContactPairPoint.impulse has unexpected size % instead of 12", size_of(type_of(PxContactPairPoint.impulse)));
        assert(((cast(*void)(*instance.internalFaceIndex1)) - cast(*void)(*instance)) == 44, "PxContactPairPoint.internalFaceIndex1 has unexpected offset % instead of 44", ((cast(*void)(*instance.internalFaceIndex1)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactPairPoint.internalFaceIndex1)) == 4, "PxContactPairPoint.internalFaceIndex1 has unexpected size % instead of 4", size_of(type_of(PxContactPairPoint.internalFaceIndex1)));
        assert(size_of(PxContactPairPoint) == 48, "PxContactPairPoint has size % instead of 48", size_of(PxContactPairPoint));
    }

    /**
    \brief Contact report pair information.

    Instances of this class are passed to PxSimulationEventCallback.onContact(). If contact reports have been requested for a pair of shapes (see #PxPairFlag),
    then the corresponding contact information will be provided through this structure.

    @see PxSimulationEventCallback.onContact()
    */
    PxContactPair :: struct {
        Constructor :: (this: *PxContactPair) -> void #cpp_method #foreign physx_lib "??0PxContactPair@physx@@QEAA@XZ";

        /**
        \brief The two shapes that make up the pair.

        \note The shape pointers might reference deleted shapes. This will be the case if #PxPairFlag::eNOTIFY_TOUCH_LOST
        or #PxPairFlag::eNOTIFY_THRESHOLD_FORCE_LOST events were requested for the pair and one of the involved shapes
        gets deleted. Check the #flags member to see whether that is the case. Do not dereference a pointer to a
        deleted shape. The pointer to a deleted shape is only provided such that user data structures which might
        depend on the pointer value can be updated.

        @see PxShape
        */
        shapes:             [2] *PxShape;

        /**
        \brief Pointer to first patch header in contact stream containing contact patch data

        This pointer is only valid if contact point information has been requested for the contact report pair (see #PxPairFlag::eNOTIFY_CONTACT_POINTS).
        Use #extractContacts() as a reference for the data layout of the stream.
        */
        contactPatches:     *PxU8;

        /**
        \brief Pointer to first contact point in contact stream containing contact data

        This pointer is only valid if contact point information has been requested for the contact report pair (see #PxPairFlag::eNOTIFY_CONTACT_POINTS).
        Use #extractContacts() as a reference for the data layout of the stream.
        */
        contactPoints:      *PxU8;

        /**
        \brief Buffer containing applied impulse data.

        This pointer is only valid if contact point information has been requested for the contact report pair (see #PxPairFlag::eNOTIFY_CONTACT_POINTS).
        Use #extractContacts() as a reference for the data layout of the stream.
        */
        contactImpulses:    *PxReal;

        /**
        \brief Size of the contact stream [bytes] including force buffer
        */
        requiredBufferSize: PxU32;

        /**
        \brief Number of contact points stored in the contact stream
        */
        contactCount:       PxU8;

        /**
        \brief Number of contact patches stored in the contact stream
        */
        patchCount:         PxU8;

        /**
        \brief Size of the contact stream [bytes] not including force buffer
        */
        contactStreamSize:  PxU16;

        /**
        \brief Additional information on the contact report pair.

        @see PxContactPairFlag
        */
        flags:              PxContactPairFlags;

        /**
        \brief Flags raised due to the contact.

        The events field is a combination of:

        <ul>
        <li>PxPairFlag::eNOTIFY_TOUCH_FOUND,</li>
        <li>PxPairFlag::eNOTIFY_TOUCH_PERSISTS,</li>
        <li>PxPairFlag::eNOTIFY_TOUCH_LOST,</li>
        <li>PxPairFlag::eNOTIFY_TOUCH_CCD,</li>
        <li>PxPairFlag::eNOTIFY_THRESHOLD_FORCE_FOUND,</li>
        <li>PxPairFlag::eNOTIFY_THRESHOLD_FORCE_PERSISTS,</li>
        <li>PxPairFlag::eNOTIFY_THRESHOLD_FORCE_LOST</li>
        </ul>

        See the documentation of #PxPairFlag for an explanation of each.

        \note eNOTIFY_TOUCH_CCD can get raised even if the pair did not request this event. However, in such a case it will only get
        raised in combination with one of the other flags to point out that the other event occured during a CCD pass.

        @see PxPairFlag
        */
        events:             PxPairFlags;

        internalData:       [2] PxU32; // For internal use only

        /**
        \brief Extracts the contact points from the stream and stores them in a convenient format.

        \param[out] userBuffer Array of PxContactPairPoint structures to extract the contact points to. The number of contacts for a pair is defined by #contactCount
        \param[in] bufferSize Number of PxContactPairPoint structures the provided buffer can store.
        \return Number of contact points written to the buffer.

        @see PxContactPairPoint
        */
        extractContacts :: (this: *PxContactPair, userBuffer: *PxContactPairPoint, bufferSize: PxU32) -> PxU32 #cpp_method #foreign physx_lib "?extractContacts@PxContactPair@physx@@QEBAIPEAUPxContactPairPoint@2@I@Z";

        /**
        \brief Helper method to clone the contact pair and copy the contact data stream into a user buffer.

        The contact data stream is only accessible during the contact report callback. This helper function provides copy functionality
        to buffer the contact stream information such that it can get accessed at a later stage.

        \param[out] newPair The contact pair info will get copied to this instance. The contact data stream pointer of the copy will be redirected to the provided user buffer. Use NULL to skip the contact pair copy operation.
        \param[out] bufferMemory Memory block to store the contact data stream to. At most #requiredBufferSize bytes will get written to the buffer.
        */
        bufferContacts :: (this: *PxContactPair, newPair: *PxContactPair, bufferMemory: *PxU8) -> void #cpp_method #foreign physx_lib "?bufferContacts@PxContactPair@physx@@QEBAXPEAU12@PEAE@Z";

        getInternalFaceIndices :: (this: *PxContactPair) -> *PxU32 #cpp_method #foreign physx_lib "?getInternalFaceIndices@PxContactPair@physx@@QEBAPEBIXZ";
    }
    #run {if true then return;
        instance: PxContactPair;
        assert(((cast(*void)(*instance.shapes)) - cast(*void)(*instance)) == 0, "PxContactPair.shapes has unexpected offset % instead of 0", ((cast(*void)(*instance.shapes)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactPair.shapes)) == 16, "PxContactPair.shapes has unexpected size % instead of 16", size_of(type_of(PxContactPair.shapes)));
        assert(((cast(*void)(*instance.contactPatches)) - cast(*void)(*instance)) == 16, "PxContactPair.contactPatches has unexpected offset % instead of 16", ((cast(*void)(*instance.contactPatches)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactPair.contactPatches)) == 8, "PxContactPair.contactPatches has unexpected size % instead of 8", size_of(type_of(PxContactPair.contactPatches)));
        assert(((cast(*void)(*instance.contactPoints)) - cast(*void)(*instance)) == 24, "PxContactPair.contactPoints has unexpected offset % instead of 24", ((cast(*void)(*instance.contactPoints)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactPair.contactPoints)) == 8, "PxContactPair.contactPoints has unexpected size % instead of 8", size_of(type_of(PxContactPair.contactPoints)));
        assert(((cast(*void)(*instance.contactImpulses)) - cast(*void)(*instance)) == 32, "PxContactPair.contactImpulses has unexpected offset % instead of 32", ((cast(*void)(*instance.contactImpulses)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactPair.contactImpulses)) == 8, "PxContactPair.contactImpulses has unexpected size % instead of 8", size_of(type_of(PxContactPair.contactImpulses)));
        assert(((cast(*void)(*instance.requiredBufferSize)) - cast(*void)(*instance)) == 40, "PxContactPair.requiredBufferSize has unexpected offset % instead of 40", ((cast(*void)(*instance.requiredBufferSize)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactPair.requiredBufferSize)) == 4, "PxContactPair.requiredBufferSize has unexpected size % instead of 4", size_of(type_of(PxContactPair.requiredBufferSize)));
        assert(((cast(*void)(*instance.contactCount)) - cast(*void)(*instance)) == 44, "PxContactPair.contactCount has unexpected offset % instead of 44", ((cast(*void)(*instance.contactCount)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactPair.contactCount)) == 1, "PxContactPair.contactCount has unexpected size % instead of 1", size_of(type_of(PxContactPair.contactCount)));
        assert(((cast(*void)(*instance.patchCount)) - cast(*void)(*instance)) == 45, "PxContactPair.patchCount has unexpected offset % instead of 45", ((cast(*void)(*instance.patchCount)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactPair.patchCount)) == 1, "PxContactPair.patchCount has unexpected size % instead of 1", size_of(type_of(PxContactPair.patchCount)));
        assert(((cast(*void)(*instance.contactStreamSize)) - cast(*void)(*instance)) == 46, "PxContactPair.contactStreamSize has unexpected offset % instead of 46", ((cast(*void)(*instance.contactStreamSize)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactPair.contactStreamSize)) == 2, "PxContactPair.contactStreamSize has unexpected size % instead of 2", size_of(type_of(PxContactPair.contactStreamSize)));
        assert(((cast(*void)(*instance.flags)) - cast(*void)(*instance)) == 48, "PxContactPair.flags has unexpected offset % instead of 48", ((cast(*void)(*instance.flags)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactPair.flags)) == 2, "PxContactPair.flags has unexpected size % instead of 2", size_of(type_of(PxContactPair.flags)));
        assert(((cast(*void)(*instance.events)) - cast(*void)(*instance)) == 50, "PxContactPair.events has unexpected offset % instead of 50", ((cast(*void)(*instance.events)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactPair.events)) == 2, "PxContactPair.events has unexpected size % instead of 2", size_of(type_of(PxContactPair.events)));
        assert(((cast(*void)(*instance.internalData)) - cast(*void)(*instance)) == 52, "PxContactPair.internalData has unexpected offset % instead of 52", ((cast(*void)(*instance.internalData)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxContactPair.internalData)) == 8, "PxContactPair.internalData has unexpected size % instead of 8", size_of(type_of(PxContactPair.internalData)));
        assert(size_of(PxContactPair) == 64, "PxContactPair has size % instead of 64", size_of(PxContactPair));
    }

    /**
    \brief Collection of flags providing information on trigger report pairs.

    @see PxTriggerPair
    */
    PxTriggerPairFlag :: struct {
        Enum :: enum s32 {
            REMOVED_SHAPE_TRIGGER :: 1;
            REMOVED_SHAPE_OTHER   :: 2;
            NEXT_FREE             :: 4;

            eREMOVED_SHAPE_TRIGGER :: REMOVED_SHAPE_TRIGGER;
            eREMOVED_SHAPE_OTHER   :: REMOVED_SHAPE_OTHER;
            eNEXT_FREE             :: NEXT_FREE;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxTriggerPairFlag) == 1, "PxTriggerPairFlag has size % instead of 1", size_of(PxTriggerPairFlag));
    }

    /**
    \brief Bitfield that contains a set of raised flags defined in PxTriggerPairFlag.

    @see PxTriggerPairFlag
    */
    PxTriggerPairFlags :: PxFlags(PxTriggerPairFlag.Enum, PxU8);

    /**
    \brief Descriptor for a trigger pair.

    An array of these structs gets passed to the PxSimulationEventCallback::onTrigger() report.

    \note The shape pointers might reference deleted shapes. This will be the case if #PxPairFlag::eNOTIFY_TOUCH_LOST
    events were requested for the pair and one of the involved shapes gets deleted. Check the #flags member to see
    whether that is the case. Do not dereference a pointer to a deleted shape. The pointer to a deleted shape is
    only provided such that user data structures which might depend on the pointer value can be updated.

    @see PxSimulationEventCallback.onTrigger()
    */
    PxTriggerPair :: struct {
        Constructor :: (this: *PxTriggerPair) -> void #cpp_method #foreign physx_lib "??0PxTriggerPair@physx@@QEAA@XZ";

        triggerShape: *PxShape; //!< The shape that has been marked as a trigger.
        triggerActor: *PxRigidActor; //!< The actor to which triggerShape is attached
        otherShape:   *PxShape; //!< The shape causing the trigger event. \deprecated (see #PxSimulationEventCallback::onTrigger()) If collision between trigger shapes is enabled, then this member might point to a trigger shape as well.
        otherActor:   *PxRigidActor; //!< The actor to which otherShape is attached
        status:       PxPairFlag.Enum; //!< Type of trigger event (eNOTIFY_TOUCH_FOUND or eNOTIFY_TOUCH_LOST). eNOTIFY_TOUCH_PERSISTS events are not supported.
        flags:        PxTriggerPairFlags; //!< Additional information on the pair (see #PxTriggerPairFlag)
    }
    #run {if true then return;
        instance: PxTriggerPair;
        assert(((cast(*void)(*instance.triggerShape)) - cast(*void)(*instance)) == 0, "PxTriggerPair.triggerShape has unexpected offset % instead of 0", ((cast(*void)(*instance.triggerShape)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTriggerPair.triggerShape)) == 8, "PxTriggerPair.triggerShape has unexpected size % instead of 8", size_of(type_of(PxTriggerPair.triggerShape)));
        assert(((cast(*void)(*instance.triggerActor)) - cast(*void)(*instance)) == 8, "PxTriggerPair.triggerActor has unexpected offset % instead of 8", ((cast(*void)(*instance.triggerActor)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTriggerPair.triggerActor)) == 8, "PxTriggerPair.triggerActor has unexpected size % instead of 8", size_of(type_of(PxTriggerPair.triggerActor)));
        assert(((cast(*void)(*instance.otherShape)) - cast(*void)(*instance)) == 16, "PxTriggerPair.otherShape has unexpected offset % instead of 16", ((cast(*void)(*instance.otherShape)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTriggerPair.otherShape)) == 8, "PxTriggerPair.otherShape has unexpected size % instead of 8", size_of(type_of(PxTriggerPair.otherShape)));
        assert(((cast(*void)(*instance.otherActor)) - cast(*void)(*instance)) == 24, "PxTriggerPair.otherActor has unexpected offset % instead of 24", ((cast(*void)(*instance.otherActor)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTriggerPair.otherActor)) == 8, "PxTriggerPair.otherActor has unexpected size % instead of 8", size_of(type_of(PxTriggerPair.otherActor)));
        assert(((cast(*void)(*instance.status)) - cast(*void)(*instance)) == 32, "PxTriggerPair.status has unexpected offset % instead of 32", ((cast(*void)(*instance.status)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTriggerPair.status)) == 4, "PxTriggerPair.status has unexpected size % instead of 4", size_of(type_of(PxTriggerPair.status)));
        assert(((cast(*void)(*instance.flags)) - cast(*void)(*instance)) == 36, "PxTriggerPair.flags has unexpected offset % instead of 36", ((cast(*void)(*instance.flags)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTriggerPair.flags)) == 1, "PxTriggerPair.flags has unexpected size % instead of 1", size_of(type_of(PxTriggerPair.flags)));
        assert(size_of(PxTriggerPair) == 40, "PxTriggerPair has size % instead of 40", size_of(PxTriggerPair));
    }

    /**
    \brief Descriptor for a broken constraint.

    An array of these structs gets passed to the PxSimulationEventCallback::onConstraintBreak() report.

    @see PxConstraint PxSimulationEventCallback.onConstraintBreak()
    */
    PxConstraintInfo :: struct {
        Constructor :: (this: *PxConstraintInfo) -> void #cpp_method #foreign physx_lib "??0PxConstraintInfo@physx@@QEAA@XZ";
        Constructor :: (this: *PxConstraintInfo, c: *PxConstraint, extRef: *void, t: PxU32) -> void #cpp_method #foreign physx_lib "??0PxConstraintInfo@physx@@QEAA@PEAVPxConstraint@1@PEAXI@Z";

        constraint:        *PxConstraint; //!< The broken constraint.
        externalReference: *void; //!< The external object which owns the constraint (see #PxConstraintConnector::getExternalReference())
        type:              PxU32; //!< Unique type ID of the external object. Allows to cast the provided external reference to the appropriate type
    }
    #run {if true then return;
        instance: PxConstraintInfo;
        assert(((cast(*void)(*instance.constraint)) - cast(*void)(*instance)) == 0, "PxConstraintInfo.constraint has unexpected offset % instead of 0", ((cast(*void)(*instance.constraint)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxConstraintInfo.constraint)) == 8, "PxConstraintInfo.constraint has unexpected size % instead of 8", size_of(type_of(PxConstraintInfo.constraint)));
        assert(((cast(*void)(*instance.externalReference)) - cast(*void)(*instance)) == 8, "PxConstraintInfo.externalReference has unexpected offset % instead of 8", ((cast(*void)(*instance.externalReference)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxConstraintInfo.externalReference)) == 8, "PxConstraintInfo.externalReference has unexpected size % instead of 8", size_of(type_of(PxConstraintInfo.externalReference)));
        assert(((cast(*void)(*instance.type)) - cast(*void)(*instance)) == 16, "PxConstraintInfo.type has unexpected offset % instead of 16", ((cast(*void)(*instance.type)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxConstraintInfo.type)) == 4, "PxConstraintInfo.type has unexpected size % instead of 4", size_of(type_of(PxConstraintInfo.type)));
        assert(size_of(PxConstraintInfo) == 24, "PxConstraintInfo has size % instead of 24", size_of(PxConstraintInfo));
    }

    /**
    \brief An interface class that the user can implement in order to receive simulation events.

    With the exception of onAdvance(), the events get sent during the call to either #PxScene::fetchResults() or
    #PxScene::flushSimulation() with sendPendingReports=true. onAdvance() gets called while the simulation
    is running (that is between PxScene::simulate(), onAdvance() and PxScene::fetchResults()).

    \note SDK state should not be modified from within the callbacks. In particular objects should not
    be created or destroyed. If state modification is needed then the changes should be stored to a buffer
    and performed after the simulation step.

    <b>Threading:</b> With the exception of onAdvance(), it is not necessary to make these callbacks thread safe as
    they will only be called in the context of the user thread.

    @see PxScene.setSimulationEventCallback() PxScene.getSimulationEventCallback()
    */
    PxSimulationEventCallback :: struct {
        vtable: *PxSimulationEventCallback_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.
        virtual_Destructor :: (this: *PxSimulationEventCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_lib "??1PxSimulationEventCallback@physx@@UEAA@XZ";
    }
    PxSimulationEventCallback_VTable :: struct #type_info_none {
        onConstraintBreak: (this: *PxSimulationEventCallback, constraints: *PxConstraintInfo, count: PxU32) -> void #cpp_method;

        onWake: (this: *PxSimulationEventCallback, actors: **PxActor, count: PxU32) -> void #cpp_method;

        onSleep: (this: *PxSimulationEventCallback, actors: **PxActor, count: PxU32) -> void #cpp_method;

        onContact: (this: *PxSimulationEventCallback, pairHeader: *PxContactPairHeader, pairs: *PxContactPair, nbPairs: PxU32) -> void #cpp_method;

        onTrigger: (this: *PxSimulationEventCallback, pairs: *PxTriggerPair, count: PxU32) -> void #cpp_method;

        onAdvance: (this: *PxSimulationEventCallback, bodyBuffer: **PxRigidBody, poseBuffer: *PxTransform, count: PxU32) -> void #cpp_method;

        Destructor: (this: *PxSimulationEventCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxSimulationEventCallback_onConstraintBreak :: inline (this: *PxSimulationEventCallback, constraints: *PxConstraintInfo, count: PxU32) { this.vtable.onConstraintBreak(this, constraints, count); }

    PxSimulationEventCallback_onWake :: inline (this: *PxSimulationEventCallback, actors: **PxActor, count: PxU32) { this.vtable.onWake(this, actors, count); }

    PxSimulationEventCallback_onSleep :: inline (this: *PxSimulationEventCallback, actors: **PxActor, count: PxU32) { this.vtable.onSleep(this, actors, count); }

    PxSimulationEventCallback_onContact :: inline (this: *PxSimulationEventCallback, pairHeader: *PxContactPairHeader, pairs: *PxContactPair, nbPairs: PxU32) { this.vtable.onContact(this, pairHeader, pairs, nbPairs); }

    PxSimulationEventCallback_onTrigger :: inline (this: *PxSimulationEventCallback, pairs: *PxTriggerPair, count: PxU32) { this.vtable.onTrigger(this, pairs, count); }

    PxSimulationEventCallback_onAdvance :: inline (this: *PxSimulationEventCallback, bodyBuffer: **PxRigidBody, poseBuffer: *PxTransform, count: PxU32) { this.vtable.onAdvance(this, bodyBuffer, poseBuffer, count); }

    PxSimulationEventCallback_Destructor :: inline (this: *PxSimulationEventCallback, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxSimulationEventCallback) -> *PxSimulationEventCallback_VTable { return obj.vtable; }

    #run {if true then return;
        assert(size_of(PxSimulationEventCallback) == 8, "PxSimulationEventCallback has size % instead of 8", size_of(PxSimulationEventCallback));
    }

    /**
    \brief A precomputed pruning structure to accelerate scene queries against newly added actors.

    The pruning structure can be provided to #PxScene:: addActors() in which case it will get merged
    directly into the scene query optimization AABB tree, thus leading to improved performance when
    doing queries against the newly added actors. This applies to both static and dynamic actors.

    \note PxPruningStructure objects can be added to a collection and get serialized.
    \note Adding a PxPruningStructure object to a collection will also add the actors that were used to build the pruning structure.

    \note PxPruningStructure must be released before its rigid actors.
    \note PxRigidBody objects can be in one PxPruningStructure only.
    \note Changing the bounds of PxRigidBody objects assigned to a pruning structure that has not been added to a scene yet will
    invalidate the pruning structure. Same happens if shape scene query flags change or shape gets removed from an actor.

    @see PxScene::addActors PxCollection
    */
    PxPruningStructure :: struct {
        #as using pxbase: PxBase;
        #place pxbase; pxpruningstructure_vtable: *PxPruningStructure_VTable;
    }
    PxPruningStructure_VTable :: struct #type_info_none {
        using pxbase: PxBase_VTable;
        getRigidActors: (this: *PxPruningStructure, userBuffer: **PxRigidActor, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        getNbRigidActors: (this: *PxPruningStructure) -> PxU32 #cpp_method;
    }

    PxPruningStructure_getRigidActors :: inline (this: *PxPruningStructure, userBuffer: **PxRigidActor, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.pxpruningstructure_vtable.getRigidActors(this, userBuffer, bufferSize, startIndex); }

    PxPruningStructure_getNbRigidActors :: inline (this: *PxPruningStructure) -> PxU32 { return this.pxpruningstructure_vtable.getNbRigidActors(this); }

    vtable :: (obj: *PxPruningStructure) -> *PxPruningStructure_VTable { return obj.pxpruningstructure_vtable; }

    #run {if true then return;
        assert(size_of(type_of(PxPruningStructure.pxbase)) == 16, "PxPruningStructure.pxbase has unexpected size % instead of 16", size_of(type_of(PxPruningStructure.pxbase)));
        assert(size_of(PxPruningStructure) == 16, "PxPruningStructure has size % instead of 16", size_of(PxPruningStructure));
    }

    PxExtended :: float64;

    PxExtendedVec3 :: struct {
        Constructor :: (this: *PxExtendedVec3) -> void #cpp_method #foreign physx_lib "??0PxExtendedVec3@physx@@QEAA@XZ";
        Constructor :: (this: *PxExtendedVec3, _x: PxExtended, _y: PxExtended, _z: PxExtended) -> void #cpp_method #foreign physx_lib "??0PxExtendedVec3@physx@@QEAA@NNN@Z";

        isZero :: (this: *PxExtendedVec3) -> bool #cpp_method #foreign physx_lib "?isZero@PxExtendedVec3@physx@@QEBA_NXZ";

        dot :: (this: *PxExtendedVec3, v: *PxVec3) -> PxExtended #cpp_method #foreign physx_lib "?dot@PxExtendedVec3@physx@@QEBANAEBVPxVec3@2@@Z";
        dot :: (this: *PxExtendedVec3, v: PxVec3) -> PxExtended #no_context {
            return dot(this, *v);
        }

        distanceSquared :: (this: *PxExtendedVec3, v: *PxExtendedVec3) -> PxExtended #cpp_method #foreign physx_lib "?distanceSquared@PxExtendedVec3@physx@@QEBANAEBU12@@Z";
        distanceSquared :: (this: *PxExtendedVec3, v: PxExtendedVec3) -> PxExtended #no_context {
            return distanceSquared(this, *v);
        }

        magnitudeSquared :: (this: *PxExtendedVec3) -> PxExtended #cpp_method #foreign physx_lib "?magnitudeSquared@PxExtendedVec3@physx@@QEBANXZ";

        magnitude :: (this: *PxExtendedVec3) -> PxExtended #cpp_method #foreign physx_lib "?magnitude@PxExtendedVec3@physx@@QEBANXZ";

        normalize :: (this: *PxExtendedVec3) -> PxExtended #cpp_method #foreign physx_lib "?normalize@PxExtendedVec3@physx@@QEAANXZ";

        isFinite :: (this: *PxExtendedVec3) -> bool #cpp_method #foreign physx_lib "?isFinite@PxExtendedVec3@physx@@QEBA_NXZ";

        maximum :: (this: *PxExtendedVec3, v: *PxExtendedVec3) -> void #cpp_method #foreign physx_lib "?maximum@PxExtendedVec3@physx@@QEAAXAEBU12@@Z";
        maximum :: (this: *PxExtendedVec3, v: PxExtendedVec3) #no_context {
            maximum(this, *v);
        }

        minimum :: (this: *PxExtendedVec3, v: *PxExtendedVec3) -> void #cpp_method #foreign physx_lib "?minimum@PxExtendedVec3@physx@@QEAAXAEBU12@@Z";
        minimum :: (this: *PxExtendedVec3, v: PxExtendedVec3) #no_context {
            minimum(this, *v);
        }

        set :: (this: *PxExtendedVec3, x_: PxExtended, y_: PxExtended, z_: PxExtended) -> void #cpp_method #foreign physx_lib "?set@PxExtendedVec3@physx@@QEAAXNNN@Z";

        setPlusInfinity :: (this: *PxExtendedVec3) -> void #cpp_method #foreign physx_lib "?setPlusInfinity@PxExtendedVec3@physx@@QEAAXXZ";

        setMinusInfinity :: (this: *PxExtendedVec3) -> void #cpp_method #foreign physx_lib "?setMinusInfinity@PxExtendedVec3@physx@@QEAAXXZ";

        cross :: (this: *PxExtendedVec3, left: *PxExtendedVec3, right: *PxVec3) -> void #cpp_method #foreign physx_lib "?cross@PxExtendedVec3@physx@@QEAAXAEBU12@AEBVPxVec3@2@@Z";
        cross :: (this: *PxExtendedVec3, left: PxExtendedVec3, right: PxVec3) #no_context {
            cross(this, *left, *right);
        }

        cross :: (this: *PxExtendedVec3, left: *PxExtendedVec3, right: *PxExtendedVec3) -> void #cpp_method #foreign physx_lib "?cross@PxExtendedVec3@physx@@QEAAXAEBU12@0@Z";
        cross :: (this: *PxExtendedVec3, left: PxExtendedVec3, right: PxExtendedVec3) #no_context {
            cross(this, *left, *right);
        }

        cross :: (this: *PxExtendedVec3, v: *PxExtendedVec3) -> PxExtendedVec3 #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "?cross@PxExtendedVec3@physx@@QEBA?AU12@AEBU12@@Z";
        cross :: (this: *PxExtendedVec3, v: PxExtendedVec3) -> PxExtendedVec3 #no_context {
            return cross(this, *v);
        }

        cross :: (this: *PxExtendedVec3, left: *PxVec3, right: *PxExtendedVec3) -> void #cpp_method #foreign physx_lib "?cross@PxExtendedVec3@physx@@QEAAXAEBVPxVec3@2@AEBU12@@Z";
        cross :: (this: *PxExtendedVec3, left: PxVec3, right: PxExtendedVec3) #no_context {
            cross(this, *left, *right);
        }

        x: PxExtended;
        y: PxExtended;
        z: PxExtended;
    }
    #run {if true then return;
        instance: PxExtendedVec3;
        assert(((cast(*void)(*instance.x)) - cast(*void)(*instance)) == 0, "PxExtendedVec3.x has unexpected offset % instead of 0", ((cast(*void)(*instance.x)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxExtendedVec3.x)) == 8, "PxExtendedVec3.x has unexpected size % instead of 8", size_of(type_of(PxExtendedVec3.x)));
        assert(((cast(*void)(*instance.y)) - cast(*void)(*instance)) == 8, "PxExtendedVec3.y has unexpected offset % instead of 8", ((cast(*void)(*instance.y)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxExtendedVec3.y)) == 8, "PxExtendedVec3.y has unexpected size % instead of 8", size_of(type_of(PxExtendedVec3.y)));
        assert(((cast(*void)(*instance.z)) - cast(*void)(*instance)) == 16, "PxExtendedVec3.z has unexpected offset % instead of 16", ((cast(*void)(*instance.z)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxExtendedVec3.z)) == 8, "PxExtendedVec3.z has unexpected size % instead of 8", size_of(type_of(PxExtendedVec3.z)));
        assert(size_of(PxExtendedVec3) == 24, "PxExtendedVec3 has size % instead of 24", size_of(PxExtendedVec3));
    }

    toVec3 :: (v: *PxExtendedVec3) -> PxVec3 #cpp_return_type_is_non_pod #foreign physx_lib "?toVec3@physx@@YA?AVPxVec3@1@AEBUPxExtendedVec3@1@@Z";
    toVec3 :: (v: PxExtendedVec3) -> PxVec3 #no_context {
        return toVec3(*v);
    }

    /**
    \brief Base class for obstacles.

    @see PxBoxObstacle PxCapsuleObstacle PxObstacleContext
    */
    PxObstacle :: struct {
        Constructor :: (this: *PxObstacle) -> void #cpp_method #foreign physx_lib "??0PxObstacle@physx@@IEAA@XZ";

        mType:     PxGeometryType.Enum;

        getType :: (this: *PxObstacle) -> PxGeometryType.Enum #cpp_method #foreign physx_lib "?getType@PxObstacle@physx@@QEBA?AW4Enum@PxGeometryType@2@XZ";

        mUserData: *void;
        mPos:      PxExtendedVec3;
        mRot:      PxQuat;
    }
    #run {if true then return;
        instance: PxObstacle;
        assert(((cast(*void)(*instance.mType)) - cast(*void)(*instance)) == 0, "PxObstacle.mType has unexpected offset % instead of 0", ((cast(*void)(*instance.mType)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxObstacle.mType)) == 4, "PxObstacle.mType has unexpected size % instead of 4", size_of(type_of(PxObstacle.mType)));
        assert(((cast(*void)(*instance.mUserData)) - cast(*void)(*instance)) == 8, "PxObstacle.mUserData has unexpected offset % instead of 8", ((cast(*void)(*instance.mUserData)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxObstacle.mUserData)) == 8, "PxObstacle.mUserData has unexpected size % instead of 8", size_of(type_of(PxObstacle.mUserData)));
        assert(((cast(*void)(*instance.mPos)) - cast(*void)(*instance)) == 16, "PxObstacle.mPos has unexpected offset % instead of 16", ((cast(*void)(*instance.mPos)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxObstacle.mPos)) == 24, "PxObstacle.mPos has unexpected size % instead of 24", size_of(type_of(PxObstacle.mPos)));
        assert(((cast(*void)(*instance.mRot)) - cast(*void)(*instance)) == 40, "PxObstacle.mRot has unexpected offset % instead of 40", ((cast(*void)(*instance.mRot)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxObstacle.mRot)) == 16, "PxObstacle.mRot has unexpected size % instead of 16", size_of(type_of(PxObstacle.mRot)));
        assert(size_of(PxObstacle) == 56, "PxObstacle has size % instead of 56", size_of(PxObstacle));
    }

    /**
    \brief A box obstacle.

    @see PxObstacle PxCapsuleObstacle PxObstacleContext
    */
    PxBoxObstacle :: struct {
        #as using pxobstacle: PxObstacle;

        Constructor :: (this: *PxBoxObstacle) -> void #cpp_method #foreign physx_lib "??0PxBoxObstacle@physx@@QEAA@XZ";

        mHalfExtents: PxVec3;
    }
    #run {if true then return;
        assert(size_of(type_of(PxBoxObstacle.pxobstacle)) == 56, "PxBoxObstacle.pxobstacle has unexpected size % instead of 56", size_of(type_of(PxBoxObstacle.pxobstacle)));
        instance: PxBoxObstacle;
        assert(((cast(*void)(*instance.mHalfExtents)) - cast(*void)(*instance)) == 56, "PxBoxObstacle.mHalfExtents has unexpected offset % instead of 56", ((cast(*void)(*instance.mHalfExtents)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxBoxObstacle.mHalfExtents)) == 12, "PxBoxObstacle.mHalfExtents has unexpected size % instead of 12", size_of(type_of(PxBoxObstacle.mHalfExtents)));
        assert(size_of(PxBoxObstacle) == 72, "PxBoxObstacle has size % instead of 72", size_of(PxBoxObstacle));
    }

    /**
    \brief A capsule obstacle.

    @see PxBoxObstacle PxObstacle PxObstacleContext
    */
    PxCapsuleObstacle :: struct {
        #as using pxobstacle: PxObstacle;

        Constructor :: (this: *PxCapsuleObstacle) -> void #cpp_method #foreign physx_lib "??0PxCapsuleObstacle@physx@@QEAA@XZ";

        mHalfHeight: PxReal;
        mRadius:     PxReal;
    }
    #run {if true then return;
        assert(size_of(type_of(PxCapsuleObstacle.pxobstacle)) == 56, "PxCapsuleObstacle.pxobstacle has unexpected size % instead of 56", size_of(type_of(PxCapsuleObstacle.pxobstacle)));
        instance: PxCapsuleObstacle;
        assert(((cast(*void)(*instance.mHalfHeight)) - cast(*void)(*instance)) == 56, "PxCapsuleObstacle.mHalfHeight has unexpected offset % instead of 56", ((cast(*void)(*instance.mHalfHeight)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxCapsuleObstacle.mHalfHeight)) == 4, "PxCapsuleObstacle.mHalfHeight has unexpected size % instead of 4", size_of(type_of(PxCapsuleObstacle.mHalfHeight)));
        assert(((cast(*void)(*instance.mRadius)) - cast(*void)(*instance)) == 60, "PxCapsuleObstacle.mRadius has unexpected offset % instead of 60", ((cast(*void)(*instance.mRadius)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxCapsuleObstacle.mRadius)) == 4, "PxCapsuleObstacle.mRadius has unexpected size % instead of 4", size_of(type_of(PxCapsuleObstacle.mRadius)));
        assert(size_of(PxCapsuleObstacle) == 64, "PxCapsuleObstacle has size % instead of 64", size_of(PxCapsuleObstacle));
    }

    ObstacleHandle :: PxU32;

    /**
    \brief Context class for obstacles.

    An obstacle context class contains and manages a set of user-defined obstacles.

    @see PxBoxObstacle PxCapsuleObstacle PxObstacle
    */
    PxObstacleContext :: struct {
        vtable: *PxObstacleContext_VTable;
    }
    PxObstacleContext_VTable :: struct #type_info_none {
        Destructor: (this: *PxObstacleContext, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

        release: (this: *PxObstacleContext) -> void #cpp_method;

        getControllerManager: (this: *PxObstacleContext) -> *PxControllerManager #cpp_method;

        addObstacle: (this: *PxObstacleContext, obstacle: *PxObstacle) -> ObstacleHandle #cpp_method;

        removeObstacle: (this: *PxObstacleContext, handle: ObstacleHandle) -> bool #cpp_method;

        updateObstacle: (this: *PxObstacleContext, handle: ObstacleHandle, obstacle: *PxObstacle) -> bool #cpp_method;

        getNbObstacles: (this: *PxObstacleContext) -> PxU32 #cpp_method;

        getObstacle: (this: *PxObstacleContext, i: PxU32) -> *PxObstacle #cpp_method;

        getObstacleByHandle: (this: *PxObstacleContext, handle: ObstacleHandle) -> *PxObstacle #cpp_method;
    }

    PxObstacleContext_Destructor :: inline (this: *PxObstacleContext, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    PxObstacleContext_release :: inline (this: *PxObstacleContext) { this.vtable.release(this); }

    PxObstacleContext_getControllerManager :: inline (this: *PxObstacleContext) -> *PxControllerManager { return this.vtable.getControllerManager(this); }

    PxObstacleContext_addObstacle :: inline (this: *PxObstacleContext, obstacle: *PxObstacle) -> ObstacleHandle { return this.vtable.addObstacle(this, obstacle); }

    PxObstacleContext_removeObstacle :: inline (this: *PxObstacleContext, handle: ObstacleHandle) -> bool { return this.vtable.removeObstacle(this, handle); }

    PxObstacleContext_updateObstacle :: inline (this: *PxObstacleContext, handle: ObstacleHandle, obstacle: *PxObstacle) -> bool { return this.vtable.updateObstacle(this, handle, obstacle); }

    PxObstacleContext_getNbObstacles :: inline (this: *PxObstacleContext) -> PxU32 { return this.vtable.getNbObstacles(this); }

    PxObstacleContext_getObstacle :: inline (this: *PxObstacleContext, i: PxU32) -> *PxObstacle { return this.vtable.getObstacle(this, i); }

    PxObstacleContext_getObstacleByHandle :: inline (this: *PxObstacleContext, handle: ObstacleHandle) -> *PxObstacle { return this.vtable.getObstacleByHandle(this, handle); }

    vtable :: (obj: *PxObstacleContext) -> *PxObstacleContext_VTable { return obj.vtable; }

    #run {if true then return;
        assert(size_of(PxObstacleContext) == 8, "PxObstacleContext has size % instead of 8", size_of(PxObstacleContext));
    }

    /**
    \brief The type of controller, eg box, sphere or capsule.
    */
    PxControllerShapeType :: struct {
        Enum :: enum s32 {
            BOX         :: 0;

            CAPSULE     :: 1;

            FORCE_DWORD :: 2147483647;

            eBOX         :: BOX;

            eCAPSULE     :: CAPSULE;

            eFORCE_DWORD :: FORCE_DWORD;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxControllerShapeType) == 1, "PxControllerShapeType has size % instead of 1", size_of(PxControllerShapeType));
    }

    /**
    \brief specifies how a CCT interacts with non-walkable parts.

    This is only used when slopeLimit is non zero. It is currently enabled for static actors only, and not supported for spheres or capsules.
    */
    PxControllerNonWalkableMode :: struct {
        Enum :: enum s32 {
            CLIMBING                   :: 0;
            CLIMBING_AND_FORCE_SLIDING :: 1;

            ePREVENT_CLIMBING                   :: CLIMBING;
            ePREVENT_CLIMBING_AND_FORCE_SLIDING :: CLIMBING_AND_FORCE_SLIDING;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxControllerNonWalkableMode) == 1, "PxControllerNonWalkableMode has size % instead of 1", size_of(PxControllerNonWalkableMode));
    }

    /**
    \brief specifies which sides a character is colliding with.
    */
    PxControllerCollisionFlag :: struct {
        Enum :: enum s32 {
            SIDES :: 1;
            UP    :: 2;
            DOWN  :: 4;

            eCOLLISION_SIDES :: SIDES;
            eCOLLISION_UP    :: UP;
            eCOLLISION_DOWN  :: DOWN;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxControllerCollisionFlag) == 1, "PxControllerCollisionFlag has size % instead of 1", size_of(PxControllerCollisionFlag));
    }

    /**
    \brief Bitfield that contains a set of raised flags defined in PxControllerCollisionFlag.

    @see PxControllerCollisionFlag
    */
    PxControllerCollisionFlags :: PxFlags(PxControllerCollisionFlag.Enum, PxU8);

    /**
    \brief Describes a controller's internal state.
    */
    PxControllerState :: struct {
        deltaXP:               PxVec3; //!< delta position vector for the object the CCT is standing/riding on. Not always match the CCT delta when variable timesteps are used.
        touchedShape:          *PxShape; //!< Shape on which the CCT is standing
        touchedActor:          *PxRigidActor; //!< Actor owning 'touchedShape'
        touchedObstacleHandle: ObstacleHandle; // Obstacle on which the CCT is standing
        collisionFlags:        PxU32; //!< Last known collision flags (PxControllerCollisionFlag)
        standOnAnotherCCT:     bool; //!< Are we standing on another CCT?
        standOnObstacle:       bool; //!< Are we standing on a user-defined obstacle?
        isMovingUp:            bool; //!< is CCT moving up or not? (i.e. explicit jumping)
    }
    #run {if true then return;
        instance: PxControllerState;
        assert(((cast(*void)(*instance.deltaXP)) - cast(*void)(*instance)) == 0, "PxControllerState.deltaXP has unexpected offset % instead of 0", ((cast(*void)(*instance.deltaXP)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxControllerState.deltaXP)) == 12, "PxControllerState.deltaXP has unexpected size % instead of 12", size_of(type_of(PxControllerState.deltaXP)));
        assert(((cast(*void)(*instance.touchedShape)) - cast(*void)(*instance)) == 16, "PxControllerState.touchedShape has unexpected offset % instead of 16", ((cast(*void)(*instance.touchedShape)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxControllerState.touchedShape)) == 8, "PxControllerState.touchedShape has unexpected size % instead of 8", size_of(type_of(PxControllerState.touchedShape)));
        assert(((cast(*void)(*instance.touchedActor)) - cast(*void)(*instance)) == 24, "PxControllerState.touchedActor has unexpected offset % instead of 24", ((cast(*void)(*instance.touchedActor)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxControllerState.touchedActor)) == 8, "PxControllerState.touchedActor has unexpected size % instead of 8", size_of(type_of(PxControllerState.touchedActor)));
        assert(((cast(*void)(*instance.touchedObstacleHandle)) - cast(*void)(*instance)) == 32, "PxControllerState.touchedObstacleHandle has unexpected offset % instead of 32", ((cast(*void)(*instance.touchedObstacleHandle)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxControllerState.touchedObstacleHandle)) == 4, "PxControllerState.touchedObstacleHandle has unexpected size % instead of 4", size_of(type_of(PxControllerState.touchedObstacleHandle)));
        assert(((cast(*void)(*instance.collisionFlags)) - cast(*void)(*instance)) == 36, "PxControllerState.collisionFlags has unexpected offset % instead of 36", ((cast(*void)(*instance.collisionFlags)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxControllerState.collisionFlags)) == 4, "PxControllerState.collisionFlags has unexpected size % instead of 4", size_of(type_of(PxControllerState.collisionFlags)));
        assert(((cast(*void)(*instance.standOnAnotherCCT)) - cast(*void)(*instance)) == 40, "PxControllerState.standOnAnotherCCT has unexpected offset % instead of 40", ((cast(*void)(*instance.standOnAnotherCCT)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxControllerState.standOnAnotherCCT)) == 1, "PxControllerState.standOnAnotherCCT has unexpected size % instead of 1", size_of(type_of(PxControllerState.standOnAnotherCCT)));
        assert(((cast(*void)(*instance.standOnObstacle)) - cast(*void)(*instance)) == 41, "PxControllerState.standOnObstacle has unexpected offset % instead of 41", ((cast(*void)(*instance.standOnObstacle)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxControllerState.standOnObstacle)) == 1, "PxControllerState.standOnObstacle has unexpected size % instead of 1", size_of(type_of(PxControllerState.standOnObstacle)));
        assert(((cast(*void)(*instance.isMovingUp)) - cast(*void)(*instance)) == 42, "PxControllerState.isMovingUp has unexpected offset % instead of 42", ((cast(*void)(*instance.isMovingUp)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxControllerState.isMovingUp)) == 1, "PxControllerState.isMovingUp has unexpected size % instead of 1", size_of(type_of(PxControllerState.isMovingUp)));
        assert(size_of(PxControllerState) == 48, "PxControllerState has size % instead of 48", size_of(PxControllerState));
    }

    /**
    \brief Describes a controller's internal statistics.
    */
    PxControllerStats :: struct {
        nbIterations:     PxU16;
        nbFullUpdates:    PxU16;
        nbPartialUpdates: PxU16;
        nbTessellation:   PxU16;
    }
    #run {if true then return;
        instance: PxControllerStats;
        assert(((cast(*void)(*instance.nbIterations)) - cast(*void)(*instance)) == 0, "PxControllerStats.nbIterations has unexpected offset % instead of 0", ((cast(*void)(*instance.nbIterations)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxControllerStats.nbIterations)) == 2, "PxControllerStats.nbIterations has unexpected size % instead of 2", size_of(type_of(PxControllerStats.nbIterations)));
        assert(((cast(*void)(*instance.nbFullUpdates)) - cast(*void)(*instance)) == 2, "PxControllerStats.nbFullUpdates has unexpected offset % instead of 2", ((cast(*void)(*instance.nbFullUpdates)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxControllerStats.nbFullUpdates)) == 2, "PxControllerStats.nbFullUpdates has unexpected size % instead of 2", size_of(type_of(PxControllerStats.nbFullUpdates)));
        assert(((cast(*void)(*instance.nbPartialUpdates)) - cast(*void)(*instance)) == 4, "PxControllerStats.nbPartialUpdates has unexpected offset % instead of 4", ((cast(*void)(*instance.nbPartialUpdates)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxControllerStats.nbPartialUpdates)) == 2, "PxControllerStats.nbPartialUpdates has unexpected size % instead of 2", size_of(type_of(PxControllerStats.nbPartialUpdates)));
        assert(((cast(*void)(*instance.nbTessellation)) - cast(*void)(*instance)) == 6, "PxControllerStats.nbTessellation has unexpected offset % instead of 6", ((cast(*void)(*instance.nbTessellation)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxControllerStats.nbTessellation)) == 2, "PxControllerStats.nbTessellation has unexpected size % instead of 2", size_of(type_of(PxControllerStats.nbTessellation)));
        assert(size_of(PxControllerStats) == 8, "PxControllerStats has size % instead of 8", size_of(PxControllerStats));
    }

    /**
    \brief Describes a generic CCT hit.
    */
    PxControllerHit :: struct {
        controller:  *PxController; //!< Current controller
        worldPos:    PxExtendedVec3; //!< Contact position in world space
        worldNormal: PxVec3; //!< Contact normal in world space
        dir:         PxVec3; //!< Motion direction
        length:      PxF32; //!< Motion length
    }
    #run {if true then return;
        instance: PxControllerHit;
        assert(((cast(*void)(*instance.controller)) - cast(*void)(*instance)) == 0, "PxControllerHit.controller has unexpected offset % instead of 0", ((cast(*void)(*instance.controller)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxControllerHit.controller)) == 8, "PxControllerHit.controller has unexpected size % instead of 8", size_of(type_of(PxControllerHit.controller)));
        assert(((cast(*void)(*instance.worldPos)) - cast(*void)(*instance)) == 8, "PxControllerHit.worldPos has unexpected offset % instead of 8", ((cast(*void)(*instance.worldPos)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxControllerHit.worldPos)) == 24, "PxControllerHit.worldPos has unexpected size % instead of 24", size_of(type_of(PxControllerHit.worldPos)));
        assert(((cast(*void)(*instance.worldNormal)) - cast(*void)(*instance)) == 32, "PxControllerHit.worldNormal has unexpected offset % instead of 32", ((cast(*void)(*instance.worldNormal)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxControllerHit.worldNormal)) == 12, "PxControllerHit.worldNormal has unexpected size % instead of 12", size_of(type_of(PxControllerHit.worldNormal)));
        assert(((cast(*void)(*instance.dir)) - cast(*void)(*instance)) == 44, "PxControllerHit.dir has unexpected offset % instead of 44", ((cast(*void)(*instance.dir)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxControllerHit.dir)) == 12, "PxControllerHit.dir has unexpected size % instead of 12", size_of(type_of(PxControllerHit.dir)));
        assert(((cast(*void)(*instance.length)) - cast(*void)(*instance)) == 56, "PxControllerHit.length has unexpected offset % instead of 56", ((cast(*void)(*instance.length)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxControllerHit.length)) == 4, "PxControllerHit.length has unexpected size % instead of 4", size_of(type_of(PxControllerHit.length)));
        assert(size_of(PxControllerHit) == 64, "PxControllerHit has size % instead of 64", size_of(PxControllerHit));
    }

    /**
    \brief Describes a hit between a CCT and a shape. Passed to onShapeHit()

    @see PxUserControllerHitReport.onShapeHit()
    */
    PxControllerShapeHit :: struct {
        #as using pxcontrollerhit: PxControllerHit;

        shape:         *PxShape; //!< Touched shape
        actor:         *PxRigidActor; //!< Touched actor
        triangleIndex: PxU32; //!< touched triangle index (only for meshes/heightfields)
    }
    #run {if true then return;
        assert(size_of(type_of(PxControllerShapeHit.pxcontrollerhit)) == 64, "PxControllerShapeHit.pxcontrollerhit has unexpected size % instead of 64", size_of(type_of(PxControllerShapeHit.pxcontrollerhit)));
        instance: PxControllerShapeHit;
        assert(((cast(*void)(*instance.shape)) - cast(*void)(*instance)) == 64, "PxControllerShapeHit.shape has unexpected offset % instead of 64", ((cast(*void)(*instance.shape)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxControllerShapeHit.shape)) == 8, "PxControllerShapeHit.shape has unexpected size % instead of 8", size_of(type_of(PxControllerShapeHit.shape)));
        assert(((cast(*void)(*instance.actor)) - cast(*void)(*instance)) == 72, "PxControllerShapeHit.actor has unexpected offset % instead of 72", ((cast(*void)(*instance.actor)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxControllerShapeHit.actor)) == 8, "PxControllerShapeHit.actor has unexpected size % instead of 8", size_of(type_of(PxControllerShapeHit.actor)));
        assert(((cast(*void)(*instance.triangleIndex)) - cast(*void)(*instance)) == 80, "PxControllerShapeHit.triangleIndex has unexpected offset % instead of 80", ((cast(*void)(*instance.triangleIndex)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxControllerShapeHit.triangleIndex)) == 4, "PxControllerShapeHit.triangleIndex has unexpected size % instead of 4", size_of(type_of(PxControllerShapeHit.triangleIndex)));
        assert(size_of(PxControllerShapeHit) == 88, "PxControllerShapeHit has size % instead of 88", size_of(PxControllerShapeHit));
    }

    /**
    \brief Describes a hit between a CCT and another CCT. Passed to onControllerHit().

    @see PxUserControllerHitReport.onControllerHit()
    */
    PxControllersHit :: struct {
        #as using pxcontrollerhit: PxControllerHit;

        other: *PxController; //!< Touched controller
    }
    #run {if true then return;
        assert(size_of(type_of(PxControllersHit.pxcontrollerhit)) == 64, "PxControllersHit.pxcontrollerhit has unexpected size % instead of 64", size_of(type_of(PxControllersHit.pxcontrollerhit)));
        instance: PxControllersHit;
        assert(((cast(*void)(*instance.other)) - cast(*void)(*instance)) == 64, "PxControllersHit.other has unexpected offset % instead of 64", ((cast(*void)(*instance.other)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxControllersHit.other)) == 8, "PxControllersHit.other has unexpected size % instead of 8", size_of(type_of(PxControllersHit.other)));
        assert(size_of(PxControllersHit) == 72, "PxControllersHit has size % instead of 72", size_of(PxControllersHit));
    }

    /**
    \brief Describes a hit between a CCT and a user-defined obstacle. Passed to onObstacleHit().

    @see PxUserControllerHitReport.onObstacleHit() PxObstacleContext
    */
    PxControllerObstacleHit :: struct {
        #as using pxcontrollerhit: PxControllerHit;

        userData: *void;
    }
    #run {if true then return;
        assert(size_of(type_of(PxControllerObstacleHit.pxcontrollerhit)) == 64, "PxControllerObstacleHit.pxcontrollerhit has unexpected size % instead of 64", size_of(type_of(PxControllerObstacleHit.pxcontrollerhit)));
        instance: PxControllerObstacleHit;
        assert(((cast(*void)(*instance.userData)) - cast(*void)(*instance)) == 64, "PxControllerObstacleHit.userData has unexpected offset % instead of 64", ((cast(*void)(*instance.userData)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxControllerObstacleHit.userData)) == 8, "PxControllerObstacleHit.userData has unexpected size % instead of 8", size_of(type_of(PxControllerObstacleHit.userData)));
        assert(size_of(PxControllerObstacleHit) == 72, "PxControllerObstacleHit has size % instead of 72", size_of(PxControllerObstacleHit));
    }

    /**
    \brief User callback class for character controller events.

    \note Character controller hit reports are only generated when move is called.

    @see PxControllerDesc.callback
    */
    PxUserControllerHitReport :: struct {
        vtable: *PxUserControllerHitReport_VTable;
    }
    PxUserControllerHitReport_VTable :: struct #type_info_none {
        onShapeHit: (this: *PxUserControllerHitReport, hit: *PxControllerShapeHit) -> void #cpp_method;

        onControllerHit: (this: *PxUserControllerHitReport, hit: *PxControllersHit) -> void #cpp_method;

        onObstacleHit: (this: *PxUserControllerHitReport, hit: *PxControllerObstacleHit) -> void #cpp_method;

        Destructor: (this: *PxUserControllerHitReport, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxUserControllerHitReport_onShapeHit :: inline (this: *PxUserControllerHitReport, hit: *PxControllerShapeHit) { this.vtable.onShapeHit(this, hit); }

    PxUserControllerHitReport_onControllerHit :: inline (this: *PxUserControllerHitReport, hit: *PxControllersHit) { this.vtable.onControllerHit(this, hit); }

    PxUserControllerHitReport_onObstacleHit :: inline (this: *PxUserControllerHitReport, hit: *PxControllerObstacleHit) { this.vtable.onObstacleHit(this, hit); }

    PxUserControllerHitReport_Destructor :: inline (this: *PxUserControllerHitReport, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxUserControllerHitReport) -> *PxUserControllerHitReport_VTable { return obj.vtable; }

    #run {if true then return;
        assert(size_of(PxUserControllerHitReport) == 8, "PxUserControllerHitReport has size % instead of 8", size_of(PxUserControllerHitReport));
    }

    /**
    \brief Dedicated filtering callback for CCT vs CCT.

    This controls collisions between CCTs (one CCT vs anoter CCT).

    To make each CCT collide against all other CCTs, just return true - or simply avoid defining a callback.
    To make each CCT freely go through all other CCTs, just return false.
    Otherwise create a custom filtering logic in this callback.

    @see PxControllerFilters
    */
    PxControllerFilterCallback :: struct {
        vtable: *PxControllerFilterCallback_VTable;
    }
    PxControllerFilterCallback_VTable :: struct #type_info_none {
        Destructor: (this: *PxControllerFilterCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

        filter: (this: *PxControllerFilterCallback, a: *PxController, b: *PxController) -> bool #cpp_method;
    }

    PxControllerFilterCallback_Destructor :: inline (this: *PxControllerFilterCallback, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    PxControllerFilterCallback_filter :: inline (this: *PxControllerFilterCallback, a: *PxController, b: *PxController) -> bool { return this.vtable.filter(this, a, b); }

    vtable :: (obj: *PxControllerFilterCallback) -> *PxControllerFilterCallback_VTable { return obj.vtable; }

    #run {if true then return;
        assert(size_of(PxControllerFilterCallback) == 8, "PxControllerFilterCallback has size % instead of 8", size_of(PxControllerFilterCallback));
    }

    /**
    \brief Filtering data for "move" call.

    This class contains all filtering-related parameters for the PxController::move() call.

    Collisions between a CCT and the world are filtered using the mFilterData, mFilterCallback and mFilterFlags
    members. These parameters are internally passed to PxScene::overlap() to find objects touched by the CCT.
    Please refer to the PxScene::overlap() documentation for details.

    Collisions between a CCT and another CCT are filtered using the mCCTFilterCallback member. If this filter
    callback is not defined, none of the CCT-vs-CCT collisions are filtered, and each CCT will collide against
    all other CCTs.

    \note PxQueryFlag::eANY_HIT and PxQueryFlag::eNO_BLOCK are ignored in mFilterFlags.

    @see PxController.move() PxControllerFilterCallback
    */
    PxControllerFilters :: struct {
        Constructor :: (this: *PxControllerFilters, filterData: *PxFilterData = null, cb: *PxQueryFilterCallback = null, cctFilterCb: *PxControllerFilterCallback = null) -> void #cpp_method #foreign physx_lib "??0PxControllerFilters@physx@@QEAA@PEBUPxFilterData@1@PEAVPxQueryFilterCallback@1@PEAVPxControllerFilterCallback@1@@Z";

        //!< Data for internal PxQueryFilterData structure. Passed to PxScene::overlap() call.
        //!< This can be NULL, in which case a default PxFilterData is used.
        mFilterData:        *PxFilterData;

        mFilterCallback:    *PxQueryFilterCallback; //!< Custom filter logic (can be NULL). Passed to PxScene::overlap() call.
        mFilterFlags:       PxQueryFlags; //!< Flags for internal PxQueryFilterData structure. Passed to PxScene::overlap() call.

        mCCTFilterCallback: *PxControllerFilterCallback; //!< CCT-vs-CCT filter callback. If NULL, all CCT-vs-CCT collisions are kept.
    }
    #run {if true then return;
        instance: PxControllerFilters;
        assert(((cast(*void)(*instance.mFilterData)) - cast(*void)(*instance)) == 0, "PxControllerFilters.mFilterData has unexpected offset % instead of 0", ((cast(*void)(*instance.mFilterData)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxControllerFilters.mFilterData)) == 8, "PxControllerFilters.mFilterData has unexpected size % instead of 8", size_of(type_of(PxControllerFilters.mFilterData)));
        assert(((cast(*void)(*instance.mFilterCallback)) - cast(*void)(*instance)) == 8, "PxControllerFilters.mFilterCallback has unexpected offset % instead of 8", ((cast(*void)(*instance.mFilterCallback)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxControllerFilters.mFilterCallback)) == 8, "PxControllerFilters.mFilterCallback has unexpected size % instead of 8", size_of(type_of(PxControllerFilters.mFilterCallback)));
        assert(((cast(*void)(*instance.mFilterFlags)) - cast(*void)(*instance)) == 16, "PxControllerFilters.mFilterFlags has unexpected offset % instead of 16", ((cast(*void)(*instance.mFilterFlags)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxControllerFilters.mFilterFlags)) == 2, "PxControllerFilters.mFilterFlags has unexpected size % instead of 2", size_of(type_of(PxControllerFilters.mFilterFlags)));
        assert(((cast(*void)(*instance.mCCTFilterCallback)) - cast(*void)(*instance)) == 24, "PxControllerFilters.mCCTFilterCallback has unexpected offset % instead of 24", ((cast(*void)(*instance.mCCTFilterCallback)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxControllerFilters.mCCTFilterCallback)) == 8, "PxControllerFilters.mCCTFilterCallback has unexpected size % instead of 8", size_of(type_of(PxControllerFilters.mCCTFilterCallback)));
        assert(size_of(PxControllerFilters) == 32, "PxControllerFilters has size % instead of 32", size_of(PxControllerFilters));
    }

    /**
    \brief Descriptor class for a character controller.

    @see PxBoxController PxCapsuleController
    */
    PxControllerDesc :: struct {
        vtable: *PxControllerDesc_VTable;
        /**
        \brief Returns the character controller type

        \return The controllers type.

        @see PxControllerType PxCapsuleControllerDesc PxBoxControllerDesc
        */
        getType :: (this: *PxControllerDesc) -> PxControllerShapeType.Enum #cpp_method #foreign physx_lib "?getType@PxControllerDesc@physx@@QEBA?AW4Enum@PxControllerShapeType@2@XZ";

        /**
        \brief The position of the character

        \note The character's initial position must be such that it does not overlap the static geometry.

        <b>Default:</b> Zero
        */
        position:                 PxExtendedVec3;

        /**
        \brief Specifies the 'up' direction

        In order to provide stepping functionality the SDK must be informed about the up direction.

        <b>Default:</b> (0, 1, 0)

        */
        upDirection:              PxVec3;

        /**
        \brief The maximum slope which the character can walk up.

        In general it is desirable to limit where the character can walk, in particular it is unrealistic
        for the character to be able to climb arbitary slopes.

        The limit is expressed as the cosine of desired limit angle. A value of 0 disables this feature.

        \warning It is currently enabled for static actors only (not for dynamic/kinematic actors), and not supported for spheres or capsules.

        <b>Default:</b> 0.707

        @see upDirection invisibleWallHeight maxJumpHeight
        */
        slopeLimit:               PxF32;

        /**
        \brief Height of invisible walls created around non-walkable triangles

        The library can automatically create invisible walls around non-walkable triangles defined
        by the 'slopeLimit' parameter. This defines the height of those walls. If it is 0.0, then
        no extra triangles are created.

        <b>Default:</b> 0.0

        @see upDirection slopeLimit maxJumpHeight
        */
        invisibleWallHeight:      PxF32;

        /**
        \brief Maximum height a jumping character can reach

        This is only used if invisible walls are created ('invisibleWallHeight' is non zero).

        When a character jumps, the non-walkable triangles he might fly over are not found
        by the collision queries (since the character's bounding volume does not touch them).
        Thus those non-walkable triangles do not create invisible walls, and it is possible
        for a jumping character to land on a non-walkable triangle, while he wouldn't have
        reached that place by just walking.

        The 'maxJumpHeight' variable is used to extend the size of the collision volume
        downward. This way, all the non-walkable triangles are properly found by the collision
        queries and it becomes impossible to 'jump over' invisible walls.

        If the character in your game can not jump, it is safe to use 0.0 here. Otherwise it
        is best to keep this value as small as possible, since a larger collision volume
        means more triangles to process.

        <b>Default:</b> 0.0

        @see upDirection slopeLimit invisibleWallHeight
        */
        maxJumpHeight:            PxF32;

        /**
        \brief The contact offset used by the controller.

        Specifies a skin around the object within which contacts will be generated.
        Use it to avoid numerical precision issues.

        This is dependant on the scale of the users world, but should be a small, positive
        non zero value.

        <b>Default:</b> 0.1
        */
        contactOffset:            PxF32;

        /**
        \brief Defines the maximum height of an obstacle which the character can climb.

        A small value will mean that the character gets stuck and cannot walk up stairs etc,
        a value which is too large will mean that the character can climb over unrealistically
        high obstacles.

        <b>Default:</b> 0.5

        @see upDirection
        */
        stepOffset:               PxF32;

        /**
        \brief Density of underlying kinematic actor

        The CCT creates a PhysX's kinematic actor under the hood. This controls its density.

        <b>Default:</b> 10.0
        */
        density:                  PxF32;

        /**
        \brief Scale coefficient for underlying kinematic actor

        The CCT creates a PhysX's kinematic actor under the hood. This controls its scale factor.
        This should be a number a bit smaller than 1.0.

        <b>Default:</b> 0.8
        */
        scaleCoeff:               PxF32;

        /**
        \brief Cached volume growth

        Amount of space around the controller we cache to improve performance. This is a scale factor
        that should be higher than 1.0f but not too big, ideally lower than 2.0f.

        <b>Default:</b> 1.5
        */
        volumeGrowth:             PxF32;

        /**
        \brief Specifies a user report callback.

        This report callback is called when the character collides with shapes and other characters.

        Setting this to NULL disables the callback.

        <b>Default:</b> NULL

        @see PxUserControllerHitReport
        */
        reportCallback:           *PxUserControllerHitReport;

        /**
        \brief Specifies a user behavior callback.

        This behavior callback is called to customize the controller's behavior w.r.t. touched shapes.

        Setting this to NULL disables the callback.

        <b>Default:</b> NULL

        @see PxControllerBehaviorCallback
        */
        behaviorCallback:         *PxControllerBehaviorCallback;

        /**
        \brief The non-walkable mode controls if a character controller slides or not on a non-walkable part.

        This is only used when slopeLimit is non zero.

        <b>Default:</b> PxControllerNonWalkableMode::ePREVENT_CLIMBING

        @see PxControllerNonWalkableMode
        */
        nonWalkableMode:          PxControllerNonWalkableMode.Enum;

        /**
        \brief The material for the actor associated with the controller.

        The controller internally creates a rigid body actor. This parameter specifies the material of the actor.

        <b>Default:</b> NULL

        @see PxMaterial
        */
        material:                 *PxMaterial;

        /**
        \brief Use a deletion listener to get informed about released objects and clear internal caches if needed.

        If a character controller registers a deletion listener, it will get informed about released objects. That allows the
        controller to invalidate cached data that connects to a released object. If a deletion listener is not
        registered, PxController::invalidateCache has to be called manually after objects have been released.

        @see PxController::invalidateCache

        <b>Default:</b> true
        */
        registerDeletionListener: bool;

        /**
        \brief User specified data associated with the controller.

        <b>Default:</b> NULL
        */
        userData:                 *void;

        mType:                    PxControllerShapeType.Enum; //!< The type of the controller. This gets set by the derived class' ctor, the user should not have to change it.

        /**
        \brief constructor sets to default.
        */
        Constructor :: (this: *PxControllerDesc, unknown0: PxControllerShapeType.Enum) -> void #cpp_method #foreign physx_lib "??0PxControllerDesc@physx@@IEAA@W4Enum@PxControllerShapeType@1@@Z";

        copy :: (this: *PxControllerDesc, unknown0: *PxControllerDesc) -> void #cpp_method #foreign physx_lib "?copy@PxControllerDesc@physx@@IEAAXAEBV12@@Z";
        copy :: (this: *PxControllerDesc, unknown0: PxControllerDesc) #no_context {
            copy(this, *unknown0);
        }

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.

        /**
        \brief returns true if the current settings are valid

        \return True if the descriptor is valid.
        */
        virtual_isValid :: (this: *PxControllerDesc) -> bool #cpp_method #foreign physx_lib "?isValid@PxControllerDesc@physx@@UEBA_NXZ";

        virtual_Destructor :: (this: *PxControllerDesc, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_lib "??1PxControllerDesc@physx@@MEAA@XZ";
    }
    PxControllerDesc_VTable :: struct #type_info_none {
        isValid: (this: *PxControllerDesc) -> bool #cpp_method;

        Destructor: (this: *PxControllerDesc, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxControllerDesc_isValid :: inline (this: *PxControllerDesc) -> bool { return this.vtable.isValid(this); }

    PxControllerDesc_Destructor :: inline (this: *PxControllerDesc, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxControllerDesc) -> *PxControllerDesc_VTable { return obj.vtable; }


    /**
    \brief assignment operator.
    */
    operator_assign :: (this: *physx.PxControllerDesc, unknown0: *physx.PxControllerDesc) -> *physx.PxControllerDesc #cpp_method #foreign physx_lib "??4PxControllerDesc@physx@@IEAAAEAV01@AEBV01@@Z";
    operator_assign :: (this: *physx.PxControllerDesc, unknown0: physx.PxControllerDesc) -> *physx.PxControllerDesc #no_context {
        return operator_assign(this, *unknown0);
    }
    #run {if true then return;
        instance: PxControllerDesc;
        assert(((cast(*void)(*instance.position)) - cast(*void)(*instance)) == 8, "PxControllerDesc.position has unexpected offset % instead of 8", ((cast(*void)(*instance.position)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxControllerDesc.position)) == 24, "PxControllerDesc.position has unexpected size % instead of 24", size_of(type_of(PxControllerDesc.position)));
        assert(((cast(*void)(*instance.upDirection)) - cast(*void)(*instance)) == 32, "PxControllerDesc.upDirection has unexpected offset % instead of 32", ((cast(*void)(*instance.upDirection)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxControllerDesc.upDirection)) == 12, "PxControllerDesc.upDirection has unexpected size % instead of 12", size_of(type_of(PxControllerDesc.upDirection)));
        assert(((cast(*void)(*instance.slopeLimit)) - cast(*void)(*instance)) == 44, "PxControllerDesc.slopeLimit has unexpected offset % instead of 44", ((cast(*void)(*instance.slopeLimit)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxControllerDesc.slopeLimit)) == 4, "PxControllerDesc.slopeLimit has unexpected size % instead of 4", size_of(type_of(PxControllerDesc.slopeLimit)));
        assert(((cast(*void)(*instance.invisibleWallHeight)) - cast(*void)(*instance)) == 48, "PxControllerDesc.invisibleWallHeight has unexpected offset % instead of 48", ((cast(*void)(*instance.invisibleWallHeight)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxControllerDesc.invisibleWallHeight)) == 4, "PxControllerDesc.invisibleWallHeight has unexpected size % instead of 4", size_of(type_of(PxControllerDesc.invisibleWallHeight)));
        assert(((cast(*void)(*instance.maxJumpHeight)) - cast(*void)(*instance)) == 52, "PxControllerDesc.maxJumpHeight has unexpected offset % instead of 52", ((cast(*void)(*instance.maxJumpHeight)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxControllerDesc.maxJumpHeight)) == 4, "PxControllerDesc.maxJumpHeight has unexpected size % instead of 4", size_of(type_of(PxControllerDesc.maxJumpHeight)));
        assert(((cast(*void)(*instance.contactOffset)) - cast(*void)(*instance)) == 56, "PxControllerDesc.contactOffset has unexpected offset % instead of 56", ((cast(*void)(*instance.contactOffset)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxControllerDesc.contactOffset)) == 4, "PxControllerDesc.contactOffset has unexpected size % instead of 4", size_of(type_of(PxControllerDesc.contactOffset)));
        assert(((cast(*void)(*instance.stepOffset)) - cast(*void)(*instance)) == 60, "PxControllerDesc.stepOffset has unexpected offset % instead of 60", ((cast(*void)(*instance.stepOffset)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxControllerDesc.stepOffset)) == 4, "PxControllerDesc.stepOffset has unexpected size % instead of 4", size_of(type_of(PxControllerDesc.stepOffset)));
        assert(((cast(*void)(*instance.density)) - cast(*void)(*instance)) == 64, "PxControllerDesc.density has unexpected offset % instead of 64", ((cast(*void)(*instance.density)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxControllerDesc.density)) == 4, "PxControllerDesc.density has unexpected size % instead of 4", size_of(type_of(PxControllerDesc.density)));
        assert(((cast(*void)(*instance.scaleCoeff)) - cast(*void)(*instance)) == 68, "PxControllerDesc.scaleCoeff has unexpected offset % instead of 68", ((cast(*void)(*instance.scaleCoeff)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxControllerDesc.scaleCoeff)) == 4, "PxControllerDesc.scaleCoeff has unexpected size % instead of 4", size_of(type_of(PxControllerDesc.scaleCoeff)));
        assert(((cast(*void)(*instance.volumeGrowth)) - cast(*void)(*instance)) == 72, "PxControllerDesc.volumeGrowth has unexpected offset % instead of 72", ((cast(*void)(*instance.volumeGrowth)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxControllerDesc.volumeGrowth)) == 4, "PxControllerDesc.volumeGrowth has unexpected size % instead of 4", size_of(type_of(PxControllerDesc.volumeGrowth)));
        assert(((cast(*void)(*instance.reportCallback)) - cast(*void)(*instance)) == 80, "PxControllerDesc.reportCallback has unexpected offset % instead of 80", ((cast(*void)(*instance.reportCallback)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxControllerDesc.reportCallback)) == 8, "PxControllerDesc.reportCallback has unexpected size % instead of 8", size_of(type_of(PxControllerDesc.reportCallback)));
        assert(((cast(*void)(*instance.behaviorCallback)) - cast(*void)(*instance)) == 88, "PxControllerDesc.behaviorCallback has unexpected offset % instead of 88", ((cast(*void)(*instance.behaviorCallback)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxControllerDesc.behaviorCallback)) == 8, "PxControllerDesc.behaviorCallback has unexpected size % instead of 8", size_of(type_of(PxControllerDesc.behaviorCallback)));
        assert(((cast(*void)(*instance.nonWalkableMode)) - cast(*void)(*instance)) == 96, "PxControllerDesc.nonWalkableMode has unexpected offset % instead of 96", ((cast(*void)(*instance.nonWalkableMode)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxControllerDesc.nonWalkableMode)) == 4, "PxControllerDesc.nonWalkableMode has unexpected size % instead of 4", size_of(type_of(PxControllerDesc.nonWalkableMode)));
        assert(((cast(*void)(*instance.material)) - cast(*void)(*instance)) == 104, "PxControllerDesc.material has unexpected offset % instead of 104", ((cast(*void)(*instance.material)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxControllerDesc.material)) == 8, "PxControllerDesc.material has unexpected size % instead of 8", size_of(type_of(PxControllerDesc.material)));
        assert(((cast(*void)(*instance.registerDeletionListener)) - cast(*void)(*instance)) == 112, "PxControllerDesc.registerDeletionListener has unexpected offset % instead of 112", ((cast(*void)(*instance.registerDeletionListener)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxControllerDesc.registerDeletionListener)) == 1, "PxControllerDesc.registerDeletionListener has unexpected size % instead of 1", size_of(type_of(PxControllerDesc.registerDeletionListener)));
        assert(((cast(*void)(*instance.userData)) - cast(*void)(*instance)) == 120, "PxControllerDesc.userData has unexpected offset % instead of 120", ((cast(*void)(*instance.userData)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxControllerDesc.userData)) == 8, "PxControllerDesc.userData has unexpected size % instead of 8", size_of(type_of(PxControllerDesc.userData)));
        assert(((cast(*void)(*instance.mType)) - cast(*void)(*instance)) == 128, "PxControllerDesc.mType has unexpected offset % instead of 128", ((cast(*void)(*instance.mType)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxControllerDesc.mType)) == 4, "PxControllerDesc.mType has unexpected size % instead of 4", size_of(type_of(PxControllerDesc.mType)));
        assert(size_of(PxControllerDesc) == 136, "PxControllerDesc has size % instead of 136", size_of(PxControllerDesc));
    }

    /**
    \brief Base class for character controllers.

    @see PxCapsuleController PxBoxController
    */
    PxController :: struct {
        vtable: *PxController_VTable;
    }
    PxController_VTable :: struct #type_info_none {
        getType: (this: *PxController) -> PxControllerShapeType.Enum #cpp_method;

        release: (this: *PxController) -> void #cpp_method;

        move: (this: *PxController, disp: *PxVec3, minDist: PxF32, elapsedTime: PxF32, filters: *PxControllerFilters, obstacles: *PxObstacleContext = null) -> PxControllerCollisionFlags #cpp_method;

        setPosition: (this: *PxController, position: *PxExtendedVec3) -> bool #cpp_method;

        getPosition: (this: *PxController) -> *PxExtendedVec3 #cpp_method;

        setFootPosition: (this: *PxController, position: *PxExtendedVec3) -> bool #cpp_method;

        getFootPosition: (this: *PxController) -> PxExtendedVec3 #cpp_method #cpp_return_type_is_non_pod;

        getActor: (this: *PxController) -> *PxRigidDynamic #cpp_method;

        setStepOffset: (this: *PxController, offset: PxF32) -> void #cpp_method;

        getStepOffset: (this: *PxController) -> PxF32 #cpp_method;

        setNonWalkableMode: (this: *PxController, flag: PxControllerNonWalkableMode.Enum) -> void #cpp_method;

        getNonWalkableMode: (this: *PxController) -> PxControllerNonWalkableMode.Enum #cpp_method;

        getContactOffset: (this: *PxController) -> PxF32 #cpp_method;

        setContactOffset: (this: *PxController, offset: PxF32) -> void #cpp_method;

        getUpDirection: (this: *PxController) -> PxVec3 #cpp_method #cpp_return_type_is_non_pod;

        setUpDirection: (this: *PxController, up: *PxVec3) -> void #cpp_method;

        getSlopeLimit: (this: *PxController) -> PxF32 #cpp_method;

        setSlopeLimit: (this: *PxController, slopeLimit: PxF32) -> void #cpp_method;

        invalidateCache: (this: *PxController) -> void #cpp_method;

        getScene: (this: *PxController) -> *PxScene #cpp_method;

        getUserData: (this: *PxController) -> *void #cpp_method;

        setUserData: (this: *PxController, userData: *void) -> void #cpp_method;

        getState: (this: *PxController, state: *PxControllerState) -> void #cpp_method;

        getStats: (this: *PxController, stats: *PxControllerStats) -> void #cpp_method;

        resize: (this: *PxController, height: PxReal) -> void #cpp_method;

        Destructor: (this: *PxController, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxController_getType :: inline (this: *PxController) -> PxControllerShapeType.Enum { return this.vtable.getType(this); }

    PxController_release :: inline (this: *PxController) { this.vtable.release(this); }

    PxController_move :: inline (this: *PxController, disp: *PxVec3, minDist: PxF32, elapsedTime: PxF32, filters: *PxControllerFilters, obstacles: *PxObstacleContext = null) -> PxControllerCollisionFlags { return this.vtable.move(this, disp, minDist, elapsedTime, filters, obstacles); }

    PxController_setPosition :: inline (this: *PxController, position: *PxExtendedVec3) -> bool { return this.vtable.setPosition(this, position); }

    PxController_getPosition :: inline (this: *PxController) -> *PxExtendedVec3 { return this.vtable.getPosition(this); }

    PxController_setFootPosition :: inline (this: *PxController, position: *PxExtendedVec3) -> bool { return this.vtable.setFootPosition(this, position); }

    PxController_getFootPosition :: inline (this: *PxController) -> PxExtendedVec3 { return this.vtable.getFootPosition(this); }

    PxController_getActor :: inline (this: *PxController) -> *PxRigidDynamic { return this.vtable.getActor(this); }

    PxController_setStepOffset :: inline (this: *PxController, offset: PxF32) { this.vtable.setStepOffset(this, offset); }

    PxController_getStepOffset :: inline (this: *PxController) -> PxF32 { return this.vtable.getStepOffset(this); }

    PxController_setNonWalkableMode :: inline (this: *PxController, flag: PxControllerNonWalkableMode.Enum) { this.vtable.setNonWalkableMode(this, flag); }

    PxController_getNonWalkableMode :: inline (this: *PxController) -> PxControllerNonWalkableMode.Enum { return this.vtable.getNonWalkableMode(this); }

    PxController_getContactOffset :: inline (this: *PxController) -> PxF32 { return this.vtable.getContactOffset(this); }

    PxController_setContactOffset :: inline (this: *PxController, offset: PxF32) { this.vtable.setContactOffset(this, offset); }

    PxController_getUpDirection :: inline (this: *PxController) -> PxVec3 { return this.vtable.getUpDirection(this); }

    PxController_setUpDirection :: inline (this: *PxController, up: *PxVec3) { this.vtable.setUpDirection(this, up); }

    PxController_getSlopeLimit :: inline (this: *PxController) -> PxF32 { return this.vtable.getSlopeLimit(this); }

    PxController_setSlopeLimit :: inline (this: *PxController, slopeLimit: PxF32) { this.vtable.setSlopeLimit(this, slopeLimit); }

    PxController_invalidateCache :: inline (this: *PxController) { this.vtable.invalidateCache(this); }

    PxController_getScene :: inline (this: *PxController) -> *PxScene { return this.vtable.getScene(this); }

    PxController_getUserData :: inline (this: *PxController) -> *void { return this.vtable.getUserData(this); }

    PxController_setUserData :: inline (this: *PxController, userData: *void) { this.vtable.setUserData(this, userData); }

    PxController_getState :: inline (this: *PxController, state: *PxControllerState) { this.vtable.getState(this, state); }

    PxController_getStats :: inline (this: *PxController, stats: *PxControllerStats) { this.vtable.getStats(this, stats); }

    PxController_resize :: inline (this: *PxController, height: PxReal) { this.vtable.resize(this, height); }

    PxController_Destructor :: inline (this: *PxController, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxController) -> *PxController_VTable { return obj.vtable; }

    #run {if true then return;
        assert(size_of(PxController) == 8, "PxController has size % instead of 8", size_of(PxController));
    }

    /**
    \brief Descriptor for a box character controller.

    @see PxBoxController PxControllerDesc
    */
    PxBoxControllerDesc :: struct {
        #as using pxcontrollerdesc: PxControllerDesc;

        /**
        \brief constructor sets to default.
        */
        Constructor :: (this: *PxBoxControllerDesc) -> void #cpp_method #foreign physx_lib "??0PxBoxControllerDesc@physx@@QEAA@XZ";

        halfHeight:        PxF32; // Half-height in the "up" direction

        halfSideExtent:    PxF32; // Half-extent in the "side" direction

        halfForwardExtent: PxF32; // Half-extent in the "forward" direction

        copy :: (this: *PxBoxControllerDesc, unknown0: *PxBoxControllerDesc) -> void #cpp_method #foreign physx_lib "?copy@PxBoxControllerDesc@physx@@IEAAXAEBV12@@Z";
        copy :: (this: *PxBoxControllerDesc, unknown0: PxBoxControllerDesc) #no_context {
            copy(this, *unknown0);
        }
        #place pxcontrollerdesc; pxboxcontrollerdesc_vtable: *PxBoxControllerDesc_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.

        virtual_Destructor :: (this: *PxBoxControllerDesc, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_lib "??1PxBoxControllerDesc@physx@@UEAA@XZ";

        /**
        \brief (re)sets the structure to the default.
        */
        virtual_setToDefault :: (this: *PxBoxControllerDesc) -> void #cpp_method #foreign physx_lib "?setToDefault@PxBoxControllerDesc@physx@@UEAAXXZ";

        /**
        \brief returns true if the current settings are valid

        \return True if the descriptor is valid.
        */
        virtual_isValid :: (this: *PxBoxControllerDesc) -> bool #cpp_method #foreign physx_lib "?isValid@PxBoxControllerDesc@physx@@UEBA_NXZ";
    }
    PxBoxControllerDesc_VTable :: struct #type_info_none {
        using pxcontrollerdesc: PxControllerDesc_VTable;
        setToDefault: (this: *PxBoxControllerDesc) -> void #cpp_method;
    }
    PxBoxControllerDesc_setToDefault :: inline (this: *PxBoxControllerDesc) { this.pxboxcontrollerdesc_vtable.setToDefault(this); }

    vtable :: (obj: *PxBoxControllerDesc) -> *PxBoxControllerDesc_VTable { return obj.pxboxcontrollerdesc_vtable; }


    /**
    \brief assignment operator.
    */
    operator_assign :: (this: *physx.PxBoxControllerDesc, unknown0: *physx.PxBoxControllerDesc) -> *physx.PxBoxControllerDesc #cpp_method #foreign physx_lib "??4PxBoxControllerDesc@physx@@QEAAAEAV01@AEBV01@@Z";
    operator_assign :: (this: *physx.PxBoxControllerDesc, unknown0: physx.PxBoxControllerDesc) -> *physx.PxBoxControllerDesc #no_context {
        return operator_assign(this, *unknown0);
    }
    #run {if true then return;
        assert(size_of(type_of(PxBoxControllerDesc.pxcontrollerdesc)) == 136, "PxBoxControllerDesc.pxcontrollerdesc has unexpected size % instead of 136", size_of(type_of(PxBoxControllerDesc.pxcontrollerdesc)));
        instance: PxBoxControllerDesc;
        assert(((cast(*void)(*instance.halfHeight)) - cast(*void)(*instance)) == 136, "PxBoxControllerDesc.halfHeight has unexpected offset % instead of 136", ((cast(*void)(*instance.halfHeight)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxBoxControllerDesc.halfHeight)) == 4, "PxBoxControllerDesc.halfHeight has unexpected size % instead of 4", size_of(type_of(PxBoxControllerDesc.halfHeight)));
        assert(((cast(*void)(*instance.halfSideExtent)) - cast(*void)(*instance)) == 140, "PxBoxControllerDesc.halfSideExtent has unexpected offset % instead of 140", ((cast(*void)(*instance.halfSideExtent)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxBoxControllerDesc.halfSideExtent)) == 4, "PxBoxControllerDesc.halfSideExtent has unexpected size % instead of 4", size_of(type_of(PxBoxControllerDesc.halfSideExtent)));
        assert(((cast(*void)(*instance.halfForwardExtent)) - cast(*void)(*instance)) == 144, "PxBoxControllerDesc.halfForwardExtent has unexpected offset % instead of 144", ((cast(*void)(*instance.halfForwardExtent)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxBoxControllerDesc.halfForwardExtent)) == 4, "PxBoxControllerDesc.halfForwardExtent has unexpected size % instead of 4", size_of(type_of(PxBoxControllerDesc.halfForwardExtent)));
        assert(size_of(PxBoxControllerDesc) == 152, "PxBoxControllerDesc has size % instead of 152", size_of(PxBoxControllerDesc));
    }

    /**
    \brief Box character controller.

    @see PxBoxControllerDesc PxController
    */
    PxBoxController :: struct {
        #as using pxcontroller: PxController;
        #place pxcontroller; pxboxcontroller_vtable: *PxBoxController_VTable;
    }
    PxBoxController_VTable :: struct #type_info_none {
        using pxcontroller: PxController_VTable;
        getHalfHeight: (this: *PxBoxController) -> PxF32 #cpp_method;

        getHalfSideExtent: (this: *PxBoxController) -> PxF32 #cpp_method;

        getHalfForwardExtent: (this: *PxBoxController) -> PxF32 #cpp_method;

        setHalfHeight: (this: *PxBoxController, halfHeight: PxF32) -> bool #cpp_method;

        setHalfSideExtent: (this: *PxBoxController, halfSideExtent: PxF32) -> bool #cpp_method;

        setHalfForwardExtent: (this: *PxBoxController, halfForwardExtent: PxF32) -> bool #cpp_method;
    }

    PxBoxController_getHalfHeight :: inline (this: *PxBoxController) -> PxF32 { return this.pxboxcontroller_vtable.getHalfHeight(this); }

    PxBoxController_getHalfSideExtent :: inline (this: *PxBoxController) -> PxF32 { return this.pxboxcontroller_vtable.getHalfSideExtent(this); }

    PxBoxController_getHalfForwardExtent :: inline (this: *PxBoxController) -> PxF32 { return this.pxboxcontroller_vtable.getHalfForwardExtent(this); }

    PxBoxController_setHalfHeight :: inline (this: *PxBoxController, halfHeight: PxF32) -> bool { return this.pxboxcontroller_vtable.setHalfHeight(this, halfHeight); }

    PxBoxController_setHalfSideExtent :: inline (this: *PxBoxController, halfSideExtent: PxF32) -> bool { return this.pxboxcontroller_vtable.setHalfSideExtent(this, halfSideExtent); }

    PxBoxController_setHalfForwardExtent :: inline (this: *PxBoxController, halfForwardExtent: PxF32) -> bool { return this.pxboxcontroller_vtable.setHalfForwardExtent(this, halfForwardExtent); }

    vtable :: (obj: *PxBoxController) -> *PxBoxController_VTable { return obj.pxboxcontroller_vtable; }

    #run {if true then return;
        assert(size_of(type_of(PxBoxController.pxcontroller)) == 8, "PxBoxController.pxcontroller has unexpected size % instead of 8", size_of(type_of(PxBoxController.pxcontroller)));
        assert(size_of(PxBoxController) == 8, "PxBoxController has size % instead of 8", size_of(PxBoxController));
    }

    PxCapsuleClimbingMode :: struct {
        Enum :: enum s32 {
            EASY        :: 0;
            CONSTRAINED :: 1;

            LAST        :: 2;

            eEASY        :: EASY;
            eCONSTRAINED :: CONSTRAINED;

            eLAST        :: LAST;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxCapsuleClimbingMode) == 1, "PxCapsuleClimbingMode has size % instead of 1", size_of(PxCapsuleClimbingMode));
    }

    /**
    \brief A descriptor for a capsule character controller.

    @see PxCapsuleController PxControllerDesc
    */
    PxCapsuleControllerDesc :: struct {
        #as using pxcontrollerdesc: PxControllerDesc;

        /**
        \brief constructor sets to default.
        */
        Constructor :: (this: *PxCapsuleControllerDesc) -> void #cpp_method #foreign physx_lib "??0PxCapsuleControllerDesc@physx@@QEAA@XZ";

        /**
        \brief The radius of the capsule

        <b>Default:</b> 0.0

        @see PxCapsuleController
        */
        radius:       PxF32;

        /**
        \brief The height of the controller

        <b>Default:</b> 0.0

        @see PxCapsuleController
        */
        height:       PxF32;

        /**
        \brief The climbing mode

        <b>Default:</b> PxCapsuleClimbingMode::eEASY

        @see PxCapsuleController
        */
        climbingMode: PxCapsuleClimbingMode.Enum;

        copy :: (this: *PxCapsuleControllerDesc, unknown0: *PxCapsuleControllerDesc) -> void #cpp_method #foreign physx_lib "?copy@PxCapsuleControllerDesc@physx@@IEAAXAEBV12@@Z";
        copy :: (this: *PxCapsuleControllerDesc, unknown0: PxCapsuleControllerDesc) #no_context {
            copy(this, *unknown0);
        }
        #place pxcontrollerdesc; pxcapsulecontrollerdesc_vtable: *PxCapsuleControllerDesc_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.

        virtual_Destructor :: (this: *PxCapsuleControllerDesc, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_lib "??1PxCapsuleControllerDesc@physx@@UEAA@XZ";

        /**
        \brief (re)sets the structure to the default.
        */
        virtual_setToDefault :: (this: *PxCapsuleControllerDesc) -> void #cpp_method #foreign physx_lib "?setToDefault@PxCapsuleControllerDesc@physx@@UEAAXXZ";

        /**
        \brief returns true if the current settings are valid

        \return True if the descriptor is valid.
        */
        virtual_isValid :: (this: *PxCapsuleControllerDesc) -> bool #cpp_method #foreign physx_lib "?isValid@PxCapsuleControllerDesc@physx@@UEBA_NXZ";
    }
    PxCapsuleControllerDesc_VTable :: struct #type_info_none {
        using pxcontrollerdesc: PxControllerDesc_VTable;
        setToDefault: (this: *PxCapsuleControllerDesc) -> void #cpp_method;
    }
    PxCapsuleControllerDesc_setToDefault :: inline (this: *PxCapsuleControllerDesc) { this.pxcapsulecontrollerdesc_vtable.setToDefault(this); }

    vtable :: (obj: *PxCapsuleControllerDesc) -> *PxCapsuleControllerDesc_VTable { return obj.pxcapsulecontrollerdesc_vtable; }


    /**
    \brief assignment operator.
    */
    operator_assign :: (this: *physx.PxCapsuleControllerDesc, unknown0: *physx.PxCapsuleControllerDesc) -> *physx.PxCapsuleControllerDesc #cpp_method #foreign physx_lib "??4PxCapsuleControllerDesc@physx@@QEAAAEAV01@AEBV01@@Z";
    operator_assign :: (this: *physx.PxCapsuleControllerDesc, unknown0: physx.PxCapsuleControllerDesc) -> *physx.PxCapsuleControllerDesc #no_context {
        return operator_assign(this, *unknown0);
    }
    #run {if true then return;
        assert(size_of(type_of(PxCapsuleControllerDesc.pxcontrollerdesc)) == 136, "PxCapsuleControllerDesc.pxcontrollerdesc has unexpected size % instead of 136", size_of(type_of(PxCapsuleControllerDesc.pxcontrollerdesc)));
        instance: PxCapsuleControllerDesc;
        assert(((cast(*void)(*instance.radius)) - cast(*void)(*instance)) == 136, "PxCapsuleControllerDesc.radius has unexpected offset % instead of 136", ((cast(*void)(*instance.radius)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxCapsuleControllerDesc.radius)) == 4, "PxCapsuleControllerDesc.radius has unexpected size % instead of 4", size_of(type_of(PxCapsuleControllerDesc.radius)));
        assert(((cast(*void)(*instance.height)) - cast(*void)(*instance)) == 140, "PxCapsuleControllerDesc.height has unexpected offset % instead of 140", ((cast(*void)(*instance.height)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxCapsuleControllerDesc.height)) == 4, "PxCapsuleControllerDesc.height has unexpected size % instead of 4", size_of(type_of(PxCapsuleControllerDesc.height)));
        assert(((cast(*void)(*instance.climbingMode)) - cast(*void)(*instance)) == 144, "PxCapsuleControllerDesc.climbingMode has unexpected offset % instead of 144", ((cast(*void)(*instance.climbingMode)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxCapsuleControllerDesc.climbingMode)) == 4, "PxCapsuleControllerDesc.climbingMode has unexpected size % instead of 4", size_of(type_of(PxCapsuleControllerDesc.climbingMode)));
        assert(size_of(PxCapsuleControllerDesc) == 152, "PxCapsuleControllerDesc has size % instead of 152", size_of(PxCapsuleControllerDesc));
    }

    /**
    \brief A capsule character controller.

    The capsule is defined as a position, a vertical height, and a radius.
    The height is the distance between the two sphere centers at the end of the capsule.
    In other words:

    p = pos (returned by controller)<br>
    h = height<br>
    r = radius<br>

    p = center of capsule<br>
    top sphere center = p.y + h*0.5<br>
    bottom sphere center = p.y - h*0.5<br>
    top capsule point = p.y + h*0.5 + r<br>
    bottom capsule point = p.y - h*0.5 - r<br>
    */
    PxCapsuleController :: struct {
        #as using pxcontroller: PxController;
        #place pxcontroller; pxcapsulecontroller_vtable: *PxCapsuleController_VTable;
    }
    PxCapsuleController_VTable :: struct #type_info_none {
        using pxcontroller: PxController_VTable;
        getRadius: (this: *PxCapsuleController) -> PxF32 #cpp_method;

        setRadius: (this: *PxCapsuleController, radius: PxF32) -> bool #cpp_method;

        getHeight: (this: *PxCapsuleController) -> PxF32 #cpp_method;

        setHeight: (this: *PxCapsuleController, height: PxF32) -> bool #cpp_method;

        getClimbingMode: (this: *PxCapsuleController) -> PxCapsuleClimbingMode.Enum #cpp_method;

        setClimbingMode: (this: *PxCapsuleController, mode: PxCapsuleClimbingMode.Enum) -> bool #cpp_method;
    }

    PxCapsuleController_getRadius :: inline (this: *PxCapsuleController) -> PxF32 { return this.pxcapsulecontroller_vtable.getRadius(this); }

    PxCapsuleController_setRadius :: inline (this: *PxCapsuleController, radius: PxF32) -> bool { return this.pxcapsulecontroller_vtable.setRadius(this, radius); }

    PxCapsuleController_getHeight :: inline (this: *PxCapsuleController) -> PxF32 { return this.pxcapsulecontroller_vtable.getHeight(this); }

    PxCapsuleController_setHeight :: inline (this: *PxCapsuleController, height: PxF32) -> bool { return this.pxcapsulecontroller_vtable.setHeight(this, height); }

    PxCapsuleController_getClimbingMode :: inline (this: *PxCapsuleController) -> PxCapsuleClimbingMode.Enum { return this.pxcapsulecontroller_vtable.getClimbingMode(this); }

    PxCapsuleController_setClimbingMode :: inline (this: *PxCapsuleController, mode: PxCapsuleClimbingMode.Enum) -> bool { return this.pxcapsulecontroller_vtable.setClimbingMode(this, mode); }

    vtable :: (obj: *PxCapsuleController) -> *PxCapsuleController_VTable { return obj.pxcapsulecontroller_vtable; }

    #run {if true then return;
        assert(size_of(type_of(PxCapsuleController.pxcontroller)) == 8, "PxCapsuleController.pxcontroller has unexpected size % instead of 8", size_of(type_of(PxCapsuleController.pxcontroller)));
        assert(size_of(PxCapsuleController) == 8, "PxCapsuleController has size % instead of 8", size_of(PxCapsuleController));
    }

    /**
    \brief specifies controller behavior
    */
    PxControllerBehaviorFlag :: struct {
        Enum :: enum s32 {
            CAN_RIDE_ON_OBJECT :: 1;
            SLIDE              :: 2;
            USER_DEFINED_RIDE  :: 4;

            eCCT_CAN_RIDE_ON_OBJECT :: CAN_RIDE_ON_OBJECT;
            eCCT_SLIDE              :: SLIDE;
            eCCT_USER_DEFINED_RIDE  :: USER_DEFINED_RIDE;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxControllerBehaviorFlag) == 1, "PxControllerBehaviorFlag has size % instead of 1", size_of(PxControllerBehaviorFlag));
    }

    /**
    \brief Bitfield that contains a set of raised flags defined in PxControllerBehaviorFlag.

    @see PxControllerBehaviorFlag
    */
    PxControllerBehaviorFlags :: PxFlags(PxControllerBehaviorFlag.Enum, PxU8);

    /**
    \brief User behavior callback.

    This behavior callback is called to customize the controller's behavior w.r.t. touched shapes.
    */
    PxControllerBehaviorCallback :: struct {
        vtable: *PxControllerBehaviorCallback_VTable;
    }
    PxControllerBehaviorCallback_VTable :: struct #type_info_none {
        getBehaviorFlags: (this: *PxControllerBehaviorCallback, obstacle: *PxObstacle) -> PxControllerBehaviorFlags #cpp_method;

        getBehaviorFlags_1: (this: *PxControllerBehaviorCallback, controller: /*const reference*/ *PxController) -> PxControllerBehaviorFlags #cpp_method;

        getBehaviorFlags_2: (this: *PxControllerBehaviorCallback, shape: /*const reference*/ *PxShape, actor: /*const reference*/ *PxActor) -> PxControllerBehaviorFlags #cpp_method;

        Destructor: (this: *PxControllerBehaviorCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxControllerBehaviorCallback_getBehaviorFlags :: inline (this: *PxControllerBehaviorCallback, obstacle: /*const reference*/ *PxObstacle) -> PxControllerBehaviorFlags { return this.vtable.getBehaviorFlags(this, obstacle); }

    PxControllerBehaviorCallback_getBehaviorFlags_1 :: inline (this: *PxControllerBehaviorCallback, controller: /*const reference*/ *PxController) -> PxControllerBehaviorFlags { return this.vtable.getBehaviorFlags_1(this, controller); }

    PxControllerBehaviorCallback_getBehaviorFlags_2 :: inline (this: *PxControllerBehaviorCallback, shape: /*const reference*/ *PxShape, actor: /*const reference*/ *PxActor) -> PxControllerBehaviorFlags { return this.vtable.getBehaviorFlags_2(this, shape, actor); }

    PxControllerBehaviorCallback_Destructor :: inline (this: *PxControllerBehaviorCallback, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxControllerBehaviorCallback) -> *PxControllerBehaviorCallback_VTable { return obj.vtable; }

    #run {if true then return;
        assert(size_of(PxControllerBehaviorCallback) == 8, "PxControllerBehaviorCallback has size % instead of 8", size_of(PxControllerBehaviorCallback));
    }

    /**
    \brief specifies debug-rendering flags
    */
    PxControllerDebugRenderFlag :: struct {
        Enum :: enum s32 {
            TEMPORAL_BV :: 1;
            CACHED_BV   :: 2;
            OBSTACLES   :: 4;

            NONE        :: 0;
            ALL         :: -1;

            eTEMPORAL_BV :: TEMPORAL_BV;
            eCACHED_BV   :: CACHED_BV;
            eOBSTACLES   :: OBSTACLES;

            eNONE        :: NONE;
            eALL         :: ALL;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxControllerDebugRenderFlag) == 1, "PxControllerDebugRenderFlag has size % instead of 1", size_of(PxControllerDebugRenderFlag));
    }

    /**
    \brief Bitfield that contains a set of raised flags defined in PxControllerDebugRenderFlag.

    @see PxControllerDebugRenderFlag
    */
    PxControllerDebugRenderFlags :: PxFlags(PxControllerDebugRenderFlag.Enum, PxU32);

    /**
    \brief Manages an array of character controllers.

    @see PxController PxBoxController PxCapsuleController
    */
    PxControllerManager :: struct {
        vtable: *PxControllerManager_VTable;
    }
    PxControllerManager_VTable :: struct #type_info_none {
        release: (this: *PxControllerManager) -> void #cpp_method;

        getScene: (this: *PxControllerManager) -> *PxScene #cpp_method;

        getNbControllers: (this: *PxControllerManager) -> PxU32 #cpp_method;

        getController: (this: *PxControllerManager, index: PxU32) -> *PxController #cpp_method;

        createController: (this: *PxControllerManager, desc: *PxControllerDesc) -> *PxController #cpp_method;

        purgeControllers: (this: *PxControllerManager) -> void #cpp_method;

        getRenderBuffer: (this: *PxControllerManager) -> *PxRenderBuffer #cpp_method;

        setDebugRenderingFlags: (this: *PxControllerManager, flags: PxControllerDebugRenderFlags) -> void #cpp_method;

        getNbObstacleContexts: (this: *PxControllerManager) -> PxU32 #cpp_method;

        getObstacleContext: (this: *PxControllerManager, index: PxU32) -> *PxObstacleContext #cpp_method;

        createObstacleContext: (this: *PxControllerManager) -> *PxObstacleContext #cpp_method;

        computeInteractions: (this: *PxControllerManager, elapsedTime: PxF32, cctFilterCb: *PxControllerFilterCallback = null) -> void #cpp_method;

        setTessellation: (this: *PxControllerManager, flag: bool, maxEdgeLength: float) -> void #cpp_method;

        setOverlapRecoveryModule: (this: *PxControllerManager, flag: bool) -> void #cpp_method;

        setPreciseSweeps: (this: *PxControllerManager, flag: bool) -> void #cpp_method;

        setPreventVerticalSlidingAgainstCeiling: (this: *PxControllerManager, flag: bool) -> void #cpp_method;

        shiftOrigin: (this: *PxControllerManager, shift: *PxVec3) -> void #cpp_method;

        Destructor: (this: *PxControllerManager, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxControllerManager_release :: inline (this: *PxControllerManager) { this.vtable.release(this); }

    PxControllerManager_getScene :: inline (this: *PxControllerManager) -> *PxScene { return this.vtable.getScene(this); }

    PxControllerManager_getNbControllers :: inline (this: *PxControllerManager) -> PxU32 { return this.vtable.getNbControllers(this); }

    PxControllerManager_getController :: inline (this: *PxControllerManager, index: PxU32) -> *PxController { return this.vtable.getController(this, index); }

    PxControllerManager_createController :: inline (this: *PxControllerManager, desc: *PxControllerDesc) -> *PxController { return this.vtable.createController(this, desc); }

    PxControllerManager_purgeControllers :: inline (this: *PxControllerManager) { this.vtable.purgeControllers(this); }

    PxControllerManager_getRenderBuffer :: inline (this: *PxControllerManager) -> *PxRenderBuffer { return this.vtable.getRenderBuffer(this); }

    PxControllerManager_setDebugRenderingFlags :: inline (this: *PxControllerManager, flags: PxControllerDebugRenderFlags) { this.vtable.setDebugRenderingFlags(this, flags); }

    PxControllerManager_getNbObstacleContexts :: inline (this: *PxControllerManager) -> PxU32 { return this.vtable.getNbObstacleContexts(this); }

    PxControllerManager_getObstacleContext :: inline (this: *PxControllerManager, index: PxU32) -> *PxObstacleContext { return this.vtable.getObstacleContext(this, index); }

    PxControllerManager_createObstacleContext :: inline (this: *PxControllerManager) -> *PxObstacleContext { return this.vtable.createObstacleContext(this); }

    PxControllerManager_computeInteractions :: inline (this: *PxControllerManager, elapsedTime: PxF32, cctFilterCb: *PxControllerFilterCallback = null) { this.vtable.computeInteractions(this, elapsedTime, cctFilterCb); }

    PxControllerManager_setTessellation :: inline (this: *PxControllerManager, flag: bool, maxEdgeLength: float) { this.vtable.setTessellation(this, flag, maxEdgeLength); }

    PxControllerManager_setOverlapRecoveryModule :: inline (this: *PxControllerManager, flag: bool) { this.vtable.setOverlapRecoveryModule(this, flag); }

    PxControllerManager_setPreciseSweeps :: inline (this: *PxControllerManager, flag: bool) { this.vtable.setPreciseSweeps(this, flag); }

    PxControllerManager_setPreventVerticalSlidingAgainstCeiling :: inline (this: *PxControllerManager, flag: bool) { this.vtable.setPreventVerticalSlidingAgainstCeiling(this, flag); }

    PxControllerManager_shiftOrigin :: inline (this: *PxControllerManager, shift: *PxVec3) { this.vtable.shiftOrigin(this, shift); }

    PxControllerManager_Destructor :: inline (this: *PxControllerManager, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxControllerManager) -> *PxControllerManager_VTable { return obj.vtable; }

    #run {if true then return;
        assert(size_of(PxControllerManager) == 8, "PxControllerManager has size % instead of 8", size_of(PxControllerManager));
    }

    /**
    \brief Flags which describe the format and behavior of a convex mesh.
    */
    PxConvexFlag :: struct {
        Enum :: enum s32 {
            _16_BIT_INDICES           :: 1;

            COMPUTE_CONVEX            :: 2;

            CHECK_ZERO_AREA_TRIANGLES :: 4;

            QUANTIZE_INPUT            :: 8;

            DISABLE_MESH_VALIDATION   :: 16;

            PLANE_SHIFTING            :: 32;

            FAST_INERTIA_COMPUTATION  :: 64;

            GPU_COMPATIBLE            :: 128;

            SHIFT_VERTICES            :: 256;

            e16_BIT_INDICES            :: _16_BIT_INDICES;

            eCOMPUTE_CONVEX            :: COMPUTE_CONVEX;

            eCHECK_ZERO_AREA_TRIANGLES :: CHECK_ZERO_AREA_TRIANGLES;

            eQUANTIZE_INPUT            :: QUANTIZE_INPUT;

            eDISABLE_MESH_VALIDATION   :: DISABLE_MESH_VALIDATION;

            ePLANE_SHIFTING            :: PLANE_SHIFTING;

            eFAST_INERTIA_COMPUTATION  :: FAST_INERTIA_COMPUTATION;

            eGPU_COMPATIBLE            :: GPU_COMPATIBLE;

            eSHIFT_VERTICES            :: SHIFT_VERTICES;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxConvexFlag) == 1, "PxConvexFlag has size % instead of 1", size_of(PxConvexFlag));
    }

    /**
    \brief collection of set bits defined in PxConvexFlag.

    @see PxConvexFlag
    */
    PxConvexFlags :: PxFlags(PxConvexFlag.Enum, PxU16);

    /**
    \brief Descriptor class for #PxConvexMesh.
    \note The number of vertices and the number of convex polygons in a cooked convex mesh is limited to 256.

    @see PxConvexMesh PxConvexMeshGeometry PxShape PxPhysics.createConvexMesh()

    */
    PxConvexMeshDesc :: struct {
        /**
        \brief Vertex positions data in PxBoundedData format.

        <b>Default:</b> NULL
        */
        points:         PxBoundedData;

        /**
        \brief Polygons data in PxBoundedData format.
        <p>Pointer to first polygon. </p>

        <b>Default:</b> NULL

        @see PxHullPolygon
        */
        polygons:       PxBoundedData;

        /**
        \brief Polygon indices data in PxBoundedData format.
        <p>Pointer to first index.</p>

        <b>Default:</b> NULL

        <p>This is declared as a void pointer because it is actually either an PxU16 or a PxU32 pointer.</p>

        @see PxHullPolygon PxConvexFlag::e16_BIT_INDICES
        */
        indices:        PxBoundedData;

        /**
        \brief Flags bits, combined from values of the enum ::PxConvexFlag

        <b>Default:</b> 0
        */
        flags:          PxConvexFlags;

        /**
        \brief Limits the number of vertices of the result convex mesh. Hard maximum limit is 256
        and minimum limit is 4 if PxConvexFlag::ePLANE_SHIFTING is used, otherwise the minimum
        limit is 8.

        \note Vertex limit is only used when PxConvexFlag::eCOMPUTE_CONVEX is specified.
        \note The please see PxConvexFlag::ePLANE_SHIFTING for algorithm explanation

        @see PxConvexFlag::ePLANE_SHIFTING

        <b>Range:</b> [4, 255]<br>
        <b>Default:</b> 255
        */
        vertexLimit:    PxU16;

        /**
        \brief Maximum number of vertices after quantization. The quantization is done during the vertex cleaning phase.
        The quantization is applied when PxConvexFlag::eQUANTIZE_INPUT is specified.

        @see PxConvexFlag::eQUANTIZE_INPUT

        <b>Range:</b> [4, 65535]<br>
        <b>Default:</b> 255
        */
        quantizedCount: PxU16;

        /**
        \brief constructor sets to default.
        */
        Constructor :: (this: *PxConvexMeshDesc) -> void #cpp_method #foreign physx_lib "??0PxConvexMeshDesc@physx@@QEAA@XZ";

        /**
        \brief (re)sets the structure to the default.
        */
        setToDefault :: (this: *PxConvexMeshDesc) -> void #cpp_method #foreign physx_lib "?setToDefault@PxConvexMeshDesc@physx@@QEAAXXZ";

        /**
        \brief Returns true if the descriptor is valid.

        \return True if the current settings are valid
        */
        isValid :: (this: *PxConvexMeshDesc) -> bool #cpp_method #foreign physx_lib "?isValid@PxConvexMeshDesc@physx@@QEBA_NXZ";
    }
    #run {if true then return;
        instance: PxConvexMeshDesc;
        assert(((cast(*void)(*instance.points)) - cast(*void)(*instance)) == 0, "PxConvexMeshDesc.points has unexpected offset % instead of 0", ((cast(*void)(*instance.points)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxConvexMeshDesc.points)) == 24, "PxConvexMeshDesc.points has unexpected size % instead of 24", size_of(type_of(PxConvexMeshDesc.points)));
        assert(((cast(*void)(*instance.polygons)) - cast(*void)(*instance)) == 24, "PxConvexMeshDesc.polygons has unexpected offset % instead of 24", ((cast(*void)(*instance.polygons)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxConvexMeshDesc.polygons)) == 24, "PxConvexMeshDesc.polygons has unexpected size % instead of 24", size_of(type_of(PxConvexMeshDesc.polygons)));
        assert(((cast(*void)(*instance.indices)) - cast(*void)(*instance)) == 48, "PxConvexMeshDesc.indices has unexpected offset % instead of 48", ((cast(*void)(*instance.indices)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxConvexMeshDesc.indices)) == 24, "PxConvexMeshDesc.indices has unexpected size % instead of 24", size_of(type_of(PxConvexMeshDesc.indices)));
        assert(((cast(*void)(*instance.flags)) - cast(*void)(*instance)) == 72, "PxConvexMeshDesc.flags has unexpected offset % instead of 72", ((cast(*void)(*instance.flags)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxConvexMeshDesc.flags)) == 2, "PxConvexMeshDesc.flags has unexpected size % instead of 2", size_of(type_of(PxConvexMeshDesc.flags)));
        assert(((cast(*void)(*instance.vertexLimit)) - cast(*void)(*instance)) == 74, "PxConvexMeshDesc.vertexLimit has unexpected offset % instead of 74", ((cast(*void)(*instance.vertexLimit)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxConvexMeshDesc.vertexLimit)) == 2, "PxConvexMeshDesc.vertexLimit has unexpected size % instead of 2", size_of(type_of(PxConvexMeshDesc.vertexLimit)));
        assert(((cast(*void)(*instance.quantizedCount)) - cast(*void)(*instance)) == 76, "PxConvexMeshDesc.quantizedCount has unexpected offset % instead of 76", ((cast(*void)(*instance.quantizedCount)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxConvexMeshDesc.quantizedCount)) == 2, "PxConvexMeshDesc.quantizedCount has unexpected size % instead of 2", size_of(type_of(PxConvexMeshDesc.quantizedCount)));
        assert(size_of(PxConvexMeshDesc) == 80, "PxConvexMeshDesc has size % instead of 80", size_of(PxConvexMeshDesc));
    }

    /**
    \brief Descriptor class for #PxTriangleMesh.

    Note that this class is derived from PxSimpleTriangleMesh which contains the members that describe the basic mesh.
    The mesh data is *copied* when an PxTriangleMesh object is created from this descriptor. After the call the
    user may discard the triangle data.

    @see PxTriangleMesh PxTriangleMeshGeometry PxShape
    */
    PxTriangleMeshDesc :: struct {
        #as using pxsimpletrianglemesh: PxSimpleTriangleMesh;

        /**
        Optional pointer to first material index, or NULL. There are PxSimpleTriangleMesh::numTriangles indices in total.
        Caller may add materialIndexStride bytes to the pointer to access the next triangle.

        When a triangle mesh collides with another object, a material is required at the collision point.
        If materialIndices is NULL, then the material of the PxShape instance is used.
        Otherwise, if the point of contact is on a triangle with index i, then the material index is determined as:
        PxMaterialTableIndex	index = *(PxMaterialTableIndex *)(((PxU8*)materialIndices) + materialIndexStride * i);

        If the contact point falls on a vertex or an edge, a triangle adjacent to the vertex or edge is selected, and its index
        used to look up a material. The selection is arbitrary but consistent over time.

        <b>Default:</b> NULL

        @see materialIndexStride
        */
        materialIndices: PxTypedStridedData(PxMaterialTableIndex);

        /**
        \brief Constructor sets to default.
        */
        Constructor :: (this: *PxTriangleMeshDesc) -> void #cpp_method #foreign physx_lib "??0PxTriangleMeshDesc@physx@@QEAA@XZ";

        /**
        \brief (re)sets the structure to the default.
        */
        setToDefault :: (this: *PxTriangleMeshDesc) -> void #cpp_method #foreign physx_lib "?setToDefault@PxTriangleMeshDesc@physx@@QEAAXXZ";

        /**
        \brief Returns true if the descriptor is valid.
        \return true if the current settings are valid
        */
        isValid :: (this: *PxTriangleMeshDesc) -> bool #cpp_method #foreign physx_lib "?isValid@PxTriangleMeshDesc@physx@@QEBA_NXZ";
    }
    #run {if true then return;
        assert(size_of(type_of(PxTriangleMeshDesc.pxsimpletrianglemesh)) == 56, "PxTriangleMeshDesc.pxsimpletrianglemesh has unexpected size % instead of 56", size_of(type_of(PxTriangleMeshDesc.pxsimpletrianglemesh)));
        instance: PxTriangleMeshDesc;
        assert(((cast(*void)(*instance.materialIndices)) - cast(*void)(*instance)) == 56, "PxTriangleMeshDesc.materialIndices has unexpected offset % instead of 56", ((cast(*void)(*instance.materialIndices)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxTriangleMeshDesc.materialIndices)) == 16, "PxTriangleMeshDesc.materialIndices has unexpected size % instead of 16", size_of(type_of(PxTriangleMeshDesc.materialIndices)));
        assert(size_of(PxTriangleMeshDesc) == 72, "PxTriangleMeshDesc has size % instead of 72", size_of(PxTriangleMeshDesc));
    }

    /** \brief Enumeration for mesh cooking hints. */
    PxMeshCookingHint :: struct {
        Enum :: enum s32 {
            SIM_PERFORMANCE     :: 0;
            COOKING_PERFORMANCE :: 1;

            eSIM_PERFORMANCE     :: SIM_PERFORMANCE;
            eCOOKING_PERFORMANCE :: COOKING_PERFORMANCE;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxMeshCookingHint) == 1, "PxMeshCookingHint has size % instead of 1", size_of(PxMeshCookingHint));
    }

    /**

    \brief Structure describing parameters affecting BVH33 midphase mesh structure.

    @see PxCookingParams, PxMidphaseDesc
    */
    PxBVH33MidphaseDesc :: struct {
        /**
        \brief Controls the trade-off between mesh size and runtime performance.

        Using a value of 1.0 will produce a larger cooked mesh with generally higher runtime performance,
        using 0.0 will produce a smaller cooked mesh, with generally lower runtime performance.

        Values outside of [0,1] range will be clamped and cause a warning when any mesh gets cooked.

        <b>Default value:</b> 0.55
        <b>Range:</b> [0.0f, 1.0f]
        */
        meshSizePerformanceTradeOff: PxF32;

        /**
        \brief Mesh cooking hint. Used to specify mesh hierarchy construction preference.

        <b>Default value:</b> PxMeshCookingHint::eSIM_PERFORMANCE
        */
        meshCookingHint:             PxMeshCookingHint.Enum;

        /**
        \brief Desc initialization to default value.
        */
        setToDefault :: (this: *PxBVH33MidphaseDesc) -> void #cpp_method #foreign physx_lib "?setToDefault@PxBVH33MidphaseDesc@physx@@QEAAXXZ";

        /**
        \brief Returns true if the descriptor is valid.
        \return true if the current settings are valid.
        */
        isValid :: (this: *PxBVH33MidphaseDesc) -> bool #cpp_method #foreign physx_lib "?isValid@PxBVH33MidphaseDesc@physx@@QEBA_NXZ";
    }
    #run {if true then return;
        instance: PxBVH33MidphaseDesc;
        assert(((cast(*void)(*instance.meshSizePerformanceTradeOff)) - cast(*void)(*instance)) == 0, "PxBVH33MidphaseDesc.meshSizePerformanceTradeOff has unexpected offset % instead of 0", ((cast(*void)(*instance.meshSizePerformanceTradeOff)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxBVH33MidphaseDesc.meshSizePerformanceTradeOff)) == 4, "PxBVH33MidphaseDesc.meshSizePerformanceTradeOff has unexpected size % instead of 4", size_of(type_of(PxBVH33MidphaseDesc.meshSizePerformanceTradeOff)));
        assert(((cast(*void)(*instance.meshCookingHint)) - cast(*void)(*instance)) == 4, "PxBVH33MidphaseDesc.meshCookingHint has unexpected offset % instead of 4", ((cast(*void)(*instance.meshCookingHint)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxBVH33MidphaseDesc.meshCookingHint)) == 4, "PxBVH33MidphaseDesc.meshCookingHint has unexpected size % instead of 4", size_of(type_of(PxBVH33MidphaseDesc.meshCookingHint)));
        assert(size_of(PxBVH33MidphaseDesc) == 8, "PxBVH33MidphaseDesc has size % instead of 8", size_of(PxBVH33MidphaseDesc));
    }

    /**

    \brief Structure describing parameters affecting BVH34 midphase mesh structure.

    @see PxCookingParams, PxMidphaseDesc
    */
    PxBVH34MidphaseDesc :: struct {
        /**
        \brief Mesh cooking hint for max primitives per leaf limit.
        Less primitives per leaf produces larger meshes with better runtime performance
        and worse cooking performance. More triangles per leaf results in faster cooking speed and
        smaller mesh sizes, but with worse runtime performance.

        <b>Default value:</b> 4
        <b>Range:</b> <4, 15>
        */
        numPrimsPerLeaf: PxU32;

        /**
        \brief Desc initialization to default value.
        */
        setToDefault :: (this: *PxBVH34MidphaseDesc) -> void #cpp_method #foreign physx_lib "?setToDefault@PxBVH34MidphaseDesc@physx@@QEAAXXZ";

        /**
        \brief Returns true if the descriptor is valid.
        \return true if the current settings are valid.
        */
        isValid :: (this: *PxBVH34MidphaseDesc) -> bool #cpp_method #foreign physx_lib "?isValid@PxBVH34MidphaseDesc@physx@@QEBA_NXZ";
    }
    #run {if true then return;
        instance: PxBVH34MidphaseDesc;
        assert(((cast(*void)(*instance.numPrimsPerLeaf)) - cast(*void)(*instance)) == 0, "PxBVH34MidphaseDesc.numPrimsPerLeaf has unexpected offset % instead of 0", ((cast(*void)(*instance.numPrimsPerLeaf)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxBVH34MidphaseDesc.numPrimsPerLeaf)) == 4, "PxBVH34MidphaseDesc.numPrimsPerLeaf has unexpected size % instead of 4", size_of(type_of(PxBVH34MidphaseDesc.numPrimsPerLeaf)));
        assert(size_of(PxBVH34MidphaseDesc) == 4, "PxBVH34MidphaseDesc has size % instead of 4", size_of(PxBVH34MidphaseDesc));
    }

    /**

    \brief Structure describing parameters affecting midphase mesh structure.

    @see PxCookingParams, PxBVH33MidphaseDesc, PxBVH34MidphaseDesc
    */
    PxMidphaseDesc :: struct {
        Constructor :: (this: *PxMidphaseDesc) -> void #cpp_method #foreign physx_lib "??0PxMidphaseDesc@physx@@QEAA@XZ";

        /**
        \brief	Returns type of midphase mesh structure.
        \return	PxMeshMidPhase::Enum

        @see PxMeshMidPhase::Enum
        */
        getType :: (this: *PxMidphaseDesc) -> PxMeshMidPhase.Enum #cpp_method #foreign physx_lib "?getType@PxMidphaseDesc@physx@@QEBA?AW4Enum@PxMeshMidPhase@2@XZ";

        /**
        \brief	Midphase descriptors union

        @see PxBV33MidphaseDesc, PxBV34MidphaseDesc
        */
        union {
            mBVH33Desc: PxBVH33MidphaseDesc;
            mBVH34Desc: PxBVH34MidphaseDesc;
        }

        /**
        \brief	Initialize the midphase mesh structure descriptor
        \param[in] type Midphase mesh structure descriptor

        @see PxBV33MidphaseDesc, PxBV34MidphaseDesc
        */
        setToDefault :: (this: *PxMidphaseDesc, type: PxMeshMidPhase.Enum) -> void #cpp_method #foreign physx_lib "?setToDefault@PxMidphaseDesc@physx@@QEAAXW4Enum@PxMeshMidPhase@2@@Z";

        /**
        \brief Returns true if the descriptor is valid.
        \return true if the current settings are valid.
        */
        isValid :: (this: *PxMidphaseDesc) -> bool #cpp_method #foreign physx_lib "?isValid@PxMidphaseDesc@physx@@QEBA_NXZ";

        mType: PxMeshMidPhase.Enum;
    }
    #run {if true then return;
        instance: PxMidphaseDesc;
        assert(((cast(*void)(*instance.mType)) - cast(*void)(*instance)) == 8, "PxMidphaseDesc.mType has unexpected offset % instead of 8", ((cast(*void)(*instance.mType)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxMidphaseDesc.mType)) == 4, "PxMidphaseDesc.mType has unexpected size % instead of 4", size_of(type_of(PxMidphaseDesc.mType)));
        assert(size_of(PxMidphaseDesc) == 12, "PxMidphaseDesc has size % instead of 12", size_of(PxMidphaseDesc));
    }

    /**

    \brief Descriptor class for #PxBVHStructure.

    @see PxBVHStructure
    */
    PxBVHStructureDesc :: struct {
        Constructor :: (this: *PxBVHStructureDesc) -> void #cpp_method #foreign physx_lib "??0PxBVHStructureDesc@physx@@QEAA@XZ";

        /**
        \brief Pointer to first bounding box.
        */
        bounds: PxBoundedData;

        /**
        \brief	Initialize the BVH structure descriptor
        */
        setToDefault :: (this: *PxBVHStructureDesc) -> void #cpp_method #foreign physx_lib "?setToDefault@PxBVHStructureDesc@physx@@QEAAXXZ";

        /**
        \brief Returns true if the descriptor is valid.
        \return true if the current settings are valid.
        */
        isValid :: (this: *PxBVHStructureDesc) -> bool #cpp_method #foreign physx_lib "?isValid@PxBVHStructureDesc@physx@@QEBA_NXZ";
    }
    #run {if true then return;
        instance: PxBVHStructureDesc;
        assert(((cast(*void)(*instance.bounds)) - cast(*void)(*instance)) == 0, "PxBVHStructureDesc.bounds has unexpected offset % instead of 0", ((cast(*void)(*instance.bounds)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxBVHStructureDesc.bounds)) == 24, "PxBVHStructureDesc.bounds has unexpected size % instead of 24", size_of(type_of(PxBVHStructureDesc.bounds)));
        assert(size_of(PxBVHStructureDesc) == 24, "PxBVHStructureDesc has size % instead of 24", size_of(PxBVHStructureDesc));
    }

    /**
    \brief Result from convex cooking.
    */
    PxConvexMeshCookingResult :: struct {
        Enum :: enum s32 {
            SUCCESS                :: 0;

            ZERO_AREA_TEST_FAILED  :: 1;

            POLYGONS_LIMIT_REACHED :: 2;

            FAILURE                :: 3;

            eSUCCESS                :: SUCCESS;

            eZERO_AREA_TEST_FAILED  :: ZERO_AREA_TEST_FAILED;

            ePOLYGONS_LIMIT_REACHED :: POLYGONS_LIMIT_REACHED;

            eFAILURE                :: FAILURE;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxConvexMeshCookingResult) == 1, "PxConvexMeshCookingResult has size % instead of 1", size_of(PxConvexMeshCookingResult));
    }

    /** \brief Enumeration for convex mesh cooking algorithms. */
    PxConvexMeshCookingType :: struct {
        Enum :: enum s32 {
            eQUICKHULL :: 0;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxConvexMeshCookingType) == 1, "PxConvexMeshCookingType has size % instead of 1", size_of(PxConvexMeshCookingType));
    }

    /**
    \brief Result from triangle mesh cooking
    */
    PxTriangleMeshCookingResult :: struct {
        Enum :: enum s32 {
            SUCCESS        :: 0;

            LARGE_TRIANGLE :: 1;

            FAILURE        :: 2;

            eSUCCESS        :: SUCCESS;

            eLARGE_TRIANGLE :: LARGE_TRIANGLE;

            eFAILURE        :: FAILURE;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxTriangleMeshCookingResult) == 1, "PxTriangleMeshCookingResult has size % instead of 1", size_of(PxTriangleMeshCookingResult));
    }

    /**

    \brief Enum for the set of mesh pre-processing parameters.

    */
    PxMeshPreprocessingFlag :: struct {
        Enum :: enum s32 {
            WELD_VERTICES                   :: 1;

            DISABLE_CLEAN_MESH              :: 2;

            DISABLE_ACTIVE_EDGES_PRECOMPUTE :: 4;

            FORCE_32BIT_INDICES             :: 8;

            eWELD_VERTICES                   :: WELD_VERTICES;

            eDISABLE_CLEAN_MESH              :: DISABLE_CLEAN_MESH;

            eDISABLE_ACTIVE_EDGES_PRECOMPUTE :: DISABLE_ACTIVE_EDGES_PRECOMPUTE;

            eFORCE_32BIT_INDICES             :: FORCE_32BIT_INDICES;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxMeshPreprocessingFlag) == 1, "PxMeshPreprocessingFlag has size % instead of 1", size_of(PxMeshPreprocessingFlag));
    }

    PxMeshPreprocessingFlags :: PxFlags(PxMeshPreprocessingFlag.Enum, PxU32);

    /**

    \brief Structure describing parameters affecting mesh cooking.

    @see PxSetCookingParams() PxGetCookingParams()
    */
    PxCookingParams :: struct {
        /**
        \brief Zero-size area epsilon used in convex hull computation.

        If the area of a triangle of the hull is below this value, the triangle will be rejected. This test
        is done only if PxConvexFlag::eCHECK_ZERO_AREA_TRIANGLES is used.

        @see PxConvexFlag::eCHECK_ZERO_AREA_TRIANGLES

        <b>Default value:</b> 0.06f*PxTolerancesScale.length*PxTolerancesScale.length

        <b>Range:</b> (0.0f, PX_MAX_F32)
        */
        areaTestEpsilon:                float;

        /**
        \brief Plane tolerance used in convex hull computation.

        The value is used during hull construction. When a new point is about to be added to the hull it
        gets dropped when the point is closer to the hull than the planeTolerance. The planeTolerance
        is increased according to the hull size.

        If 0.0f is set all points are accepted when the convex hull is created. This may lead to edge cases
        where the new points may be merged into an existing polygon and the polygons plane equation might
        slightly change therefore. This might lead to failures during polygon merging phase in the hull computation.

        It is recommended to use the default value, however if it is required that all points needs to be
        accepted or huge thin convexes are created, it might be required to lower the default value.

        \note The plane tolerance is used only within PxConvexMeshCookingType::eQUICKHULL algorithm.

        <b>Default value:</b> 0.0007f

        <b>Range:</b> <0.0f, PX_MAX_F32)
        */
        planeTolerance:                 float;

        /**
        \brief Convex hull creation algorithm.

        <b>Default value:</b> PxConvexMeshCookingType::eQUICKHULL

        @see PxConvexMeshCookingType
        */
        convexMeshCookingType:          PxConvexMeshCookingType.Enum;

        /**
        \brief When true, the face remap table is not created.  This saves a significant amount of memory, but the SDK will
        not be able to provide the remap information for internal mesh triangles returned by collisions,
        sweeps or raycasts hits.

        <b>Default value:</b> false
        */
        suppressTriangleMeshRemapTable: bool;

        /**
        \brief When true, the triangle adjacency information is created. You can get the adjacency triangles
        for a given triangle from getTriangle.

        <b>Default value:</b> false
        */
        buildTriangleAdjacencies:       bool;

        /**
        \brief When true, addigional information required for GPU-accelerated rigid body simulation is created. This can increase memory usage and cooking times for convex meshes and triangle meshes.

        <b>Default value:</b> false
        */
        buildGPUData:                   bool;

        /**
        \brief Tolerance scale is used to check if cooked triangles are not too huge. This check will help with simulation stability.

        \note The PxTolerancesScale values have to match the values used when creating a PxPhysics or PxScene instance.

        @see PxTolerancesScale
        */
        scale:                          PxTolerancesScale;

        /**
        \brief Mesh pre-processing parameters. Used to control options like whether the mesh cooking performs vertex welding before cooking.

        <b>Default value:</b> 0
        */
        meshPreprocessParams:           PxMeshPreprocessingFlags;

        /**
        \brief Mesh weld tolerance. If mesh welding is enabled, this controls the distance at which vertices are welded.
        If mesh welding is not enabled, this value defines the acceptance distance for mesh validation. Provided no two vertices are within this distance, the mesh is considered to be
        clean. If not, a warning will be emitted. Having a clean, welded mesh is required to achieve the best possible performance.

        The default vertex welding uses a snap-to-grid approach. This approach effectively truncates each vertex to integer values using meshWeldTolerance.
        Once these snapped vertices are produced, all vertices that snap to a given vertex on the grid are remapped to reference a single vertex. Following this,
        all triangles' indices are remapped to reference this subset of clean vertices. It should be noted that	the vertices that we do not alter the
        position of the vertices; the snap-to-grid is only performed to identify nearby vertices.

        The mesh validation approach also uses the same snap-to-grid approach to identify nearby vertices. If more than one vertex snaps to a given grid coordinate,
        we ensure that the distance between the vertices is at least meshWeldTolerance. If this is not the case, a warning is emitted.

        <b>Default value:</b> 0.0
        */
        meshWeldTolerance:              PxReal;

        /**
        \brief Controls the desired midphase desc structure for triangle meshes.

        @see PxBVH33MidphaseDesc, PxBVH34MidphaseDesc, PxMidphaseDesc

        <b>Default value:</b> PxMeshMidPhase::eBVH33
        */
        midphaseDesc:                   PxMidphaseDesc;

        /**
        \brief Vertex limit beyond which additional acceleration structures are computed for each convex mesh. Increase that limit to reduce memory usage.
        Computing the extra structures all the time does not guarantee optimal performance. There is a per-platform break-even point below which the
        extra structures actually hurt performance.

        <b>Default value:</b> 32
        */
        gaussMapLimit:                  PxU32;

        Constructor :: (this: *PxCookingParams, sc: *PxTolerancesScale) -> void #cpp_method #foreign physx_lib "??0PxCookingParams@physx@@QEAA@AEBVPxTolerancesScale@1@@Z";
        Constructor :: (this: *PxCookingParams, sc: PxTolerancesScale) #no_context {
            Constructor(this, *sc);
        }
    }
    #run {if true then return;
        instance: PxCookingParams;
        assert(((cast(*void)(*instance.areaTestEpsilon)) - cast(*void)(*instance)) == 0, "PxCookingParams.areaTestEpsilon has unexpected offset % instead of 0", ((cast(*void)(*instance.areaTestEpsilon)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxCookingParams.areaTestEpsilon)) == 4, "PxCookingParams.areaTestEpsilon has unexpected size % instead of 4", size_of(type_of(PxCookingParams.areaTestEpsilon)));
        assert(((cast(*void)(*instance.planeTolerance)) - cast(*void)(*instance)) == 4, "PxCookingParams.planeTolerance has unexpected offset % instead of 4", ((cast(*void)(*instance.planeTolerance)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxCookingParams.planeTolerance)) == 4, "PxCookingParams.planeTolerance has unexpected size % instead of 4", size_of(type_of(PxCookingParams.planeTolerance)));
        assert(((cast(*void)(*instance.convexMeshCookingType)) - cast(*void)(*instance)) == 8, "PxCookingParams.convexMeshCookingType has unexpected offset % instead of 8", ((cast(*void)(*instance.convexMeshCookingType)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxCookingParams.convexMeshCookingType)) == 4, "PxCookingParams.convexMeshCookingType has unexpected size % instead of 4", size_of(type_of(PxCookingParams.convexMeshCookingType)));
        assert(((cast(*void)(*instance.suppressTriangleMeshRemapTable)) - cast(*void)(*instance)) == 12, "PxCookingParams.suppressTriangleMeshRemapTable has unexpected offset % instead of 12", ((cast(*void)(*instance.suppressTriangleMeshRemapTable)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxCookingParams.suppressTriangleMeshRemapTable)) == 1, "PxCookingParams.suppressTriangleMeshRemapTable has unexpected size % instead of 1", size_of(type_of(PxCookingParams.suppressTriangleMeshRemapTable)));
        assert(((cast(*void)(*instance.buildTriangleAdjacencies)) - cast(*void)(*instance)) == 13, "PxCookingParams.buildTriangleAdjacencies has unexpected offset % instead of 13", ((cast(*void)(*instance.buildTriangleAdjacencies)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxCookingParams.buildTriangleAdjacencies)) == 1, "PxCookingParams.buildTriangleAdjacencies has unexpected size % instead of 1", size_of(type_of(PxCookingParams.buildTriangleAdjacencies)));
        assert(((cast(*void)(*instance.buildGPUData)) - cast(*void)(*instance)) == 14, "PxCookingParams.buildGPUData has unexpected offset % instead of 14", ((cast(*void)(*instance.buildGPUData)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxCookingParams.buildGPUData)) == 1, "PxCookingParams.buildGPUData has unexpected size % instead of 1", size_of(type_of(PxCookingParams.buildGPUData)));
        assert(((cast(*void)(*instance.scale)) - cast(*void)(*instance)) == 16, "PxCookingParams.scale has unexpected offset % instead of 16", ((cast(*void)(*instance.scale)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxCookingParams.scale)) == 8, "PxCookingParams.scale has unexpected size % instead of 8", size_of(type_of(PxCookingParams.scale)));
        assert(((cast(*void)(*instance.meshPreprocessParams)) - cast(*void)(*instance)) == 24, "PxCookingParams.meshPreprocessParams has unexpected offset % instead of 24", ((cast(*void)(*instance.meshPreprocessParams)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxCookingParams.meshPreprocessParams)) == 4, "PxCookingParams.meshPreprocessParams has unexpected size % instead of 4", size_of(type_of(PxCookingParams.meshPreprocessParams)));
        assert(((cast(*void)(*instance.meshWeldTolerance)) - cast(*void)(*instance)) == 28, "PxCookingParams.meshWeldTolerance has unexpected offset % instead of 28", ((cast(*void)(*instance.meshWeldTolerance)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxCookingParams.meshWeldTolerance)) == 4, "PxCookingParams.meshWeldTolerance has unexpected size % instead of 4", size_of(type_of(PxCookingParams.meshWeldTolerance)));
        assert(((cast(*void)(*instance.midphaseDesc)) - cast(*void)(*instance)) == 32, "PxCookingParams.midphaseDesc has unexpected offset % instead of 32", ((cast(*void)(*instance.midphaseDesc)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxCookingParams.midphaseDesc)) == 12, "PxCookingParams.midphaseDesc has unexpected size % instead of 12", size_of(type_of(PxCookingParams.midphaseDesc)));
        assert(((cast(*void)(*instance.gaussMapLimit)) - cast(*void)(*instance)) == 44, "PxCookingParams.gaussMapLimit has unexpected offset % instead of 44", ((cast(*void)(*instance.gaussMapLimit)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxCookingParams.gaussMapLimit)) == 4, "PxCookingParams.gaussMapLimit has unexpected size % instead of 4", size_of(type_of(PxCookingParams.gaussMapLimit)));
        assert(size_of(PxCookingParams) == 48, "PxCookingParams has size % instead of 48", size_of(PxCookingParams));
    }

    PxCooking :: struct {
        vtable: *PxCooking_VTable;
    }
    PxCooking_VTable :: struct #type_info_none {
        release: (this: *PxCooking) -> void #cpp_method;

        setParams: (this: *PxCooking, params: *PxCookingParams) -> void #cpp_method;

        getParams: (this: *PxCooking) -> *PxCookingParams #cpp_method;

        platformMismatch: (this: *PxCooking) -> bool #cpp_method;

        cookTriangleMesh: (this: *PxCooking, desc: *PxTriangleMeshDesc, stream: *PxOutputStream, condition: *PxTriangleMeshCookingResult.Enum = null) -> bool #cpp_method;

        createTriangleMesh: (this: *PxCooking, desc: *PxTriangleMeshDesc, insertionCallback: *PxPhysicsInsertionCallback, condition: *PxTriangleMeshCookingResult.Enum = null) -> *PxTriangleMesh #cpp_method;

        validateTriangleMesh: (this: *PxCooking, desc: *PxTriangleMeshDesc) -> bool #cpp_method;

        cookConvexMesh: (this: *PxCooking, desc: *PxConvexMeshDesc, stream: *PxOutputStream, condition: *PxConvexMeshCookingResult.Enum = null) -> bool #cpp_method;

        createConvexMesh: (this: *PxCooking, desc: *PxConvexMeshDesc, insertionCallback: *PxPhysicsInsertionCallback, condition: *PxConvexMeshCookingResult.Enum = null) -> *PxConvexMesh #cpp_method;

        validateConvexMesh: (this: *PxCooking, desc: *PxConvexMeshDesc) -> bool #cpp_method;

        computeHullPolygons: (this: *PxCooking, mesh: *PxSimpleTriangleMesh, inCallback: *PxAllocatorCallback, nbVerts: *PxU32, vertices: **PxVec3, nbIndices: *PxU32, indices: **PxU32, nbPolygons: *PxU32, hullPolygons: **PxHullPolygon) -> bool #cpp_method;

        cookHeightField: (this: *PxCooking, desc: *PxHeightFieldDesc, stream: *PxOutputStream) -> bool #cpp_method;

        createHeightField: (this: *PxCooking, desc: *PxHeightFieldDesc, insertionCallback: *PxPhysicsInsertionCallback) -> *PxHeightField #cpp_method;

        cookBVHStructure: (this: *PxCooking, desc: *PxBVHStructureDesc, stream: *PxOutputStream) -> bool #cpp_method;

        createBVHStructure: (this: *PxCooking, desc: *PxBVHStructureDesc, insertionCallback: *PxPhysicsInsertionCallback) -> *PxBVHStructure #cpp_method;

        Destructor: (this: *PxCooking, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxCooking_release :: inline (this: *PxCooking) { this.vtable.release(this); }

    PxCooking_setParams :: inline (this: *PxCooking, params: *PxCookingParams) { this.vtable.setParams(this, params); }

    PxCooking_getParams :: inline (this: *PxCooking) -> *PxCookingParams { return this.vtable.getParams(this); }

    PxCooking_platformMismatch :: inline (this: *PxCooking) -> bool { return this.vtable.platformMismatch(this); }

    PxCooking_cookTriangleMesh :: inline (this: *PxCooking, desc: *PxTriangleMeshDesc, stream: *PxOutputStream, condition: *PxTriangleMeshCookingResult.Enum = null) -> bool { return this.vtable.cookTriangleMesh(this, desc, stream, condition); }

    PxCooking_createTriangleMesh :: inline (this: *PxCooking, desc: *PxTriangleMeshDesc, insertionCallback: *PxPhysicsInsertionCallback, condition: *PxTriangleMeshCookingResult.Enum = null) -> *PxTriangleMesh { return this.vtable.createTriangleMesh(this, desc, insertionCallback, condition); }

    PxCooking_validateTriangleMesh :: inline (this: *PxCooking, desc: *PxTriangleMeshDesc) -> bool { return this.vtable.validateTriangleMesh(this, desc); }

    PxCooking_cookConvexMesh :: inline (this: *PxCooking, desc: *PxConvexMeshDesc, stream: *PxOutputStream, condition: *PxConvexMeshCookingResult.Enum = null) -> bool { return this.vtable.cookConvexMesh(this, desc, stream, condition); }

    PxCooking_createConvexMesh :: inline (this: *PxCooking, desc: *PxConvexMeshDesc, insertionCallback: *PxPhysicsInsertionCallback, condition: *PxConvexMeshCookingResult.Enum = null) -> *PxConvexMesh { return this.vtable.createConvexMesh(this, desc, insertionCallback, condition); }

    PxCooking_validateConvexMesh :: inline (this: *PxCooking, desc: *PxConvexMeshDesc) -> bool { return this.vtable.validateConvexMesh(this, desc); }

    PxCooking_computeHullPolygons :: inline (this: *PxCooking, mesh: *PxSimpleTriangleMesh, inCallback: *PxAllocatorCallback, nbVerts: *PxU32, vertices: **PxVec3, nbIndices: *PxU32, indices: **PxU32, nbPolygons: *PxU32, hullPolygons: **PxHullPolygon) -> bool { return this.vtable.computeHullPolygons(this, mesh, inCallback, nbVerts, vertices, nbIndices, indices, nbPolygons, hullPolygons); }

    PxCooking_cookHeightField :: inline (this: *PxCooking, desc: *PxHeightFieldDesc, stream: *PxOutputStream) -> bool { return this.vtable.cookHeightField(this, desc, stream); }

    PxCooking_createHeightField :: inline (this: *PxCooking, desc: *PxHeightFieldDesc, insertionCallback: *PxPhysicsInsertionCallback) -> *PxHeightField { return this.vtable.createHeightField(this, desc, insertionCallback); }

    PxCooking_cookBVHStructure :: inline (this: *PxCooking, desc: *PxBVHStructureDesc, stream: *PxOutputStream) -> bool { return this.vtable.cookBVHStructure(this, desc, stream); }

    PxCooking_createBVHStructure :: inline (this: *PxCooking, desc: *PxBVHStructureDesc, insertionCallback: *PxPhysicsInsertionCallback) -> *PxBVHStructure { return this.vtable.createBVHStructure(this, desc, insertionCallback); }

    PxCooking_Destructor :: inline (this: *PxCooking, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxCooking) -> *PxCooking_VTable { return obj.vtable; }

    #run {if true then return;
        assert(size_of(PxCooking) == 8, "PxCooking has size % instead of 8", size_of(PxCooking));
    }

    /**
    \brief default implementation of a memory write stream

    @see PxOutputStream
    */
    PxDefaultMemoryOutputStream :: struct {
        #as using pxoutputstream: PxOutputStream;

        mAllocator: *PxAllocatorCallback;
        mData:      *PxU8;
        mSize:      PxU32;
        mCapacity:  PxU32;
        #place pxoutputstream; pxdefaultmemoryoutputstream_vtable: *PxDefaultMemoryOutputStream_VTable;
    }
    PxDefaultMemoryOutputStream_VTable :: struct #type_info_none {
        using pxoutputstream: PxOutputStream_VTable;
        getSize: (this: *PxDefaultMemoryOutputStream) -> PxU32 #cpp_method;
        getData: (this: *PxDefaultMemoryOutputStream) -> *PxU8 #cpp_method;
    }

    PxDefaultMemoryOutputStream_getSize :: inline (this: *PxDefaultMemoryOutputStream) -> PxU32 { return this.pxdefaultmemoryoutputstream_vtable.getSize(this); }
    PxDefaultMemoryOutputStream_getData :: inline (this: *PxDefaultMemoryOutputStream) -> *PxU8 { return this.pxdefaultmemoryoutputstream_vtable.getData(this); }

    vtable :: (obj: *PxDefaultMemoryOutputStream) -> *PxDefaultMemoryOutputStream_VTable { return obj.pxdefaultmemoryoutputstream_vtable; }

    #run {if true then return;
        assert(size_of(type_of(PxDefaultMemoryOutputStream.pxoutputstream)) == 8, "PxDefaultMemoryOutputStream.pxoutputstream has unexpected size % instead of 8", size_of(type_of(PxDefaultMemoryOutputStream.pxoutputstream)));
        instance: PxDefaultMemoryOutputStream;
        assert(((cast(*void)(*instance.mAllocator)) - cast(*void)(*instance)) == 8, "PxDefaultMemoryOutputStream.mAllocator has unexpected offset % instead of 8", ((cast(*void)(*instance.mAllocator)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxDefaultMemoryOutputStream.mAllocator)) == 8, "PxDefaultMemoryOutputStream.mAllocator has unexpected size % instead of 8", size_of(type_of(PxDefaultMemoryOutputStream.mAllocator)));
        assert(((cast(*void)(*instance.mData)) - cast(*void)(*instance)) == 16, "PxDefaultMemoryOutputStream.mData has unexpected offset % instead of 16", ((cast(*void)(*instance.mData)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxDefaultMemoryOutputStream.mData)) == 8, "PxDefaultMemoryOutputStream.mData has unexpected size % instead of 8", size_of(type_of(PxDefaultMemoryOutputStream.mData)));
        assert(((cast(*void)(*instance.mSize)) - cast(*void)(*instance)) == 24, "PxDefaultMemoryOutputStream.mSize has unexpected offset % instead of 24", ((cast(*void)(*instance.mSize)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxDefaultMemoryOutputStream.mSize)) == 4, "PxDefaultMemoryOutputStream.mSize has unexpected size % instead of 4", size_of(type_of(PxDefaultMemoryOutputStream.mSize)));
        assert(((cast(*void)(*instance.mCapacity)) - cast(*void)(*instance)) == 28, "PxDefaultMemoryOutputStream.mCapacity has unexpected offset % instead of 28", ((cast(*void)(*instance.mCapacity)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxDefaultMemoryOutputStream.mCapacity)) == 4, "PxDefaultMemoryOutputStream.mCapacity has unexpected size % instead of 4", size_of(type_of(PxDefaultMemoryOutputStream.mCapacity)));
        assert(size_of(PxDefaultMemoryOutputStream) == 32, "PxDefaultMemoryOutputStream has size % instead of 32", size_of(PxDefaultMemoryOutputStream));
    }

    /**
    \brief default implementation of a memory read stream

    @see PxInputData
    */
    PxDefaultMemoryInputData :: struct {
        #as using pxinputdata: PxInputData;

        mSize: PxU32;
        mData: *PxU8;
        mPos:  PxU32;
    }
    #run {if true then return;
        assert(size_of(type_of(PxDefaultMemoryInputData.pxinputdata)) == 8, "PxDefaultMemoryInputData.pxinputdata has unexpected size % instead of 8", size_of(type_of(PxDefaultMemoryInputData.pxinputdata)));
        instance: PxDefaultMemoryInputData;
        assert(((cast(*void)(*instance.mSize)) - cast(*void)(*instance)) == 8, "PxDefaultMemoryInputData.mSize has unexpected offset % instead of 8", ((cast(*void)(*instance.mSize)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxDefaultMemoryInputData.mSize)) == 4, "PxDefaultMemoryInputData.mSize has unexpected size % instead of 4", size_of(type_of(PxDefaultMemoryInputData.mSize)));
        assert(((cast(*void)(*instance.mData)) - cast(*void)(*instance)) == 16, "PxDefaultMemoryInputData.mData has unexpected offset % instead of 16", ((cast(*void)(*instance.mData)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxDefaultMemoryInputData.mData)) == 8, "PxDefaultMemoryInputData.mData has unexpected size % instead of 8", size_of(type_of(PxDefaultMemoryInputData.mData)));
        assert(((cast(*void)(*instance.mPos)) - cast(*void)(*instance)) == 24, "PxDefaultMemoryInputData.mPos has unexpected offset % instead of 24", ((cast(*void)(*instance.mPos)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxDefaultMemoryInputData.mPos)) == 4, "PxDefaultMemoryInputData.mPos has unexpected size % instead of 4", size_of(type_of(PxDefaultMemoryInputData.mPos)));
        assert(size_of(PxDefaultMemoryInputData) == 32, "PxDefaultMemoryInputData has size % instead of 32", size_of(PxDefaultMemoryInputData));
    }

    /**
    \brief default implementation of a file write stream

    @see PxOutputStream
    */
    PxDefaultFileOutputStream :: struct {
        #as using pxoutputstream: PxOutputStream;

        mFile: PxFileHandle;
        #place pxoutputstream; pxdefaultfileoutputstream_vtable: *PxDefaultFileOutputStream_VTable;
    }
    PxDefaultFileOutputStream_VTable :: struct #type_info_none {
        using pxoutputstream: PxOutputStream_VTable;
        isValid: (this: *PxDefaultFileOutputStream) -> bool #cpp_method;
    }
    PxDefaultFileOutputStream_isValid :: inline (this: *PxDefaultFileOutputStream) -> bool { return this.pxdefaultfileoutputstream_vtable.isValid(this); }

    vtable :: (obj: *PxDefaultFileOutputStream) -> *PxDefaultFileOutputStream_VTable { return obj.pxdefaultfileoutputstream_vtable; }

    #run {if true then return;
        assert(size_of(type_of(PxDefaultFileOutputStream.pxoutputstream)) == 8, "PxDefaultFileOutputStream.pxoutputstream has unexpected size % instead of 8", size_of(type_of(PxDefaultFileOutputStream.pxoutputstream)));
        instance: PxDefaultFileOutputStream;
        assert(((cast(*void)(*instance.mFile)) - cast(*void)(*instance)) == 8, "PxDefaultFileOutputStream.mFile has unexpected offset % instead of 8", ((cast(*void)(*instance.mFile)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxDefaultFileOutputStream.mFile)) == 8, "PxDefaultFileOutputStream.mFile has unexpected size % instead of 8", size_of(type_of(PxDefaultFileOutputStream.mFile)));
        assert(size_of(PxDefaultFileOutputStream) == 16, "PxDefaultFileOutputStream has size % instead of 16", size_of(PxDefaultFileOutputStream));
    }

    /**
    \brief default implementation of a file read stream

    @see PxInputData
    */
    PxDefaultFileInputData :: struct {
        #as using pxinputdata: PxInputData;

        mFile:   PxFileHandle;
        mLength: PxU32;
    }
    #run {if true then return;
        assert(size_of(type_of(PxDefaultFileInputData.pxinputdata)) == 8, "PxDefaultFileInputData.pxinputdata has unexpected size % instead of 8", size_of(type_of(PxDefaultFileInputData.pxinputdata)));
        instance: PxDefaultFileInputData;
        assert(((cast(*void)(*instance.mFile)) - cast(*void)(*instance)) == 8, "PxDefaultFileInputData.mFile has unexpected offset % instead of 8", ((cast(*void)(*instance.mFile)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxDefaultFileInputData.mFile)) == 8, "PxDefaultFileInputData.mFile has unexpected size % instead of 8", size_of(type_of(PxDefaultFileInputData.mFile)));
        assert(((cast(*void)(*instance.mLength)) - cast(*void)(*instance)) == 16, "PxDefaultFileInputData.mLength has unexpected offset % instead of 16", ((cast(*void)(*instance.mLength)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxDefaultFileInputData.mLength)) == 4, "PxDefaultFileInputData.mLength has unexpected size % instead of 4", size_of(type_of(PxDefaultFileInputData.mLength)));
        assert(size_of(PxDefaultFileInputData) == 24, "PxDefaultFileInputData has size % instead of 24", size_of(PxDefaultFileInputData));
    }

    /**
    \brief an enumeration of PhysX' built-in joint types

    @see PxJoint
    */
    PxJointConcreteType :: struct {
        Enum :: enum s32 {
            SPHERICAL :: 256;
            REVOLUTE  :: 257;
            PRISMATIC :: 258;
            FIXED     :: 259;
            DISTANCE  :: 260;
            D6        :: 261;
            CONTACT   :: 262;
            Last      :: 263;

            eSPHERICAL :: SPHERICAL;
            eREVOLUTE  :: REVOLUTE;
            ePRISMATIC :: PRISMATIC;
            eFIXED     :: FIXED;
            eDISTANCE  :: DISTANCE;
            eD6        :: D6;
            eCONTACT   :: CONTACT;
            eLast      :: Last;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxJointConcreteType) == 1, "PxJointConcreteType has size % instead of 1", size_of(PxJointConcreteType));
    }

    /**
    \brief an enumeration for specifying one or other of the actors referenced by a joint

    @see PxJoint
    */
    PxJointActorIndex :: struct {
        Enum :: enum s32 {
            eACTOR0 :: 0;
            eACTOR1 :: 1;
            COUNT   :: 2;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxJointActorIndex) == 1, "PxJointActorIndex has size % instead of 1", size_of(PxJointActorIndex));
    }

    /**
    \brief a base interface providing common functionality for PhysX joints
    */
    PxJoint :: struct {
        #as using pxbase: PxBase;

        userData: *void; //!< user can assign this to whatever, usually to create a 1:1 relationship with a user object.
        #place pxbase; pxjoint_vtable: *PxJoint_VTable;
    }
    PxJoint_VTable :: struct #type_info_none {
        using pxbase: PxBase_VTable;
        setActors: (this: *PxJoint, actor0: *PxRigidActor, actor1: *PxRigidActor) -> void #cpp_method;

        getActors: (this: *PxJoint, actor0: **PxRigidActor, actor1: **PxRigidActor) -> void #cpp_method;

        setLocalPose: (this: *PxJoint, actor: PxJointActorIndex.Enum, localPose: *PxTransform) -> void #cpp_method;

        getLocalPose: (this: *PxJoint, actor: PxJointActorIndex.Enum) -> PxTransform #cpp_method #cpp_return_type_is_non_pod;

        getRelativeTransform: (this: *PxJoint) -> PxTransform #cpp_method #cpp_return_type_is_non_pod;

        getRelativeLinearVelocity: (this: *PxJoint) -> PxVec3 #cpp_method #cpp_return_type_is_non_pod;

        getRelativeAngularVelocity: (this: *PxJoint) -> PxVec3 #cpp_method #cpp_return_type_is_non_pod;

        setBreakForce: (this: *PxJoint, force: PxReal, torque: PxReal) -> void #cpp_method;

        getBreakForce: (this: *PxJoint, force: *PxReal, torque: *PxReal) -> void #cpp_method;

        setConstraintFlags: (this: *PxJoint, flags: PxConstraintFlags) -> void #cpp_method;

        setConstraintFlag: (this: *PxJoint, flag: PxConstraintFlag.Enum, value: bool) -> void #cpp_method;

        getConstraintFlags: (this: *PxJoint) -> PxConstraintFlags #cpp_method;

        setInvMassScale0: (this: *PxJoint, invMassScale: PxReal) -> void #cpp_method;

        getInvMassScale0: (this: *PxJoint) -> PxReal #cpp_method;

        setInvInertiaScale0: (this: *PxJoint, invInertiaScale: PxReal) -> void #cpp_method;

        getInvInertiaScale0: (this: *PxJoint) -> PxReal #cpp_method;

        setInvMassScale1: (this: *PxJoint, invMassScale: PxReal) -> void #cpp_method;

        getInvMassScale1: (this: *PxJoint) -> PxReal #cpp_method;

        setInvInertiaScale1: (this: *PxJoint, invInertiaScale: PxReal) -> void #cpp_method;

        getInvInertiaScale1: (this: *PxJoint) -> PxReal #cpp_method;

        getConstraint: (this: *PxJoint) -> *PxConstraint #cpp_method;

        setName: (this: *PxJoint, name: *u8) -> void #cpp_method;

        getName: (this: *PxJoint) -> *u8 #cpp_method;

        getScene: (this: *PxJoint) -> *PxScene #cpp_method;
    }

    PxJoint_setActors :: inline (this: *PxJoint, actor0: *PxRigidActor, actor1: *PxRigidActor) { this.pxjoint_vtable.setActors(this, actor0, actor1); }

    PxJoint_getActors :: inline (this: *PxJoint, actor0: **PxRigidActor, actor1: **PxRigidActor) { this.pxjoint_vtable.getActors(this, actor0, actor1); }

    PxJoint_setLocalPose :: inline (this: *PxJoint, actor: PxJointActorIndex.Enum, localPose: *PxTransform) { this.pxjoint_vtable.setLocalPose(this, actor, localPose); }

    PxJoint_getLocalPose :: inline (this: *PxJoint, actor: PxJointActorIndex.Enum) -> PxTransform { return this.pxjoint_vtable.getLocalPose(this, actor); }

    PxJoint_getRelativeTransform :: inline (this: *PxJoint) -> PxTransform { return this.pxjoint_vtable.getRelativeTransform(this); }

    PxJoint_getRelativeLinearVelocity :: inline (this: *PxJoint) -> PxVec3 { return this.pxjoint_vtable.getRelativeLinearVelocity(this); }

    PxJoint_getRelativeAngularVelocity :: inline (this: *PxJoint) -> PxVec3 { return this.pxjoint_vtable.getRelativeAngularVelocity(this); }

    PxJoint_setBreakForce :: inline (this: *PxJoint, force: PxReal, torque: PxReal) { this.pxjoint_vtable.setBreakForce(this, force, torque); }

    PxJoint_getBreakForce :: inline (this: *PxJoint, force: *PxReal, torque: *PxReal) { this.pxjoint_vtable.getBreakForce(this, force, torque); }

    PxJoint_setConstraintFlags :: inline (this: *PxJoint, flags: PxConstraintFlags) { this.pxjoint_vtable.setConstraintFlags(this, flags); }

    PxJoint_setConstraintFlag :: inline (this: *PxJoint, flag: PxConstraintFlag.Enum, value: bool) { this.pxjoint_vtable.setConstraintFlag(this, flag, value); }

    PxJoint_getConstraintFlags :: inline (this: *PxJoint) -> PxConstraintFlags { return this.pxjoint_vtable.getConstraintFlags(this); }

    PxJoint_setInvMassScale0 :: inline (this: *PxJoint, invMassScale: PxReal) { this.pxjoint_vtable.setInvMassScale0(this, invMassScale); }

    PxJoint_getInvMassScale0 :: inline (this: *PxJoint) -> PxReal { return this.pxjoint_vtable.getInvMassScale0(this); }

    PxJoint_setInvInertiaScale0 :: inline (this: *PxJoint, invInertiaScale: PxReal) { this.pxjoint_vtable.setInvInertiaScale0(this, invInertiaScale); }

    PxJoint_getInvInertiaScale0 :: inline (this: *PxJoint) -> PxReal { return this.pxjoint_vtable.getInvInertiaScale0(this); }

    PxJoint_setInvMassScale1 :: inline (this: *PxJoint, invMassScale: PxReal) { this.pxjoint_vtable.setInvMassScale1(this, invMassScale); }

    PxJoint_getInvMassScale1 :: inline (this: *PxJoint) -> PxReal { return this.pxjoint_vtable.getInvMassScale1(this); }

    PxJoint_setInvInertiaScale1 :: inline (this: *PxJoint, invInertiaScale: PxReal) { this.pxjoint_vtable.setInvInertiaScale1(this, invInertiaScale); }

    PxJoint_getInvInertiaScale1 :: inline (this: *PxJoint) -> PxReal { return this.pxjoint_vtable.getInvInertiaScale1(this); }

    PxJoint_getConstraint :: inline (this: *PxJoint) -> *PxConstraint { return this.pxjoint_vtable.getConstraint(this); }

    PxJoint_setName :: inline (this: *PxJoint, name: *u8) { this.pxjoint_vtable.setName(this, name); }

    PxJoint_getName :: inline (this: *PxJoint) -> *u8 { return this.pxjoint_vtable.getName(this); }

    PxJoint_getScene :: inline (this: *PxJoint) -> *PxScene { return this.pxjoint_vtable.getScene(this); }

    vtable :: (obj: *PxJoint) -> *PxJoint_VTable { return obj.pxjoint_vtable; }

    #run {if true then return;
        assert(size_of(type_of(PxJoint.pxbase)) == 16, "PxJoint.pxbase has unexpected size % instead of 16", size_of(type_of(PxJoint.pxbase)));
        instance: PxJoint;
        assert(((cast(*void)(*instance.userData)) - cast(*void)(*instance)) == 16, "PxJoint.userData has unexpected offset % instead of 16", ((cast(*void)(*instance.userData)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxJoint.userData)) == 8, "PxJoint.userData has unexpected size % instead of 8", size_of(type_of(PxJoint.userData)));
        assert(size_of(PxJoint) == 24, "PxJoint has size % instead of 24", size_of(PxJoint));
    }

    PxSpring :: struct {
        stiffness: PxReal; //!< the spring strength of the drive: that is, the force proportional to the position error
        damping:   PxReal; //!< the damping strength of the drive: that is, the force proportional to the velocity error

        Constructor :: (this: *PxSpring, stiffness_: PxReal, damping_: PxReal) -> void #cpp_method #foreign physx_lib "??0PxSpring@physx@@QEAA@MM@Z";
    }
    #run {if true then return;
        instance: PxSpring;
        assert(((cast(*void)(*instance.stiffness)) - cast(*void)(*instance)) == 0, "PxSpring.stiffness has unexpected offset % instead of 0", ((cast(*void)(*instance.stiffness)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSpring.stiffness)) == 4, "PxSpring.stiffness has unexpected size % instead of 4", size_of(type_of(PxSpring.stiffness)));
        assert(((cast(*void)(*instance.damping)) - cast(*void)(*instance)) == 4, "PxSpring.damping has unexpected offset % instead of 4", ((cast(*void)(*instance.damping)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxSpring.damping)) == 4, "PxSpring.damping has unexpected size % instead of 4", size_of(type_of(PxSpring.damping)));
        assert(size_of(PxSpring) == 8, "PxSpring has size % instead of 8", size_of(PxSpring));
    }

    /**
    \brief flags for configuring the drive of a PxDistanceJoint

    @see PxDistanceJoint
    */
    PxDistanceJointFlag :: struct {
        Enum :: enum s32 {
            MAX_DISTANCE_ENABLED :: 2;
            MIN_DISTANCE_ENABLED :: 4;
            SPRING_ENABLED       :: 8;

            eMAX_DISTANCE_ENABLED :: MAX_DISTANCE_ENABLED;
            eMIN_DISTANCE_ENABLED :: MIN_DISTANCE_ENABLED;
            eSPRING_ENABLED       :: SPRING_ENABLED;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxDistanceJointFlag) == 1, "PxDistanceJointFlag has size % instead of 1", size_of(PxDistanceJointFlag));
    }

    PxDistanceJointFlags :: PxFlags(PxDistanceJointFlag.Enum, PxU16);

    /**
    \brief a joint that maintains an upper or lower bound (or both) on the distance between two points on different objects

    @see PxDistanceJointCreate PxJoint
    */
    PxDistanceJoint :: struct {
        #as using pxjoint: PxJoint;
        #place pxjoint; pxdistancejoint_vtable: *PxDistanceJoint_VTable;
    }
    PxDistanceJoint_VTable :: struct #type_info_none {
        using pxjoint: PxJoint_VTable;
        getDistance: (this: *PxDistanceJoint) -> PxReal #cpp_method;

        setMinDistance: (this: *PxDistanceJoint, distance: PxReal) -> void #cpp_method;

        getMinDistance: (this: *PxDistanceJoint) -> PxReal #cpp_method;

        setMaxDistance: (this: *PxDistanceJoint, distance: PxReal) -> void #cpp_method;

        getMaxDistance: (this: *PxDistanceJoint) -> PxReal #cpp_method;

        setTolerance: (this: *PxDistanceJoint, tolerance: PxReal) -> void #cpp_method;

        getTolerance: (this: *PxDistanceJoint) -> PxReal #cpp_method;

        setStiffness: (this: *PxDistanceJoint, stiffness: PxReal) -> void #cpp_method;

        getStiffness: (this: *PxDistanceJoint) -> PxReal #cpp_method;

        setDamping: (this: *PxDistanceJoint, damping: PxReal) -> void #cpp_method;

        getDamping: (this: *PxDistanceJoint) -> PxReal #cpp_method;

        setDistanceJointFlags: (this: *PxDistanceJoint, flags: PxDistanceJointFlags) -> void #cpp_method;

        setDistanceJointFlag: (this: *PxDistanceJoint, flag: PxDistanceJointFlag.Enum, value: bool) -> void #cpp_method;

        getDistanceJointFlags: (this: *PxDistanceJoint) -> PxDistanceJointFlags #cpp_method;
    }

    PxDistanceJoint_getDistance :: inline (this: *PxDistanceJoint) -> PxReal { return this.pxdistancejoint_vtable.getDistance(this); }

    PxDistanceJoint_setMinDistance :: inline (this: *PxDistanceJoint, distance: PxReal) { this.pxdistancejoint_vtable.setMinDistance(this, distance); }

    PxDistanceJoint_getMinDistance :: inline (this: *PxDistanceJoint) -> PxReal { return this.pxdistancejoint_vtable.getMinDistance(this); }

    PxDistanceJoint_setMaxDistance :: inline (this: *PxDistanceJoint, distance: PxReal) { this.pxdistancejoint_vtable.setMaxDistance(this, distance); }

    PxDistanceJoint_getMaxDistance :: inline (this: *PxDistanceJoint) -> PxReal { return this.pxdistancejoint_vtable.getMaxDistance(this); }

    PxDistanceJoint_setTolerance :: inline (this: *PxDistanceJoint, tolerance: PxReal) { this.pxdistancejoint_vtable.setTolerance(this, tolerance); }

    PxDistanceJoint_getTolerance :: inline (this: *PxDistanceJoint) -> PxReal { return this.pxdistancejoint_vtable.getTolerance(this); }

    PxDistanceJoint_setStiffness :: inline (this: *PxDistanceJoint, stiffness: PxReal) { this.pxdistancejoint_vtable.setStiffness(this, stiffness); }

    PxDistanceJoint_getStiffness :: inline (this: *PxDistanceJoint) -> PxReal { return this.pxdistancejoint_vtable.getStiffness(this); }

    PxDistanceJoint_setDamping :: inline (this: *PxDistanceJoint, damping: PxReal) { this.pxdistancejoint_vtable.setDamping(this, damping); }

    PxDistanceJoint_getDamping :: inline (this: *PxDistanceJoint) -> PxReal { return this.pxdistancejoint_vtable.getDamping(this); }

    PxDistanceJoint_setDistanceJointFlags :: inline (this: *PxDistanceJoint, flags: PxDistanceJointFlags) { this.pxdistancejoint_vtable.setDistanceJointFlags(this, flags); }

    PxDistanceJoint_setDistanceJointFlag :: inline (this: *PxDistanceJoint, flag: PxDistanceJointFlag.Enum, value: bool) { this.pxdistancejoint_vtable.setDistanceJointFlag(this, flag, value); }

    PxDistanceJoint_getDistanceJointFlags :: inline (this: *PxDistanceJoint) -> PxDistanceJointFlags { return this.pxdistancejoint_vtable.getDistanceJointFlags(this); }

    vtable :: (obj: *PxDistanceJoint) -> *PxDistanceJoint_VTable { return obj.pxdistancejoint_vtable; }

    #run {if true then return;
        assert(size_of(type_of(PxDistanceJoint.pxjoint)) == 24, "PxDistanceJoint.pxjoint has unexpected size % instead of 24", size_of(type_of(PxDistanceJoint.pxjoint)));
        assert(size_of(PxDistanceJoint) == 24, "PxDistanceJoint has size % instead of 24", size_of(PxDistanceJoint));
    }

    // on win32 we only have 8-byte alignment guaranteed, but the CRT provides special aligned allocation fns
    platformAlignedAlloc :: (size: size_t) -> *void #foreign physx_lib "?platformAlignedAlloc@physx@@YAPEAX_K@Z";

    platformAlignedFree :: (ptr: *void) -> void #foreign physx_lib "?platformAlignedFree@physx@@YAXPEAX@Z";

    /**
    \brief default implementation of the allocator interface required by the SDK
    */
    PxDefaultAllocator :: struct {
        #as using pxallocatorcallback: PxAllocatorCallback;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.

        virtual_allocate :: (this: *PxDefaultAllocator, size: size_t, unknown0: *u8, unknown1: *u8, unknown2: s32) -> *void #cpp_method #foreign physx_lib "?allocate@PxDefaultAllocator@physx@@UEAAPEAX_KPEBD1H@Z";

        virtual_deallocate :: (this: *PxDefaultAllocator, ptr: *void) -> void #cpp_method #foreign physx_lib "?deallocate@PxDefaultAllocator@physx@@UEAAXPEAX@Z";
    }
    #run {if true then return;
        assert(size_of(type_of(PxDefaultAllocator.pxallocatorcallback)) == 8, "PxDefaultAllocator.pxallocatorcallback has unexpected size % instead of 8", size_of(type_of(PxDefaultAllocator.pxallocatorcallback)));
        assert(size_of(PxDefaultAllocator) == 8, "PxDefaultAllocator has size % instead of 8", size_of(PxDefaultAllocator));
    }

    /**
    \brief Unique identifiers for extensions classes which implement a constraint based on PxConstraint.

    \note Users which want to create their own custom constraint types should choose an ID larger or equal to eNEXT_FREE_ID
    and not eINVALID_ID.

    @see PxConstraint PxSimulationEventCallback.onConstraintBreak()
    */
    PxConstraintExtIDs :: struct {
        Enum :: enum s32 {
            JOINT               :: 0;
            VEHICLE_SUSP_LIMIT  :: 1;
            VEHICLE_STICKY_TYRE :: 2;
            NEXT_FREE_ID        :: 3;
            INVALID_ID          :: 2147483647;

            eJOINT               :: JOINT;
            eVEHICLE_SUSP_LIMIT  :: VEHICLE_SUSP_LIMIT;
            eVEHICLE_STICKY_TYRE :: VEHICLE_STICKY_TYRE;
            eNEXT_FREE_ID        :: NEXT_FREE_ID;
            eINVALID_ID          :: INVALID_ID;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxConstraintExtIDs) == 1, "PxConstraintExtIDs has size % instead of 1", size_of(PxConstraintExtIDs));
    }

    /**
    \brief a joint that maintains an upper or lower bound (or both) on the distance between two points on different objects

    @see PxContactJointCreate PxJoint
    */
    PxJacobianRow :: struct {
        linear0:  PxVec3;
        linear1:  PxVec3;
        angular0: PxVec3;
        angular1: PxVec3;

        Constructor :: (this: *PxJacobianRow) -> void #cpp_method #foreign physx_lib "??0PxJacobianRow@physx@@QEAA@XZ";

        Constructor :: (this: *PxJacobianRow, lin0: *PxVec3, lin1: *PxVec3, ang0: *PxVec3, ang1: *PxVec3) -> void #cpp_method #foreign physx_lib "??0PxJacobianRow@physx@@QEAA@AEBVPxVec3@1@000@Z";
        Constructor :: (this: *PxJacobianRow, lin0: PxVec3, lin1: PxVec3, ang0: PxVec3, ang1: PxVec3) #no_context {
            Constructor(this, *lin0, *lin1, *ang0, *ang1);
        }
    }
    #run {if true then return;
        instance: PxJacobianRow;
        assert(((cast(*void)(*instance.linear0)) - cast(*void)(*instance)) == 0, "PxJacobianRow.linear0 has unexpected offset % instead of 0", ((cast(*void)(*instance.linear0)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxJacobianRow.linear0)) == 12, "PxJacobianRow.linear0 has unexpected size % instead of 12", size_of(type_of(PxJacobianRow.linear0)));
        assert(((cast(*void)(*instance.linear1)) - cast(*void)(*instance)) == 12, "PxJacobianRow.linear1 has unexpected offset % instead of 12", ((cast(*void)(*instance.linear1)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxJacobianRow.linear1)) == 12, "PxJacobianRow.linear1 has unexpected size % instead of 12", size_of(type_of(PxJacobianRow.linear1)));
        assert(((cast(*void)(*instance.angular0)) - cast(*void)(*instance)) == 24, "PxJacobianRow.angular0 has unexpected offset % instead of 24", ((cast(*void)(*instance.angular0)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxJacobianRow.angular0)) == 12, "PxJacobianRow.angular0 has unexpected size % instead of 12", size_of(type_of(PxJacobianRow.angular0)));
        assert(((cast(*void)(*instance.angular1)) - cast(*void)(*instance)) == 36, "PxJacobianRow.angular1 has unexpected offset % instead of 36", ((cast(*void)(*instance.angular1)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxJacobianRow.angular1)) == 12, "PxJacobianRow.angular1 has unexpected size % instead of 12", size_of(type_of(PxJacobianRow.angular1)));
        assert(size_of(PxJacobianRow) == 48, "PxJacobianRow has size % instead of 48", size_of(PxJacobianRow));
    }

    /**
    \brief a joint that maintains an upper or lower bound (or both) on the distance between two points on different objects

    @see PxContactJointCreate PxJoint
    */
    PxContactJoint :: struct {
        #as using pxjoint: PxJoint;
        #place pxjoint; pxcontactjoint_vtable: *PxContactJoint_VTable;
    }
    PxContactJoint_VTable :: struct #type_info_none {
        using pxjoint: PxJoint_VTable;
        setContact: (this: *PxContactJoint, contact: *PxVec3) -> void #cpp_method;

        setContactNormal: (this: *PxContactJoint, contactNormal: *PxVec3) -> void #cpp_method;

        setPenetration: (this: *PxContactJoint, penetration: PxReal) -> void #cpp_method;

        getContact: (this: *PxContactJoint) -> PxVec3 #cpp_method #cpp_return_type_is_non_pod;

        getContactNormal: (this: *PxContactJoint) -> PxVec3 #cpp_method #cpp_return_type_is_non_pod;

        getPenetration: (this: *PxContactJoint) -> PxReal #cpp_method;

        getResititution: (this: *PxContactJoint) -> PxReal #cpp_method;
        setResititution: (this: *PxContactJoint, resititution: PxReal) -> void #cpp_method;
        getBounceThreshold: (this: *PxContactJoint) -> PxReal #cpp_method;
        setBounceThreshold: (this: *PxContactJoint, bounceThreshold: PxReal) -> void #cpp_method;

        computeJacobians: (this: *PxContactJoint, jacobian: *PxJacobianRow) -> void #cpp_method;
        getNbJacobianRows: (this: *PxContactJoint) -> PxU32 #cpp_method;
    }

    PxContactJoint_setContact :: inline (this: *PxContactJoint, contact: *PxVec3) { this.pxcontactjoint_vtable.setContact(this, contact); }

    PxContactJoint_setContactNormal :: inline (this: *PxContactJoint, contactNormal: *PxVec3) { this.pxcontactjoint_vtable.setContactNormal(this, contactNormal); }

    PxContactJoint_setPenetration :: inline (this: *PxContactJoint, penetration: PxReal) { this.pxcontactjoint_vtable.setPenetration(this, penetration); }

    PxContactJoint_getContact :: inline (this: *PxContactJoint) -> PxVec3 { return this.pxcontactjoint_vtable.getContact(this); }

    PxContactJoint_getContactNormal :: inline (this: *PxContactJoint) -> PxVec3 { return this.pxcontactjoint_vtable.getContactNormal(this); }

    PxContactJoint_getPenetration :: inline (this: *PxContactJoint) -> PxReal { return this.pxcontactjoint_vtable.getPenetration(this); }

    PxContactJoint_getResititution :: inline (this: *PxContactJoint) -> PxReal { return this.pxcontactjoint_vtable.getResititution(this); }
    PxContactJoint_setResititution :: inline (this: *PxContactJoint, resititution: PxReal) { this.pxcontactjoint_vtable.setResititution(this, resititution); }
    PxContactJoint_getBounceThreshold :: inline (this: *PxContactJoint) -> PxReal { return this.pxcontactjoint_vtable.getBounceThreshold(this); }
    PxContactJoint_setBounceThreshold :: inline (this: *PxContactJoint, bounceThreshold: PxReal) { this.pxcontactjoint_vtable.setBounceThreshold(this, bounceThreshold); }

    PxContactJoint_computeJacobians :: inline (this: *PxContactJoint, jacobian: *PxJacobianRow) { this.pxcontactjoint_vtable.computeJacobians(this, jacobian); }
    PxContactJoint_getNbJacobianRows :: inline (this: *PxContactJoint) -> PxU32 { return this.pxcontactjoint_vtable.getNbJacobianRows(this); }

    vtable :: (obj: *PxContactJoint) -> *PxContactJoint_VTable { return obj.pxcontactjoint_vtable; }

    #run {if true then return;
        assert(size_of(type_of(PxContactJoint.pxjoint)) == 24, "PxContactJoint.pxjoint has unexpected size % instead of 24", size_of(type_of(PxContactJoint.pxjoint)));
        assert(size_of(PxContactJoint) == 24, "PxContactJoint has size % instead of 24", size_of(PxContactJoint));
    }

    /**
    \brief A fixed joint permits no relative movement between two bodies. ie the bodies are glued together.

    \image html fixedJoint.png

    @see PxFixedJointCreate() PxJoint
    */
    PxFixedJoint :: struct {
        #as using pxjoint: PxJoint;
        #place pxjoint; pxfixedjoint_vtable: *PxFixedJoint_VTable;
    }
    PxFixedJoint_VTable :: struct #type_info_none {
        using pxjoint: PxJoint_VTable;
        setProjectionLinearTolerance: (this: *PxFixedJoint, tolerance: PxReal) -> void #cpp_method;

        getProjectionLinearTolerance: (this: *PxFixedJoint) -> PxReal #cpp_method;

        setProjectionAngularTolerance: (this: *PxFixedJoint, tolerance: PxReal) -> void #cpp_method;

        getProjectionAngularTolerance: (this: *PxFixedJoint) -> PxReal #cpp_method;
    }

    PxFixedJoint_setProjectionLinearTolerance :: inline (this: *PxFixedJoint, tolerance: PxReal) { this.pxfixedjoint_vtable.setProjectionLinearTolerance(this, tolerance); }

    PxFixedJoint_getProjectionLinearTolerance :: inline (this: *PxFixedJoint) -> PxReal { return this.pxfixedjoint_vtable.getProjectionLinearTolerance(this); }

    PxFixedJoint_setProjectionAngularTolerance :: inline (this: *PxFixedJoint, tolerance: PxReal) { this.pxfixedjoint_vtable.setProjectionAngularTolerance(this, tolerance); }

    PxFixedJoint_getProjectionAngularTolerance :: inline (this: *PxFixedJoint) -> PxReal { return this.pxfixedjoint_vtable.getProjectionAngularTolerance(this); }

    vtable :: (obj: *PxFixedJoint) -> *PxFixedJoint_VTable { return obj.pxfixedjoint_vtable; }

    #run {if true then return;
        assert(size_of(type_of(PxFixedJoint.pxjoint)) == 24, "PxFixedJoint.pxjoint has unexpected size % instead of 24", size_of(type_of(PxFixedJoint.pxjoint)));
        assert(size_of(PxFixedJoint) == 24, "PxFixedJoint has size % instead of 24", size_of(PxFixedJoint));
    }

    /**
    \brief Describes the parameters for a joint limit.

    Limits are enabled or disabled by setting flags or other configuration parameters joints, see the
    documentation for specific joint types for details.
    */
    PxJointLimitParameters :: struct {
        /**
        \brief Controls the amount of bounce when the joint hits a limit.

        A restitution value of 1.0 causes the joint to bounce back with the velocity which it hit the limit.
        A value of zero causes the joint to stop dead.

        In situations where the joint has many locked DOFs (e.g. 5) the restitution may not be applied
        correctly. This is due to a limitation in the solver which causes the restitution velocity to become zero
        as the solver enforces constraints on the other DOFs.

        This limitation applies to both angular and linear limits, however it is generally most apparent with limited
        angular DOFs. Disabling joint projection and increasing the solver iteration count may improve this behavior
        to some extent.

        Also, combining soft joint limits with joint drives driving against those limits may affect stability.

        <b>Range:</b> [0,1]<br>
        <b>Default:</b> 0.0
        */
        restitution:     PxReal;

        /**
        determines the minimum impact velocity which will cause the joint to bounce
        */
        bounceThreshold: PxReal;

        /**
        \brief if greater than zero, the limit is soft, i.e. a spring pulls the joint back to the limit

        <b>Range:</b> [0, PX_MAX_F32)<br>
        <b>Default:</b> 0.0
        */
        stiffness:       PxReal;

        /**
        \brief if spring is greater than zero, this is the damping of the limit spring

        <b>Range:</b> [0, PX_MAX_F32)<br>
        <b>Default:</b> 0.0
        */
        damping:         PxReal;

        /**
        \brief the distance inside the limit value at which the limit will be considered to be active by the
        solver.  As this value is made larger, the limit becomes active more quickly. It thus becomes less
        likely to violate the extents of the limit, but more expensive.

        The contact distance should be less than the limit angle or distance, and in the case of a pair limit,
        less than half the distance between the upper and lower bounds. Exceeding this value will result in
        the limit being active all the time.

        Making this value too small can result in jitter around the limit.

        <b>Default:</b> depends on the joint

        @see PxPhysics::getTolerancesScale()
        */
        contactDistance: PxReal;

        Constructor :: (this: *PxJointLimitParameters) -> void #cpp_method #foreign physx_lib "??0PxJointLimitParameters@physx@@QEAA@XZ";

        /**
        \brief Returns true if the current settings are valid.

        \return true if the current settings are valid
        */
        isValid :: (this: *PxJointLimitParameters) -> bool #cpp_method #foreign physx_lib "?isValid@PxJointLimitParameters@physx@@QEBA_NXZ";

        isSoft :: (this: *PxJointLimitParameters) -> bool #cpp_method #foreign physx_lib "?isSoft@PxJointLimitParameters@physx@@QEBA_NXZ";

        Destructor :: (this: *PxJointLimitParameters) -> void #cpp_method #foreign physx_lib "??1PxJointLimitParameters@physx@@IEAA@XZ";
    }
    #run {if true then return;
        instance: PxJointLimitParameters;
        assert(((cast(*void)(*instance.restitution)) - cast(*void)(*instance)) == 0, "PxJointLimitParameters.restitution has unexpected offset % instead of 0", ((cast(*void)(*instance.restitution)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxJointLimitParameters.restitution)) == 4, "PxJointLimitParameters.restitution has unexpected size % instead of 4", size_of(type_of(PxJointLimitParameters.restitution)));
        assert(((cast(*void)(*instance.bounceThreshold)) - cast(*void)(*instance)) == 4, "PxJointLimitParameters.bounceThreshold has unexpected offset % instead of 4", ((cast(*void)(*instance.bounceThreshold)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxJointLimitParameters.bounceThreshold)) == 4, "PxJointLimitParameters.bounceThreshold has unexpected size % instead of 4", size_of(type_of(PxJointLimitParameters.bounceThreshold)));
        assert(((cast(*void)(*instance.stiffness)) - cast(*void)(*instance)) == 8, "PxJointLimitParameters.stiffness has unexpected offset % instead of 8", ((cast(*void)(*instance.stiffness)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxJointLimitParameters.stiffness)) == 4, "PxJointLimitParameters.stiffness has unexpected size % instead of 4", size_of(type_of(PxJointLimitParameters.stiffness)));
        assert(((cast(*void)(*instance.damping)) - cast(*void)(*instance)) == 12, "PxJointLimitParameters.damping has unexpected offset % instead of 12", ((cast(*void)(*instance.damping)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxJointLimitParameters.damping)) == 4, "PxJointLimitParameters.damping has unexpected size % instead of 4", size_of(type_of(PxJointLimitParameters.damping)));
        assert(((cast(*void)(*instance.contactDistance)) - cast(*void)(*instance)) == 16, "PxJointLimitParameters.contactDistance has unexpected offset % instead of 16", ((cast(*void)(*instance.contactDistance)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxJointLimitParameters.contactDistance)) == 4, "PxJointLimitParameters.contactDistance has unexpected size % instead of 4", size_of(type_of(PxJointLimitParameters.contactDistance)));
        assert(size_of(PxJointLimitParameters) == 20, "PxJointLimitParameters has size % instead of 20", size_of(PxJointLimitParameters));
    }

    /**
    \brief Describes a one-sided linear limit.
    */
    PxJointLinearLimit :: struct {
        #as using pxjointlimitparameters: PxJointLimitParameters;

        /**
        \brief the extent of the limit.

        <b>Range:</b> (0, PX_MAX_F32) <br>
        <b>Default:</b> PX_MAX_F32
        */
        value: PxReal;

        /**
        \brief construct a linear hard limit

        \param[in] scale		A PxTolerancesScale struct. Should be the same as used when creating the PxPhysics object.
        \param[in] extent		The extent of the limit
        \param[in] contactDist	The distance from the limit at which it becomes active. Default is 0.01f scaled by the tolerance length scale

        @see PxJointLimitParameters PxTolerancesScale
        */
        Constructor :: (this: *PxJointLinearLimit, scale: *PxTolerancesScale, extent: PxReal, contactDist: PxReal = -1.0) -> void #cpp_method #foreign physx_lib "??0PxJointLinearLimit@physx@@QEAA@AEBVPxTolerancesScale@1@MM@Z";
        Constructor :: (this: *PxJointLinearLimit, scale: PxTolerancesScale, extent: PxReal, contactDist: PxReal = -1.0) #no_context {
            Constructor(this, *scale, extent, contactDist);
        }

        /**
        \brief construct a linear soft limit

        \param[in] extent the extent of the limit
        \param[in] spring the stiffness and damping parameters for the limit spring

        @see PxJointLimitParameters PxTolerancesScale
        */
        Constructor :: (this: *PxJointLinearLimit, extent: PxReal, spring: *PxSpring) -> void #cpp_method #foreign physx_lib "??0PxJointLinearLimit@physx@@QEAA@MAEBVPxSpring@1@@Z";
        Constructor :: (this: *PxJointLinearLimit, extent: PxReal, spring: PxSpring) #no_context {
            Constructor(this, extent, *spring);
        }

        /**
        \brief Returns true if the limit is valid

        \return true if the current settings are valid
        */
        isValid :: (this: *PxJointLinearLimit) -> bool #cpp_method #foreign physx_lib "?isValid@PxJointLinearLimit@physx@@QEBA_NXZ";
    }
    #run {if true then return;
        assert(size_of(type_of(PxJointLinearLimit.pxjointlimitparameters)) == 20, "PxJointLinearLimit.pxjointlimitparameters has unexpected size % instead of 20", size_of(type_of(PxJointLinearLimit.pxjointlimitparameters)));
        instance: PxJointLinearLimit;
        assert(((cast(*void)(*instance.value)) - cast(*void)(*instance)) == 20, "PxJointLinearLimit.value has unexpected offset % instead of 20", ((cast(*void)(*instance.value)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxJointLinearLimit.value)) == 4, "PxJointLinearLimit.value has unexpected size % instead of 4", size_of(type_of(PxJointLinearLimit.value)));
        assert(size_of(PxJointLinearLimit) == 24, "PxJointLinearLimit has size % instead of 24", size_of(PxJointLinearLimit));
    }

    /**
    \brief Describes a two-sided limit.
    */
    PxJointLinearLimitPair :: struct {
        #as using pxjointlimitparameters: PxJointLimitParameters;

        /**
        \brief the range of the limit. The upper limit must be no lower than the
        lower limit, and if they are equal the limited degree of freedom will be treated as locked.

        <b>Range:</b> See the joint on which the limit is used for details<br>
        <b>Default:</b> lower = -PX_MAX_F32/3, upper = PX_MAX_F32/3
        */
        upper: PxReal;
        /**
        \brief the range of the limit. The upper limit must be no lower than the
        lower limit, and if they are equal the limited degree of freedom will be treated as locked.

        <b>Range:</b> See the joint on which the limit is used for details<br>
        <b>Default:</b> lower = -PX_MAX_F32/3, upper = PX_MAX_F32/3
        */
        lower: PxReal;

        /**
        \brief Construct a linear hard limit pair. The lower distance value must be less than the upper distance value.

        \param[in] scale		A PxTolerancesScale struct. Should be the same as used when creating the PxPhysics object.
        \param[in] lowerLimit	The lower distance of the limit
        \param[in] upperLimit	The upper distance of the limit
        \param[in] contactDist	The distance from the limit at which it becomes active. Default is the lesser of 0.01f scaled by the tolerance length scale, and 0.49 * (upperLimit - lowerLimit)

        @see PxJointLimitParameters PxTolerancesScale
        */
        Constructor :: (this: *PxJointLinearLimitPair, scale: *PxTolerancesScale, lowerLimit: PxReal = -FLOAT32_MAX / 3.0, upperLimit: PxReal = FLOAT32_MAX, contactDist: PxReal = -1.0) -> void #cpp_method #foreign physx_lib "??0PxJointLinearLimitPair@physx@@QEAA@AEBVPxTolerancesScale@1@MMM@Z";
        Constructor :: (this: *PxJointLinearLimitPair, scale: PxTolerancesScale, lowerLimit: PxReal = -FLOAT32_MAX / 3.0, upperLimit: PxReal = FLOAT32_MAX, contactDist: PxReal = -1.0) #no_context {
            Constructor(this, *scale, lowerLimit, upperLimit, contactDist);
        }

        /**
        \brief construct a linear soft limit pair

        \param[in] lowerLimit	The lower distance of the limit
        \param[in] upperLimit	The upper distance of the limit
        \param[in] spring		The stiffness and damping parameters of the limit spring

        @see PxJointLimitParameters PxTolerancesScale
        */
        Constructor :: (this: *PxJointLinearLimitPair, lowerLimit: PxReal, upperLimit: PxReal, spring: *PxSpring) -> void #cpp_method #foreign physx_lib "??0PxJointLinearLimitPair@physx@@QEAA@MMAEBVPxSpring@1@@Z";
        Constructor :: (this: *PxJointLinearLimitPair, lowerLimit: PxReal, upperLimit: PxReal, spring: PxSpring) #no_context {
            Constructor(this, lowerLimit, upperLimit, *spring);
        }

        /**
        \brief Returns true if the limit is valid.

        \return true if the current settings are valid
        */
        isValid :: (this: *PxJointLinearLimitPair) -> bool #cpp_method #foreign physx_lib "?isValid@PxJointLinearLimitPair@physx@@QEBA_NXZ";
    }
    #run {if true then return;
        assert(size_of(type_of(PxJointLinearLimitPair.pxjointlimitparameters)) == 20, "PxJointLinearLimitPair.pxjointlimitparameters has unexpected size % instead of 20", size_of(type_of(PxJointLinearLimitPair.pxjointlimitparameters)));
        instance: PxJointLinearLimitPair;
        assert(((cast(*void)(*instance.upper)) - cast(*void)(*instance)) == 20, "PxJointLinearLimitPair.upper has unexpected offset % instead of 20", ((cast(*void)(*instance.upper)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxJointLinearLimitPair.upper)) == 4, "PxJointLinearLimitPair.upper has unexpected size % instead of 4", size_of(type_of(PxJointLinearLimitPair.upper)));
        assert(((cast(*void)(*instance.lower)) - cast(*void)(*instance)) == 24, "PxJointLinearLimitPair.lower has unexpected offset % instead of 24", ((cast(*void)(*instance.lower)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxJointLinearLimitPair.lower)) == 4, "PxJointLinearLimitPair.lower has unexpected size % instead of 4", size_of(type_of(PxJointLinearLimitPair.lower)));
        assert(size_of(PxJointLinearLimitPair) == 28, "PxJointLinearLimitPair has size % instead of 28", size_of(PxJointLinearLimitPair));
    }

    PxJointAngularLimitPair :: struct {
        #as using pxjointlimitparameters: PxJointLimitParameters;

        /**
        \brief the range of the limit. The upper limit must be no lower than the lower limit.

        <b>Unit:</b> Angular: Radians
        <b>Range:</b> See the joint on which the limit is used for details<br>
        <b>Default:</b> lower = -PI/2, upper = PI/2
        */
        upper: PxReal;
        /**
        \brief the range of the limit. The upper limit must be no lower than the lower limit.

        <b>Unit:</b> Angular: Radians
        <b>Range:</b> See the joint on which the limit is used for details<br>
        <b>Default:</b> lower = -PI/2, upper = PI/2
        */
        lower: PxReal;

        /**
        \brief construct an angular hard limit pair.

        The lower value must be less than the upper value.

        \param[in] lowerLimit	The lower angle of the limit
        \param[in] upperLimit	The upper angle of the limit
        \param[in] contactDist	The distance from the limit at which it becomes active. Default is the lesser of 0.1 radians, and 0.49 * (upperLimit - lowerLimit)

        @see PxJointLimitParameters
        */
        Constructor :: (this: *PxJointAngularLimitPair, lowerLimit: PxReal, upperLimit: PxReal, contactDist: PxReal = -1.0) -> void #cpp_method #foreign physx_lib "??0PxJointAngularLimitPair@physx@@QEAA@MMM@Z";

        /**
        \brief construct an angular soft limit pair.

        The lower value must be less than the upper value.

        \param[in] lowerLimit	The lower angle of the limit
        \param[in] upperLimit	The upper angle of the limit
        \param[in] spring		The stiffness and damping of the limit spring

        @see PxJointLimitParameters
        */
        Constructor :: (this: *PxJointAngularLimitPair, lowerLimit: PxReal, upperLimit: PxReal, spring: *PxSpring) -> void #cpp_method #foreign physx_lib "??0PxJointAngularLimitPair@physx@@QEAA@MMAEBVPxSpring@1@@Z";
        Constructor :: (this: *PxJointAngularLimitPair, lowerLimit: PxReal, upperLimit: PxReal, spring: PxSpring) #no_context {
            Constructor(this, lowerLimit, upperLimit, *spring);
        }

        /**
        \brief Returns true if the limit is valid.

        \return true if the current settings are valid
        */
        isValid :: (this: *PxJointAngularLimitPair) -> bool #cpp_method #foreign physx_lib "?isValid@PxJointAngularLimitPair@physx@@QEBA_NXZ";
    }
    #run {if true then return;
        assert(size_of(type_of(PxJointAngularLimitPair.pxjointlimitparameters)) == 20, "PxJointAngularLimitPair.pxjointlimitparameters has unexpected size % instead of 20", size_of(type_of(PxJointAngularLimitPair.pxjointlimitparameters)));
        instance: PxJointAngularLimitPair;
        assert(((cast(*void)(*instance.upper)) - cast(*void)(*instance)) == 20, "PxJointAngularLimitPair.upper has unexpected offset % instead of 20", ((cast(*void)(*instance.upper)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxJointAngularLimitPair.upper)) == 4, "PxJointAngularLimitPair.upper has unexpected size % instead of 4", size_of(type_of(PxJointAngularLimitPair.upper)));
        assert(((cast(*void)(*instance.lower)) - cast(*void)(*instance)) == 24, "PxJointAngularLimitPair.lower has unexpected offset % instead of 24", ((cast(*void)(*instance.lower)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxJointAngularLimitPair.lower)) == 4, "PxJointAngularLimitPair.lower has unexpected size % instead of 4", size_of(type_of(PxJointAngularLimitPair.lower)));
        assert(size_of(PxJointAngularLimitPair) == 28, "PxJointAngularLimitPair has size % instead of 28", size_of(PxJointAngularLimitPair));
    }

    /**
    \brief Describes an elliptical conical joint limit. Note that very small or highly elliptical limit cones may
    result in jitter.

    @see PxD6Joint PxSphericalJoint
    */
    PxJointLimitCone :: struct {
        #as using pxjointlimitparameters: PxJointLimitParameters;

        /**
        \brief the maximum angle from the Y axis of the constraint frame.

        <b>Unit:</b> Angular: Radians
        <b>Range:</b> Angular: (0,PI)<br>
        <b>Default:</b> PI/2
        */
        yAngle: PxReal;

        /**
        \brief the maximum angle from the Z-axis of the constraint frame.

        <b>Unit:</b> Angular: Radians
        <b>Range:</b> Angular: (0,PI)<br>
        <b>Default:</b> PI/2
        */
        zAngle: PxReal;

        /**
        \brief Construct a cone hard limit.

        \param[in] yLimitAngle	The limit angle from the Y-axis of the constraint frame
        \param[in] zLimitAngle	The limit angle from the Z-axis of the constraint frame
        \param[in] contactDist	The distance from the limit at which it becomes active. Default is the lesser of 0.1 radians, and 0.49 * the lower of the limit angles

        @see PxJointLimitParameters
        */
        Constructor :: (this: *PxJointLimitCone, yLimitAngle: PxReal, zLimitAngle: PxReal, contactDist: PxReal = -1.0) -> void #cpp_method #foreign physx_lib "??0PxJointLimitCone@physx@@QEAA@MMM@Z";

        /**
        \brief Construct a cone soft limit.

        \param[in] yLimitAngle	The limit angle from the Y-axis of the constraint frame
        \param[in] zLimitAngle	The limit angle from the Z-axis of the constraint frame
        \param[in] spring		The stiffness and damping of the limit spring

        @see PxJointLimitParameters
        */
        Constructor :: (this: *PxJointLimitCone, yLimitAngle: PxReal, zLimitAngle: PxReal, spring: *PxSpring) -> void #cpp_method #foreign physx_lib "??0PxJointLimitCone@physx@@QEAA@MMAEBVPxSpring@1@@Z";
        Constructor :: (this: *PxJointLimitCone, yLimitAngle: PxReal, zLimitAngle: PxReal, spring: PxSpring) #no_context {
            Constructor(this, yLimitAngle, zLimitAngle, *spring);
        }

        /**
        \brief Returns true if the limit is valid.

        \return true if the current settings are valid
        */
        isValid :: (this: *PxJointLimitCone) -> bool #cpp_method #foreign physx_lib "?isValid@PxJointLimitCone@physx@@QEBA_NXZ";
    }
    #run {if true then return;
        assert(size_of(type_of(PxJointLimitCone.pxjointlimitparameters)) == 20, "PxJointLimitCone.pxjointlimitparameters has unexpected size % instead of 20", size_of(type_of(PxJointLimitCone.pxjointlimitparameters)));
        instance: PxJointLimitCone;
        assert(((cast(*void)(*instance.yAngle)) - cast(*void)(*instance)) == 20, "PxJointLimitCone.yAngle has unexpected offset % instead of 20", ((cast(*void)(*instance.yAngle)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxJointLimitCone.yAngle)) == 4, "PxJointLimitCone.yAngle has unexpected size % instead of 4", size_of(type_of(PxJointLimitCone.yAngle)));
        assert(((cast(*void)(*instance.zAngle)) - cast(*void)(*instance)) == 24, "PxJointLimitCone.zAngle has unexpected offset % instead of 24", ((cast(*void)(*instance.zAngle)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxJointLimitCone.zAngle)) == 4, "PxJointLimitCone.zAngle has unexpected size % instead of 4", size_of(type_of(PxJointLimitCone.zAngle)));
        assert(size_of(PxJointLimitCone) == 28, "PxJointLimitCone has size % instead of 28", size_of(PxJointLimitCone));
    }

    /**
    \brief Describes a pyramidal joint limit.

    @see PxD6Joint
    */
    PxJointLimitPyramid :: struct {
        #as using pxjointlimitparameters: PxJointLimitParameters;

        /**
        \brief the minimum angle from the Y axis of the constraint frame.

        <b>Unit:</b> Angular: Radians
        <b>Range:</b> Angular: (-PI,PI)<br>
        <b>Default:</b> -PI/2
        */
        yAngleMin: PxReal;

        /**
        \brief the maximum angle from the Y axis of the constraint frame.

        <b>Unit:</b> Angular: Radians
        <b>Range:</b> Angular: (-PI,PI)<br>
        <b>Default:</b> PI/2
        */
        yAngleMax: PxReal;

        /**
        \brief the minimum angle from the Z-axis of the constraint frame.

        <b>Unit:</b> Angular: Radians
        <b>Range:</b> Angular: (-PI,PI)<br>
        <b>Default:</b> -PI/2
        */
        zAngleMin: PxReal;

        /**
        \brief the maximum angle from the Z-axis of the constraint frame.

        <b>Unit:</b> Angular: Radians
        <b>Range:</b> Angular: (-PI,PI)<br>
        <b>Default:</b> PI/2
        */
        zAngleMax: PxReal;

        /**
        \brief Construct a pyramid hard limit.

        \param[in] yLimitAngleMin	The minimum limit angle from the Y-axis of the constraint frame
        \param[in] yLimitAngleMax	The maximum limit angle from the Y-axis of the constraint frame
        \param[in] zLimitAngleMin	The minimum limit angle from the Z-axis of the constraint frame
        \param[in] zLimitAngleMax	The maximum limit angle from the Z-axis of the constraint frame
        \param[in] contactDist		The distance from the limit at which it becomes active. Default is the lesser of 0.1 radians, and 0.49 * the lower of the limit angles

        @see PxJointLimitParameters
        */
        Constructor :: (this: *PxJointLimitPyramid, yLimitAngleMin: PxReal, yLimitAngleMax: PxReal, zLimitAngleMin: PxReal, zLimitAngleMax: PxReal, contactDist: PxReal = -1.0) -> void #cpp_method #foreign physx_lib "??0PxJointLimitPyramid@physx@@QEAA@MMMMM@Z";

        /**
        \brief Construct a pyramid soft limit.

        \param[in] yLimitAngleMin	The minimum limit angle from the Y-axis of the constraint frame
        \param[in] yLimitAngleMax	The maximum limit angle from the Y-axis of the constraint frame
        \param[in] zLimitAngleMin	The minimum limit angle from the Z-axis of the constraint frame
        \param[in] zLimitAngleMax	The maximum limit angle from the Z-axis of the constraint frame
        \param[in] spring			The stiffness and damping of the limit spring

        @see PxJointLimitParameters
        */
        Constructor :: (this: *PxJointLimitPyramid, yLimitAngleMin: PxReal, yLimitAngleMax: PxReal, zLimitAngleMin: PxReal, zLimitAngleMax: PxReal, spring: *PxSpring) -> void #cpp_method #foreign physx_lib "??0PxJointLimitPyramid@physx@@QEAA@MMMMAEBVPxSpring@1@@Z";
        Constructor :: (this: *PxJointLimitPyramid, yLimitAngleMin: PxReal, yLimitAngleMax: PxReal, zLimitAngleMin: PxReal, zLimitAngleMax: PxReal, spring: PxSpring) #no_context {
            Constructor(this, yLimitAngleMin, yLimitAngleMax, zLimitAngleMin, zLimitAngleMax, *spring);
        }

        /**
        \brief Returns true if the limit is valid.

        \return true if the current settings are valid
        */
        isValid :: (this: *PxJointLimitPyramid) -> bool #cpp_method #foreign physx_lib "?isValid@PxJointLimitPyramid@physx@@QEBA_NXZ";
    }
    #run {if true then return;
        assert(size_of(type_of(PxJointLimitPyramid.pxjointlimitparameters)) == 20, "PxJointLimitPyramid.pxjointlimitparameters has unexpected size % instead of 20", size_of(type_of(PxJointLimitPyramid.pxjointlimitparameters)));
        instance: PxJointLimitPyramid;
        assert(((cast(*void)(*instance.yAngleMin)) - cast(*void)(*instance)) == 20, "PxJointLimitPyramid.yAngleMin has unexpected offset % instead of 20", ((cast(*void)(*instance.yAngleMin)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxJointLimitPyramid.yAngleMin)) == 4, "PxJointLimitPyramid.yAngleMin has unexpected size % instead of 4", size_of(type_of(PxJointLimitPyramid.yAngleMin)));
        assert(((cast(*void)(*instance.yAngleMax)) - cast(*void)(*instance)) == 24, "PxJointLimitPyramid.yAngleMax has unexpected offset % instead of 24", ((cast(*void)(*instance.yAngleMax)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxJointLimitPyramid.yAngleMax)) == 4, "PxJointLimitPyramid.yAngleMax has unexpected size % instead of 4", size_of(type_of(PxJointLimitPyramid.yAngleMax)));
        assert(((cast(*void)(*instance.zAngleMin)) - cast(*void)(*instance)) == 28, "PxJointLimitPyramid.zAngleMin has unexpected offset % instead of 28", ((cast(*void)(*instance.zAngleMin)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxJointLimitPyramid.zAngleMin)) == 4, "PxJointLimitPyramid.zAngleMin has unexpected size % instead of 4", size_of(type_of(PxJointLimitPyramid.zAngleMin)));
        assert(((cast(*void)(*instance.zAngleMax)) - cast(*void)(*instance)) == 32, "PxJointLimitPyramid.zAngleMax has unexpected offset % instead of 32", ((cast(*void)(*instance.zAngleMax)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxJointLimitPyramid.zAngleMax)) == 4, "PxJointLimitPyramid.zAngleMax has unexpected size % instead of 4", size_of(type_of(PxJointLimitPyramid.zAngleMax)));
        assert(size_of(PxJointLimitPyramid) == 36, "PxJointLimitPyramid has size % instead of 36", size_of(PxJointLimitPyramid));
    }

    /**
    \brief Flags specific to the prismatic joint.

    @see PxPrismaticJoint
    */
    PxPrismaticJointFlag :: struct {
        Enum :: enum s32 {
            eLIMIT_ENABLED :: 2;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxPrismaticJointFlag) == 1, "PxPrismaticJointFlag has size % instead of 1", size_of(PxPrismaticJointFlag));
    }

    PxPrismaticJointFlags :: PxFlags(PxPrismaticJointFlag.Enum, PxU16);

    /**
    \brief A prismatic joint permits relative translational movement between two bodies along
    an axis, but no relative rotational movement.

    the axis on each body is defined as the line containing the origin of the joint frame and
    extending along the x-axis of that frame

    \image html prismJoint.png

    @see PxPrismaticJointCreate() PxJoint
    */
    PxPrismaticJoint :: struct {
        #as using pxjoint: PxJoint;
        #place pxjoint; pxprismaticjoint_vtable: *PxPrismaticJoint_VTable;
    }
    PxPrismaticJoint_VTable :: struct #type_info_none {
        using pxjoint: PxJoint_VTable;
        getPosition: (this: *PxPrismaticJoint) -> PxReal #cpp_method;

        getVelocity: (this: *PxPrismaticJoint) -> PxReal #cpp_method;

        setLimit: (this: *PxPrismaticJoint, unknown0: *PxJointLinearLimitPair) -> void #cpp_method;

        getLimit: (this: *PxPrismaticJoint) -> PxJointLinearLimitPair #cpp_method #cpp_return_type_is_non_pod;

        setPrismaticJointFlags: (this: *PxPrismaticJoint, flags: PxPrismaticJointFlags) -> void #cpp_method;

        setPrismaticJointFlag: (this: *PxPrismaticJoint, flag: PxPrismaticJointFlag.Enum, value: bool) -> void #cpp_method;

        getPrismaticJointFlags: (this: *PxPrismaticJoint) -> PxPrismaticJointFlags #cpp_method;

        setProjectionLinearTolerance: (this: *PxPrismaticJoint, tolerance: PxReal) -> void #cpp_method;

        getProjectionLinearTolerance: (this: *PxPrismaticJoint) -> PxReal #cpp_method;

        setProjectionAngularTolerance: (this: *PxPrismaticJoint, tolerance: PxReal) -> void #cpp_method;

        getProjectionAngularTolerance: (this: *PxPrismaticJoint) -> PxReal #cpp_method;
    }

    PxPrismaticJoint_getPosition :: inline (this: *PxPrismaticJoint) -> PxReal { return this.pxprismaticjoint_vtable.getPosition(this); }

    PxPrismaticJoint_getVelocity :: inline (this: *PxPrismaticJoint) -> PxReal { return this.pxprismaticjoint_vtable.getVelocity(this); }

    PxPrismaticJoint_setLimit :: inline (this: *PxPrismaticJoint, unknown0: *PxJointLinearLimitPair) { this.pxprismaticjoint_vtable.setLimit(this, unknown0); }

    PxPrismaticJoint_getLimit :: inline (this: *PxPrismaticJoint) -> PxJointLinearLimitPair { return this.pxprismaticjoint_vtable.getLimit(this); }

    PxPrismaticJoint_setPrismaticJointFlags :: inline (this: *PxPrismaticJoint, flags: PxPrismaticJointFlags) { this.pxprismaticjoint_vtable.setPrismaticJointFlags(this, flags); }

    PxPrismaticJoint_setPrismaticJointFlag :: inline (this: *PxPrismaticJoint, flag: PxPrismaticJointFlag.Enum, value: bool) { this.pxprismaticjoint_vtable.setPrismaticJointFlag(this, flag, value); }

    PxPrismaticJoint_getPrismaticJointFlags :: inline (this: *PxPrismaticJoint) -> PxPrismaticJointFlags { return this.pxprismaticjoint_vtable.getPrismaticJointFlags(this); }

    PxPrismaticJoint_setProjectionLinearTolerance :: inline (this: *PxPrismaticJoint, tolerance: PxReal) { this.pxprismaticjoint_vtable.setProjectionLinearTolerance(this, tolerance); }

    PxPrismaticJoint_getProjectionLinearTolerance :: inline (this: *PxPrismaticJoint) -> PxReal { return this.pxprismaticjoint_vtable.getProjectionLinearTolerance(this); }

    PxPrismaticJoint_setProjectionAngularTolerance :: inline (this: *PxPrismaticJoint, tolerance: PxReal) { this.pxprismaticjoint_vtable.setProjectionAngularTolerance(this, tolerance); }

    PxPrismaticJoint_getProjectionAngularTolerance :: inline (this: *PxPrismaticJoint) -> PxReal { return this.pxprismaticjoint_vtable.getProjectionAngularTolerance(this); }

    vtable :: (obj: *PxPrismaticJoint) -> *PxPrismaticJoint_VTable { return obj.pxprismaticjoint_vtable; }

    #run {if true then return;
        assert(size_of(type_of(PxPrismaticJoint.pxjoint)) == 24, "PxPrismaticJoint.pxjoint has unexpected size % instead of 24", size_of(type_of(PxPrismaticJoint.pxjoint)));
        assert(size_of(PxPrismaticJoint) == 24, "PxPrismaticJoint has size % instead of 24", size_of(PxPrismaticJoint));
    }

    /**
    \brief Flags specific to the Revolute Joint.

    @see PxRevoluteJoint
    */
    PxRevoluteJointFlag :: struct {
        Enum :: enum s32 {
            LIMIT_ENABLED  :: 1;
            DRIVE_ENABLED  :: 2;
            DRIVE_FREESPIN :: 4;

            eLIMIT_ENABLED  :: LIMIT_ENABLED;
            eDRIVE_ENABLED  :: DRIVE_ENABLED;
            eDRIVE_FREESPIN :: DRIVE_FREESPIN;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxRevoluteJointFlag) == 1, "PxRevoluteJointFlag has size % instead of 1", size_of(PxRevoluteJointFlag));
    }

    PxRevoluteJointFlags :: PxFlags(PxRevoluteJointFlag.Enum, PxU16);

    /**

    \brief A joint which behaves in a similar way to a hinge or axle.

    A hinge joint removes all but a single rotational degree of freedom from two objects.
    The axis along which the two bodies may rotate is specified with a point and a direction
    vector.

    The position of the hinge on each body is specified by the origin of the body's joint frame.
    The axis of the hinge is specified as the direction of the x-axis in the body's joint frame.

    \image html revoluteJoint.png

    A revolute joint can be given a motor, so that it can apply a force to rotate the attached actors.
    It may also be given a limit, to restrict the revolute motion to within a certain range. In
    addition, the bodies may be projected together if the distance or angle between them exceeds
    a given threshold.

    Projection, drive and limits are activated by setting the appropriate flags on the joint.

    @see PxRevoluteJointCreate() PxJoint
    */
    PxRevoluteJoint :: struct {
        #as using pxjoint: PxJoint;
        #place pxjoint; pxrevolutejoint_vtable: *PxRevoluteJoint_VTable;
    }
    PxRevoluteJoint_VTable :: struct #type_info_none {
        using pxjoint: PxJoint_VTable;
        getAngle: (this: *PxRevoluteJoint) -> PxReal #cpp_method;

        getVelocity: (this: *PxRevoluteJoint) -> PxReal #cpp_method;

        setLimit: (this: *PxRevoluteJoint, limits: *PxJointAngularLimitPair) -> void #cpp_method;

        getLimit: (this: *PxRevoluteJoint) -> PxJointAngularLimitPair #cpp_method #cpp_return_type_is_non_pod;

        setDriveVelocity: (this: *PxRevoluteJoint, velocity: PxReal, autowake := true) -> void #cpp_method;

        getDriveVelocity: (this: *PxRevoluteJoint) -> PxReal #cpp_method;

        setDriveForceLimit: (this: *PxRevoluteJoint, limit: PxReal) -> void #cpp_method;

        getDriveForceLimit: (this: *PxRevoluteJoint) -> PxReal #cpp_method;

        setDriveGearRatio: (this: *PxRevoluteJoint, ratio: PxReal) -> void #cpp_method;

        getDriveGearRatio: (this: *PxRevoluteJoint) -> PxReal #cpp_method;

        setRevoluteJointFlags: (this: *PxRevoluteJoint, flags: PxRevoluteJointFlags) -> void #cpp_method;

        setRevoluteJointFlag: (this: *PxRevoluteJoint, flag: PxRevoluteJointFlag.Enum, value: bool) -> void #cpp_method;

        getRevoluteJointFlags: (this: *PxRevoluteJoint) -> PxRevoluteJointFlags #cpp_method;

        setProjectionLinearTolerance: (this: *PxRevoluteJoint, tolerance: PxReal) -> void #cpp_method;

        getProjectionLinearTolerance: (this: *PxRevoluteJoint) -> PxReal #cpp_method;

        setProjectionAngularTolerance: (this: *PxRevoluteJoint, tolerance: PxReal) -> void #cpp_method;

        getProjectionAngularTolerance: (this: *PxRevoluteJoint) -> PxReal #cpp_method;
    }

    PxRevoluteJoint_getAngle :: inline (this: *PxRevoluteJoint) -> PxReal { return this.pxrevolutejoint_vtable.getAngle(this); }

    PxRevoluteJoint_getVelocity :: inline (this: *PxRevoluteJoint) -> PxReal { return this.pxrevolutejoint_vtable.getVelocity(this); }

    PxRevoluteJoint_setLimit :: inline (this: *PxRevoluteJoint, limits: *PxJointAngularLimitPair) { this.pxrevolutejoint_vtable.setLimit(this, limits); }

    PxRevoluteJoint_getLimit :: inline (this: *PxRevoluteJoint) -> PxJointAngularLimitPair { return this.pxrevolutejoint_vtable.getLimit(this); }

    PxRevoluteJoint_setDriveVelocity :: inline (this: *PxRevoluteJoint, velocity: PxReal, autowake := true) { this.pxrevolutejoint_vtable.setDriveVelocity(this, velocity, autowake); }

    PxRevoluteJoint_getDriveVelocity :: inline (this: *PxRevoluteJoint) -> PxReal { return this.pxrevolutejoint_vtable.getDriveVelocity(this); }

    PxRevoluteJoint_setDriveForceLimit :: inline (this: *PxRevoluteJoint, limit: PxReal) { this.pxrevolutejoint_vtable.setDriveForceLimit(this, limit); }

    PxRevoluteJoint_getDriveForceLimit :: inline (this: *PxRevoluteJoint) -> PxReal { return this.pxrevolutejoint_vtable.getDriveForceLimit(this); }

    PxRevoluteJoint_setDriveGearRatio :: inline (this: *PxRevoluteJoint, ratio: PxReal) { this.pxrevolutejoint_vtable.setDriveGearRatio(this, ratio); }

    PxRevoluteJoint_getDriveGearRatio :: inline (this: *PxRevoluteJoint) -> PxReal { return this.pxrevolutejoint_vtable.getDriveGearRatio(this); }

    PxRevoluteJoint_setRevoluteJointFlags :: inline (this: *PxRevoluteJoint, flags: PxRevoluteJointFlags) { this.pxrevolutejoint_vtable.setRevoluteJointFlags(this, flags); }

    PxRevoluteJoint_setRevoluteJointFlag :: inline (this: *PxRevoluteJoint, flag: PxRevoluteJointFlag.Enum, value: bool) { this.pxrevolutejoint_vtable.setRevoluteJointFlag(this, flag, value); }

    PxRevoluteJoint_getRevoluteJointFlags :: inline (this: *PxRevoluteJoint) -> PxRevoluteJointFlags { return this.pxrevolutejoint_vtable.getRevoluteJointFlags(this); }

    PxRevoluteJoint_setProjectionLinearTolerance :: inline (this: *PxRevoluteJoint, tolerance: PxReal) { this.pxrevolutejoint_vtable.setProjectionLinearTolerance(this, tolerance); }

    PxRevoluteJoint_getProjectionLinearTolerance :: inline (this: *PxRevoluteJoint) -> PxReal { return this.pxrevolutejoint_vtable.getProjectionLinearTolerance(this); }

    PxRevoluteJoint_setProjectionAngularTolerance :: inline (this: *PxRevoluteJoint, tolerance: PxReal) { this.pxrevolutejoint_vtable.setProjectionAngularTolerance(this, tolerance); }

    PxRevoluteJoint_getProjectionAngularTolerance :: inline (this: *PxRevoluteJoint) -> PxReal { return this.pxrevolutejoint_vtable.getProjectionAngularTolerance(this); }

    vtable :: (obj: *PxRevoluteJoint) -> *PxRevoluteJoint_VTable { return obj.pxrevolutejoint_vtable; }

    #run {if true then return;
        assert(size_of(type_of(PxRevoluteJoint.pxjoint)) == 24, "PxRevoluteJoint.pxjoint has unexpected size % instead of 24", size_of(type_of(PxRevoluteJoint.pxjoint)));
        assert(size_of(PxRevoluteJoint) == 24, "PxRevoluteJoint has size % instead of 24", size_of(PxRevoluteJoint));
    }

    /**
    \brief Flags specific to the spherical joint.

    @see PxSphericalJoint
    */
    PxSphericalJointFlag :: struct {
        Enum :: enum s32 {
            eLIMIT_ENABLED :: 2;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxSphericalJointFlag) == 1, "PxSphericalJointFlag has size % instead of 1", size_of(PxSphericalJointFlag));
    }

    PxSphericalJointFlags :: PxFlags(PxSphericalJointFlag.Enum, PxU16);

    /**
    \brief A joint which behaves in a similar way to a ball and socket.

    A spherical joint removes all linear degrees of freedom from two objects.

    The position of the joint on each actor is specified by the origin of the body's joint frame.

    A spherical joint may have a cone limit, to restrict the motion to within a certain range. In
    addition, the bodies may be projected together if the distance between them exceeds a given threshold.

    Projection, drive and limits are activated by setting the appropriate flags on the joint.

    @see PxRevoluteJointCreate() PxJoint
    */
    PxSphericalJoint :: struct {
        #as using pxjoint: PxJoint;
        #place pxjoint; pxsphericaljoint_vtable: *PxSphericalJoint_VTable;
    }
    PxSphericalJoint_VTable :: struct #type_info_none {
        using pxjoint: PxJoint_VTable;
        getLimitCone: (this: *PxSphericalJoint) -> PxJointLimitCone #cpp_method #cpp_return_type_is_non_pod;

        setLimitCone: (this: *PxSphericalJoint, limit: *PxJointLimitCone) -> void #cpp_method;

        getSwingYAngle: (this: *PxSphericalJoint) -> PxReal #cpp_method;

        getSwingZAngle: (this: *PxSphericalJoint) -> PxReal #cpp_method;

        setSphericalJointFlags: (this: *PxSphericalJoint, flags: PxSphericalJointFlags) -> void #cpp_method;

        setSphericalJointFlag: (this: *PxSphericalJoint, flag: PxSphericalJointFlag.Enum, value: bool) -> void #cpp_method;

        getSphericalJointFlags: (this: *PxSphericalJoint) -> PxSphericalJointFlags #cpp_method;

        setProjectionLinearTolerance: (this: *PxSphericalJoint, tolerance: PxReal) -> void #cpp_method;

        getProjectionLinearTolerance: (this: *PxSphericalJoint) -> PxReal #cpp_method;
    }

    PxSphericalJoint_getLimitCone :: inline (this: *PxSphericalJoint) -> PxJointLimitCone { return this.pxsphericaljoint_vtable.getLimitCone(this); }

    PxSphericalJoint_setLimitCone :: inline (this: *PxSphericalJoint, limit: *PxJointLimitCone) { this.pxsphericaljoint_vtable.setLimitCone(this, limit); }

    PxSphericalJoint_getSwingYAngle :: inline (this: *PxSphericalJoint) -> PxReal { return this.pxsphericaljoint_vtable.getSwingYAngle(this); }

    PxSphericalJoint_getSwingZAngle :: inline (this: *PxSphericalJoint) -> PxReal { return this.pxsphericaljoint_vtable.getSwingZAngle(this); }

    PxSphericalJoint_setSphericalJointFlags :: inline (this: *PxSphericalJoint, flags: PxSphericalJointFlags) { this.pxsphericaljoint_vtable.setSphericalJointFlags(this, flags); }

    PxSphericalJoint_setSphericalJointFlag :: inline (this: *PxSphericalJoint, flag: PxSphericalJointFlag.Enum, value: bool) { this.pxsphericaljoint_vtable.setSphericalJointFlag(this, flag, value); }

    PxSphericalJoint_getSphericalJointFlags :: inline (this: *PxSphericalJoint) -> PxSphericalJointFlags { return this.pxsphericaljoint_vtable.getSphericalJointFlags(this); }

    PxSphericalJoint_setProjectionLinearTolerance :: inline (this: *PxSphericalJoint, tolerance: PxReal) { this.pxsphericaljoint_vtable.setProjectionLinearTolerance(this, tolerance); }

    PxSphericalJoint_getProjectionLinearTolerance :: inline (this: *PxSphericalJoint) -> PxReal { return this.pxsphericaljoint_vtable.getProjectionLinearTolerance(this); }

    vtable :: (obj: *PxSphericalJoint) -> *PxSphericalJoint_VTable { return obj.pxsphericaljoint_vtable; }

    #run {if true then return;
        assert(size_of(type_of(PxSphericalJoint.pxjoint)) == 24, "PxSphericalJoint.pxjoint has unexpected size % instead of 24", size_of(type_of(PxSphericalJoint.pxjoint)));
        assert(size_of(PxSphericalJoint) == 24, "PxSphericalJoint has size % instead of 24", size_of(PxSphericalJoint));
    }

    /**
    \brief Used to specify one of the degrees of freedom of  a D6 joint.

    @see PxD6Joint
    */
    PxD6Axis :: struct {
        Enum :: enum s32 {
            X      :: 0;
            Y      :: 1;
            Z      :: 2;
            TWIST  :: 3;
            SWING1 :: 4;
            SWING2 :: 5;
            COUNT  :: 6;

            eX      :: X;
            eY      :: Y;
            eZ      :: Z;
            eTWIST  :: TWIST;
            eSWING1 :: SWING1;
            eSWING2 :: SWING2;
            eCOUNT  :: COUNT;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxD6Axis) == 1, "PxD6Axis has size % instead of 1", size_of(PxD6Axis));
    }

    /**
    \brief Used to specify the range of motions allowed for a degree of freedom in a D6 joint.

    @see PxD6Joint
    */
    PxD6Motion :: struct {
        Enum :: enum s32 {
            LOCKED  :: 0;
            LIMITED :: 1;
            FREE    :: 2;

            eLOCKED  :: LOCKED;
            eLIMITED :: LIMITED;
            eFREE    :: FREE;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxD6Motion) == 1, "PxD6Motion has size % instead of 1", size_of(PxD6Motion));
    }

    /**
    \brief Used to specify which axes of a D6 joint are driven.

    Each drive is an implicit force-limited damped spring:

    force = spring * (target position - position) + damping * (targetVelocity - velocity)

    Alternatively, the spring may be configured to generate a specified acceleration instead of a force.

    A linear axis is affected by drive only if the corresponding drive flag is set. There are two possible models
    for angular drive: swing/twist, which may be used to drive one or more angular degrees of freedom, or slerp,
    which may only be used to drive all three angular degrees simultaneously.

    @see PxD6Joint
    */
    PxD6Drive :: struct {
        Enum :: enum s32 {
            X     :: 0;
            Y     :: 1;
            Z     :: 2;
            SWING :: 3;
            TWIST :: 4;
            SLERP :: 5;
            COUNT :: 6;

            eX     :: X;
            eY     :: Y;
            eZ     :: Z;
            eSWING :: SWING;
            eTWIST :: TWIST;
            eSLERP :: SLERP;
            eCOUNT :: COUNT;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxD6Drive) == 1, "PxD6Drive has size % instead of 1", size_of(PxD6Drive));
    }

    /**
    \brief flags for configuring the drive model of a PxD6Joint

    @see PxD6JointDrive PxD6Joint
    */
    PxD6JointDriveFlag :: struct {
        Enum :: enum s32 {
            eACCELERATION :: 1;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxD6JointDriveFlag) == 1, "PxD6JointDriveFlag has size % instead of 1", size_of(PxD6JointDriveFlag));
    }

    PxD6JointDriveFlags :: PxFlags(PxD6JointDriveFlag.Enum, PxU32);

    /**
    \brief parameters for configuring the drive model of a PxD6Joint

    @see PxD6Joint
    */
    PxD6JointDrive :: struct {
        #as using pxspring: PxSpring;

        forceLimit: PxReal; //!< the force limit of the drive - may be an impulse or a force depending on PxConstraintFlag::eDRIVE_LIMITS_ARE_FORCES
        flags:      PxD6JointDriveFlags; //!< the joint drive flags

        /**
        \brief default constructor for PxD6JointDrive.
        */
        Constructor :: (this: *PxD6JointDrive) -> void #cpp_method #foreign physx_lib "??0PxD6JointDrive@physx@@QEAA@XZ";

        /**
        \brief constructor a PxD6JointDrive.

        \param[in] driveStiffness	The stiffness of the drive spring.
        \param[in] driveDamping		The damping of the drive spring
        \param[in] driveForceLimit	The maximum impulse or force that can be exerted by the drive
        \param[in] isAcceleration	Whether the drive is an acceleration drive or a force drive
        */
        Constructor :: (this: *PxD6JointDrive, driveStiffness: PxReal, driveDamping: PxReal, driveForceLimit: PxReal, isAcceleration := false) -> void #cpp_method #foreign physx_lib "??0PxD6JointDrive@physx@@QEAA@MMM_N@Z";

        /**
        \brief returns true if the drive is valid
        */
        isValid :: (this: *PxD6JointDrive) -> bool #cpp_method #foreign physx_lib "?isValid@PxD6JointDrive@physx@@QEBA_NXZ";
    }
    #run {if true then return;
        assert(size_of(type_of(PxD6JointDrive.pxspring)) == 8, "PxD6JointDrive.pxspring has unexpected size % instead of 8", size_of(type_of(PxD6JointDrive.pxspring)));
        instance: PxD6JointDrive;
        assert(((cast(*void)(*instance.forceLimit)) - cast(*void)(*instance)) == 8, "PxD6JointDrive.forceLimit has unexpected offset % instead of 8", ((cast(*void)(*instance.forceLimit)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxD6JointDrive.forceLimit)) == 4, "PxD6JointDrive.forceLimit has unexpected size % instead of 4", size_of(type_of(PxD6JointDrive.forceLimit)));
        assert(((cast(*void)(*instance.flags)) - cast(*void)(*instance)) == 12, "PxD6JointDrive.flags has unexpected offset % instead of 12", ((cast(*void)(*instance.flags)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxD6JointDrive.flags)) == 4, "PxD6JointDrive.flags has unexpected size % instead of 4", size_of(type_of(PxD6JointDrive.flags)));
        assert(size_of(PxD6JointDrive) == 16, "PxD6JointDrive has size % instead of 16", size_of(PxD6JointDrive));
    }

    /**
    \brief A D6 joint is a general constraint between two actors.

    It allows the application to individually define the linear and rotational degrees of freedom,
    and also to configure a variety of limits and driven degrees of freedom.

    By default all degrees of freedom are locked. So to create a prismatic joint with free motion
    along the x-axis:

    \code
    ...
    joint->setMotion(PxD6Axis::eX, PxD6JointMotion::eFREE);
    ...
    \endcode

    Or a Revolute joint with motion free allowed around the x-axis:

    \code
    ...
    joint->setMotion(PxD6Axis::eTWIST, PxD6JointMotion::eFREE);
    ...
    \endcode

    Degrees of freedom may also be set to limited instead of locked.

    There are two different kinds of linear limits available. The first kind is a single limit value
    for all linear degrees of freedom, which may act as a linear, circular, or spherical limit depending
    on which degrees of freedom are limited. This is similar to a distance limit. Then, the second kind
    supports a pair of limit values for each linear axis, which can be used to implement a traditional
    prismatic joint for example.

    If the twist degree of freedom is limited, is supports upper and lower limits. The two swing degrees
    of freedom are limited with a cone limit.
    @see PxD6JointCreate() PxJoint
    */
    PxD6Joint :: struct {
        #as using pxjoint: PxJoint;

        /**
        \brief get the twist angle of the joint

        \deprecated Use getTwistAngle instead. Deprecated since PhysX version 4.0
        */
        getTwist :: (this: *PxD6Joint) -> PxReal #cpp_method #foreign physx_lib "?getTwist@PxD6Joint@physx@@QEBAMXZ";

        /**
        \deprecated Use setDistanceLimit instead. Deprecated since PhysX version 4.0
        */
        setLinearLimit :: (this: *PxD6Joint, limit: *PxJointLinearLimit) -> void #cpp_method #foreign physx_lib "?setLinearLimit@PxD6Joint@physx@@QEAAXAEBVPxJointLinearLimit@2@@Z";
        setLinearLimit :: (this: *PxD6Joint, limit: PxJointLinearLimit) #no_context {
            setLinearLimit(this, *limit);
        }

        /**
        \deprecated Use getDistanceLimit instead. Deprecated since PhysX version 4.0
        */
        getLinearLimit :: (this: *PxD6Joint) -> PxJointLinearLimit #cpp_method #cpp_return_type_is_non_pod #foreign physx_lib "?getLinearLimit@PxD6Joint@physx@@QEBA?AVPxJointLinearLimit@2@XZ";
        #place pxjoint; pxd6joint_vtable: *PxD6Joint_VTable;
    }
    PxD6Joint_VTable :: struct #type_info_none {
        using pxjoint: PxJoint_VTable;
        setMotion: (this: *PxD6Joint, axis: PxD6Axis.Enum, type: PxD6Motion.Enum) -> void #cpp_method;

        getMotion: (this: *PxD6Joint, axis: PxD6Axis.Enum) -> PxD6Motion.Enum #cpp_method;

        getTwistAngle: (this: *PxD6Joint) -> PxReal #cpp_method;

        getSwingYAngle: (this: *PxD6Joint) -> PxReal #cpp_method;

        getSwingZAngle: (this: *PxD6Joint) -> PxReal #cpp_method;

        setDistanceLimit: (this: *PxD6Joint, limit: *PxJointLinearLimit) -> void #cpp_method;

        getDistanceLimit: (this: *PxD6Joint) -> PxJointLinearLimit #cpp_method #cpp_return_type_is_non_pod;

        setLinearLimit: (this: *PxD6Joint, axis: PxD6Axis.Enum, limit: *PxJointLinearLimitPair) -> void #cpp_method;

        getLinearLimit: (this: *PxD6Joint, axis: PxD6Axis.Enum) -> PxJointLinearLimitPair #cpp_method #cpp_return_type_is_non_pod;

        setTwistLimit: (this: *PxD6Joint, limit: *PxJointAngularLimitPair) -> void #cpp_method;

        getTwistLimit: (this: *PxD6Joint) -> PxJointAngularLimitPair #cpp_method #cpp_return_type_is_non_pod;

        setSwingLimit: (this: *PxD6Joint, limit: *PxJointLimitCone) -> void #cpp_method;

        getSwingLimit: (this: *PxD6Joint) -> PxJointLimitCone #cpp_method #cpp_return_type_is_non_pod;

        setPyramidSwingLimit: (this: *PxD6Joint, limit: *PxJointLimitPyramid) -> void #cpp_method;

        getPyramidSwingLimit: (this: *PxD6Joint) -> PxJointLimitPyramid #cpp_method #cpp_return_type_is_non_pod;

        setDrive: (this: *PxD6Joint, index: PxD6Drive.Enum, drive: *PxD6JointDrive) -> void #cpp_method;

        getDrive: (this: *PxD6Joint, index: PxD6Drive.Enum) -> PxD6JointDrive #cpp_method #cpp_return_type_is_non_pod;

        setDrivePosition: (this: *PxD6Joint, pose: *PxTransform, autowake := true) -> void #cpp_method;

        getDrivePosition: (this: *PxD6Joint) -> PxTransform #cpp_method #cpp_return_type_is_non_pod;

        setDriveVelocity: (this: *PxD6Joint, linear: *PxVec3, angular: *PxVec3, autowake := true) -> void #cpp_method;

        getDriveVelocity: (this: *PxD6Joint, linear: *PxVec3, angular: *PxVec3) -> void #cpp_method;

        setProjectionLinearTolerance: (this: *PxD6Joint, tolerance: PxReal) -> void #cpp_method;

        getProjectionLinearTolerance: (this: *PxD6Joint) -> PxReal #cpp_method;

        setProjectionAngularTolerance: (this: *PxD6Joint, tolerance: PxReal) -> void #cpp_method;

        getProjectionAngularTolerance: (this: *PxD6Joint) -> PxReal #cpp_method;
    }

    PxD6Joint_setMotion :: inline (this: *PxD6Joint, axis: PxD6Axis.Enum, type: PxD6Motion.Enum) { this.pxd6joint_vtable.setMotion(this, axis, type); }

    PxD6Joint_getMotion :: inline (this: *PxD6Joint, axis: PxD6Axis.Enum) -> PxD6Motion.Enum { return this.pxd6joint_vtable.getMotion(this, axis); }

    PxD6Joint_getTwistAngle :: inline (this: *PxD6Joint) -> PxReal { return this.pxd6joint_vtable.getTwistAngle(this); }

    PxD6Joint_getSwingYAngle :: inline (this: *PxD6Joint) -> PxReal { return this.pxd6joint_vtable.getSwingYAngle(this); }

    PxD6Joint_getSwingZAngle :: inline (this: *PxD6Joint) -> PxReal { return this.pxd6joint_vtable.getSwingZAngle(this); }

    PxD6Joint_setDistanceLimit :: inline (this: *PxD6Joint, limit: *PxJointLinearLimit) { this.pxd6joint_vtable.setDistanceLimit(this, limit); }

    PxD6Joint_getDistanceLimit :: inline (this: *PxD6Joint) -> PxJointLinearLimit { return this.pxd6joint_vtable.getDistanceLimit(this); }

    PxD6Joint_setLinearLimit :: inline (this: *PxD6Joint, axis: PxD6Axis.Enum, limit: *PxJointLinearLimitPair) { this.pxd6joint_vtable.setLinearLimit(this, axis, limit); }

    PxD6Joint_getLinearLimit :: inline (this: *PxD6Joint, axis: PxD6Axis.Enum) -> PxJointLinearLimitPair { return this.pxd6joint_vtable.getLinearLimit(this, axis); }

    PxD6Joint_setTwistLimit :: inline (this: *PxD6Joint, limit: *PxJointAngularLimitPair) { this.pxd6joint_vtable.setTwistLimit(this, limit); }

    PxD6Joint_getTwistLimit :: inline (this: *PxD6Joint) -> PxJointAngularLimitPair { return this.pxd6joint_vtable.getTwistLimit(this); }

    PxD6Joint_setSwingLimit :: inline (this: *PxD6Joint, limit: *PxJointLimitCone) { this.pxd6joint_vtable.setSwingLimit(this, limit); }

    PxD6Joint_getSwingLimit :: inline (this: *PxD6Joint) -> PxJointLimitCone { return this.pxd6joint_vtable.getSwingLimit(this); }

    PxD6Joint_setPyramidSwingLimit :: inline (this: *PxD6Joint, limit: *PxJointLimitPyramid) { this.pxd6joint_vtable.setPyramidSwingLimit(this, limit); }

    PxD6Joint_getPyramidSwingLimit :: inline (this: *PxD6Joint) -> PxJointLimitPyramid { return this.pxd6joint_vtable.getPyramidSwingLimit(this); }

    PxD6Joint_setDrive :: inline (this: *PxD6Joint, index: PxD6Drive.Enum, drive: *PxD6JointDrive) { this.pxd6joint_vtable.setDrive(this, index, drive); }

    PxD6Joint_getDrive :: inline (this: *PxD6Joint, index: PxD6Drive.Enum) -> PxD6JointDrive { return this.pxd6joint_vtable.getDrive(this, index); }

    PxD6Joint_setDrivePosition :: inline (this: *PxD6Joint, pose: *PxTransform, autowake := true) { this.pxd6joint_vtable.setDrivePosition(this, pose, autowake); }

    PxD6Joint_getDrivePosition :: inline (this: *PxD6Joint) -> PxTransform { return this.pxd6joint_vtable.getDrivePosition(this); }

    PxD6Joint_setDriveVelocity :: inline (this: *PxD6Joint, linear: *PxVec3, angular: *PxVec3, autowake := true) { this.pxd6joint_vtable.setDriveVelocity(this, linear, angular, autowake); }

    PxD6Joint_getDriveVelocity :: inline (this: *PxD6Joint, linear: *PxVec3, angular: *PxVec3) { this.pxd6joint_vtable.getDriveVelocity(this, linear, angular); }

    PxD6Joint_setProjectionLinearTolerance :: inline (this: *PxD6Joint, tolerance: PxReal) { this.pxd6joint_vtable.setProjectionLinearTolerance(this, tolerance); }

    PxD6Joint_getProjectionLinearTolerance :: inline (this: *PxD6Joint) -> PxReal { return this.pxd6joint_vtable.getProjectionLinearTolerance(this); }

    PxD6Joint_setProjectionAngularTolerance :: inline (this: *PxD6Joint, tolerance: PxReal) { this.pxd6joint_vtable.setProjectionAngularTolerance(this, tolerance); }

    PxD6Joint_getProjectionAngularTolerance :: inline (this: *PxD6Joint) -> PxReal { return this.pxd6joint_vtable.getProjectionAngularTolerance(this); }

    vtable :: (obj: *PxD6Joint) -> *PxD6Joint_VTable { return obj.pxd6joint_vtable; }

    #run {if true then return;
        assert(size_of(type_of(PxD6Joint.pxjoint)) == 24, "PxD6Joint.pxjoint has unexpected size % instead of 24", size_of(type_of(PxD6Joint.pxjoint)));
        assert(size_of(PxD6Joint) == 24, "PxD6Joint has size % instead of 24", size_of(PxD6Joint));
    }

    /**
    \brief 64-bit mask used for collision filtering.

    The collision filtering equation for 2 objects o0 and o1 is:

    <pre> (G0 op0 K0) op2 (G1 op1 K1) == b </pre>

    with

    <ul>
    <li> G0 = PxGroupsMask for object o0. See PxSetGroupsMask </li>
    <li> G1 = PxGroupsMask for object o1. See PxSetGroupsMask </li>
    <li> K0 = filtering constant 0. See PxSetFilterConstants </li>
    <li> K1 = filtering constant 1. See PxSetFilterConstants </li>
    <li> b = filtering boolean. See PxSetFilterBool </li>
    <li> op0, op1, op2 = filtering operations. See PxSetFilterOps </li>
    </ul>

    If the filtering equation is true, collision detection is enabled.

    @see PxSetFilterOps()
    */
    PxGroupsMask :: struct {
        Constructor :: (this: *PxGroupsMask) -> void #cpp_method #foreign physx_lib "??0PxGroupsMask@physx@@QEAA@XZ";
        Destructor :: (this: *PxGroupsMask) -> void #cpp_method #foreign physx_lib "??1PxGroupsMask@physx@@QEAA@XZ";

        bits0: PxU16;
        bits1: PxU16;
        bits2: PxU16;
        bits3: PxU16;
    }
    #run {if true then return;
        instance: PxGroupsMask;
        assert(((cast(*void)(*instance.bits0)) - cast(*void)(*instance)) == 0, "PxGroupsMask.bits0 has unexpected offset % instead of 0", ((cast(*void)(*instance.bits0)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxGroupsMask.bits0)) == 2, "PxGroupsMask.bits0 has unexpected size % instead of 2", size_of(type_of(PxGroupsMask.bits0)));
        assert(((cast(*void)(*instance.bits1)) - cast(*void)(*instance)) == 2, "PxGroupsMask.bits1 has unexpected offset % instead of 2", ((cast(*void)(*instance.bits1)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxGroupsMask.bits1)) == 2, "PxGroupsMask.bits1 has unexpected size % instead of 2", size_of(type_of(PxGroupsMask.bits1)));
        assert(((cast(*void)(*instance.bits2)) - cast(*void)(*instance)) == 4, "PxGroupsMask.bits2 has unexpected offset % instead of 4", ((cast(*void)(*instance.bits2)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxGroupsMask.bits2)) == 2, "PxGroupsMask.bits2 has unexpected size % instead of 2", size_of(type_of(PxGroupsMask.bits2)));
        assert(((cast(*void)(*instance.bits3)) - cast(*void)(*instance)) == 6, "PxGroupsMask.bits3 has unexpected offset % instead of 6", ((cast(*void)(*instance.bits3)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxGroupsMask.bits3)) == 2, "PxGroupsMask.bits3 has unexpected size % instead of 2", size_of(type_of(PxGroupsMask.bits3)));
        assert(size_of(PxGroupsMask) == 8, "PxGroupsMask has size % instead of 8", size_of(PxGroupsMask));
    }

    /**
    \brief Collision filtering operations.

    @see PxGroupsMask
    */
    PxFilterOp :: struct {
        Enum :: enum s32 {
            AND      :: 0;
            OR       :: 1;
            XOR      :: 2;
            NAND     :: 3;
            NOR      :: 4;
            NXOR     :: 5;
            SWAP_AND :: 6;

            PX_FILTEROP_AND      :: AND;
            PX_FILTEROP_OR       :: OR;
            PX_FILTEROP_XOR      :: XOR;
            PX_FILTEROP_NAND     :: NAND;
            PX_FILTEROP_NOR      :: NOR;
            PX_FILTEROP_NXOR     :: NXOR;
            PX_FILTEROP_SWAP_AND :: SWAP_AND;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxFilterOp) == 1, "PxFilterOp has size % instead of 1", size_of(PxFilterOp));
    }

    /**
    \brief default implementation of the error callback

    This class is provided in order to enable the SDK to be started with the minimum of user code. Typically an application
    will use its own error callback, and log the error to file or otherwise make it visible. Warnings and error messages from
    the SDK are usually indicative that changes are required in order for PhysX to function correctly, and should not be ignored.
    */
    PxDefaultErrorCallback :: struct {
        #as using pxerrorcallback: PxErrorCallback;
    }
    #run {if true then return;
        assert(size_of(type_of(PxDefaultErrorCallback.pxerrorcallback)) == 8, "PxDefaultErrorCallback.pxerrorcallback has unexpected size % instead of 8", size_of(type_of(PxDefaultErrorCallback.pxerrorcallback)));
        assert(size_of(PxDefaultErrorCallback) == 8, "PxDefaultErrorCallback has size % instead of 8", size_of(PxDefaultErrorCallback));
    }

    /**
    \brief utility functions for use with PxRigidActor and subclasses

    @see PxRigidActor PxRigidStatic PxRigidBody PxRigidDynamic PxArticulationLink
    */
    PxRigidActorExt :: struct {
        /**
        \brief Creates a new shape with default properties and a list of materials and adds it to the list of shapes of this actor.

        This is equivalent to the following

        PxShape* shape(...) = PxGetPhysics().createShape(...);	// reference count is 1
        actor->attachShape(shape);								// increments reference count
        shape->release();										// releases user reference, leaving reference count at 1

        As a consequence, detachShape() will result in the release of the last reference, and the shape will be deleted.

        \note The default shape flags to be set are: eVISUALIZATION, eSIMULATION_SHAPE, eSCENE_QUERY_SHAPE (see #PxShapeFlag).
        Triangle mesh, heightfield or plane geometry shapes configured as eSIMULATION_SHAPE are not supported for
        non-kinematic PxRigidDynamic instances.

        \note Creating compounds with a very large number of shapes may adversely affect performance and stability.

        <b>Sleeping:</b> Does <b>NOT</b> wake the actor up automatically.

        \param[in] actor the actor to which to attach the shape
        \param[in] geometry	the geometry of the shape
        \param[in] materials a pointer to an array of material pointers
        \param[in] materialCount the count of materials
        \param[in] shapeFlags optional PxShapeFlags

        \return The newly created shape.

        @see PxShape PxShape::release(), PxPhysics::createShape(), PxRigidActor::attachShape()
        */
        createExclusiveShape :: (actor: *PxRigidActor, geometry: *PxGeometry, materials: **PxMaterial, materialCount: PxU16, shapeFlags: PxShapeFlags) -> *PxShape #foreign physx_lib "?createExclusiveShape@PxRigidActorExt@physx@@SAPEAVPxShape@2@AEAVPxRigidActor@2@AEBVPxGeometry@2@PEBQEAVPxMaterial@2@GV?$PxFlags@W4Enum@PxShapeFlag@physx@@E@2@@Z";
        createExclusiveShape :: (actor: *PxRigidActor, geometry: PxGeometry, materials: **PxMaterial, materialCount: PxU16, shapeFlags: PxShapeFlags) -> *PxShape #no_context {
            return createExclusiveShape(actor, *geometry, materials, materialCount, shapeFlags);
        }

        /**
        \brief Creates a new shape with default properties and a single material adds it to the list of shapes of this actor.

        This is equivalent to the following

        PxShape* shape(...) = PxGetPhysics().createShape(...);	// reference count is 1
        actor->attachShape(shape);								// increments reference count
        shape->release();										// releases user reference, leaving reference count at 1

        As a consequence, detachShape() will result in the release of the last reference, and the shape will be deleted.

        \note The default shape flags to be set are: eVISUALIZATION, eSIMULATION_SHAPE, eSCENE_QUERY_SHAPE (see #PxShapeFlag).
        Triangle mesh, heightfield or plane geometry shapes configured as eSIMULATION_SHAPE are not supported for
        non-kinematic PxRigidDynamic instances.

        \note Creating compounds with a very large number of shapes may adversely affect performance and stability.

        <b>Sleeping:</b> Does <b>NOT</b> wake the actor up automatically.

        \param[in] actor the actor to which to attach the shape
        \param[in] geometry	the geometry of the shape
        \param[in] material	the material for the shape
        \param[in] shapeFlags optional PxShapeFlags

        \return The newly created shape.

        @see PxShape PxShape::release(), PxPhysics::createShape(), PxRigidActor::attachShape()
        */
        createExclusiveShape :: (actor: *PxRigidActor, geometry: *PxGeometry, material: *PxMaterial, shapeFlags: PxShapeFlags) -> *PxShape #foreign physx_lib "?createExclusiveShape@PxRigidActorExt@physx@@SAPEAVPxShape@2@AEAVPxRigidActor@2@AEBVPxGeometry@2@AEBVPxMaterial@2@V?$PxFlags@W4Enum@PxShapeFlag@physx@@E@2@@Z";
        createExclusiveShape :: (actor: *PxRigidActor, geometry: PxGeometry, material: PxMaterial, shapeFlags: PxShapeFlags) -> *PxShape #no_context {
            return createExclusiveShape(actor, *geometry, *material, shapeFlags);
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxRigidActorExt) == 1, "PxRigidActorExt has size % instead of 1", size_of(PxRigidActorExt));
    }

    /**
    \brief Utility class to compute and manipulate mass and inertia tensor properties.

    In most cases #PxRigidBodyExt::updateMassAndInertia(), #PxRigidBodyExt::setMassAndUpdateInertia() should be enough to
    setup the mass properties of a rigid body. This utility class targets users that need to customize the mass properties
    computation.
    */
    PxMassProperties :: struct {
        /**
        \brief Default constructor.
        */
        Constructor :: (this: *PxMassProperties) -> void #cpp_method #foreign physx_lib "??0PxMassProperties@physx@@QEAA@XZ";

        /**
        \brief Construct from individual elements.
        */
        Constructor :: (this: *PxMassProperties, m: PxReal, inertiaT: *PxMat33, com: *PxVec3) -> void #cpp_method #foreign physx_lib "??0PxMassProperties@physx@@QEAA@MAEBVPxMat33@1@AEBVPxVec3@1@@Z";
        Constructor :: (this: *PxMassProperties, m: PxReal, inertiaT: PxMat33, com: PxVec3) #no_context {
            Constructor(this, m, *inertiaT, *com);
        }

        /**
        \brief Compute mass properties based on a provided geometry structure.

        This constructor assumes the geometry has a density of 1. Mass and inertia tensor scale linearly with density.

        \param[in] geometry The geometry to compute the mass properties for. Supported geometry types are: sphere, box, capsule and convex mesh.
        */
        Constructor :: (this: *PxMassProperties, geometry: *PxGeometry) -> void #cpp_method #foreign physx_lib "??0PxMassProperties@physx@@QEAA@AEBVPxGeometry@1@@Z";
        Constructor :: (this: *PxMassProperties, geometry: PxGeometry) #no_context {
            Constructor(this, *geometry);
        }

        /**
        \brief Translate the center of mass by a given vector and adjust the inertia tensor accordingly.

        \param[in] t The translation vector for the center of mass.
        */
        translate :: (this: *PxMassProperties, t: *PxVec3) -> void #cpp_method #foreign physx_lib "?translate@PxMassProperties@physx@@QEAAXAEBVPxVec3@2@@Z";
        translate :: (this: *PxMassProperties, t: PxVec3) #no_context {
            translate(this, *t);
        }

        /**
        \brief Get the entries of the diagonalized inertia tensor and the corresponding reference rotation.

        \param[in] inertia The inertia tensor to diagonalize.
        \param[out] massFrame The frame the diagonalized tensor refers to.
        \return The entries of the diagonalized inertia tensor.
        */
        getMassSpaceInertia :: (inertia: *PxMat33, massFrame: *PxQuat) -> PxVec3 #cpp_return_type_is_non_pod #foreign physx_lib "?getMassSpaceInertia@PxMassProperties@physx@@SA?AVPxVec3@2@AEBVPxMat33@2@AEAVPxQuat@2@@Z";
        getMassSpaceInertia :: (inertia: PxMat33, massFrame: *PxQuat) -> PxVec3 #no_context {
            return getMassSpaceInertia(*inertia, massFrame);
        }

        /**
        \brief Translate an inertia tensor using the parallel axis theorem

        \param[in] inertia The inertia tensor to translate.
        \param[in] mass The mass of the object.
        \param[in] t The relative frame to translate the inertia tensor to.
        \return The translated inertia tensor.
        */
        translateInertia :: (inertia: *PxMat33, mass: PxReal, t: *PxVec3) -> PxMat33 #cpp_return_type_is_non_pod #foreign physx_lib "?translateInertia@PxMassProperties@physx@@SA?AVPxMat33@2@AEBV32@MAEBVPxVec3@2@@Z";
        translateInertia :: (inertia: PxMat33, mass: PxReal, t: PxVec3) -> PxMat33 #no_context {
            return translateInertia(*inertia, mass, *t);
        }

        /**
        \brief Rotate an inertia tensor around the center of mass

        \param[in] inertia The inertia tensor to rotate.
        \param[in] q The rotation to apply to the inertia tensor.
        \return The rotated inertia tensor.
        */
        rotateInertia :: (inertia: *PxMat33, q: *PxQuat) -> PxMat33 #cpp_return_type_is_non_pod #foreign physx_lib "?rotateInertia@PxMassProperties@physx@@SA?AVPxMat33@2@AEBV32@AEBVPxQuat@2@@Z";
        rotateInertia :: (inertia: PxMat33, q: PxQuat) -> PxMat33 #no_context {
            return rotateInertia(*inertia, *q);
        }

        /**
        \brief Non-uniform scaling of the inertia tensor

        \param[in] inertia The inertia tensor to scale.
        \param[in] scaleRotation The frame of the provided scaling factors.
        \param[in] scale The scaling factor for each axis (relative to the frame specified in scaleRotation).
        \return The scaled inertia tensor.
        */
        scaleInertia :: (inertia: *PxMat33, scaleRotation: *PxQuat, scale: *PxVec3) -> PxMat33 #cpp_return_type_is_non_pod #foreign physx_lib "?scaleInertia@PxMassProperties@physx@@SA?AVPxMat33@2@AEBV32@AEBVPxQuat@2@AEBVPxVec3@2@@Z";
        scaleInertia :: (inertia: PxMat33, scaleRotation: PxQuat, scale: PxVec3) -> PxMat33 #no_context {
            return scaleInertia(*inertia, *scaleRotation, *scale);
        }

        /**
        \brief Sum up individual mass properties.

        \param[in] props Array of mass properties to sum up.
        \param[in] transforms Reference transforms for each mass properties entry.
        \param[in] count The number of mass properties to sum up.
        \return The summed up mass properties.
        */
        sum :: (props: *PxMassProperties, transforms: *PxTransform, count: PxU32) -> PxMassProperties #cpp_return_type_is_non_pod #foreign physx_lib "?sum@PxMassProperties@physx@@SA?AV12@PEBV12@PEBVPxTransform@2@I@Z";

        inertiaTensor: PxMat33; //!< The inertia tensor of the object.
        centerOfMass:  PxVec3; //!< The center of mass of the object.
        mass:          PxReal; //!< The mass of the object.
    }
    #run {if true then return;
        instance: PxMassProperties;
        assert(((cast(*void)(*instance.inertiaTensor)) - cast(*void)(*instance)) == 0, "PxMassProperties.inertiaTensor has unexpected offset % instead of 0", ((cast(*void)(*instance.inertiaTensor)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxMassProperties.inertiaTensor)) == 36, "PxMassProperties.inertiaTensor has unexpected size % instead of 36", size_of(type_of(PxMassProperties.inertiaTensor)));
        assert(((cast(*void)(*instance.centerOfMass)) - cast(*void)(*instance)) == 36, "PxMassProperties.centerOfMass has unexpected offset % instead of 36", ((cast(*void)(*instance.centerOfMass)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxMassProperties.centerOfMass)) == 12, "PxMassProperties.centerOfMass has unexpected size % instead of 12", size_of(type_of(PxMassProperties.centerOfMass)));
        assert(((cast(*void)(*instance.mass)) - cast(*void)(*instance)) == 48, "PxMassProperties.mass has unexpected offset % instead of 48", ((cast(*void)(*instance.mass)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxMassProperties.mass)) == 4, "PxMassProperties.mass has unexpected size % instead of 4", size_of(type_of(PxMassProperties.mass)));
        assert(size_of(PxMassProperties) == 52, "PxMassProperties has size % instead of 52", size_of(PxMassProperties));
    }

    /**
    \brief utility functions for use with PxRigidBody and subclasses

    @see PxRigidBody PxRigidDynamic PxArticulationLink
    */
    PxRigidBodyExt :: struct {
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxRigidBodyExt) == 1, "PxRigidBodyExt has size % instead of 1", size_of(PxRigidBodyExt));
    }

    /**
    \brief utility functions for use with PxShape

    @see PxShape
    */
    PxShapeExt :: struct {
        /**
        \brief Retrieves the world space pose of the shape.

        \param[in] shape The shape for which to get the global pose.
        \param[in] actor The actor to which the shape is attached

        \return Global pose of shape.
        */
        getGlobalPose :: (shape: *PxShape, actor: *PxRigidActor) -> PxTransform #cpp_return_type_is_non_pod #foreign physx_lib "?getGlobalPose@PxShapeExt@physx@@SA?AVPxTransform@2@AEBVPxShape@2@AEBVPxRigidActor@2@@Z";
        getGlobalPose :: (shape: PxShape, actor: PxRigidActor) -> PxTransform #no_context {
            return getGlobalPose(*shape, *actor);
        }

        /**
        \brief Raycast test against the shape.

        \param[in] shape the shape
        \param[in] actor the actor to which the shape is attached
        \param[in] rayOrigin The origin of the ray to test the geometry object against
        \param[in] rayDir The direction of the ray to test the geometry object against
        \param[in] maxDist Maximum ray length
        \param[in] hitFlags Specify which properties per hit should be computed and written to result hit array. Combination of #PxHitFlag flags
        \param[in] maxHits max number of returned hits = size of 'rayHits' buffer
        \param[out] rayHits Raycast hits information
        \return Number of hits between the ray and the shape

        @see PxRaycastHit PxTransform
        */
        raycast :: (shape: *PxShape, actor: *PxRigidActor, rayOrigin: *PxVec3, rayDir: *PxVec3, maxDist: PxReal, hitFlags: PxHitFlags, maxHits: PxU32, rayHits: *PxRaycastHit) -> PxU32 #foreign physx_lib "?raycast@PxShapeExt@physx@@SAIAEBVPxShape@2@AEBVPxRigidActor@2@AEBVPxVec3@2@2MV?$PxFlags@W4Enum@PxHitFlag@physx@@G@2@IPEAUPxRaycastHit@2@@Z";
        raycast :: (shape: PxShape, actor: PxRigidActor, rayOrigin: PxVec3, rayDir: PxVec3, maxDist: PxReal, hitFlags: PxHitFlags, maxHits: PxU32, rayHits: *PxRaycastHit) -> PxU32 #no_context {
            return raycast(*shape, *actor, *rayOrigin, *rayDir, maxDist, hitFlags, maxHits, rayHits);
        }

        /**
        \brief Test overlap between the shape and a geometry object

        \param[in] shape the shape
        \param[in] actor the actor to which the shape is attached
        \param[in] otherGeom The other geometry object to test overlap with
        \param[in] otherGeomPose Pose of the other geometry object
        \return True if the shape overlaps the geometry object

        @see PxGeometry PxTransform
        */
        overlap :: (shape: *PxShape, actor: *PxRigidActor, otherGeom: *PxGeometry, otherGeomPose: *PxTransform) -> bool #foreign physx_lib "?overlap@PxShapeExt@physx@@SA_NAEBVPxShape@2@AEBVPxRigidActor@2@AEBVPxGeometry@2@AEBVPxTransform@2@@Z";
        overlap :: (shape: PxShape, actor: PxRigidActor, otherGeom: PxGeometry, otherGeomPose: PxTransform) -> bool #no_context {
            return overlap(*shape, *actor, *otherGeom, *otherGeomPose);
        }

        /**
        \brief Sweep a geometry object against the shape.

        Currently only box, sphere, capsule and convex mesh shapes are supported, i.e. the swept geometry object must be one of those types.

        \param[in] shape the shape
        \param[in] actor the actor to which the shape is attached
        \param[in] unitDir Normalized direction along which the geometry object should be swept.
        \param[in] distance Sweep distance. Needs to be larger than 0.
        \param[in] otherGeom The geometry object to sweep against the shape
        \param[in] otherGeomPose Pose of the geometry object
        \param[out] sweepHit The sweep hit information. Only valid if this method returns true.
        \param[in] hitFlags Specify which properties per hit should be computed and written to result hit array. Combination of #PxHitFlag flags
        \return True if the swept geometry object hits the shape

        @see PxGeometry PxTransform PxSweepHit
        */
        sweep :: (shape: *PxShape, actor: *PxRigidActor, unitDir: *PxVec3, distance: PxReal, otherGeom: *PxGeometry, otherGeomPose: *PxTransform, sweepHit: *PxSweepHit, hitFlags: PxHitFlags) -> bool #foreign physx_lib "?sweep@PxShapeExt@physx@@SA_NAEBVPxShape@2@AEBVPxRigidActor@2@AEBVPxVec3@2@MAEBVPxGeometry@2@AEBVPxTransform@2@AEAUPxSweepHit@2@V?$PxFlags@W4Enum@PxHitFlag@physx@@G@2@@Z";
        sweep :: (shape: PxShape, actor: PxRigidActor, unitDir: PxVec3, distance: PxReal, otherGeom: PxGeometry, otherGeomPose: PxTransform, sweepHit: *PxSweepHit, hitFlags: PxHitFlags) -> bool #no_context {
            return sweep(*shape, *actor, *unitDir, distance, *otherGeom, *otherGeomPose, sweepHit, hitFlags);
        }

        /**
        \brief Retrieves the axis aligned bounding box enclosing the shape.

        \return The shape's bounding box.

        \param[in] shape the shape
        \param[in] actor the actor to which the shape is attached
        \param[in] inflation  Scale factor for computed world bounds. Box extents are multiplied by this value.

        @see PxBounds3
        */
        getWorldBounds :: (shape: *PxShape, actor: *PxRigidActor, inflation: float = 1.01) -> PxBounds3 #cpp_return_type_is_non_pod #foreign physx_lib "?getWorldBounds@PxShapeExt@physx@@SA?AVPxBounds3@2@AEBVPxShape@2@AEBVPxRigidActor@2@M@Z";
        getWorldBounds :: (shape: PxShape, actor: PxRigidActor, inflation: float = 1.01) -> PxBounds3 #no_context {
            return getWorldBounds(*shape, *actor, inflation);
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxShapeExt) == 1, "PxShapeExt has size % instead of 1", size_of(PxShapeExt));
    }

    /**
    \brief Utility class to find mesh triangles touched by a specified geometry object.

    This class is a helper calling PxMeshQuery::findOverlapTriangleMesh or PxMeshQuery::findOverlapHeightField under the hood,
    while taking care of necessary memory management issues.

    PxMeshQuery::findOverlapTriangleMesh and PxMeshQuery::findOverlapHeightField are the "raw" functions operating on user-provided fixed-size
    buffers. These functions abort with an error code in case of buffer overflow. PxMeshOverlapUtil is a convenient helper function checking
    this error code, and resizing buffers appropriately, until the desired call succeeds.

    Returned triangle indices are stored within the class, and can be used with PxMeshQuery::getTriangle() to retrieve the triangle properties.
    */
    PxMeshOverlapUtil :: struct {
        /**
        \brief Retrieves array of triangle indices after a findOverlap call.
        \return Indices of touched triangles
        */
        getResults :: (this: *PxMeshOverlapUtil) -> *PxU32 #cpp_method #foreign physx_lib "?getResults@PxMeshOverlapUtil@physx@@QEBAPEBIXZ";

        /**
        \brief Retrieves number of triangle indices after a findOverlap call.
        \return Number of touched triangles
        */
        getNbResults :: (this: *PxMeshOverlapUtil) -> PxU32 #cpp_method #foreign physx_lib "?getNbResults@PxMeshOverlapUtil@physx@@QEBAIXZ";

        mResultsMemory: *PxU32;
        mResults:       [256] PxU32;
        mNbResults:     PxU32;
        mMaxNbResults:  PxU32;
    }
    #run {if true then return;
        instance: PxMeshOverlapUtil;
        assert(((cast(*void)(*instance.mResultsMemory)) - cast(*void)(*instance)) == 0, "PxMeshOverlapUtil.mResultsMemory has unexpected offset % instead of 0", ((cast(*void)(*instance.mResultsMemory)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxMeshOverlapUtil.mResultsMemory)) == 8, "PxMeshOverlapUtil.mResultsMemory has unexpected size % instead of 8", size_of(type_of(PxMeshOverlapUtil.mResultsMemory)));
        assert(((cast(*void)(*instance.mResults)) - cast(*void)(*instance)) == 8, "PxMeshOverlapUtil.mResults has unexpected offset % instead of 8", ((cast(*void)(*instance.mResults)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxMeshOverlapUtil.mResults)) == 1024, "PxMeshOverlapUtil.mResults has unexpected size % instead of 1024", size_of(type_of(PxMeshOverlapUtil.mResults)));
        assert(((cast(*void)(*instance.mNbResults)) - cast(*void)(*instance)) == 1032, "PxMeshOverlapUtil.mNbResults has unexpected offset % instead of 1032", ((cast(*void)(*instance.mNbResults)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxMeshOverlapUtil.mNbResults)) == 4, "PxMeshOverlapUtil.mNbResults has unexpected size % instead of 4", size_of(type_of(PxMeshOverlapUtil.mNbResults)));
        assert(((cast(*void)(*instance.mMaxNbResults)) - cast(*void)(*instance)) == 1036, "PxMeshOverlapUtil.mMaxNbResults has unexpected offset % instead of 1036", ((cast(*void)(*instance.mMaxNbResults)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxMeshOverlapUtil.mMaxNbResults)) == 4, "PxMeshOverlapUtil.mMaxNbResults has unexpected size % instead of 4", size_of(type_of(PxMeshOverlapUtil.mMaxNbResults)));
        assert(size_of(PxMeshOverlapUtil) == 1040, "PxMeshOverlapUtil has size % instead of 1040", size_of(PxMeshOverlapUtil));
    }

    /**
    \brief Utility functions for serialization

    @see PxCollection, PxSerializationRegistry
    */
    PxSerialization :: struct {
        /**
        \brief Additional PxScene and PxPhysics options stored in XML serialized data.

        The PxXmlMiscParameter parameter can be serialized and deserialized along with PxCollection instances (XML only).
        This is for application use only and has no impact on how objects are serialized or deserialized.
        @see PxSerialization::createCollectionFromXml, PxSerialization::serializeCollectionToXml
        */
        PxXmlMiscParameter :: struct {
            /**
            \brief Up vector for the scene reference coordinate system.
            */
            upVector: PxVec3;

            /**
            \brief Tolerances scale to be used for the scene.
            */
            scale:    PxTolerancesScale;

            Constructor :: (this: *PxXmlMiscParameter) -> void #cpp_method #foreign physx_lib "??0PxXmlMiscParameter@PxSerialization@physx@@QEAA@XZ";
            Constructor :: (this: *PxXmlMiscParameter, inUpVector: *PxVec3, inScale: PxTolerancesScale) -> void #cpp_method #foreign physx_lib "??0PxXmlMiscParameter@PxSerialization@physx@@QEAA@AEAVPxVec3@2@VPxTolerancesScale@2@@Z";
        }
        #run {if true then return;
            instance: PxXmlMiscParameter;
            assert(((cast(*void)(*instance.upVector)) - cast(*void)(*instance)) == 0, "PxXmlMiscParameter.upVector has unexpected offset % instead of 0", ((cast(*void)(*instance.upVector)) - cast(*void)(*instance)));
            assert(size_of(type_of(PxXmlMiscParameter.upVector)) == 12, "PxXmlMiscParameter.upVector has unexpected size % instead of 12", size_of(type_of(PxXmlMiscParameter.upVector)));
            assert(((cast(*void)(*instance.scale)) - cast(*void)(*instance)) == 12, "PxXmlMiscParameter.scale has unexpected offset % instead of 12", ((cast(*void)(*instance.scale)) - cast(*void)(*instance)));
            assert(size_of(type_of(PxXmlMiscParameter.scale)) == 8, "PxXmlMiscParameter.scale has unexpected size % instead of 8", size_of(type_of(PxXmlMiscParameter.scale)));
            assert(size_of(PxXmlMiscParameter) == 20, "PxXmlMiscParameter has size % instead of 20", size_of(PxXmlMiscParameter));
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxSerialization) == 1, "PxSerialization has size % instead of 1", size_of(PxSerialization));
    }

    /**
    \brief A default implementation for a CPU task dispatcher.

    @see PxDefaultCpuDispatcherCreate() PxCpuDispatcher
    */
    PxDefaultCpuDispatcher :: struct {
        #as using pxcpudispatcher: PxCpuDispatcher;
        #place pxcpudispatcher; pxdefaultcpudispatcher_vtable: *PxDefaultCpuDispatcher_VTable;
    }
    PxDefaultCpuDispatcher_VTable :: struct #type_info_none {
        using pxcpudispatcher: PxCpuDispatcher_VTable;
        release: (this: *PxDefaultCpuDispatcher) -> void #cpp_method;

        setRunProfiled: (this: *PxDefaultCpuDispatcher, runProfiled: bool) -> void #cpp_method;

        getRunProfiled: (this: *PxDefaultCpuDispatcher) -> bool #cpp_method;
    }

    PxDefaultCpuDispatcher_release :: inline (this: *PxDefaultCpuDispatcher) { this.pxdefaultcpudispatcher_vtable.release(this); }

    PxDefaultCpuDispatcher_setRunProfiled :: inline (this: *PxDefaultCpuDispatcher, runProfiled: bool) { this.pxdefaultcpudispatcher_vtable.setRunProfiled(this, runProfiled); }

    PxDefaultCpuDispatcher_getRunProfiled :: inline (this: *PxDefaultCpuDispatcher) -> bool { return this.pxdefaultcpudispatcher_vtable.getRunProfiled(this); }

    vtable :: (obj: *PxDefaultCpuDispatcher) -> *PxDefaultCpuDispatcher_VTable { return obj.pxdefaultcpudispatcher_vtable; }

    #run {if true then return;
        assert(size_of(type_of(PxDefaultCpuDispatcher.pxcpudispatcher)) == 8, "PxDefaultCpuDispatcher.pxcpudispatcher has unexpected size % instead of 8", size_of(type_of(PxDefaultCpuDispatcher.pxcpudispatcher)));
        assert(size_of(PxDefaultCpuDispatcher) == 8, "PxDefaultCpuDispatcher has size % instead of 8", size_of(PxDefaultCpuDispatcher));
    }

    /**
    \brief a factory class for creating PxStringTable with a specific allocator.

    @see PxStringTable
    */
    PxStringTableExt :: struct {
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxStringTableExt) == 1, "PxStringTableExt has size % instead of 1", size_of(PxStringTableExt));
    }

    PxBroadPhaseExt :: struct {
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxBroadPhaseExt) == 1, "PxBroadPhaseExt has size % instead of 1", size_of(PxBroadPhaseExt));
    }

    // These types have been deprecated (removed) in PhysX 3.4. We typedef them to the new types here for easy migration from 3.3 to 3.4.
    PxSceneQueryHit :: PxQueryHit;
    PxSceneQueryFilterData :: PxQueryFilterData;
    PxSceneQueryFilterCallback :: PxQueryFilterCallback;
    PxSceneQueryCache :: PxQueryCache;
    PxSceneQueryFlag :: PxHitFlag;
    PxSceneQueryFlags :: PxHitFlags;

    /**
    \brief utility functions for use with PxScene, related to scene queries.

    Some of these functions have been deprecated (removed) in PhysX 3.4. We re-implement them here for easy migration from 3.3 to 3.4.

    @see PxShape
    */
    PxSceneQueryExt :: struct {
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxSceneQueryExt) == 1, "PxSceneQueryExt has size % instead of 1", size_of(PxSceneQueryExt));
    }

    PxConverterReportMode :: struct {
        Enum :: enum s32 {
            NONE    :: 0;
            NORMAL  :: 1;
            VERBOSE :: 2;

            eNONE    :: NONE;
            eNORMAL  :: NORMAL;
            eVERBOSE :: VERBOSE;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxConverterReportMode) == 1, "PxConverterReportMode has size % instead of 1", size_of(PxConverterReportMode));
    }

    /**
    \brief Binary converter for serialized streams.

    The binary converter class is targeted at converting binary streams from authoring platforms,
    such as windows, osx or linux to any game runtime platform supported by PhysX. Particularly
    it is currently not supported to run the converter on a platforms that has an endian mismatch
    with the platform corresponding to the source binary file and source meta data.

    If you want to use multiple threads for batch conversions, please create one instance
    of this class for each thread.

    @see PxSerialization.createBinaryConverter
    */
    PxBinaryConverter :: struct {
        vtable: *PxBinaryConverter_VTable;
    }
    PxBinaryConverter_VTable :: struct #type_info_none {
        release: (this: *PxBinaryConverter) -> void #cpp_method;

        setReportMode: (this: *PxBinaryConverter, mode: PxConverterReportMode.Enum) -> void #cpp_method;

        setMetaData: (this: *PxBinaryConverter, srcMetaData: *PxInputStream, dstMetaData: *PxInputStream) -> bool #cpp_method;

        compareMetaData: (this: *PxBinaryConverter) -> bool #cpp_method;

        convert: (this: *PxBinaryConverter, srcStream: *PxInputStream, srcSize: PxU32, targetStream: *PxOutputStream) -> bool #cpp_method;

        Destructor: (this: *PxBinaryConverter, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxBinaryConverter_release :: inline (this: *PxBinaryConverter) { this.vtable.release(this); }

    PxBinaryConverter_setReportMode :: inline (this: *PxBinaryConverter, mode: PxConverterReportMode.Enum) { this.vtable.setReportMode(this, mode); }

    PxBinaryConverter_setMetaData :: inline (this: *PxBinaryConverter, srcMetaData: *PxInputStream, dstMetaData: *PxInputStream) -> bool { return this.vtable.setMetaData(this, srcMetaData, dstMetaData); }

    PxBinaryConverter_compareMetaData :: inline (this: *PxBinaryConverter) -> bool { return this.vtable.compareMetaData(this); }

    PxBinaryConverter_convert :: inline (this: *PxBinaryConverter, srcStream: *PxInputStream, srcSize: PxU32, targetStream: *PxOutputStream) -> bool { return this.vtable.convert(this, srcStream, srcSize, targetStream); }

    PxBinaryConverter_Destructor :: inline (this: *PxBinaryConverter, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxBinaryConverter) -> *PxBinaryConverter_VTable { return obj.vtable; }

    #run {if true then return;
        assert(size_of(PxBinaryConverter) == 8, "PxBinaryConverter has size % instead of 8", size_of(PxBinaryConverter));
    }

    /**
    \brief Helper class containing the mapping of id to object, and type name.
    */
    PxRepXObject :: struct {
        /**
        \brief Identifies the extension meant to handle this object.
        @see PxTypeInfo, PX_DEFINE_TYPEINFO, PxRepXSerializer
        */
        typeName:     *u8;

        /**
        \brief Pointer to the serializable this was created from
        */
        serializable: *void;

        /**
        \brief Id given to this object at some point
        */
        id:           PxSerialObjectId;
        Constructor :: (this: *PxRepXObject, inTypeName: *u8 = "", inSerializable: *void = null, inId: PxSerialObjectId = 0) -> void #cpp_method #foreign physx_lib "??0PxRepXObject@physx@@QEAA@PEBDPEBX_K@Z";

        isValid :: (this: *PxRepXObject) -> bool #cpp_method #foreign physx_lib "?isValid@PxRepXObject@physx@@QEBA_NXZ";
    }
    #run {if true then return;
        instance: PxRepXObject;
        assert(((cast(*void)(*instance.typeName)) - cast(*void)(*instance)) == 0, "PxRepXObject.typeName has unexpected offset % instead of 0", ((cast(*void)(*instance.typeName)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxRepXObject.typeName)) == 8, "PxRepXObject.typeName has unexpected size % instead of 8", size_of(type_of(PxRepXObject.typeName)));
        assert(((cast(*void)(*instance.serializable)) - cast(*void)(*instance)) == 8, "PxRepXObject.serializable has unexpected offset % instead of 8", ((cast(*void)(*instance.serializable)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxRepXObject.serializable)) == 8, "PxRepXObject.serializable has unexpected size % instead of 8", size_of(type_of(PxRepXObject.serializable)));
        assert(((cast(*void)(*instance.id)) - cast(*void)(*instance)) == 16, "PxRepXObject.id has unexpected offset % instead of 16", ((cast(*void)(*instance.id)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxRepXObject.id)) == 8, "PxRepXObject.id has unexpected size % instead of 8", size_of(type_of(PxRepXObject.id)));
        assert(size_of(PxRepXObject) == 24, "PxRepXObject has size % instead of 24", size_of(PxRepXObject));
    }

    /**
    \brief Arguments required to instantiate a serializable object from RepX.

    Extra arguments can be added to the object map under special ids.

    @see PxRepXSerializer::objectToFile, PxRepXSerializer::fileToObject
    */
    PxRepXInstantiationArgs :: struct {
        physics:     *PxPhysics;
        cooker:      *PxCooking;
        stringTable: *PxStringTable;
        Constructor :: (this: *PxRepXInstantiationArgs, inPhysics: *PxPhysics, inCooking: *PxCooking = null, inStringTable: *PxStringTable = null) -> void #cpp_method #foreign physx_lib "??0PxRepXInstantiationArgs@physx@@QEAA@AEAVPxPhysics@1@PEAVPxCooking@1@PEAVPxStringTable@1@@Z";
    }
    #run {if true then return;
        instance: PxRepXInstantiationArgs;
        assert(((cast(*void)(*instance.physics)) - cast(*void)(*instance)) == 0, "PxRepXInstantiationArgs.physics has unexpected offset % instead of 0", ((cast(*void)(*instance.physics)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxRepXInstantiationArgs.physics)) == 8, "PxRepXInstantiationArgs.physics has unexpected size % instead of 8", size_of(type_of(PxRepXInstantiationArgs.physics)));
        assert(((cast(*void)(*instance.cooker)) - cast(*void)(*instance)) == 8, "PxRepXInstantiationArgs.cooker has unexpected offset % instead of 8", ((cast(*void)(*instance.cooker)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxRepXInstantiationArgs.cooker)) == 8, "PxRepXInstantiationArgs.cooker has unexpected size % instead of 8", size_of(type_of(PxRepXInstantiationArgs.cooker)));
        assert(((cast(*void)(*instance.stringTable)) - cast(*void)(*instance)) == 16, "PxRepXInstantiationArgs.stringTable has unexpected offset % instead of 16", ((cast(*void)(*instance.stringTable)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxRepXInstantiationArgs.stringTable)) == 8, "PxRepXInstantiationArgs.stringTable has unexpected size % instead of 8", size_of(type_of(PxRepXInstantiationArgs.stringTable)));
        assert(size_of(PxRepXInstantiationArgs) == 24, "PxRepXInstantiationArgs has size % instead of 24", size_of(PxRepXInstantiationArgs));
    }

    XmlMemoryAllocator :: struct {}
    XmlWriter :: struct {}
    XmlReader :: struct {}
    MemoryBuffer :: struct {}

    /**
    \brief Serializer interface for RepX (Xml) serialization.

    In order to serialize a class to RepX both a PxSerializer and
    a PxRepXSerializer implementation are needed.

    A repx Serializer provides the ability to capture a live
    object to a descriptor or static state and the ability to
    write that state out to a file.  Objects allocated
    by the Serializer using the allocator are freed when the
    collection itself is freed.
    SnRepXCoreSerializers.cpp implements a set of Serializers
    for the core PhysX types.

    \note Implementing a PxRepXSerializer is currently not practical without including the internal PhysXExtension header "SnRepXSerializerImpl.h".

    @see PxSerializer, PX_NEW_REPX_SERIALIZER, PxSerializationRegistry::registerRepXSerializer
    */
    PxRepXSerializer :: struct {
        vtable: *PxRepXSerializer_VTable;
    }
    PxRepXSerializer_VTable :: struct #type_info_none {
        Destructor: (this: *PxRepXSerializer, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

        getTypeName: (this: *PxRepXSerializer) -> *u8 #cpp_method;

        objectToFile: (this: *PxRepXSerializer, inLiveObject: *PxRepXObject, inCollection: *PxCollection, inWriter: *XmlWriter, inTempBuffer: *MemoryBuffer, inArgs: *PxRepXInstantiationArgs) -> void #cpp_method;

        fileToObject: (this: *PxRepXSerializer, inReader: *XmlReader, inAllocator: *XmlMemoryAllocator, inArgs: *PxRepXInstantiationArgs, inCollection: *PxCollection) -> PxRepXObject #cpp_method #cpp_return_type_is_non_pod;
    }

    PxRepXSerializer_Destructor :: inline (this: *PxRepXSerializer, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    PxRepXSerializer_getTypeName :: inline (this: *PxRepXSerializer) -> *u8 { return this.vtable.getTypeName(this); }

    PxRepXSerializer_objectToFile :: inline (this: *PxRepXSerializer, inLiveObject: *PxRepXObject, inCollection: *PxCollection, inWriter: *XmlWriter, inTempBuffer: *MemoryBuffer, inArgs: *PxRepXInstantiationArgs) { this.vtable.objectToFile(this, inLiveObject, inCollection, inWriter, inTempBuffer, inArgs); }

    PxRepXSerializer_fileToObject :: inline (this: *PxRepXSerializer, inReader: *XmlReader, inAllocator: *XmlMemoryAllocator, inArgs: *PxRepXInstantiationArgs, inCollection: *PxCollection) -> PxRepXObject { return this.vtable.fileToObject(this, inReader, inAllocator, inArgs, inCollection); }

    vtable :: (obj: *PxRepXSerializer) -> *PxRepXSerializer_VTable { return obj.vtable; }

    #run {if true then return;
        assert(size_of(PxRepXSerializer) == 8, "PxRepXSerializer has size % instead of 8", size_of(PxRepXSerializer));
    }

    /**
    @see PxVehicleDrive4W, PxVehicleDriveTank, PxVehicleDriveNW, PxVehicleNoDrive, PxVehicleWheels::getVehicleType
    */
    PxVehicleTypes :: struct {
        Enum :: enum s32 {
            DRIVE4W              :: 0;
            DRIVENW              :: 1;
            DRIVETANK            :: 2;
            NODRIVE              :: 3;
            USER1                :: 4;
            USER2                :: 5;
            USER3                :: 6;
            MAX_NB_VEHICLE_TYPES :: 7;

            eDRIVE4W              :: DRIVE4W;
            eDRIVENW              :: DRIVENW;
            eDRIVETANK            :: DRIVETANK;
            eNODRIVE              :: NODRIVE;
            eUSER1                :: USER1;
            eUSER2                :: USER2;
            eUSER3                :: USER3;
            eMAX_NB_VEHICLE_TYPES :: MAX_NB_VEHICLE_TYPES;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxVehicleTypes) == 1, "PxVehicleTypes has size % instead of 1", size_of(PxVehicleTypes));
    }

    /**
    \brief An enumeration of concrete vehicle classes inheriting from PxBase.
    \note This enum can be used to identify a vehicle object stored in a PxCollection.
    @see PxBase, PxTypeInfo, PxBase::getConcreteType
    */
    PxVehicleConcreteType :: struct {
        Enum :: enum s32 {
            NoDrive   :: 512;
            Drive4W   :: 513;
            DriveNW   :: 514;
            DriveTank :: 515;

            eVehicleNoDrive   :: NoDrive;
            eVehicleDrive4W   :: Drive4W;
            eVehicleDriveNW   :: DriveNW;
            eVehicleDriveTank :: DriveTank;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxVehicleConcreteType) == 1, "PxVehicleConcreteType has size % instead of 1", size_of(PxVehicleConcreteType));
    }

    /**
    @see PxVehicleSetUpdateMode
    */
    PxVehicleUpdateMode :: struct {
        Enum :: enum s32 {
            VELOCITY_CHANGE :: 0;
            ACCELERATION    :: 1;

            eVELOCITY_CHANGE :: VELOCITY_CHANGE;
            eACCELERATION    :: ACCELERATION;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxVehicleUpdateMode) == 1, "PxVehicleUpdateMode has size % instead of 1", size_of(PxVehicleUpdateMode));
    }

    PxVehicleChassisData :: struct {
        Constructor :: (this: *PxVehicleChassisData) -> void #cpp_method #foreign physx_lib "??0PxVehicleChassisData@physx@@QEAA@XZ";

        /**
        \brief Moment of inertia of vehicle rigid body actor.

        \note Specified in kilograms metres-squared (kg m^2).
        */
        mMOI:      PxVec3;

        /**
        \brief Mass of vehicle rigid body actor.

        \note Specified in kilograms (kg).
        */
        mMass:     PxReal;

        /**
        \brief Center of mass offset of vehicle rigid body actor.

        \note Specified in metres (m).
        */
        mCMOffset: PxVec3;

        pad:       PxReal;
    }
    #run {if true then return;
        instance: PxVehicleChassisData;
        assert(((cast(*void)(*instance.mMOI)) - cast(*void)(*instance)) == 0, "PxVehicleChassisData.mMOI has unexpected offset % instead of 0", ((cast(*void)(*instance.mMOI)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleChassisData.mMOI)) == 12, "PxVehicleChassisData.mMOI has unexpected size % instead of 12", size_of(type_of(PxVehicleChassisData.mMOI)));
        assert(((cast(*void)(*instance.mMass)) - cast(*void)(*instance)) == 12, "PxVehicleChassisData.mMass has unexpected offset % instead of 12", ((cast(*void)(*instance.mMass)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleChassisData.mMass)) == 4, "PxVehicleChassisData.mMass has unexpected size % instead of 4", size_of(type_of(PxVehicleChassisData.mMass)));
        assert(((cast(*void)(*instance.mCMOffset)) - cast(*void)(*instance)) == 16, "PxVehicleChassisData.mCMOffset has unexpected offset % instead of 16", ((cast(*void)(*instance.mCMOffset)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleChassisData.mCMOffset)) == 12, "PxVehicleChassisData.mCMOffset has unexpected size % instead of 12", size_of(type_of(PxVehicleChassisData.mCMOffset)));
        assert(((cast(*void)(*instance.pad)) - cast(*void)(*instance)) == 28, "PxVehicleChassisData.pad has unexpected offset % instead of 28", ((cast(*void)(*instance.pad)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleChassisData.pad)) == 4, "PxVehicleChassisData.pad has unexpected size % instead of 4", size_of(type_of(PxVehicleChassisData.pad)));
        assert(size_of(PxVehicleChassisData) == 32, "PxVehicleChassisData has size % instead of 32", size_of(PxVehicleChassisData));
    }

    PxCompileTimeAssert_Dummy4 :: [1] u8;

    PxVehicleEngineData :: struct {
        anon_enum_2 :: enum s32 {
            eMAX_NB_ENGINE_TORQUE_CURVE_ENTRIES :: 8;
        }

        Constructor :: (this: *PxVehicleEngineData) -> void #cpp_method #foreign physx_lib "??0PxVehicleEngineData@physx@@QEAA@XZ";

        /**
        \brief Graph of normalized torque (torque/mPeakTorque) against normalized engine speed ( engineRotationSpeed / mMaxOmega ).

        \note The normalized engine speed is the x-axis of the graph, while the normalized torque is the y-axis of the graph.
        */
        mTorqueCurve:                             PxFixedSizeLookupTable(/*anon_enum_2.eMAX_NB_ENGINE_TORQUE_CURVE_ENTRIES*/8);

        /**
        \brief Moment of inertia of the engine around the axis of rotation.

        \note Specified in kilograms metres-squared (kg m^2)
        */
        mMOI:                                     PxReal;

        /**
        \brief Maximum torque available to apply to the engine when the accelerator pedal is at maximum.

        \note The torque available is the value of the accelerator pedal (in range [0, 1]) multiplied by the normalized torque as computed from mTorqueCurve multiplied by mPeakTorque.

        \note Specified in kilograms metres-squared per second-squared (kg m^2 s^-2).

        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mPeakTorque:                              PxReal;

        /**
        \brief Maximum rotation speed of the engine.

        \note Specified in radians per second (s^-1).

        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mMaxOmega:                                PxReal;

        /**
        \brief Damping rate of engine when full throttle is applied.

        \note If the clutch is engaged (any gear except neutral) then the damping rate applied at run-time is an interpolation
        between mDampingRateZeroThrottleClutchEngaged and mDampingRateFullThrottle:
        mDampingRateZeroThrottleClutchEngaged + (mDampingRateFullThrottle-mDampingRateZeroThrottleClutchEngaged)*acceleratorPedal;

        \note If the clutch is disengaged (in neutral gear) the damping rate applied at run-time is an interpolation
        between mDampingRateZeroThrottleClutchDisengaged and mDampingRateFullThrottle:
        mDampingRateZeroThrottleClutchDisengaged + (mDampingRateFullThrottle-mDampingRateZeroThrottleClutchDisengaged)*acceleratorPedal;

        \note Specified in kilograms metres-squared per second (kg m^2 s^-1).

        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mDampingRateFullThrottle:                 PxReal;

        /**
        \brief Damping rate of engine when full throttle is applied.

        \note If the clutch is engaged (any gear except neutral) then the damping rate applied at run-time is an interpolation
        between mDampingRateZeroThrottleClutchEngaged and mDampingRateFullThrottle:
        mDampingRateZeroThrottleClutchEngaged + (mDampingRateFullThrottle-mDampingRateZeroThrottleClutchEngaged)*acceleratorPedal;

        \note If the clutch is disengaged (in neutral gear) the damping rate applied at run-time is an interpolation
        between mDampingRateZeroThrottleClutchDisengaged and mDampingRateFullThrottle:
        mDampingRateZeroThrottleClutchDisengaged + (mDampingRateFullThrottle-mDampingRateZeroThrottleClutchDisengaged)*acceleratorPedal;

        \note Specified in kilograms metres-squared per second (kg m^2 s^-1).

        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mDampingRateZeroThrottleClutchEngaged:    PxReal;

        /**
        \brief Damping rate of engine when full throttle is applied.

        \note If the clutch is engaged (any gear except neutral) then the damping rate applied at run-time is an interpolation
        between mDampingRateZeroThrottleClutchEngaged and mDampingRateFullThrottle:
        mDampingRateZeroThrottleClutchEngaged + (mDampingRateFullThrottle-mDampingRateZeroThrottleClutchEngaged)*acceleratorPedal;

        \note If the clutch is disengaged (in neutral gear) the damping rate applied at run-time is an interpolation
        between mDampingRateZeroThrottleClutchDisengaged and mDampingRateFullThrottle:
        mDampingRateZeroThrottleClutchDisengaged + (mDampingRateFullThrottle-mDampingRateZeroThrottleClutchDisengaged)*acceleratorPedal;

        \note Specified in kilograms metres-squared per second (kg m^2 s^-1).

        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mDampingRateZeroThrottleClutchDisengaged: PxReal;

        /**
        \brief Return value of mRecipMOI(=1.0f/mMOI) that is automatically set by PxVehicleDriveSimData::setEngineData
        */
        getRecipMOI :: (this: *PxVehicleEngineData) -> PxReal #cpp_method #foreign physx_lib "?getRecipMOI@PxVehicleEngineData@physx@@QEBAMXZ";

        /**
        \brief Return value of mRecipMaxOmega( = 1.0f / mMaxOmega ) that is automatically set by PxVehicleDriveSimData::setEngineData
        */
        getRecipMaxOmega :: (this: *PxVehicleEngineData) -> PxReal #cpp_method #foreign physx_lib "?getRecipMaxOmega@PxVehicleEngineData@physx@@QEBAMXZ";

        /**
        \brief Reciprocal of the engine moment of inertia.

        \note Not necessary to set this value because it is set by PxVehicleDriveSimData::setEngineData

        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mRecipMOI:                                PxReal;

        /**
        \brief Reciprocal of the maximum rotation speed of the engine.

        \note Not necessary to set this value because it is set by PxVehicleDriveSimData::setEngineData

        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mRecipMaxOmega:                           PxReal;

        //serialization
        Constructor :: (this: *PxVehicleEngineData, unknown0: PxEMPTY) -> void #cpp_method #foreign physx_lib "??0PxVehicleEngineData@physx@@QEAA@W4PxEMPTY@1@@Z";
    }
    #run {if true then return;
        instance: PxVehicleEngineData;
        assert(((cast(*void)(*instance.mTorqueCurve)) - cast(*void)(*instance)) == 0, "PxVehicleEngineData.mTorqueCurve has unexpected offset % instead of 0", ((cast(*void)(*instance.mTorqueCurve)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleEngineData.mTorqueCurve)) == 80, "PxVehicleEngineData.mTorqueCurve has unexpected size % instead of 80", size_of(type_of(PxVehicleEngineData.mTorqueCurve)));
        assert(((cast(*void)(*instance.mMOI)) - cast(*void)(*instance)) == 80, "PxVehicleEngineData.mMOI has unexpected offset % instead of 80", ((cast(*void)(*instance.mMOI)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleEngineData.mMOI)) == 4, "PxVehicleEngineData.mMOI has unexpected size % instead of 4", size_of(type_of(PxVehicleEngineData.mMOI)));
        assert(((cast(*void)(*instance.mPeakTorque)) - cast(*void)(*instance)) == 84, "PxVehicleEngineData.mPeakTorque has unexpected offset % instead of 84", ((cast(*void)(*instance.mPeakTorque)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleEngineData.mPeakTorque)) == 4, "PxVehicleEngineData.mPeakTorque has unexpected size % instead of 4", size_of(type_of(PxVehicleEngineData.mPeakTorque)));
        assert(((cast(*void)(*instance.mMaxOmega)) - cast(*void)(*instance)) == 88, "PxVehicleEngineData.mMaxOmega has unexpected offset % instead of 88", ((cast(*void)(*instance.mMaxOmega)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleEngineData.mMaxOmega)) == 4, "PxVehicleEngineData.mMaxOmega has unexpected size % instead of 4", size_of(type_of(PxVehicleEngineData.mMaxOmega)));
        assert(((cast(*void)(*instance.mDampingRateFullThrottle)) - cast(*void)(*instance)) == 92, "PxVehicleEngineData.mDampingRateFullThrottle has unexpected offset % instead of 92", ((cast(*void)(*instance.mDampingRateFullThrottle)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleEngineData.mDampingRateFullThrottle)) == 4, "PxVehicleEngineData.mDampingRateFullThrottle has unexpected size % instead of 4", size_of(type_of(PxVehicleEngineData.mDampingRateFullThrottle)));
        assert(((cast(*void)(*instance.mDampingRateZeroThrottleClutchEngaged)) - cast(*void)(*instance)) == 96, "PxVehicleEngineData.mDampingRateZeroThrottleClutchEngaged has unexpected offset % instead of 96", ((cast(*void)(*instance.mDampingRateZeroThrottleClutchEngaged)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleEngineData.mDampingRateZeroThrottleClutchEngaged)) == 4, "PxVehicleEngineData.mDampingRateZeroThrottleClutchEngaged has unexpected size % instead of 4", size_of(type_of(PxVehicleEngineData.mDampingRateZeroThrottleClutchEngaged)));
        assert(((cast(*void)(*instance.mDampingRateZeroThrottleClutchDisengaged)) - cast(*void)(*instance)) == 100, "PxVehicleEngineData.mDampingRateZeroThrottleClutchDisengaged has unexpected offset % instead of 100", ((cast(*void)(*instance.mDampingRateZeroThrottleClutchDisengaged)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleEngineData.mDampingRateZeroThrottleClutchDisengaged)) == 4, "PxVehicleEngineData.mDampingRateZeroThrottleClutchDisengaged has unexpected size % instead of 4", size_of(type_of(PxVehicleEngineData.mDampingRateZeroThrottleClutchDisengaged)));
        assert(((cast(*void)(*instance.mRecipMOI)) - cast(*void)(*instance)) == 104, "PxVehicleEngineData.mRecipMOI has unexpected offset % instead of 104", ((cast(*void)(*instance.mRecipMOI)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleEngineData.mRecipMOI)) == 4, "PxVehicleEngineData.mRecipMOI has unexpected size % instead of 4", size_of(type_of(PxVehicleEngineData.mRecipMOI)));
        assert(((cast(*void)(*instance.mRecipMaxOmega)) - cast(*void)(*instance)) == 108, "PxVehicleEngineData.mRecipMaxOmega has unexpected offset % instead of 108", ((cast(*void)(*instance.mRecipMaxOmega)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleEngineData.mRecipMaxOmega)) == 4, "PxVehicleEngineData.mRecipMaxOmega has unexpected size % instead of 4", size_of(type_of(PxVehicleEngineData.mRecipMaxOmega)));
        assert(size_of(PxVehicleEngineData) == 112, "PxVehicleEngineData has size % instead of 112", size_of(PxVehicleEngineData));
    }

    PxCompileTimeAssert_Dummy5 :: [1] u8;

    PxVehicleGearsData :: struct {
        Enum :: enum s32 {
            REVERSE          :: 0;
            NEUTRAL          :: 1;
            FIRST            :: 2;
            SECOND           :: 3;
            THIRD            :: 4;
            FOURTH           :: 5;
            FIFTH            :: 6;
            SIXTH            :: 7;
            SEVENTH          :: 8;
            EIGHTH           :: 9;
            NINTH            :: 10;
            TENTH            :: 11;
            ELEVENTH         :: 12;
            TWELFTH          :: 13;
            THIRTEENTH       :: 14;
            FOURTEENTH       :: 15;
            FIFTEENTH        :: 16;
            SIXTEENTH        :: 17;
            SEVENTEENTH      :: 18;
            EIGHTEENTH       :: 19;
            NINETEENTH       :: 20;
            TWENTIETH        :: 21;
            TWENTYFIRST      :: 22;
            TWENTYSECOND     :: 23;
            TWENTYTHIRD      :: 24;
            TWENTYFOURTH     :: 25;
            TWENTYFIFTH      :: 26;
            TWENTYSIXTH      :: 27;
            TWENTYSEVENTH    :: 28;
            TWENTYEIGHTH     :: 29;
            TWENTYNINTH      :: 30;
            THIRTIETH        :: 31;
            GEARSRATIO_COUNT :: 32;

            eREVERSE          :: REVERSE;
            eNEUTRAL          :: NEUTRAL;
            eFIRST            :: FIRST;
            eSECOND           :: SECOND;
            eTHIRD            :: THIRD;
            eFOURTH           :: FOURTH;
            eFIFTH            :: FIFTH;
            eSIXTH            :: SIXTH;
            eSEVENTH          :: SEVENTH;
            eEIGHTH           :: EIGHTH;
            eNINTH            :: NINTH;
            eTENTH            :: TENTH;
            eELEVENTH         :: ELEVENTH;
            eTWELFTH          :: TWELFTH;
            eTHIRTEENTH       :: THIRTEENTH;
            eFOURTEENTH       :: FOURTEENTH;
            eFIFTEENTH        :: FIFTEENTH;
            eSIXTEENTH        :: SIXTEENTH;
            eSEVENTEENTH      :: SEVENTEENTH;
            eEIGHTEENTH       :: EIGHTEENTH;
            eNINETEENTH       :: NINETEENTH;
            eTWENTIETH        :: TWENTIETH;
            eTWENTYFIRST      :: TWENTYFIRST;
            eTWENTYSECOND     :: TWENTYSECOND;
            eTWENTYTHIRD      :: TWENTYTHIRD;
            eTWENTYFOURTH     :: TWENTYFOURTH;
            eTWENTYFIFTH      :: TWENTYFIFTH;
            eTWENTYSIXTH      :: TWENTYSIXTH;
            eTWENTYSEVENTH    :: TWENTYSEVENTH;
            eTWENTYEIGHTH     :: TWENTYEIGHTH;
            eTWENTYNINTH      :: TWENTYNINTH;
            eTHIRTIETH        :: THIRTIETH;
            eGEARSRATIO_COUNT :: GEARSRATIO_COUNT;
        }

        Constructor :: (this: *PxVehicleGearsData) -> void #cpp_method #foreign physx_lib "??0PxVehicleGearsData@physx@@QEAA@XZ";

        /**
        \brief Gear ratios

        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mRatios:     [32] PxReal;

        /**
        \brief Gear ratio applied is mRatios[currentGear]*finalRatio

        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mFinalRatio: PxReal;

        /**
        \brief Number of gears (including reverse and neutral).

        <b>Range:</b> (0, MAX_NB_GEAR_RATIOS)<br>
        */
        mNbRatios:   PxU32;

        /**
        \brief Time it takes to switch gear.

        \note Specified in seconds (s).

        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mSwitchTime: PxReal;

        mPad:        PxReal;

        //serialization
        Constructor :: (this: *PxVehicleGearsData, unknown0: PxEMPTY) -> void #cpp_method #foreign physx_lib "??0PxVehicleGearsData@physx@@QEAA@W4PxEMPTY@1@@Z";
        getGearRatio :: (this: *PxVehicleGearsData, a: Enum) -> PxReal #cpp_method #foreign physx_lib "?getGearRatio@PxVehicleGearsData@physx@@QEBAMW4Enum@12@@Z";
        setGearRatio :: (this: *PxVehicleGearsData, a: Enum, ratio: PxReal) -> void #cpp_method #foreign physx_lib "?setGearRatio@PxVehicleGearsData@physx@@QEAAXW4Enum@12@M@Z";
    }
    #run {if true then return;
        instance: PxVehicleGearsData;
        assert(((cast(*void)(*instance.mRatios)) - cast(*void)(*instance)) == 0, "PxVehicleGearsData.mRatios has unexpected offset % instead of 0", ((cast(*void)(*instance.mRatios)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleGearsData.mRatios)) == 128, "PxVehicleGearsData.mRatios has unexpected size % instead of 128", size_of(type_of(PxVehicleGearsData.mRatios)));
        assert(((cast(*void)(*instance.mFinalRatio)) - cast(*void)(*instance)) == 128, "PxVehicleGearsData.mFinalRatio has unexpected offset % instead of 128", ((cast(*void)(*instance.mFinalRatio)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleGearsData.mFinalRatio)) == 4, "PxVehicleGearsData.mFinalRatio has unexpected size % instead of 4", size_of(type_of(PxVehicleGearsData.mFinalRatio)));
        assert(((cast(*void)(*instance.mNbRatios)) - cast(*void)(*instance)) == 132, "PxVehicleGearsData.mNbRatios has unexpected offset % instead of 132", ((cast(*void)(*instance.mNbRatios)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleGearsData.mNbRatios)) == 4, "PxVehicleGearsData.mNbRatios has unexpected size % instead of 4", size_of(type_of(PxVehicleGearsData.mNbRatios)));
        assert(((cast(*void)(*instance.mSwitchTime)) - cast(*void)(*instance)) == 136, "PxVehicleGearsData.mSwitchTime has unexpected offset % instead of 136", ((cast(*void)(*instance.mSwitchTime)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleGearsData.mSwitchTime)) == 4, "PxVehicleGearsData.mSwitchTime has unexpected size % instead of 4", size_of(type_of(PxVehicleGearsData.mSwitchTime)));
        assert(((cast(*void)(*instance.mPad)) - cast(*void)(*instance)) == 140, "PxVehicleGearsData.mPad has unexpected offset % instead of 140", ((cast(*void)(*instance.mPad)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleGearsData.mPad)) == 4, "PxVehicleGearsData.mPad has unexpected size % instead of 4", size_of(type_of(PxVehicleGearsData.mPad)));
        assert(size_of(PxVehicleGearsData) == 144, "PxVehicleGearsData has size % instead of 144", size_of(PxVehicleGearsData));
    }

    PxCompileTimeAssert_Dummy6 :: [1] u8;

    PxVehicleAutoBoxData :: struct {
        Constructor :: (this: *PxVehicleAutoBoxData) -> void #cpp_method #foreign physx_lib "??0PxVehicleAutoBoxData@physx@@QEAA@XZ";

        /**
        \brief Value of ( engineRotationSpeed / PxVehicleEngineData::mMaxOmega ) that is high enough to increment gear.

        \note When ( engineRotationSpeed / PxVehicleEngineData::mMaxOmega ) > mUpRatios[currentGear] the autobox will begin
        a transition to currentGear+1 unless currentGear is the highest possible gear or neutral or reverse.

        <b>Range:</b> [0, 1]<br>
        */
        mUpRatios:   [32] PxReal;

        /**
        \brief Value of engineRevs/maxEngineRevs that is low enough to decrement gear.

        \note When ( engineRotationSpeed / PxVehicleEngineData::mMaxOmega ) < mDownRatios[currentGear] the autobox will begin
        a transition to currentGear-1 unless currentGear is first gear or neutral or reverse.

        <b>Range:</b> [0, 1]<br>
        */
        mDownRatios: [32] PxReal;

        /**
        \brief Set the latency time of the autobox.

        \note Latency time is the minimum time that must pass between each gear change that is initiated by the autobox.
        The auto-box will only attempt to initiate another gear change up or down if the simulation time that has passed since the most recent
        automated gear change is greater than the specified latency.

        \note Specified in seconds (s).

        @see getLatency
        */
        setLatency :: (this: *PxVehicleAutoBoxData, latency: PxReal) -> void #cpp_method #foreign physx_lib "?setLatency@PxVehicleAutoBoxData@physx@@QEAAXM@Z";

        /**
        \brief Get the latency time of the autobox.

        \note Specified in seconds (s).

        @see setLatency
        */
        getLatency :: (this: *PxVehicleAutoBoxData) -> PxReal #cpp_method #foreign physx_lib "?getLatency@PxVehicleAutoBoxData@physx@@QEBAMXZ";

        //serialization
        Constructor :: (this: *PxVehicleAutoBoxData, unknown0: PxEMPTY) -> void #cpp_method #foreign physx_lib "??0PxVehicleAutoBoxData@physx@@QEAA@W4PxEMPTY@1@@Z";

        getUpRatios :: (this: *PxVehicleAutoBoxData, a: PxVehicleGearsData.Enum) -> PxReal #cpp_method #foreign physx_lib "?getUpRatios@PxVehicleAutoBoxData@physx@@QEBAMW4Enum@PxVehicleGearsData@2@@Z";
        setUpRatios :: (this: *PxVehicleAutoBoxData, a: PxVehicleGearsData.Enum, ratio: PxReal) -> void #cpp_method #foreign physx_lib "?setUpRatios@PxVehicleAutoBoxData@physx@@QEAAXW4Enum@PxVehicleGearsData@2@M@Z";

        getDownRatios :: (this: *PxVehicleAutoBoxData, a: PxVehicleGearsData.Enum) -> PxReal #cpp_method #foreign physx_lib "?getDownRatios@PxVehicleAutoBoxData@physx@@QEBAMW4Enum@PxVehicleGearsData@2@@Z";
        setDownRatios :: (this: *PxVehicleAutoBoxData, a: PxVehicleGearsData.Enum, ratio: PxReal) -> void #cpp_method #foreign physx_lib "?setDownRatios@PxVehicleAutoBoxData@physx@@QEAAXW4Enum@PxVehicleGearsData@2@M@Z";
    }
    #run {if true then return;
        instance: PxVehicleAutoBoxData;
        assert(((cast(*void)(*instance.mUpRatios)) - cast(*void)(*instance)) == 0, "PxVehicleAutoBoxData.mUpRatios has unexpected offset % instead of 0", ((cast(*void)(*instance.mUpRatios)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleAutoBoxData.mUpRatios)) == 128, "PxVehicleAutoBoxData.mUpRatios has unexpected size % instead of 128", size_of(type_of(PxVehicleAutoBoxData.mUpRatios)));
        assert(((cast(*void)(*instance.mDownRatios)) - cast(*void)(*instance)) == 128, "PxVehicleAutoBoxData.mDownRatios has unexpected offset % instead of 128", ((cast(*void)(*instance.mDownRatios)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleAutoBoxData.mDownRatios)) == 128, "PxVehicleAutoBoxData.mDownRatios has unexpected size % instead of 128", size_of(type_of(PxVehicleAutoBoxData.mDownRatios)));
        assert(size_of(PxVehicleAutoBoxData) == 256, "PxVehicleAutoBoxData has size % instead of 256", size_of(PxVehicleAutoBoxData));
    }

    PxCompileTimeAssert_Dummy7 :: [1] u8;

    PxVehicleDifferential4WData :: struct {
        Enum :: enum s32 {
            DIFF_TYPE_LS_4WD       :: 0;
            DIFF_TYPE_LS_FRONTWD   :: 1;
            DIFF_TYPE_LS_REARWD    :: 2;
            DIFF_TYPE_OPEN_4WD     :: 3;
            DIFF_TYPE_OPEN_FRONTWD :: 4;
            DIFF_TYPE_OPEN_REARWD  :: 5;
            MAX_NB_DIFF_TYPES      :: 6;

            eDIFF_TYPE_LS_4WD       :: DIFF_TYPE_LS_4WD;
            eDIFF_TYPE_LS_FRONTWD   :: DIFF_TYPE_LS_FRONTWD;
            eDIFF_TYPE_LS_REARWD    :: DIFF_TYPE_LS_REARWD;
            eDIFF_TYPE_OPEN_4WD     :: DIFF_TYPE_OPEN_4WD;
            eDIFF_TYPE_OPEN_FRONTWD :: DIFF_TYPE_OPEN_FRONTWD;
            eDIFF_TYPE_OPEN_REARWD  :: DIFF_TYPE_OPEN_REARWD;
            eMAX_NB_DIFF_TYPES      :: MAX_NB_DIFF_TYPES;
        }

        Constructor :: (this: *PxVehicleDifferential4WData) -> void #cpp_method #foreign physx_lib "??0PxVehicleDifferential4WData@physx@@QEAA@XZ";

        /**
        \brief Ratio of torque split between front and rear (>0.5 means more to front, <0.5 means more to rear).

        \note Only applied to DIFF_TYPE_LS_4WD and eDIFF_TYPE_OPEN_4WD

        <b>Range:</b> [0, 1]<br>
        */
        mFrontRearSplit:      PxReal;

        /**
        \brief Ratio of torque split between front-left and front-right (>0.5 means more to front-left, <0.5 means more to front-right).

        \note Only applied to DIFF_TYPE_LS_4WD and eDIFF_TYPE_OPEN_4WD and eDIFF_TYPE_LS_FRONTWD

        <b>Range:</b> [0, 1]<br>
        */
        mFrontLeftRightSplit: PxReal;

        /**
        \brief Ratio of torque split between rear-left and rear-right (>0.5 means more to rear-left, <0.5 means more to rear-right).

        \note Only applied to DIFF_TYPE_LS_4WD and eDIFF_TYPE_OPEN_4WD and eDIFF_TYPE_LS_REARWD

        <b>Range:</b> [0, 1]<br>
        */
        mRearLeftRightSplit:  PxReal;

        /**
        \brief Maximum allowed ratio of average front wheel rotation speed and rear wheel rotation speeds
        The differential will divert more torque to the slower wheels when the bias is exceeded.

        \note Only applied to DIFF_TYPE_LS_4WD

        <b>Range:</b> [1, PX_MAX_F32)<br>
        */
        mCentreBias:          PxReal;

        /**
        \brief Maximum allowed ratio of front-left and front-right wheel rotation speeds.
        The differential will divert more torque to the slower wheel when the bias is exceeded.

        \note Only applied to DIFF_TYPE_LS_4WD and DIFF_TYPE_LS_FRONTWD

        <b>Range:</b> [1, PX_MAX_F32)<br>
        */
        mFrontBias:           PxReal;

        /**
        \brief Maximum allowed ratio of rear-left and rear-right wheel rotation speeds.
        The differential will divert more torque to the slower wheel when the bias is exceeded.

        \note Only applied to DIFF_TYPE_LS_4WD and DIFF_TYPE_LS_REARWD

        <b>Range:</b> [1, PX_MAX_F32)<br>
        */
        mRearBias:            PxReal;

        /**
        \brief Type of differential.

        <b>Range:</b> [DIFF_TYPE_LS_4WD, DIFF_TYPE_OPEN_FRONTWD]<br>
        */
        mType:                Enum;

        mPad:                 [1] PxReal;

        //serialization
        Constructor :: (this: *PxVehicleDifferential4WData, unknown0: PxEMPTY) -> void #cpp_method #foreign physx_lib "??0PxVehicleDifferential4WData@physx@@QEAA@W4PxEMPTY@1@@Z";
    }
    #run {if true then return;
        instance: PxVehicleDifferential4WData;
        assert(((cast(*void)(*instance.mFrontRearSplit)) - cast(*void)(*instance)) == 0, "PxVehicleDifferential4WData.mFrontRearSplit has unexpected offset % instead of 0", ((cast(*void)(*instance.mFrontRearSplit)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleDifferential4WData.mFrontRearSplit)) == 4, "PxVehicleDifferential4WData.mFrontRearSplit has unexpected size % instead of 4", size_of(type_of(PxVehicleDifferential4WData.mFrontRearSplit)));
        assert(((cast(*void)(*instance.mFrontLeftRightSplit)) - cast(*void)(*instance)) == 4, "PxVehicleDifferential4WData.mFrontLeftRightSplit has unexpected offset % instead of 4", ((cast(*void)(*instance.mFrontLeftRightSplit)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleDifferential4WData.mFrontLeftRightSplit)) == 4, "PxVehicleDifferential4WData.mFrontLeftRightSplit has unexpected size % instead of 4", size_of(type_of(PxVehicleDifferential4WData.mFrontLeftRightSplit)));
        assert(((cast(*void)(*instance.mRearLeftRightSplit)) - cast(*void)(*instance)) == 8, "PxVehicleDifferential4WData.mRearLeftRightSplit has unexpected offset % instead of 8", ((cast(*void)(*instance.mRearLeftRightSplit)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleDifferential4WData.mRearLeftRightSplit)) == 4, "PxVehicleDifferential4WData.mRearLeftRightSplit has unexpected size % instead of 4", size_of(type_of(PxVehicleDifferential4WData.mRearLeftRightSplit)));
        assert(((cast(*void)(*instance.mCentreBias)) - cast(*void)(*instance)) == 12, "PxVehicleDifferential4WData.mCentreBias has unexpected offset % instead of 12", ((cast(*void)(*instance.mCentreBias)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleDifferential4WData.mCentreBias)) == 4, "PxVehicleDifferential4WData.mCentreBias has unexpected size % instead of 4", size_of(type_of(PxVehicleDifferential4WData.mCentreBias)));
        assert(((cast(*void)(*instance.mFrontBias)) - cast(*void)(*instance)) == 16, "PxVehicleDifferential4WData.mFrontBias has unexpected offset % instead of 16", ((cast(*void)(*instance.mFrontBias)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleDifferential4WData.mFrontBias)) == 4, "PxVehicleDifferential4WData.mFrontBias has unexpected size % instead of 4", size_of(type_of(PxVehicleDifferential4WData.mFrontBias)));
        assert(((cast(*void)(*instance.mRearBias)) - cast(*void)(*instance)) == 20, "PxVehicleDifferential4WData.mRearBias has unexpected offset % instead of 20", ((cast(*void)(*instance.mRearBias)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleDifferential4WData.mRearBias)) == 4, "PxVehicleDifferential4WData.mRearBias has unexpected size % instead of 4", size_of(type_of(PxVehicleDifferential4WData.mRearBias)));
        assert(((cast(*void)(*instance.mType)) - cast(*void)(*instance)) == 24, "PxVehicleDifferential4WData.mType has unexpected offset % instead of 24", ((cast(*void)(*instance.mType)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleDifferential4WData.mType)) == 4, "PxVehicleDifferential4WData.mType has unexpected size % instead of 4", size_of(type_of(PxVehicleDifferential4WData.mType)));
        assert(((cast(*void)(*instance.mPad)) - cast(*void)(*instance)) == 28, "PxVehicleDifferential4WData.mPad has unexpected offset % instead of 28", ((cast(*void)(*instance.mPad)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleDifferential4WData.mPad)) == 4, "PxVehicleDifferential4WData.mPad has unexpected size % instead of 4", size_of(type_of(PxVehicleDifferential4WData.mPad)));
        assert(size_of(PxVehicleDifferential4WData) == 32, "PxVehicleDifferential4WData has size % instead of 32", size_of(PxVehicleDifferential4WData));
    }

    PxCompileTimeAssert_Dummy8 :: [1] u8;

    PxVehicleDifferentialNWData :: struct {
        Constructor :: (this: *PxVehicleDifferentialNWData) -> void #cpp_method #foreign physx_lib "??0PxVehicleDifferentialNWData@physx@@QEAA@XZ";

        mBitmapBuffer:      [1] PxU32;
        mNbDrivenWheels:    PxU32;
        mInvNbDrivenWheels: PxReal;
        mPad:               PxU32;

        //serialization
        Constructor :: (this: *PxVehicleDifferentialNWData, unknown0: PxEMPTY) -> void #cpp_method #foreign physx_lib "??0PxVehicleDifferentialNWData@physx@@QEAA@W4PxEMPTY@1@@Z";
    }
    #run {if true then return;
        instance: PxVehicleDifferentialNWData;
        assert(((cast(*void)(*instance.mBitmapBuffer)) - cast(*void)(*instance)) == 0, "PxVehicleDifferentialNWData.mBitmapBuffer has unexpected offset % instead of 0", ((cast(*void)(*instance.mBitmapBuffer)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleDifferentialNWData.mBitmapBuffer)) == 4, "PxVehicleDifferentialNWData.mBitmapBuffer has unexpected size % instead of 4", size_of(type_of(PxVehicleDifferentialNWData.mBitmapBuffer)));
        assert(((cast(*void)(*instance.mNbDrivenWheels)) - cast(*void)(*instance)) == 4, "PxVehicleDifferentialNWData.mNbDrivenWheels has unexpected offset % instead of 4", ((cast(*void)(*instance.mNbDrivenWheels)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleDifferentialNWData.mNbDrivenWheels)) == 4, "PxVehicleDifferentialNWData.mNbDrivenWheels has unexpected size % instead of 4", size_of(type_of(PxVehicleDifferentialNWData.mNbDrivenWheels)));
        assert(((cast(*void)(*instance.mInvNbDrivenWheels)) - cast(*void)(*instance)) == 8, "PxVehicleDifferentialNWData.mInvNbDrivenWheels has unexpected offset % instead of 8", ((cast(*void)(*instance.mInvNbDrivenWheels)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleDifferentialNWData.mInvNbDrivenWheels)) == 4, "PxVehicleDifferentialNWData.mInvNbDrivenWheels has unexpected size % instead of 4", size_of(type_of(PxVehicleDifferentialNWData.mInvNbDrivenWheels)));
        assert(((cast(*void)(*instance.mPad)) - cast(*void)(*instance)) == 12, "PxVehicleDifferentialNWData.mPad has unexpected offset % instead of 12", ((cast(*void)(*instance.mPad)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleDifferentialNWData.mPad)) == 4, "PxVehicleDifferentialNWData.mPad has unexpected size % instead of 4", size_of(type_of(PxVehicleDifferentialNWData.mPad)));
        assert(size_of(PxVehicleDifferentialNWData) == 16, "PxVehicleDifferentialNWData has size % instead of 16", size_of(PxVehicleDifferentialNWData));
    }

    PxCompileTimeAssert_Dummy9 :: [1] u8;

    PxVehicleAckermannGeometryData :: struct {
        Constructor :: (this: *PxVehicleAckermannGeometryData) -> void #cpp_method #foreign physx_lib "??0PxVehicleAckermannGeometryData@physx@@QEAA@XZ";

        /**
        \brief Accuracy of Ackermann steer calculation.

        \note Accuracy with value 0.0 results in no Ackermann steer-correction, while
        accuracy with value 1.0 results in perfect Ackermann steer-correction.

        \note Perfect Ackermann steer correction modifies the steer angles applied to the front-left and
        front-right wheels so that the perpendiculars to the wheels' longitudinal directions cross the
        extended vector of the rear axle at the same point.  It is also applied to any steer angle applied
        to the rear wheels but instead using the extended vector of the front axle.

        \note In general, more steer correction produces better cornering behavior.

        <b>Range:</b> [0, 1]<br>
        */
        mAccuracy:       PxReal;

        /**
        \brief Distance between center-point of the two front wheels.

        \note Specified in metres (m).

        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mFrontWidth:     PxReal;

        /**
        \brief Distance between center-point of the two rear wheels.

        \note Specified in metres (m).

        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mRearWidth:      PxReal;

        /**
        \brief Distance between center of front axle and center of rear axle.

        \note Specified in metres (m).

        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mAxleSeparation: PxReal;

        //serialization
        Constructor :: (this: *PxVehicleAckermannGeometryData, unknown0: PxEMPTY) -> void #cpp_method #foreign physx_lib "??0PxVehicleAckermannGeometryData@physx@@QEAA@W4PxEMPTY@1@@Z";
    }
    #run {if true then return;
        instance: PxVehicleAckermannGeometryData;
        assert(((cast(*void)(*instance.mAccuracy)) - cast(*void)(*instance)) == 0, "PxVehicleAckermannGeometryData.mAccuracy has unexpected offset % instead of 0", ((cast(*void)(*instance.mAccuracy)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleAckermannGeometryData.mAccuracy)) == 4, "PxVehicleAckermannGeometryData.mAccuracy has unexpected size % instead of 4", size_of(type_of(PxVehicleAckermannGeometryData.mAccuracy)));
        assert(((cast(*void)(*instance.mFrontWidth)) - cast(*void)(*instance)) == 4, "PxVehicleAckermannGeometryData.mFrontWidth has unexpected offset % instead of 4", ((cast(*void)(*instance.mFrontWidth)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleAckermannGeometryData.mFrontWidth)) == 4, "PxVehicleAckermannGeometryData.mFrontWidth has unexpected size % instead of 4", size_of(type_of(PxVehicleAckermannGeometryData.mFrontWidth)));
        assert(((cast(*void)(*instance.mRearWidth)) - cast(*void)(*instance)) == 8, "PxVehicleAckermannGeometryData.mRearWidth has unexpected offset % instead of 8", ((cast(*void)(*instance.mRearWidth)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleAckermannGeometryData.mRearWidth)) == 4, "PxVehicleAckermannGeometryData.mRearWidth has unexpected size % instead of 4", size_of(type_of(PxVehicleAckermannGeometryData.mRearWidth)));
        assert(((cast(*void)(*instance.mAxleSeparation)) - cast(*void)(*instance)) == 12, "PxVehicleAckermannGeometryData.mAxleSeparation has unexpected offset % instead of 12", ((cast(*void)(*instance.mAxleSeparation)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleAckermannGeometryData.mAxleSeparation)) == 4, "PxVehicleAckermannGeometryData.mAxleSeparation has unexpected size % instead of 4", size_of(type_of(PxVehicleAckermannGeometryData.mAxleSeparation)));
        assert(size_of(PxVehicleAckermannGeometryData) == 16, "PxVehicleAckermannGeometryData has size % instead of 16", size_of(PxVehicleAckermannGeometryData));
    }

    PxCompileTimeAssert_Dummy10 :: [1] u8;

    /**
    \brief Choose between a potentially more expensive but more accurate solution to the clutch model or a potentially cheaper but less accurate solution.
    @see PxVehicleClutchData
    */
    PxVehicleClutchAccuracyMode :: struct {
        Enum :: enum s32 {
            ESTIMATE      :: 0;
            BEST_POSSIBLE :: 1;

            eESTIMATE      :: ESTIMATE;
            eBEST_POSSIBLE :: BEST_POSSIBLE;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxVehicleClutchAccuracyMode) == 1, "PxVehicleClutchAccuracyMode has size % instead of 1", size_of(PxVehicleClutchAccuracyMode));
    }

    PxVehicleClutchData :: struct {
        Constructor :: (this: *PxVehicleClutchData) -> void #cpp_method #foreign physx_lib "??0PxVehicleClutchData@physx@@QEAA@XZ";

        /**
        \brief Strength of clutch.

        \note The clutch is the mechanism that couples the engine to the wheels.
        A stronger clutch more strongly couples the engine to the wheels, while a
        clutch of strength zero completely decouples the engine from the wheels.
        Stronger clutches more quickly bring the wheels and engine into equilibrium, while weaker
        clutches take longer, resulting in periods of clutch slip and delays in power transmission
        from the engine to the wheels.
        The torque generated by the clutch is proportional to the clutch strength and
        the velocity difference between the engine's rotational speed and the rotational speed of the
        driven wheels after accounting for the gear ratio.
        The torque at the clutch is applied negatively to the engine and positively to the driven wheels.

        \note Specified in kilograms metres-squared per second (kg m^2 s^-1)

        <b>Range:</b> [0,PX_MAX_F32)<br>
        */
        mStrength:           PxReal;

        /**
        \brief The engine and wheel rotation speeds that are coupled through the clutch can be updated by choosing
        one of two modes: eESTIMATE and eBEST_POSSIBLE.

        \note If eESTIMATE is chosen the vehicle sdk will update the wheel and engine rotation speeds
        with estimated values to the implemented clutch model.

        \note If eBEST_POSSIBLE is chosen the vehicle sdk will compute the best possible
        solution (within floating point tolerance) to the implemented clutch model.
        This is the recommended mode.

        \note The clutch model remains the same if either eESTIMATE or eBEST_POSSIBLE is chosen but the accuracy and
        computational cost of the solution to the model can be tuned as required.
        */
        mAccuracyMode:       PxVehicleClutchAccuracyMode.Enum;

        /**
        \brief Tune the mathematical accuracy and computational cost of the computed estimate to the wheel and
        engine rotation speeds if eESTIMATE is chosen.

        \note As mEstimateIterations increases the computational cost of the clutch also increases and the solution
        approaches the solution that would be computed if eBEST_POSSIBLE was chosen instead.

        \note This has no effect if eBEST_POSSIBLE is chosen as the accuracy mode.

        \note A value of zero is not allowed if eESTIMATE is chosen as the accuracy mode.
        */
        mEstimateIterations: PxU32;

        mPad:                [4] PxU8;

        //serialization
        Constructor :: (this: *PxVehicleClutchData, unknown0: PxEMPTY) -> void #cpp_method #foreign physx_lib "??0PxVehicleClutchData@physx@@QEAA@W4PxEMPTY@1@@Z";
    }
    #run {if true then return;
        instance: PxVehicleClutchData;
        assert(((cast(*void)(*instance.mStrength)) - cast(*void)(*instance)) == 0, "PxVehicleClutchData.mStrength has unexpected offset % instead of 0", ((cast(*void)(*instance.mStrength)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleClutchData.mStrength)) == 4, "PxVehicleClutchData.mStrength has unexpected size % instead of 4", size_of(type_of(PxVehicleClutchData.mStrength)));
        assert(((cast(*void)(*instance.mAccuracyMode)) - cast(*void)(*instance)) == 4, "PxVehicleClutchData.mAccuracyMode has unexpected offset % instead of 4", ((cast(*void)(*instance.mAccuracyMode)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleClutchData.mAccuracyMode)) == 4, "PxVehicleClutchData.mAccuracyMode has unexpected size % instead of 4", size_of(type_of(PxVehicleClutchData.mAccuracyMode)));
        assert(((cast(*void)(*instance.mEstimateIterations)) - cast(*void)(*instance)) == 8, "PxVehicleClutchData.mEstimateIterations has unexpected offset % instead of 8", ((cast(*void)(*instance.mEstimateIterations)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleClutchData.mEstimateIterations)) == 4, "PxVehicleClutchData.mEstimateIterations has unexpected size % instead of 4", size_of(type_of(PxVehicleClutchData.mEstimateIterations)));
        assert(((cast(*void)(*instance.mPad)) - cast(*void)(*instance)) == 12, "PxVehicleClutchData.mPad has unexpected offset % instead of 12", ((cast(*void)(*instance.mPad)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleClutchData.mPad)) == 4, "PxVehicleClutchData.mPad has unexpected size % instead of 4", size_of(type_of(PxVehicleClutchData.mPad)));
        assert(size_of(PxVehicleClutchData) == 16, "PxVehicleClutchData has size % instead of 16", size_of(PxVehicleClutchData));
    }

    PxCompileTimeAssert_Dummy11 :: [1] u8;

    /**
    \brief Tire load variation can be strongly dependent on the time-step so it is a good idea to filter it
    to give less jerky handling behavior.

    \note The x-axis of the graph is normalized tire load, while the y-axis is the filtered normalized tire load.

    \note The normalized load is the force acting downwards on the tire divided by the force experienced by the tire when the car is at rest on the ground.

    \note The rest load is approximately the product of the value of gravitational acceleration and PxVehicleSuspensionData::mSprungMass.

    \note The minimum possible normalized load is zero.

    \note There are two points on the graph: (mMinNormalisedLoad, mMinNormalisedFilteredLoad) and (mMaxNormalisedLoad, mMaxFilteredNormalisedLoad).

    \note Normalized loads less than mMinNormalisedLoad have filtered normalized load = mMinNormalisedFilteredLoad.

    \note Normalized loads greater than mMaxNormalisedLoad have filtered normalized load = mMaxFilteredNormalisedLoad.

    \note Normalized loads in-between are linearly interpolated between mMinNormalisedFilteredLoad and mMaxFilteredNormalisedLoad.

    \note The tire load applied as input to the tire force computation is the filtered normalized load multiplied by the rest load.
    */
    PxVehicleTireLoadFilterData :: struct {
        Constructor :: (this: *PxVehicleTireLoadFilterData) -> void #cpp_method #foreign physx_lib "??0PxVehicleTireLoadFilterData@physx@@QEAA@XZ";

        /**
        \brief Graph point (mMinNormalisedLoad,mMinFilteredNormalisedLoad)
        */
        mMinNormalisedLoad:         PxReal;

        /**
        \brief Graph point (mMinNormalisedLoad,mMinFilteredNormalisedLoad)
        */
        mMinFilteredNormalisedLoad: PxReal;

        /**
        \brief Graph point (mMaxNormalisedLoad,mMaxFilteredNormalisedLoad)
        */
        mMaxNormalisedLoad:         PxReal;

        /**
        \brief Graph point (mMaxNormalisedLoad,mMaxFilteredNormalisedLoad)
        */
        mMaxFilteredNormalisedLoad: PxReal;

        getDenominator :: (this: *PxVehicleTireLoadFilterData) -> PxReal #cpp_method #foreign physx_lib "?getDenominator@PxVehicleTireLoadFilterData@physx@@QEBAMXZ";

        /**
        \brief Not necessary to set this value.
        */
        //1.0f/(mMaxNormalisedLoad-mMinNormalisedLoad) for quick calculations
        mDenominator:               PxReal;

        mPad:                       [3] PxU32;

        //serialization
        Constructor :: (this: *PxVehicleTireLoadFilterData, unknown0: PxEMPTY) -> void #cpp_method #foreign physx_lib "??0PxVehicleTireLoadFilterData@physx@@QEAA@W4PxEMPTY@1@@Z";
    }
    #run {if true then return;
        instance: PxVehicleTireLoadFilterData;
        assert(((cast(*void)(*instance.mMinNormalisedLoad)) - cast(*void)(*instance)) == 0, "PxVehicleTireLoadFilterData.mMinNormalisedLoad has unexpected offset % instead of 0", ((cast(*void)(*instance.mMinNormalisedLoad)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleTireLoadFilterData.mMinNormalisedLoad)) == 4, "PxVehicleTireLoadFilterData.mMinNormalisedLoad has unexpected size % instead of 4", size_of(type_of(PxVehicleTireLoadFilterData.mMinNormalisedLoad)));
        assert(((cast(*void)(*instance.mMinFilteredNormalisedLoad)) - cast(*void)(*instance)) == 4, "PxVehicleTireLoadFilterData.mMinFilteredNormalisedLoad has unexpected offset % instead of 4", ((cast(*void)(*instance.mMinFilteredNormalisedLoad)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleTireLoadFilterData.mMinFilteredNormalisedLoad)) == 4, "PxVehicleTireLoadFilterData.mMinFilteredNormalisedLoad has unexpected size % instead of 4", size_of(type_of(PxVehicleTireLoadFilterData.mMinFilteredNormalisedLoad)));
        assert(((cast(*void)(*instance.mMaxNormalisedLoad)) - cast(*void)(*instance)) == 8, "PxVehicleTireLoadFilterData.mMaxNormalisedLoad has unexpected offset % instead of 8", ((cast(*void)(*instance.mMaxNormalisedLoad)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleTireLoadFilterData.mMaxNormalisedLoad)) == 4, "PxVehicleTireLoadFilterData.mMaxNormalisedLoad has unexpected size % instead of 4", size_of(type_of(PxVehicleTireLoadFilterData.mMaxNormalisedLoad)));
        assert(((cast(*void)(*instance.mMaxFilteredNormalisedLoad)) - cast(*void)(*instance)) == 12, "PxVehicleTireLoadFilterData.mMaxFilteredNormalisedLoad has unexpected offset % instead of 12", ((cast(*void)(*instance.mMaxFilteredNormalisedLoad)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleTireLoadFilterData.mMaxFilteredNormalisedLoad)) == 4, "PxVehicleTireLoadFilterData.mMaxFilteredNormalisedLoad has unexpected size % instead of 4", size_of(type_of(PxVehicleTireLoadFilterData.mMaxFilteredNormalisedLoad)));
        assert(((cast(*void)(*instance.mDenominator)) - cast(*void)(*instance)) == 16, "PxVehicleTireLoadFilterData.mDenominator has unexpected offset % instead of 16", ((cast(*void)(*instance.mDenominator)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleTireLoadFilterData.mDenominator)) == 4, "PxVehicleTireLoadFilterData.mDenominator has unexpected size % instead of 4", size_of(type_of(PxVehicleTireLoadFilterData.mDenominator)));
        assert(((cast(*void)(*instance.mPad)) - cast(*void)(*instance)) == 20, "PxVehicleTireLoadFilterData.mPad has unexpected offset % instead of 20", ((cast(*void)(*instance.mPad)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleTireLoadFilterData.mPad)) == 12, "PxVehicleTireLoadFilterData.mPad has unexpected size % instead of 12", size_of(type_of(PxVehicleTireLoadFilterData.mPad)));
        assert(size_of(PxVehicleTireLoadFilterData) == 32, "PxVehicleTireLoadFilterData has size % instead of 32", size_of(PxVehicleTireLoadFilterData));
    }

    PxCompileTimeAssert_Dummy12 :: [1] u8;

    PxVehicleWheelData :: struct {
        Constructor :: (this: *PxVehicleWheelData) -> void #cpp_method #foreign physx_lib "??0PxVehicleWheelData@physx@@QEAA@XZ";

        /**
        \brief Radius of unit that includes metal wheel plus rubber tire.

        \note Specified in metres (m).

        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mRadius:             PxReal;

        /**
        \brief Maximum width of unit that includes wheel plus tire.

        \note Specified in metres (m).

        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mWidth:              PxReal;

        /**
        \brief Mass of unit that includes wheel plus tire.

        \note Specified in kilograms (kg).

        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mMass:               PxReal;

        /**
        \brief Moment of inertia of unit that includes wheel plus tire about the rolling axis.

        \note Specified in kilograms metres-squared (kg m^2).

        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mMOI:                PxReal;

        /**
        \brief Damping rate applied to wheel.

        \note Specified in kilograms metres-squared per second (kg m^2 s^-1).

        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mDampingRate:        PxReal;

        /**
        \brief Max brake torque that can be applied to wheel.

        \note Specified in kilograms metres-squared per second-squared (kg m^2 s^-2)

        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mMaxBrakeTorque:     PxReal;

        /**
        \brief Max handbrake torque that can be applied to wheel.

        \note Specified in kilograms metres-squared per second-squared (kg m^2 s^-2)

        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mMaxHandBrakeTorque: PxReal;

        /**
        \brief Max steer angle that can be achieved by the wheel.

        \note Specified in radians.

        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mMaxSteer:           PxReal;

        mToeAngle:           PxReal; //in radians

        /**
        \brief Return value equal to 1.0f/mRadius

        @see PxVehicleWheelsSimData::setWheelData
        */
        getRecipRadius :: (this: *PxVehicleWheelData) -> PxReal #cpp_method #foreign physx_lib "?getRecipRadius@PxVehicleWheelData@physx@@QEBAMXZ";

        /**
        \brief Return value equal to 1.0f/mRecipMOI

        @see PxVehicleWheelsSimData::setWheelData
        */
        getRecipMOI :: (this: *PxVehicleWheelData) -> PxReal #cpp_method #foreign physx_lib "?getRecipMOI@PxVehicleWheelData@physx@@QEBAMXZ";

        /**
        \brief Reciprocal of radius of unit that includes metal wheel plus rubber tire.

        \note Not necessary to set this value because it is set by PxVehicleWheelsSimData::setWheelData

        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mRecipRadius:        PxReal;

        /**
        \brief Reciprocal of moment of inertia of unit that includes wheel plus tire about single allowed axis of rotation.

        \note Not necessary to set this value because it is set by PxVehicleWheelsSimData::setWheelData

        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mRecipMOI:           PxReal;

        mPad:                [1] PxReal;
    }
    #run {if true then return;
        instance: PxVehicleWheelData;
        assert(((cast(*void)(*instance.mRadius)) - cast(*void)(*instance)) == 0, "PxVehicleWheelData.mRadius has unexpected offset % instead of 0", ((cast(*void)(*instance.mRadius)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleWheelData.mRadius)) == 4, "PxVehicleWheelData.mRadius has unexpected size % instead of 4", size_of(type_of(PxVehicleWheelData.mRadius)));
        assert(((cast(*void)(*instance.mWidth)) - cast(*void)(*instance)) == 4, "PxVehicleWheelData.mWidth has unexpected offset % instead of 4", ((cast(*void)(*instance.mWidth)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleWheelData.mWidth)) == 4, "PxVehicleWheelData.mWidth has unexpected size % instead of 4", size_of(type_of(PxVehicleWheelData.mWidth)));
        assert(((cast(*void)(*instance.mMass)) - cast(*void)(*instance)) == 8, "PxVehicleWheelData.mMass has unexpected offset % instead of 8", ((cast(*void)(*instance.mMass)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleWheelData.mMass)) == 4, "PxVehicleWheelData.mMass has unexpected size % instead of 4", size_of(type_of(PxVehicleWheelData.mMass)));
        assert(((cast(*void)(*instance.mMOI)) - cast(*void)(*instance)) == 12, "PxVehicleWheelData.mMOI has unexpected offset % instead of 12", ((cast(*void)(*instance.mMOI)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleWheelData.mMOI)) == 4, "PxVehicleWheelData.mMOI has unexpected size % instead of 4", size_of(type_of(PxVehicleWheelData.mMOI)));
        assert(((cast(*void)(*instance.mDampingRate)) - cast(*void)(*instance)) == 16, "PxVehicleWheelData.mDampingRate has unexpected offset % instead of 16", ((cast(*void)(*instance.mDampingRate)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleWheelData.mDampingRate)) == 4, "PxVehicleWheelData.mDampingRate has unexpected size % instead of 4", size_of(type_of(PxVehicleWheelData.mDampingRate)));
        assert(((cast(*void)(*instance.mMaxBrakeTorque)) - cast(*void)(*instance)) == 20, "PxVehicleWheelData.mMaxBrakeTorque has unexpected offset % instead of 20", ((cast(*void)(*instance.mMaxBrakeTorque)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleWheelData.mMaxBrakeTorque)) == 4, "PxVehicleWheelData.mMaxBrakeTorque has unexpected size % instead of 4", size_of(type_of(PxVehicleWheelData.mMaxBrakeTorque)));
        assert(((cast(*void)(*instance.mMaxHandBrakeTorque)) - cast(*void)(*instance)) == 24, "PxVehicleWheelData.mMaxHandBrakeTorque has unexpected offset % instead of 24", ((cast(*void)(*instance.mMaxHandBrakeTorque)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleWheelData.mMaxHandBrakeTorque)) == 4, "PxVehicleWheelData.mMaxHandBrakeTorque has unexpected size % instead of 4", size_of(type_of(PxVehicleWheelData.mMaxHandBrakeTorque)));
        assert(((cast(*void)(*instance.mMaxSteer)) - cast(*void)(*instance)) == 28, "PxVehicleWheelData.mMaxSteer has unexpected offset % instead of 28", ((cast(*void)(*instance.mMaxSteer)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleWheelData.mMaxSteer)) == 4, "PxVehicleWheelData.mMaxSteer has unexpected size % instead of 4", size_of(type_of(PxVehicleWheelData.mMaxSteer)));
        assert(((cast(*void)(*instance.mToeAngle)) - cast(*void)(*instance)) == 32, "PxVehicleWheelData.mToeAngle has unexpected offset % instead of 32", ((cast(*void)(*instance.mToeAngle)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleWheelData.mToeAngle)) == 4, "PxVehicleWheelData.mToeAngle has unexpected size % instead of 4", size_of(type_of(PxVehicleWheelData.mToeAngle)));
        assert(((cast(*void)(*instance.mRecipRadius)) - cast(*void)(*instance)) == 36, "PxVehicleWheelData.mRecipRadius has unexpected offset % instead of 36", ((cast(*void)(*instance.mRecipRadius)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleWheelData.mRecipRadius)) == 4, "PxVehicleWheelData.mRecipRadius has unexpected size % instead of 4", size_of(type_of(PxVehicleWheelData.mRecipRadius)));
        assert(((cast(*void)(*instance.mRecipMOI)) - cast(*void)(*instance)) == 40, "PxVehicleWheelData.mRecipMOI has unexpected offset % instead of 40", ((cast(*void)(*instance.mRecipMOI)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleWheelData.mRecipMOI)) == 4, "PxVehicleWheelData.mRecipMOI has unexpected size % instead of 4", size_of(type_of(PxVehicleWheelData.mRecipMOI)));
        assert(((cast(*void)(*instance.mPad)) - cast(*void)(*instance)) == 44, "PxVehicleWheelData.mPad has unexpected offset % instead of 44", ((cast(*void)(*instance.mPad)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleWheelData.mPad)) == 4, "PxVehicleWheelData.mPad has unexpected size % instead of 4", size_of(type_of(PxVehicleWheelData.mPad)));
        assert(size_of(PxVehicleWheelData) == 48, "PxVehicleWheelData has size % instead of 48", size_of(PxVehicleWheelData));
    }

    PxCompileTimeAssert_Dummy13 :: [1] u8;

    PxVehicleSuspensionData :: struct {
        Constructor :: (this: *PxVehicleSuspensionData) -> void #cpp_method #foreign physx_lib "??0PxVehicleSuspensionData@physx@@QEAA@XZ";

        /**
        \brief Spring strength of suspension unit.

        \note Specified in kilograms per second-squared (kg s^-2).

        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mSpringStrength:         PxReal;

        /**
        \brief Spring damper rate of suspension unit.

        \note Specified in kilograms per second (kg s^-1).

        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mSpringDamperRate:       PxReal;

        /**
        \brief Maximum compression allowed by suspension spring.

        \note Specified in metres (m).

        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mMaxCompression:         PxReal;

        /**
        \brief Maximum elongation allowed by suspension spring.

        \note Specified in metres (m).

        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mMaxDroop:               PxReal;

        /**
        \brief Mass of vehicle that is supported by suspension spring.

        \note Specified in kilograms (kg).

        \note Each suspension is guaranteed to generate an upwards force of |gravity|*mSprungMass along the suspension direction when the wheel is perfectly
        at rest and sitting at the rest pose defined by the wheel centre offset.

        \note The sum of the sprung masses of all suspensions of a vehicle should match the mass of the PxRigidDynamic associated with the vehicle.
        When this condition is satisfied for a vehicle on a horizontal plane the wheels of the vehicle are guaranteed to sit at the rest pose
        defined by the wheel centre offset.  The mass matching condition is not enforced.

        \note As the wheel compresses or elongates along the suspension direction the force generated by the spring is
        F = |gravity|*mSprungMass + deltaX*mSpringStrength + deltaXDot*mSpringDamperRate
        where deltaX is the deviation from the defined rest pose and deltaXDot is the velocity of the sprung mass along the suspension direction.
        In practice, deltaXDot is computed by comparing the current and previous deviation from the rest pose and dividing the difference
        by the simulation timestep.

        \note If a single suspension spring is hanging in the air and generates zero force the remaining springs of the vehicle will necessarily
        sit in a compressed configuration.  In summary, the sum of the remaining suspension forces cannot balance the downwards gravitational force
        acting on the vehicle without extra force arising from the deltaX*mSpringStrength force term.

        \note Theoretically, a suspension spring should generate zero force at maximum elongation and increase linearly as the suspension approaches the rest pose.
        PxVehicleSuspensionData will only enforce this physical law if the spring is configured so that |gravity|*mSprungMass == mMaxDroop*mSpringStrength.
        To help decouple vehicle handling from visual wheel positioning this condition is not enforced.
        In practice, the value of |gravity|*mSprungMass + deltaX*mSpringStrength is clamped at zero to ensure it never falls negative.

        @see PxVehicleComputeSprungMasses, PxVehicleWheelsSimData::setWheelCentreOffset, PxVehicleSuspensionData::mSpringStrength, PxVehicleSuspensionData::mSpringDamperRate, PxVehicleSuspensionData::mMaxDroop

        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mSprungMass:             PxReal;

        /**
        \brief Camber angle (in radians) of wheel when the suspension is at its rest position.

        \note Specified in radians.

        <b>Range:</b> [-pi/2, pi/2]<br>

        */
        mCamberAtRest:           PxReal;

        /**
        \brief Camber angle (in radians) of wheel when the suspension is at maximum compression.

        \note For compressed suspensions the camber angle is a linear interpolation of
        mCamberAngleAtRest and mCamberAtMaxCompression

        \note Specified in radians.

        <b>Range:</b> [-pi/2, pi/2]<br>
        */
        mCamberAtMaxCompression: PxReal;

        /**
        \brief Camber angle (in radians) of wheel when the suspension is at maximum droop.

        \note For extended suspensions the camber angle is linearly interpolation of
        mCamberAngleAtRest and mCamberAtMaxDroop

        \note Specified in radians.

        <b>Range:</b> [-pi/2, pi/2]<br>
        */
        mCamberAtMaxDroop:       PxReal;

        /**
        \brief Reciprocal of maximum compression.

        \note Not necessary to set this value because it is set by PxVehicleWheelsSimData::setSuspensionData

        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        getRecipMaxCompression :: (this: *PxVehicleSuspensionData) -> PxReal #cpp_method #foreign physx_lib "?getRecipMaxCompression@PxVehicleSuspensionData@physx@@QEBAMXZ";

        /**
        \brief Reciprocal of maximum droop.

        \note Not necessary to set this value because it is set by PxVehicleWheelsSimData::setSuspensionData

        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        getRecipMaxDroop :: (this: *PxVehicleSuspensionData) -> PxReal #cpp_method #foreign physx_lib "?getRecipMaxDroop@PxVehicleSuspensionData@physx@@QEBAMXZ";

        /**
        \brief Set a new sprung mass for the suspension and modify the spring strength so that the natural frequency
        of the spring is preserved.
        \param[in] newSprungMass is the new mass that the suspension spring will support.
        */
        setMassAndPreserveNaturalFrequency :: (this: *PxVehicleSuspensionData, newSprungMass: PxReal) -> void #cpp_method #foreign physx_lib "?setMassAndPreserveNaturalFrequency@PxVehicleSuspensionData@physx@@QEAAXM@Z";

        /**
        \brief Cached value of 1.0f/mMaxCompression

        \note Not necessary to set this value because it is set by PxVehicleWheelsSimData::setSuspensionData
        */
        mRecipMaxCompression:    PxReal;

        /**
        \brief Cached value of 1.0f/mMaxDroop

        \note Not necessary to set this value because it is set by PxVehicleWheelsSimData::setSuspensionData
        */
        mRecipMaxDroop:          PxReal;

        //padding
        mPad:                    [2] PxReal;
    }
    #run {if true then return;
        instance: PxVehicleSuspensionData;
        assert(((cast(*void)(*instance.mSpringStrength)) - cast(*void)(*instance)) == 0, "PxVehicleSuspensionData.mSpringStrength has unexpected offset % instead of 0", ((cast(*void)(*instance.mSpringStrength)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleSuspensionData.mSpringStrength)) == 4, "PxVehicleSuspensionData.mSpringStrength has unexpected size % instead of 4", size_of(type_of(PxVehicleSuspensionData.mSpringStrength)));
        assert(((cast(*void)(*instance.mSpringDamperRate)) - cast(*void)(*instance)) == 4, "PxVehicleSuspensionData.mSpringDamperRate has unexpected offset % instead of 4", ((cast(*void)(*instance.mSpringDamperRate)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleSuspensionData.mSpringDamperRate)) == 4, "PxVehicleSuspensionData.mSpringDamperRate has unexpected size % instead of 4", size_of(type_of(PxVehicleSuspensionData.mSpringDamperRate)));
        assert(((cast(*void)(*instance.mMaxCompression)) - cast(*void)(*instance)) == 8, "PxVehicleSuspensionData.mMaxCompression has unexpected offset % instead of 8", ((cast(*void)(*instance.mMaxCompression)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleSuspensionData.mMaxCompression)) == 4, "PxVehicleSuspensionData.mMaxCompression has unexpected size % instead of 4", size_of(type_of(PxVehicleSuspensionData.mMaxCompression)));
        assert(((cast(*void)(*instance.mMaxDroop)) - cast(*void)(*instance)) == 12, "PxVehicleSuspensionData.mMaxDroop has unexpected offset % instead of 12", ((cast(*void)(*instance.mMaxDroop)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleSuspensionData.mMaxDroop)) == 4, "PxVehicleSuspensionData.mMaxDroop has unexpected size % instead of 4", size_of(type_of(PxVehicleSuspensionData.mMaxDroop)));
        assert(((cast(*void)(*instance.mSprungMass)) - cast(*void)(*instance)) == 16, "PxVehicleSuspensionData.mSprungMass has unexpected offset % instead of 16", ((cast(*void)(*instance.mSprungMass)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleSuspensionData.mSprungMass)) == 4, "PxVehicleSuspensionData.mSprungMass has unexpected size % instead of 4", size_of(type_of(PxVehicleSuspensionData.mSprungMass)));
        assert(((cast(*void)(*instance.mCamberAtRest)) - cast(*void)(*instance)) == 20, "PxVehicleSuspensionData.mCamberAtRest has unexpected offset % instead of 20", ((cast(*void)(*instance.mCamberAtRest)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleSuspensionData.mCamberAtRest)) == 4, "PxVehicleSuspensionData.mCamberAtRest has unexpected size % instead of 4", size_of(type_of(PxVehicleSuspensionData.mCamberAtRest)));
        assert(((cast(*void)(*instance.mCamberAtMaxCompression)) - cast(*void)(*instance)) == 24, "PxVehicleSuspensionData.mCamberAtMaxCompression has unexpected offset % instead of 24", ((cast(*void)(*instance.mCamberAtMaxCompression)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleSuspensionData.mCamberAtMaxCompression)) == 4, "PxVehicleSuspensionData.mCamberAtMaxCompression has unexpected size % instead of 4", size_of(type_of(PxVehicleSuspensionData.mCamberAtMaxCompression)));
        assert(((cast(*void)(*instance.mCamberAtMaxDroop)) - cast(*void)(*instance)) == 28, "PxVehicleSuspensionData.mCamberAtMaxDroop has unexpected offset % instead of 28", ((cast(*void)(*instance.mCamberAtMaxDroop)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleSuspensionData.mCamberAtMaxDroop)) == 4, "PxVehicleSuspensionData.mCamberAtMaxDroop has unexpected size % instead of 4", size_of(type_of(PxVehicleSuspensionData.mCamberAtMaxDroop)));
        assert(((cast(*void)(*instance.mRecipMaxCompression)) - cast(*void)(*instance)) == 32, "PxVehicleSuspensionData.mRecipMaxCompression has unexpected offset % instead of 32", ((cast(*void)(*instance.mRecipMaxCompression)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleSuspensionData.mRecipMaxCompression)) == 4, "PxVehicleSuspensionData.mRecipMaxCompression has unexpected size % instead of 4", size_of(type_of(PxVehicleSuspensionData.mRecipMaxCompression)));
        assert(((cast(*void)(*instance.mRecipMaxDroop)) - cast(*void)(*instance)) == 36, "PxVehicleSuspensionData.mRecipMaxDroop has unexpected offset % instead of 36", ((cast(*void)(*instance.mRecipMaxDroop)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleSuspensionData.mRecipMaxDroop)) == 4, "PxVehicleSuspensionData.mRecipMaxDroop has unexpected size % instead of 4", size_of(type_of(PxVehicleSuspensionData.mRecipMaxDroop)));
        assert(((cast(*void)(*instance.mPad)) - cast(*void)(*instance)) == 40, "PxVehicleSuspensionData.mPad has unexpected offset % instead of 40", ((cast(*void)(*instance.mPad)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleSuspensionData.mPad)) == 8, "PxVehicleSuspensionData.mPad has unexpected size % instead of 8", size_of(type_of(PxVehicleSuspensionData.mPad)));
        assert(size_of(PxVehicleSuspensionData) == 48, "PxVehicleSuspensionData has size % instead of 48", size_of(PxVehicleSuspensionData));
    }

    PxCompileTimeAssert_Dummy14 :: [1] u8;

    PxVehicleAntiRollBarData :: struct {
        Constructor :: (this: *PxVehicleAntiRollBarData) -> void #cpp_method #foreign physx_lib "??0PxVehicleAntiRollBarData@physx@@QEAA@XZ";

        /*
        \brief The anti-roll bar connects two wheels with indices mWheel0 and mWheel1
        */
        mWheel0:    PxU32;

        /*
        \brief The anti-roll bar connects two wheels with indices mWheel0 and mWheel1
        */
        mWheel1:    PxU32;

        /*
        \brief The stiffness of the anti-roll bar.

        \note Specified in kilograms per second-squared (kg s^-2).

        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mStiffness: PxF32;

        mPad:       [1] PxF32;
    }
    #run {if true then return;
        instance: PxVehicleAntiRollBarData;
        assert(((cast(*void)(*instance.mWheel0)) - cast(*void)(*instance)) == 0, "PxVehicleAntiRollBarData.mWheel0 has unexpected offset % instead of 0", ((cast(*void)(*instance.mWheel0)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleAntiRollBarData.mWheel0)) == 4, "PxVehicleAntiRollBarData.mWheel0 has unexpected size % instead of 4", size_of(type_of(PxVehicleAntiRollBarData.mWheel0)));
        assert(((cast(*void)(*instance.mWheel1)) - cast(*void)(*instance)) == 4, "PxVehicleAntiRollBarData.mWheel1 has unexpected offset % instead of 4", ((cast(*void)(*instance.mWheel1)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleAntiRollBarData.mWheel1)) == 4, "PxVehicleAntiRollBarData.mWheel1 has unexpected size % instead of 4", size_of(type_of(PxVehicleAntiRollBarData.mWheel1)));
        assert(((cast(*void)(*instance.mStiffness)) - cast(*void)(*instance)) == 8, "PxVehicleAntiRollBarData.mStiffness has unexpected offset % instead of 8", ((cast(*void)(*instance.mStiffness)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleAntiRollBarData.mStiffness)) == 4, "PxVehicleAntiRollBarData.mStiffness has unexpected size % instead of 4", size_of(type_of(PxVehicleAntiRollBarData.mStiffness)));
        assert(((cast(*void)(*instance.mPad)) - cast(*void)(*instance)) == 12, "PxVehicleAntiRollBarData.mPad has unexpected offset % instead of 12", ((cast(*void)(*instance.mPad)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleAntiRollBarData.mPad)) == 4, "PxVehicleAntiRollBarData.mPad has unexpected size % instead of 4", size_of(type_of(PxVehicleAntiRollBarData.mPad)));
        assert(size_of(PxVehicleAntiRollBarData) == 16, "PxVehicleAntiRollBarData has size % instead of 16", size_of(PxVehicleAntiRollBarData));
    }

    PxCompileTimeAssert_Dummy15 :: [1] u8;

    PxVehicleTireData :: struct {
        Constructor :: (this: *PxVehicleTireData) -> void #cpp_method #foreign physx_lib "??0PxVehicleTireData@physx@@QEAA@XZ";

        /**
        \brief Tire lateral stiffness is a graph of tire load that has linear behavior near zero load and
        flattens at large loads.  mLatStiffX describes the minimum normalized load (load/restLoad) that gives a
        flat lateral stiffness response to load.

        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mLatStiffX:                                PxReal;

        /**
        \brief Tire lateral stiffness is a graph of tire load that has linear behavior near zero load and
        flattens at large loads. mLatStiffY describes the maximum possible value of lateralStiffness/restLoad that occurs
        when (load/restLoad)>= mLatStiffX.

        \note If load/restLoad is greater than mLatStiffX then the lateral stiffness is mLatStiffY*restLoad.

        \note If load/restLoad is less than mLatStiffX then the lateral stiffness is mLastStiffY*(load/mLatStiffX)

        \note Lateral force can be approximated as lateralStiffness * lateralSlip.

        \note Specified in per radian.

        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mLatStiffY:                                PxReal;

        /**
        \brief Tire Longitudinal stiffness per unit gravitational acceleration.

        \note Longitudinal stiffness of the tire is calculated as gravitationalAcceleration*mLongitudinalStiffnessPerUnitGravity.

        \note Longitudinal force can be approximated as gravitationalAcceleration*mLongitudinalStiffnessPerUnitGravity*longitudinalSlip.

        \note Specified in kilograms per radian.

        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mLongitudinalStiffnessPerUnitGravity:      PxReal;

        /**
        \brief tire Tire camber stiffness per unity gravitational acceleration.

        \note Camber stiffness of the tire is calculated as gravitationalAcceleration*mCamberStiffnessPerUnitGravity

        \note Camber force can be approximated as gravitationalAcceleration*mCamberStiffnessPerUnitGravity*camberAngle.

        \note Specified in kilograms per radian.

        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mCamberStiffnessPerUnitGravity:            PxReal;

        /**
        \brief Graph of friction vs longitudinal slip with 3 points.

        \note mFrictionVsSlipGraph[0][0] is always zero.

        \note mFrictionVsSlipGraph[0][1] is the friction available at zero longitudinal slip.

        \note mFrictionVsSlipGraph[1][0] is the value of longitudinal slip with maximum friction.

        \note mFrictionVsSlipGraph[1][1] is the maximum friction.

        \note mFrictionVsSlipGraph[2][0] is the end point of the graph.

        \note mFrictionVsSlipGraph[2][1] is the value of friction for slips greater than mFrictionVsSlipGraph[2][0].

        \note The friction value computed from the friction vs longitudinal slip graph is used to scale the friction
        value for the combination of material and tire type (PxVehicleDrivableSurfaceToTireFrictionPairs).

        \note mFrictionVsSlipGraph[2][0] > mFrictionVsSlipGraph[1][0] > mFrictionVsSlipGraph[0][0]

        \note mFrictionVsSlipGraph[1][1] is typically greater than  mFrictionVsSlipGraph[0][1]

        \note mFrictionVsSlipGraph[2][1] is typically smaller than mFrictionVsSlipGraph[1][1]

        \note longitudinal slips > mFrictionVsSlipGraph[2][0] use friction multiplier mFrictionVsSlipGraph[2][1]

        \note The final friction value used by the tire model is the value returned by PxVehicleDrivableSurfaceToTireFrictionPairs
        multiplied by the value computed from mFrictionVsSlipGraph.

        @see PxVehicleDrivableSurfaceToTireFrictionPairs, PxVehicleComputeTireForce

        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mFrictionVsSlipGraph:                      [3] [2] PxReal;

        /**
        \brief Tire type denoting slicks, wets, snow, winter, summer, all-terrain, mud etc.

        @see PxVehicleDrivableSurfaceToTireFrictionPairs

        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mType:                                     PxU32;

        /**
        \brief Return Cached value of 1.0/mLongitudinalStiffnessPerUnitGravity

        @see PxVehicleWheelsSimData::setTireData
        */
        getRecipLongitudinalStiffnessPerUnitGravity :: (this: *PxVehicleTireData) -> PxReal #cpp_method #foreign physx_lib "?getRecipLongitudinalStiffnessPerUnitGravity@PxVehicleTireData@physx@@QEBAMXZ";

        /**
        \brief Return Cached value of 1.0f/(mFrictionVsSlipGraph[1][0]-mFrictionVsSlipGraph[0][0])

        @see PxVehicleWheelsSimData::setTireData
        */
        getFrictionVsSlipGraphRecipx1Minusx0 :: (this: *PxVehicleTireData) -> PxReal #cpp_method #foreign physx_lib "?getFrictionVsSlipGraphRecipx1Minusx0@PxVehicleTireData@physx@@QEBAMXZ";

        /**
        \brief Return Cached value of 1.0f/(mFrictionVsSlipGraph[2][0]-mFrictionVsSlipGraph[1][0])

        @see PxVehicleWheelsSimData::setTireData
        */
        getFrictionVsSlipGraphRecipx2Minusx1 :: (this: *PxVehicleTireData) -> PxReal #cpp_method #foreign physx_lib "?getFrictionVsSlipGraphRecipx2Minusx1@PxVehicleTireData@physx@@QEBAMXZ";

        /**
        \brief Cached value of 1.0/mLongitudinalStiffnessPerUnitGravity.

        \note Not necessary to set this value because it is set by PxVehicleWheelsSimData::setTireData

        @see PxVehicleWheelsSimData::setTireData
        */
        mRecipLongitudinalStiffnessPerUnitGravity: PxReal;

        /**
        \brief Cached value of 1.0f/(mFrictionVsSlipGraph[1][0]-mFrictionVsSlipGraph[0][0])

        \note Not necessary to set this value because it is set by PxVehicleWheelsSimData::setTireData

        @see PxVehicleWheelsSimData::setTireData
        */
        mFrictionVsSlipGraphRecipx1Minusx0:        PxReal;

        /**
        \brief Cached value of 1.0f/(mFrictionVsSlipGraph[2][0]-mFrictionVsSlipGraph[1][0])

        \note Not necessary to set this value because it is set by PxVehicleWheelsSimData::setTireData

        @see PxVehicleWheelsSimData::setTireData
        */
        mFrictionVsSlipGraphRecipx2Minusx1:        PxReal;

        mPad:                                      [2] PxReal;
    }
    #run {if true then return;
        instance: PxVehicleTireData;
        assert(((cast(*void)(*instance.mLatStiffX)) - cast(*void)(*instance)) == 0, "PxVehicleTireData.mLatStiffX has unexpected offset % instead of 0", ((cast(*void)(*instance.mLatStiffX)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleTireData.mLatStiffX)) == 4, "PxVehicleTireData.mLatStiffX has unexpected size % instead of 4", size_of(type_of(PxVehicleTireData.mLatStiffX)));
        assert(((cast(*void)(*instance.mLatStiffY)) - cast(*void)(*instance)) == 4, "PxVehicleTireData.mLatStiffY has unexpected offset % instead of 4", ((cast(*void)(*instance.mLatStiffY)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleTireData.mLatStiffY)) == 4, "PxVehicleTireData.mLatStiffY has unexpected size % instead of 4", size_of(type_of(PxVehicleTireData.mLatStiffY)));
        assert(((cast(*void)(*instance.mLongitudinalStiffnessPerUnitGravity)) - cast(*void)(*instance)) == 8, "PxVehicleTireData.mLongitudinalStiffnessPerUnitGravity has unexpected offset % instead of 8", ((cast(*void)(*instance.mLongitudinalStiffnessPerUnitGravity)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleTireData.mLongitudinalStiffnessPerUnitGravity)) == 4, "PxVehicleTireData.mLongitudinalStiffnessPerUnitGravity has unexpected size % instead of 4", size_of(type_of(PxVehicleTireData.mLongitudinalStiffnessPerUnitGravity)));
        assert(((cast(*void)(*instance.mCamberStiffnessPerUnitGravity)) - cast(*void)(*instance)) == 12, "PxVehicleTireData.mCamberStiffnessPerUnitGravity has unexpected offset % instead of 12", ((cast(*void)(*instance.mCamberStiffnessPerUnitGravity)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleTireData.mCamberStiffnessPerUnitGravity)) == 4, "PxVehicleTireData.mCamberStiffnessPerUnitGravity has unexpected size % instead of 4", size_of(type_of(PxVehicleTireData.mCamberStiffnessPerUnitGravity)));
        assert(((cast(*void)(*instance.mFrictionVsSlipGraph)) - cast(*void)(*instance)) == 16, "PxVehicleTireData.mFrictionVsSlipGraph has unexpected offset % instead of 16", ((cast(*void)(*instance.mFrictionVsSlipGraph)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleTireData.mFrictionVsSlipGraph)) == 24, "PxVehicleTireData.mFrictionVsSlipGraph has unexpected size % instead of 24", size_of(type_of(PxVehicleTireData.mFrictionVsSlipGraph)));
        assert(((cast(*void)(*instance.mType)) - cast(*void)(*instance)) == 40, "PxVehicleTireData.mType has unexpected offset % instead of 40", ((cast(*void)(*instance.mType)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleTireData.mType)) == 4, "PxVehicleTireData.mType has unexpected size % instead of 4", size_of(type_of(PxVehicleTireData.mType)));
        assert(((cast(*void)(*instance.mRecipLongitudinalStiffnessPerUnitGravity)) - cast(*void)(*instance)) == 44, "PxVehicleTireData.mRecipLongitudinalStiffnessPerUnitGravity has unexpected offset % instead of 44", ((cast(*void)(*instance.mRecipLongitudinalStiffnessPerUnitGravity)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleTireData.mRecipLongitudinalStiffnessPerUnitGravity)) == 4, "PxVehicleTireData.mRecipLongitudinalStiffnessPerUnitGravity has unexpected size % instead of 4", size_of(type_of(PxVehicleTireData.mRecipLongitudinalStiffnessPerUnitGravity)));
        assert(((cast(*void)(*instance.mFrictionVsSlipGraphRecipx1Minusx0)) - cast(*void)(*instance)) == 48, "PxVehicleTireData.mFrictionVsSlipGraphRecipx1Minusx0 has unexpected offset % instead of 48", ((cast(*void)(*instance.mFrictionVsSlipGraphRecipx1Minusx0)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleTireData.mFrictionVsSlipGraphRecipx1Minusx0)) == 4, "PxVehicleTireData.mFrictionVsSlipGraphRecipx1Minusx0 has unexpected size % instead of 4", size_of(type_of(PxVehicleTireData.mFrictionVsSlipGraphRecipx1Minusx0)));
        assert(((cast(*void)(*instance.mFrictionVsSlipGraphRecipx2Minusx1)) - cast(*void)(*instance)) == 52, "PxVehicleTireData.mFrictionVsSlipGraphRecipx2Minusx1 has unexpected offset % instead of 52", ((cast(*void)(*instance.mFrictionVsSlipGraphRecipx2Minusx1)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleTireData.mFrictionVsSlipGraphRecipx2Minusx1)) == 4, "PxVehicleTireData.mFrictionVsSlipGraphRecipx2Minusx1 has unexpected size % instead of 4", size_of(type_of(PxVehicleTireData.mFrictionVsSlipGraphRecipx2Minusx1)));
        assert(((cast(*void)(*instance.mPad)) - cast(*void)(*instance)) == 56, "PxVehicleTireData.mPad has unexpected offset % instead of 56", ((cast(*void)(*instance.mPad)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleTireData.mPad)) == 8, "PxVehicleTireData.mPad has unexpected size % instead of 8", size_of(type_of(PxVehicleTireData.mPad)));
        assert(size_of(PxVehicleTireData) == 64, "PxVehicleTireData has size % instead of 64", size_of(PxVehicleTireData));
    }

    PxCompileTimeAssert_Dummy16 :: [1] u8;

    /**
    \brief Prototype of shader function that is used to compute wheel torque and tire forces.
    \param[in]  shaderData is the shader data for the tire being processed.  The shader data describes the tire data in the format required by the tire model that is implemented by the shader function.
    \param[in]  tireFriction is the value of friction for the contact between the tire and the ground.
    \param[in]  longSlip is the value of longitudinal slip experienced by the tire.
    \param[in]  latSlip is the value of lateral slip experienced by the tire.
    \param[in]  camber is the camber angle of the tire in radians.
    \param[in]  wheelOmega is the rotational speed of the wheel.
    \param[in]  wheelRadius is the distance from the tire surface to the center of the wheel.
    \param[in]  recipWheelRadius is the reciprocal of wheelRadius.
    \param[in]  restTireLoad is the load force experienced by the tire when the vehicle is at rest.
    \param[in]  normalisedTireLoad is a pre-computed value equal to the load force on the tire divided by restTireLoad.
    \param[in]  tireLoad is the load force currently experienced by the tire (= restTireLoad*normalisedTireLoad)
    \param[in]  gravity is the magnitude of gravitational acceleration.
    \param[in]  recipGravity is the reciprocal of the magnitude of gravitational acceleration.
    \param[out] wheelTorque is the torque that is to be applied to the wheel around the wheel's axle.
    \param[out] tireLongForceMag is the magnitude of the longitudinal tire force to be applied to the vehicle's rigid body.
    \param[out] tireLatForceMag is the magnitude of the lateral tire force to be applied to the vehicle's rigid body.
    \param[out] tireAlignMoment is the aligning moment of the tire that is to be applied to the vehicle's rigid body (not currently used).
    @see PxVehicleWheelsDynData::setTireForceShaderFunction,  PxVehicleWheelsDynData::setTireForceShaderData
    */
    PxVehicleComputeTireForce :: #type (shaderData: *void, tireFriction: PxF32, longSlip: PxF32, latSlip: PxF32, camber: PxF32, wheelOmega: PxF32, wheelRadius: PxF32, recipWheelRadius: PxF32, restTireLoad: PxF32, normalisedTireLoad: PxF32, tireLoad: PxF32, gravity: PxF32, recipGravity: PxF32, wheelTorque: *PxF32, tireLongForceMag: *PxF32, tireLatForceMag: *PxF32, tireAlignMoment: *PxF32) -> void #c_call;

    PxVehicleWheels4SimData :: struct {}
    PxVehicleWheels4DynData :: struct {}
    PxVehicleTireForceCalculator :: struct {}

    /**
    \brief Flags to configure the vehicle wheel simulation.

    @see PxVehicleWheelsSimData::setFlags(), PxVehicleWheelsSimData::getFlags()
    */
    PxVehicleWheelsSimFlag :: struct {
        Enum :: enum s32 {
            eLIMIT_SUSPENSION_EXPANSION_VELOCITY :: 1;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxVehicleWheelsSimFlag) == 1, "PxVehicleWheelsSimFlag has size % instead of 1", size_of(PxVehicleWheelsSimFlag));
    }

    /**
    \brief Collection of set bits defined in #PxVehicleWheelsSimFlag.

    @see PxVehicleWheelsSimFlag
    */
    PxVehicleWheelsSimFlags :: PxFlags(PxVehicleWheelsSimFlag.Enum, PxU32);

    /**
    \brief Data structure describing configuration data of a vehicle with up to 20 wheels.
    */
    PxVehicleWheelsSimData :: struct {
        /**
        \brief Return the number of wheels
        @see allocate
        */
        getNbWheels :: (this: *PxVehicleWheelsSimData) -> PxU32 #cpp_method #foreign physx_lib "?getNbWheels@PxVehicleWheelsSimData@physx@@QEBAIXZ";

        /**
        \brief Return the number of unique anti-roll bars that have been added with addAntiRollBarData
        @see PxVehicleWheelsSimData::addAntiRollBarData
        */
        getNbAntiRollBars :: (this: *PxVehicleWheelsSimData) -> PxU32 #cpp_method #foreign physx_lib "?getNbAntiRollBars@PxVehicleWheelsSimData@physx@@QEBAIXZ";

        /**
        \brief Return the data that describes the filtering of the tire load to produce smoother handling at large time-steps.
        */
        getTireLoadFilterData :: (this: *PxVehicleWheelsSimData) -> *PxVehicleTireLoadFilterData #cpp_method #foreign physx_lib "?getTireLoadFilterData@PxVehicleWheelsSimData@physx@@QEBAAEBVPxVehicleTireLoadFilterData@2@XZ";

        /**
        \brief Graph to filter normalised load
        @see setTireLoadFilterData, getTireLoadFilterData
        */
        mNormalisedLoadFilter:         PxVehicleTireLoadFilterData;

        /**
        \brief Wheels data organised in blocks of 4 wheels.
        */
        mWheels4SimData:               *PxVehicleWheels4SimData;

        /**
        \brief Number of blocks of 4 wheels.
        */
        mNbWheels4:                    PxU32;

        /**
        \brief Number of actual wheels (<=(mNbWheels4*4))
        */
        mNbActiveWheels:               PxU32;

        /**
        \brief Anti-roll bars
        */
        mAntiRollBars:                 *PxVehicleAntiRollBarData;

        /**
        \brief 2 anti-rollbars allocated for each block of 4 wheels.
        */
        mNbAntiRollBars4:              PxU32;

        /**
        \brief Number of active anti-roll bars.
        */
        mNbActiveAntiRollBars:         PxU32;

        /**
        \brief Which of the mNbActiveWheels are active or disabled?
        The default is that all mNbActiveWheels wheels are active.
        */
        mActiveWheelsBitmapBuffer:     [1] PxU32;

        /**
        \brief Threshold longitudinal speed used to decide whether to use
        mLowForwardSpeedSubStepCount or mHighForwardSpeedSubStepCount as the
        number of sub-steps that will be peformed.
        */
        mThresholdLongitudinalSpeed:   PxF32;

        /**
        \brief Number of sub-steps that will be performed if the longitudinal speed
        of the vehicle is smaller than mThresholdLongitudinalSpeed.
        */
        mLowForwardSpeedSubStepCount:  PxU32;

        /**
        \brief Number of sub-steps that will be performed if the longitudinal speed
        of the vehicle is greater than or equal to mThresholdLongitudinalSpeed.
        */
        mHighForwardSpeedSubStepCount: PxU32;

        /**
        \brief Minimum long slip denominator
        */
        mMinLongSlipDenominator:       PxF32;

        /**
        \brief The vehicle wheel simulation flags.

        @see PxVehicleWheelsSimFlags
        */
        mFlags:                        PxU32;

        mPad:                          [1] PxU32;

        //serialization
        Constructor :: (this: *PxVehicleWheelsSimData, unknown0: PxEMPTY) -> void #cpp_method #foreign physx_lib "??0PxVehicleWheelsSimData@physx@@QEAA@W4PxEMPTY@1@@Z";

        getNbWheels4 :: (this: *PxVehicleWheelsSimData) -> PxU32 #cpp_method #foreign physx_lib "?getNbWheels4@PxVehicleWheelsSimData@physx@@QEBAIXZ";
        getNbSuspensionData :: (this: *PxVehicleWheelsSimData) -> PxU32 #cpp_method #foreign physx_lib "?getNbSuspensionData@PxVehicleWheelsSimData@physx@@QEBAIXZ";
        getNbWheelData :: (this: *PxVehicleWheelsSimData) -> PxU32 #cpp_method #foreign physx_lib "?getNbWheelData@PxVehicleWheelsSimData@physx@@QEBAIXZ";
        getNbSuspTravelDirection :: (this: *PxVehicleWheelsSimData) -> PxU32 #cpp_method #foreign physx_lib "?getNbSuspTravelDirection@PxVehicleWheelsSimData@physx@@QEBAIXZ";
        getNbTireData :: (this: *PxVehicleWheelsSimData) -> PxU32 #cpp_method #foreign physx_lib "?getNbTireData@PxVehicleWheelsSimData@physx@@QEBAIXZ";
        getNbSuspForceAppPointOffset :: (this: *PxVehicleWheelsSimData) -> PxU32 #cpp_method #foreign physx_lib "?getNbSuspForceAppPointOffset@PxVehicleWheelsSimData@physx@@QEBAIXZ";
        getNbTireForceAppPointOffset :: (this: *PxVehicleWheelsSimData) -> PxU32 #cpp_method #foreign physx_lib "?getNbTireForceAppPointOffset@PxVehicleWheelsSimData@physx@@QEBAIXZ";
        getNbWheelCentreOffset :: (this: *PxVehicleWheelsSimData) -> PxU32 #cpp_method #foreign physx_lib "?getNbWheelCentreOffset@PxVehicleWheelsSimData@physx@@QEBAIXZ";
        getNbWheelShapeMapping :: (this: *PxVehicleWheelsSimData) -> PxU32 #cpp_method #foreign physx_lib "?getNbWheelShapeMapping@PxVehicleWheelsSimData@physx@@QEBAIXZ";
        getNbSceneQueryFilterData :: (this: *PxVehicleWheelsSimData) -> PxU32 #cpp_method #foreign physx_lib "?getNbSceneQueryFilterData@PxVehicleWheelsSimData@physx@@QEBAIXZ";
        getMinLongSlipDenominator :: (this: *PxVehicleWheelsSimData) -> PxF32 #cpp_method #foreign physx_lib "?getMinLongSlipDenominator@PxVehicleWheelsSimData@physx@@QEBAMXZ";
        setThresholdLongSpeed :: (this: *PxVehicleWheelsSimData, f: PxF32) -> void #cpp_method #foreign physx_lib "?setThresholdLongSpeed@PxVehicleWheelsSimData@physx@@QEAAXM@Z";
        getThresholdLongSpeed :: (this: *PxVehicleWheelsSimData) -> PxF32 #cpp_method #foreign physx_lib "?getThresholdLongSpeed@PxVehicleWheelsSimData@physx@@QEBAMXZ";
        setLowForwardSpeedSubStepCount :: (this: *PxVehicleWheelsSimData, f: PxU32) -> void #cpp_method #foreign physx_lib "?setLowForwardSpeedSubStepCount@PxVehicleWheelsSimData@physx@@QEAAXI@Z";
        getLowForwardSpeedSubStepCount :: (this: *PxVehicleWheelsSimData) -> PxU32 #cpp_method #foreign physx_lib "?getLowForwardSpeedSubStepCount@PxVehicleWheelsSimData@physx@@QEBAIXZ";
        setHighForwardSpeedSubStepCount :: (this: *PxVehicleWheelsSimData, f: PxU32) -> void #cpp_method #foreign physx_lib "?setHighForwardSpeedSubStepCount@PxVehicleWheelsSimData@physx@@QEAAXI@Z";
        getHighForwardSpeedSubStepCount :: (this: *PxVehicleWheelsSimData) -> PxU32 #cpp_method #foreign physx_lib "?getHighForwardSpeedSubStepCount@PxVehicleWheelsSimData@physx@@QEBAIXZ";
        setWheelEnabledState :: (this: *PxVehicleWheelsSimData, wheel: PxU32, state: bool) -> void #cpp_method #foreign physx_lib "?setWheelEnabledState@PxVehicleWheelsSimData@physx@@QEAAXI_N@Z";
        getWheelEnabledState :: (this: *PxVehicleWheelsSimData, wheel: PxU32) -> bool #cpp_method #foreign physx_lib "?getWheelEnabledState@PxVehicleWheelsSimData@physx@@QEBA_NI@Z";
        getNbWheelEnabledState :: (this: *PxVehicleWheelsSimData) -> PxU32 #cpp_method #foreign physx_lib "?getNbWheelEnabledState@PxVehicleWheelsSimData@physx@@QEBAIXZ";
        getNbAntiRollBars4 :: (this: *PxVehicleWheelsSimData) -> PxU32 #cpp_method #foreign physx_lib "?getNbAntiRollBars4@PxVehicleWheelsSimData@physx@@QEBAIXZ";
        getNbAntiRollBarData :: (this: *PxVehicleWheelsSimData) -> PxU32 #cpp_method #foreign physx_lib "?getNbAntiRollBarData@PxVehicleWheelsSimData@physx@@QEBAIXZ";

        Constructor :: (this: *PxVehicleWheelsSimData) -> void #cpp_method #foreign physx_lib "??0PxVehicleWheelsSimData@physx@@QEAA@XZ";
        Destructor :: (this: *PxVehicleWheelsSimData) -> void #cpp_method #foreign physx_lib "??1PxVehicleWheelsSimData@physx@@QEAA@XZ";
    }
    #run {if true then return;
        instance: PxVehicleWheelsSimData;
        assert(((cast(*void)(*instance.mNormalisedLoadFilter)) - cast(*void)(*instance)) == 0, "PxVehicleWheelsSimData.mNormalisedLoadFilter has unexpected offset % instead of 0", ((cast(*void)(*instance.mNormalisedLoadFilter)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleWheelsSimData.mNormalisedLoadFilter)) == 32, "PxVehicleWheelsSimData.mNormalisedLoadFilter has unexpected size % instead of 32", size_of(type_of(PxVehicleWheelsSimData.mNormalisedLoadFilter)));
        assert(((cast(*void)(*instance.mWheels4SimData)) - cast(*void)(*instance)) == 32, "PxVehicleWheelsSimData.mWheels4SimData has unexpected offset % instead of 32", ((cast(*void)(*instance.mWheels4SimData)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleWheelsSimData.mWheels4SimData)) == 8, "PxVehicleWheelsSimData.mWheels4SimData has unexpected size % instead of 8", size_of(type_of(PxVehicleWheelsSimData.mWheels4SimData)));
        assert(((cast(*void)(*instance.mNbWheels4)) - cast(*void)(*instance)) == 40, "PxVehicleWheelsSimData.mNbWheels4 has unexpected offset % instead of 40", ((cast(*void)(*instance.mNbWheels4)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleWheelsSimData.mNbWheels4)) == 4, "PxVehicleWheelsSimData.mNbWheels4 has unexpected size % instead of 4", size_of(type_of(PxVehicleWheelsSimData.mNbWheels4)));
        assert(((cast(*void)(*instance.mNbActiveWheels)) - cast(*void)(*instance)) == 44, "PxVehicleWheelsSimData.mNbActiveWheels has unexpected offset % instead of 44", ((cast(*void)(*instance.mNbActiveWheels)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleWheelsSimData.mNbActiveWheels)) == 4, "PxVehicleWheelsSimData.mNbActiveWheels has unexpected size % instead of 4", size_of(type_of(PxVehicleWheelsSimData.mNbActiveWheels)));
        assert(((cast(*void)(*instance.mAntiRollBars)) - cast(*void)(*instance)) == 48, "PxVehicleWheelsSimData.mAntiRollBars has unexpected offset % instead of 48", ((cast(*void)(*instance.mAntiRollBars)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleWheelsSimData.mAntiRollBars)) == 8, "PxVehicleWheelsSimData.mAntiRollBars has unexpected size % instead of 8", size_of(type_of(PxVehicleWheelsSimData.mAntiRollBars)));
        assert(((cast(*void)(*instance.mNbAntiRollBars4)) - cast(*void)(*instance)) == 56, "PxVehicleWheelsSimData.mNbAntiRollBars4 has unexpected offset % instead of 56", ((cast(*void)(*instance.mNbAntiRollBars4)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleWheelsSimData.mNbAntiRollBars4)) == 4, "PxVehicleWheelsSimData.mNbAntiRollBars4 has unexpected size % instead of 4", size_of(type_of(PxVehicleWheelsSimData.mNbAntiRollBars4)));
        assert(((cast(*void)(*instance.mNbActiveAntiRollBars)) - cast(*void)(*instance)) == 60, "PxVehicleWheelsSimData.mNbActiveAntiRollBars has unexpected offset % instead of 60", ((cast(*void)(*instance.mNbActiveAntiRollBars)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleWheelsSimData.mNbActiveAntiRollBars)) == 4, "PxVehicleWheelsSimData.mNbActiveAntiRollBars has unexpected size % instead of 4", size_of(type_of(PxVehicleWheelsSimData.mNbActiveAntiRollBars)));
        assert(((cast(*void)(*instance.mActiveWheelsBitmapBuffer)) - cast(*void)(*instance)) == 64, "PxVehicleWheelsSimData.mActiveWheelsBitmapBuffer has unexpected offset % instead of 64", ((cast(*void)(*instance.mActiveWheelsBitmapBuffer)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleWheelsSimData.mActiveWheelsBitmapBuffer)) == 4, "PxVehicleWheelsSimData.mActiveWheelsBitmapBuffer has unexpected size % instead of 4", size_of(type_of(PxVehicleWheelsSimData.mActiveWheelsBitmapBuffer)));
        assert(((cast(*void)(*instance.mThresholdLongitudinalSpeed)) - cast(*void)(*instance)) == 68, "PxVehicleWheelsSimData.mThresholdLongitudinalSpeed has unexpected offset % instead of 68", ((cast(*void)(*instance.mThresholdLongitudinalSpeed)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleWheelsSimData.mThresholdLongitudinalSpeed)) == 4, "PxVehicleWheelsSimData.mThresholdLongitudinalSpeed has unexpected size % instead of 4", size_of(type_of(PxVehicleWheelsSimData.mThresholdLongitudinalSpeed)));
        assert(((cast(*void)(*instance.mLowForwardSpeedSubStepCount)) - cast(*void)(*instance)) == 72, "PxVehicleWheelsSimData.mLowForwardSpeedSubStepCount has unexpected offset % instead of 72", ((cast(*void)(*instance.mLowForwardSpeedSubStepCount)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleWheelsSimData.mLowForwardSpeedSubStepCount)) == 4, "PxVehicleWheelsSimData.mLowForwardSpeedSubStepCount has unexpected size % instead of 4", size_of(type_of(PxVehicleWheelsSimData.mLowForwardSpeedSubStepCount)));
        assert(((cast(*void)(*instance.mHighForwardSpeedSubStepCount)) - cast(*void)(*instance)) == 76, "PxVehicleWheelsSimData.mHighForwardSpeedSubStepCount has unexpected offset % instead of 76", ((cast(*void)(*instance.mHighForwardSpeedSubStepCount)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleWheelsSimData.mHighForwardSpeedSubStepCount)) == 4, "PxVehicleWheelsSimData.mHighForwardSpeedSubStepCount has unexpected size % instead of 4", size_of(type_of(PxVehicleWheelsSimData.mHighForwardSpeedSubStepCount)));
        assert(((cast(*void)(*instance.mMinLongSlipDenominator)) - cast(*void)(*instance)) == 80, "PxVehicleWheelsSimData.mMinLongSlipDenominator has unexpected offset % instead of 80", ((cast(*void)(*instance.mMinLongSlipDenominator)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleWheelsSimData.mMinLongSlipDenominator)) == 4, "PxVehicleWheelsSimData.mMinLongSlipDenominator has unexpected size % instead of 4", size_of(type_of(PxVehicleWheelsSimData.mMinLongSlipDenominator)));
        assert(((cast(*void)(*instance.mFlags)) - cast(*void)(*instance)) == 84, "PxVehicleWheelsSimData.mFlags has unexpected offset % instead of 84", ((cast(*void)(*instance.mFlags)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleWheelsSimData.mFlags)) == 4, "PxVehicleWheelsSimData.mFlags has unexpected size % instead of 4", size_of(type_of(PxVehicleWheelsSimData.mFlags)));
        assert(((cast(*void)(*instance.mPad)) - cast(*void)(*instance)) == 88, "PxVehicleWheelsSimData.mPad has unexpected offset % instead of 88", ((cast(*void)(*instance.mPad)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleWheelsSimData.mPad)) == 4, "PxVehicleWheelsSimData.mPad has unexpected size % instead of 4", size_of(type_of(PxVehicleWheelsSimData.mPad)));
        assert(size_of(PxVehicleWheelsSimData) == 96, "PxVehicleWheelsSimData has size % instead of 96", size_of(PxVehicleWheelsSimData));
    }

    PxCompileTimeAssert_Dummy17 :: [1] u8;

    /**
    \brief Data structure with instanced dynamics data for wheels
    */
    PxVehicleWheelsDynData :: struct {
        Constructor :: (this: *PxVehicleWheelsDynData) -> void #cpp_method #foreign physx_lib "??0PxVehicleWheelsDynData@physx@@QEAA@XZ";
        Destructor :: (this: *PxVehicleWheelsDynData) -> void #cpp_method #foreign physx_lib "??1PxVehicleWheelsDynData@physx@@QEAA@XZ";

        /**
        \brief Dynamics data arranged in blocks of 4 wheels.
        */
        mWheels4DynData:       *PxVehicleWheels4DynData;

        /**
        \brief Shader data and function for tire force calculations.
        */
        mTireForceCalculators: *PxVehicleTireForceCalculator;

        /**
        \brief A userData pointer can be stored for each wheel.
        @see setUserData, getUserData
        */
        mUserDatas:            **void;

        /**
        \brief Number of blocks of 4 wheels.
        */
        mNbWheels4:            PxU32;

        /**
        \brief Number of wheels (mNbActiveWheels <= (mNbWheels4*4))
        */
        mNbActiveWheels:       PxU32;

        mPad:                  [3] PxU32;

        getNbWheelRotationSpeed :: (this: *PxVehicleWheelsDynData) -> PxU32 #cpp_method #foreign physx_lib "?getNbWheelRotationSpeed@PxVehicleWheelsDynData@physx@@QEBAIXZ";
        getNbWheelRotationAngle :: (this: *PxVehicleWheelsDynData) -> PxU32 #cpp_method #foreign physx_lib "?getNbWheelRotationAngle@PxVehicleWheelsDynData@physx@@QEBAIXZ";
        getWheel4DynData :: (this: *PxVehicleWheelsDynData) -> *PxVehicleWheels4DynData #cpp_method #foreign physx_lib "?getWheel4DynData@PxVehicleWheelsDynData@physx@@QEBAPEAVPxVehicleWheels4DynData@2@XZ";
    }
    #run {if true then return;
        instance: PxVehicleWheelsDynData;
        assert(((cast(*void)(*instance.mWheels4DynData)) - cast(*void)(*instance)) == 0, "PxVehicleWheelsDynData.mWheels4DynData has unexpected offset % instead of 0", ((cast(*void)(*instance.mWheels4DynData)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleWheelsDynData.mWheels4DynData)) == 8, "PxVehicleWheelsDynData.mWheels4DynData has unexpected size % instead of 8", size_of(type_of(PxVehicleWheelsDynData.mWheels4DynData)));
        assert(((cast(*void)(*instance.mTireForceCalculators)) - cast(*void)(*instance)) == 8, "PxVehicleWheelsDynData.mTireForceCalculators has unexpected offset % instead of 8", ((cast(*void)(*instance.mTireForceCalculators)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleWheelsDynData.mTireForceCalculators)) == 8, "PxVehicleWheelsDynData.mTireForceCalculators has unexpected size % instead of 8", size_of(type_of(PxVehicleWheelsDynData.mTireForceCalculators)));
        assert(((cast(*void)(*instance.mUserDatas)) - cast(*void)(*instance)) == 16, "PxVehicleWheelsDynData.mUserDatas has unexpected offset % instead of 16", ((cast(*void)(*instance.mUserDatas)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleWheelsDynData.mUserDatas)) == 8, "PxVehicleWheelsDynData.mUserDatas has unexpected size % instead of 8", size_of(type_of(PxVehicleWheelsDynData.mUserDatas)));
        assert(((cast(*void)(*instance.mNbWheels4)) - cast(*void)(*instance)) == 24, "PxVehicleWheelsDynData.mNbWheels4 has unexpected offset % instead of 24", ((cast(*void)(*instance.mNbWheels4)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleWheelsDynData.mNbWheels4)) == 4, "PxVehicleWheelsDynData.mNbWheels4 has unexpected size % instead of 4", size_of(type_of(PxVehicleWheelsDynData.mNbWheels4)));
        assert(((cast(*void)(*instance.mNbActiveWheels)) - cast(*void)(*instance)) == 28, "PxVehicleWheelsDynData.mNbActiveWheels has unexpected offset % instead of 28", ((cast(*void)(*instance.mNbActiveWheels)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleWheelsDynData.mNbActiveWheels)) == 4, "PxVehicleWheelsDynData.mNbActiveWheels has unexpected size % instead of 4", size_of(type_of(PxVehicleWheelsDynData.mNbActiveWheels)));
        assert(((cast(*void)(*instance.mPad)) - cast(*void)(*instance)) == 32, "PxVehicleWheelsDynData.mPad has unexpected offset % instead of 32", ((cast(*void)(*instance.mPad)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleWheelsDynData.mPad)) == 12, "PxVehicleWheelsDynData.mPad has unexpected size % instead of 12", size_of(type_of(PxVehicleWheelsDynData.mPad)));
        assert(size_of(PxVehicleWheelsDynData) == 48, "PxVehicleWheelsDynData has size % instead of 48", size_of(PxVehicleWheelsDynData));
    }

    PxCompileTimeAssert_Dummy18 :: [1] u8;

    /**
    \brief Data structure with instanced dynamics data and configuration data of a vehicle with just wheels
    @see PxVehicleDrive, PxVehicleDrive4W, PxVehicleDriveTank
    */
    PxVehicleWheels :: struct {
        #as using pxbase: PxBase;

        /**
        \brief Return the type of vehicle
        @see PxVehicleTypes
        */
        getVehicleType :: (this: *PxVehicleWheels) -> PxU32 #cpp_method #foreign physx_lib "?getVehicleType@PxVehicleWheels@physx@@QEBAIXZ";

        /**
        \brief Get non-const ptr to PxRigidDynamic instance that is the vehicle's physx representation
        */
        getRigidDynamicActor :: (this: *PxVehicleWheels) -> *PxRigidDynamic #cpp_method #foreign physx_lib "?getRigidDynamicActor@PxVehicleWheels@physx@@QEAAPEAVPxRigidDynamic@2@XZ";

        /**
        \brief Get const ptr to PxRigidDynamic instance that is the vehicle's physx representation
        */
        getRigidDynamicActor_1 :: (this: /*const*/ *PxVehicleWheels) -> *PxRigidDynamic #cpp_method #foreign physx_lib "?getRigidDynamicActor@PxVehicleWheels@physx@@QEBAPEBVPxRigidDynamic@2@XZ";

        /**
        \brief Data describing the setup of all the wheels/suspensions/tires.
        */
        mWheelsSimData:              PxVehicleWheelsSimData;

        /**
        \brief Data describing the dynamic state of all wheels/suspension/tires.
        */
        mWheelsDynData:              PxVehicleWheelsDynData;

        /**
        \brief The rigid body actor that represents the vehicle in the PhysX SDK.
        */
        mActor:                      *PxRigidDynamic;

        /**
        \brief Count the number of constraint connectors that have hit their callback when deleting a vehicle.
        Can only delete the vehicle's memory when all constraint connectors have hit their callback.
        */
        mNbNonDrivenWheels:          PxU32;

        mOnConstraintReleaseCounter: PxU8;

        /**
        \brief Vehicle type (eVehicleDriveTypes)
        */
        mType:                       PxU8;

        mPad0:                       [14] PxU8;

        getNbNonDrivenWheels :: (this: *PxVehicleWheels) -> PxU32 #cpp_method #foreign physx_lib "?getNbNonDrivenWheels@PxVehicleWheels@physx@@QEBAIXZ";
        Constructor :: (this: *PxVehicleWheels, concreteType: PxType, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_lib "??0PxVehicleWheels@physx@@QEAA@GV?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        Constructor :: (this: *PxVehicleWheels, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_lib "??0PxVehicleWheels@physx@@QEAA@V?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        #place pxbase; pxvehiclewheels_vtable: *PxVehicleWheels_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.

        virtual_getConcreteTypeName :: (this: *PxVehicleWheels) -> *u8 #cpp_method #foreign physx_lib "?getConcreteTypeName@PxVehicleWheels@physx@@UEBAPEBDXZ";
        virtual_isKindOf :: (this: *PxVehicleWheels, name: *u8) -> bool #cpp_method #foreign physx_lib "?isKindOf@PxVehicleWheels@physx@@UEBA_NPEBD@Z";
        virtual_preExportDataReset :: (this: *PxVehicleWheels) -> void #cpp_method #foreign physx_lib "?preExportDataReset@PxVehicleWheels@physx@@UEAAXXZ";

        virtual_Destructor :: (this: *PxVehicleWheels, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_lib "??1PxVehicleWheels@physx@@UEAA@XZ";
        virtual_release :: (this: *PxVehicleWheels) -> void #cpp_method #foreign physx_lib "?release@PxVehicleWheels@physx@@UEAAXXZ";
    }
    PxVehicleWheels_VTable :: struct #type_info_none {
        using pxbase: PxBase_VTable;
        init: (this: *PxVehicleWheels, numWheels: PxU32) -> void #cpp_method;

        requiresObjects: (this: *PxVehicleWheels, c: *PxProcessPxBaseCallback) -> void #cpp_method;

        preExportDataReset: (this: *PxVehicleWheels) -> void #cpp_method;
        exportExtraData: (this: *PxVehicleWheels, unknown0: *PxSerializationContext) -> void #cpp_method;
    }

    PxVehicleWheels_init :: inline (this: *PxVehicleWheels, numWheels: PxU32) { this.pxvehiclewheels_vtable.init(this, numWheels); }

    PxVehicleWheels_requiresObjects :: inline (this: *PxVehicleWheels, c: *PxProcessPxBaseCallback) { this.pxvehiclewheels_vtable.requiresObjects(this, c); }

    PxVehicleWheels_preExportDataReset :: inline (this: *PxVehicleWheels) { this.pxvehiclewheels_vtable.preExportDataReset(this); }
    PxVehicleWheels_exportExtraData :: inline (this: *PxVehicleWheels, unknown0: *PxSerializationContext) { this.pxvehiclewheels_vtable.exportExtraData(this, unknown0); }

    vtable :: (obj: *PxVehicleWheels) -> *PxVehicleWheels_VTable { return obj.pxvehiclewheels_vtable; }

    #run {if true then return;
        assert(size_of(type_of(PxVehicleWheels.pxbase)) == 16, "PxVehicleWheels.pxbase has unexpected size % instead of 16", size_of(type_of(PxVehicleWheels.pxbase)));
        instance: PxVehicleWheels;
        assert(((cast(*void)(*instance.mWheelsSimData)) - cast(*void)(*instance)) == 16, "PxVehicleWheels.mWheelsSimData has unexpected offset % instead of 16", ((cast(*void)(*instance.mWheelsSimData)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleWheels.mWheelsSimData)) == 96, "PxVehicleWheels.mWheelsSimData has unexpected size % instead of 96", size_of(type_of(PxVehicleWheels.mWheelsSimData)));
        assert(((cast(*void)(*instance.mWheelsDynData)) - cast(*void)(*instance)) == 112, "PxVehicleWheels.mWheelsDynData has unexpected offset % instead of 112", ((cast(*void)(*instance.mWheelsDynData)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleWheels.mWheelsDynData)) == 48, "PxVehicleWheels.mWheelsDynData has unexpected size % instead of 48", size_of(type_of(PxVehicleWheels.mWheelsDynData)));
        assert(((cast(*void)(*instance.mActor)) - cast(*void)(*instance)) == 160, "PxVehicleWheels.mActor has unexpected offset % instead of 160", ((cast(*void)(*instance.mActor)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleWheels.mActor)) == 8, "PxVehicleWheels.mActor has unexpected size % instead of 8", size_of(type_of(PxVehicleWheels.mActor)));
        assert(((cast(*void)(*instance.mNbNonDrivenWheels)) - cast(*void)(*instance)) == 168, "PxVehicleWheels.mNbNonDrivenWheels has unexpected offset % instead of 168", ((cast(*void)(*instance.mNbNonDrivenWheels)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleWheels.mNbNonDrivenWheels)) == 4, "PxVehicleWheels.mNbNonDrivenWheels has unexpected size % instead of 4", size_of(type_of(PxVehicleWheels.mNbNonDrivenWheels)));
        assert(((cast(*void)(*instance.mOnConstraintReleaseCounter)) - cast(*void)(*instance)) == 172, "PxVehicleWheels.mOnConstraintReleaseCounter has unexpected offset % instead of 172", ((cast(*void)(*instance.mOnConstraintReleaseCounter)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleWheels.mOnConstraintReleaseCounter)) == 1, "PxVehicleWheels.mOnConstraintReleaseCounter has unexpected size % instead of 1", size_of(type_of(PxVehicleWheels.mOnConstraintReleaseCounter)));
        assert(((cast(*void)(*instance.mType)) - cast(*void)(*instance)) == 173, "PxVehicleWheels.mType has unexpected offset % instead of 173", ((cast(*void)(*instance.mType)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleWheels.mType)) == 1, "PxVehicleWheels.mType has unexpected size % instead of 1", size_of(type_of(PxVehicleWheels.mType)));
        assert(((cast(*void)(*instance.mPad0)) - cast(*void)(*instance)) == 174, "PxVehicleWheels.mPad0 has unexpected offset % instead of 174", ((cast(*void)(*instance.mPad0)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleWheels.mPad0)) == 14, "PxVehicleWheels.mPad0 has unexpected size % instead of 14", size_of(type_of(PxVehicleWheels.mPad0)));
        assert(size_of(PxVehicleWheels) == 192, "PxVehicleWheels has size % instead of 192", size_of(PxVehicleWheels));
    }

    PxCompileTimeAssert_Dummy19 :: [1] u8;

    /**
    \brief Data structure describing non-wheel configuration data of a vehicle that has engine, gears, clutch, and auto-box.
    @see PxVehicleWheelsSimData for wheels configuration data.
    */
    PxVehicleDriveSimData :: struct {
        /**
        \brief Return the engine data
        */
        getEngineData :: (this: *PxVehicleDriveSimData) -> *PxVehicleEngineData #cpp_method #foreign physx_lib "?getEngineData@PxVehicleDriveSimData@physx@@QEBAAEBVPxVehicleEngineData@2@XZ";

        /**
        \brief Return the gears data
        */
        getGearsData :: (this: *PxVehicleDriveSimData) -> *PxVehicleGearsData #cpp_method #foreign physx_lib "?getGearsData@PxVehicleDriveSimData@physx@@QEBAAEBVPxVehicleGearsData@2@XZ";

        /**
        \brief Return the clutch data
        */
        getClutchData :: (this: *PxVehicleDriveSimData) -> *PxVehicleClutchData #cpp_method #foreign physx_lib "?getClutchData@PxVehicleDriveSimData@physx@@QEBAAEBVPxVehicleClutchData@2@XZ";

        /**
        \brief Return the autobox data
        */
        getAutoBoxData :: (this: *PxVehicleDriveSimData) -> *PxVehicleAutoBoxData #cpp_method #foreign physx_lib "?getAutoBoxData@PxVehicleDriveSimData@physx@@QEBAAEBVPxVehicleAutoBoxData@2@XZ";

        /*
        \brief Engine simulation data
        @see setEngineData, getEngineData
        */
        mEngine:  PxVehicleEngineData;

        /*
        \brief Gear simulation data
        @see setGearsData, getGearsData
        */
        mGears:   PxVehicleGearsData;

        /*
        \brief Clutch simulation data
        @see setClutchData, getClutchData
        */
        mClutch:  PxVehicleClutchData;

        /*
        \brief Autobox simulation data
        @see setAutoboxData, getAutoboxData
        */
        mAutoBox: PxVehicleAutoBoxData;

        //serialization
        Constructor :: (this: *PxVehicleDriveSimData) -> void #cpp_method #foreign physx_lib "??0PxVehicleDriveSimData@physx@@QEAA@XZ";
        Constructor :: (this: *PxVehicleDriveSimData, unknown0: PxEMPTY) -> void #cpp_method #foreign physx_lib "??0PxVehicleDriveSimData@physx@@QEAA@W4PxEMPTY@1@@Z";
    }
    #run {if true then return;
        instance: PxVehicleDriveSimData;
        assert(((cast(*void)(*instance.mEngine)) - cast(*void)(*instance)) == 0, "PxVehicleDriveSimData.mEngine has unexpected offset % instead of 0", ((cast(*void)(*instance.mEngine)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleDriveSimData.mEngine)) == 112, "PxVehicleDriveSimData.mEngine has unexpected size % instead of 112", size_of(type_of(PxVehicleDriveSimData.mEngine)));
        assert(((cast(*void)(*instance.mGears)) - cast(*void)(*instance)) == 112, "PxVehicleDriveSimData.mGears has unexpected offset % instead of 112", ((cast(*void)(*instance.mGears)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleDriveSimData.mGears)) == 144, "PxVehicleDriveSimData.mGears has unexpected size % instead of 144", size_of(type_of(PxVehicleDriveSimData.mGears)));
        assert(((cast(*void)(*instance.mClutch)) - cast(*void)(*instance)) == 256, "PxVehicleDriveSimData.mClutch has unexpected offset % instead of 256", ((cast(*void)(*instance.mClutch)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleDriveSimData.mClutch)) == 16, "PxVehicleDriveSimData.mClutch has unexpected size % instead of 16", size_of(type_of(PxVehicleDriveSimData.mClutch)));
        assert(((cast(*void)(*instance.mAutoBox)) - cast(*void)(*instance)) == 272, "PxVehicleDriveSimData.mAutoBox has unexpected offset % instead of 272", ((cast(*void)(*instance.mAutoBox)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleDriveSimData.mAutoBox)) == 256, "PxVehicleDriveSimData.mAutoBox has unexpected size % instead of 256", size_of(type_of(PxVehicleDriveSimData.mAutoBox)));
        assert(size_of(PxVehicleDriveSimData) == 528, "PxVehicleDriveSimData has size % instead of 528", size_of(PxVehicleDriveSimData));
    }

    PxCompileTimeAssert_Dummy20 :: [1] u8;

    /**
    \brief Data structure with instanced dynamics data for vehicle with engine, clutch, gears, autobox
    @see PxVehicleWheelsDynData for wheels dynamics data.
    */
    PxVehicleDriveDynData :: struct {
        anon_enum_3 :: enum s32 {
            eMAX_NB_ANALOG_INPUTS :: 16;
        }

        /**
        \brief Inform the vehicle that the gear-up button has been pressed.

        \param[in] digitalVal is the state of the gear-up button.

        \note If digitalVal is true the vehicle will attempt to initiate a gear change at the next call to PxVehicleUpdates.

        \note The value of mGearUpPressed is not reset by PxVehicleUpdates
        */
        setGearUp :: (this: *PxVehicleDriveDynData, digitalVal: bool) -> void #cpp_method #foreign physx_lib "?setGearUp@PxVehicleDriveDynData@physx@@QEAAX_N@Z";

        /**
        \brief Set that the gear-down button has been pressed.

        \param[in] digitalVal is the state of the gear-down button.

        \note If digitalVal is true the vehicle will attempt to initiate a gear change at the next call to PxVehicleUpdates.

        \note The value of mGearDownPressed is not reset by PxVehicleUpdates
        */
        setGearDown :: (this: *PxVehicleDriveDynData, digitalVal: bool) -> void #cpp_method #foreign physx_lib "?setGearDown@PxVehicleDriveDynData@physx@@QEAAX_N@Z";

        /**
        \brief Check if the gear-up button has been pressed
        \return The state of the gear-up button.
        */
        getGearUp :: (this: *PxVehicleDriveDynData) -> bool #cpp_method #foreign physx_lib "?getGearUp@PxVehicleDriveDynData@physx@@QEBA_NXZ";

        /**
        \brief Check if the gear-down button has been pressed
        \return The state of the gear-down button.
        */
        getGearDown :: (this: *PxVehicleDriveDynData) -> bool #cpp_method #foreign physx_lib "?getGearDown@PxVehicleDriveDynData@physx@@QEBA_NXZ";

        /**
        \brief Set the flag that will be used to select auto-gears
        If useAutoGears is true the auto-box will be active.
        \param[in] useAutoGears is the active state of the auto-box.
        */
        setUseAutoGears :: (this: *PxVehicleDriveDynData, useAutoGears: bool) -> void #cpp_method #foreign physx_lib "?setUseAutoGears@PxVehicleDriveDynData@physx@@QEAAX_N@Z";

        /**
        \brief Get the flag status that is used to select auto-gears
        \return The active status of the auto-box.
        */
        getUseAutoGears :: (this: *PxVehicleDriveDynData) -> bool #cpp_method #foreign physx_lib "?getUseAutoGears@PxVehicleDriveDynData@physx@@QEBA_NXZ";

        /**
        \brief Toggle the auto-gears flag
        If useAutoGears is true the auto-box will be active.
        */
        toggleAutoGears :: (this: *PxVehicleDriveDynData) -> void #cpp_method #foreign physx_lib "?toggleAutoGears@PxVehicleDriveDynData@physx@@QEAAXXZ";

        /**
        \brief Set the current gear.

        \param[in] currentGear is the vehicle's gear.

        \note If the target gear is different from the current gear the vehicle will
        attempt to start a gear change from the current gear that has just been set
        towards the target gear at the next call to PxVehicleUpdates.

        @see setTargetGear, PxVehicleGearsData
        */
        setCurrentGear :: (this: *PxVehicleDriveDynData, currentGear: PxU32) -> void #cpp_method #foreign physx_lib "?setCurrentGear@PxVehicleDriveDynData@physx@@QEAAXI@Z";

        /**
        \brief Get the current gear.

        \return The vehicle's current gear.

        @see getTargetGear, PxVehicleGearsData
        */
        getCurrentGear :: (this: *PxVehicleDriveDynData) -> PxU32 #cpp_method #foreign physx_lib "?getCurrentGear@PxVehicleDriveDynData@physx@@QEBAIXZ";

        /**
        \brief Set the target gear.

        \param[in] targetGear is the vehicle's target gear.

        \note If the target gear is different from the current gear the vehicle will
        attempt to start a gear change towards the target gear at the next call to
        PxVehicleUpdates.

        @see PxVehicleGearsData
        */
        setTargetGear :: (this: *PxVehicleDriveDynData, targetGear: PxU32) -> void #cpp_method #foreign physx_lib "?setTargetGear@PxVehicleDriveDynData@physx@@QEAAXI@Z";

        /**
        \brief Get the target gear.

        \return The vehicle's target gear.

        @see setTargetGear, PxVehicleGearsData
        */
        getTargetGear :: (this: *PxVehicleDriveDynData) -> PxU32 #cpp_method #foreign physx_lib "?getTargetGear@PxVehicleDriveDynData@physx@@QEBAIXZ";

        /**
        \brief Start a gear change to a target gear.

        \param[in] targetGear is the gear the vehicle will begin a transition towards.

        \note The gear change will begin at the next call to PxVehicleUpadates.

        @see PxVehicleGearsData
        */
        startGearChange :: (this: *PxVehicleDriveDynData, targetGear: PxU32) -> void #cpp_method #foreign physx_lib "?startGearChange@PxVehicleDriveDynData@physx@@QEAAXI@Z";

        /**
        \brief Force an immediate gear change to a target gear

        \param[in] targetGear is the gear the vehicle will be given immediately.

        @see PxVehicleGearsData
        */
        forceGearChange :: (this: *PxVehicleDriveDynData, targetGear: PxU32) -> void #cpp_method #foreign physx_lib "?forceGearChange@PxVehicleDriveDynData@physx@@QEAAXI@Z";

        /**
        \brief Set the rotation speed of the engine (radians per second)

        \param[in] speed is the rotational speed (radians per second) to apply to the engine.
        */
        setEngineRotationSpeed :: (this: *PxVehicleDriveDynData, speed: PxF32) -> void #cpp_method #foreign physx_lib "?setEngineRotationSpeed@PxVehicleDriveDynData@physx@@QEAAXM@Z";

        /**
        \brief Return the rotation speed of the engine (radians per second)

        \return The rotational speed (radians per second) of the engine.
        */
        getEngineRotationSpeed :: (this: *PxVehicleDriveDynData) -> PxReal #cpp_method #foreign physx_lib "?getEngineRotationSpeed@PxVehicleDriveDynData@physx@@QEBAMXZ";

        /**
        \brief Return the time that has passed since the current gear change was initiated.

        \return The time that has passed since the current gear change was initiated.

        \note If no gear change is in process the gear switch time will be zero.

        @see PxVehicleGearsData.mSwitchTime
        */
        getGearSwitchTime :: (this: *PxVehicleDriveDynData) -> PxReal #cpp_method #foreign physx_lib "?getGearSwitchTime@PxVehicleDriveDynData@physx@@QEBAMXZ";

        /**
        \brief Return the time that has passed since the autobox last initiated a gear change.

        \return  The time that has passed since the autobox last initiated a gear change.

        @see PxVehicleAutoBoxData::setLatency, PxVehicleAutoBoxData::getLatency
        */
        getAutoBoxSwitchTime :: (this: *PxVehicleDriveDynData) -> PxReal #cpp_method #foreign physx_lib "?getAutoBoxSwitchTime@PxVehicleDriveDynData@physx@@QEBAMXZ";

        /**
        \brief Analog control values used by vehicle simulation.
        @see setAnalogInput, getAnalogInput, PxVehicleDrive4WControl, PxVehicleDriveNWControl, PxVehicleDriveTankControl
        */
        mControlAnalogVals: [16] PxReal;

        /**
        \brief Auto-gear flag used by vehicle simulation.  Set true to enable the autobox, false to disable the autobox.
        @see setUseAutoGears, setUseAutoGears, toggleAutoGears, PxVehicleAutoBoxData
        */
        mUseAutoGears:      bool;

        /**
        \brief Gear-up digital control value used by vehicle simulation.

        \note If true a gear change will be initiated towards currentGear+1 (or to first gear if in reverse).

        @see setDigitalInput, getDigitalInput
        */
        mGearUpPressed:     bool;

        /**
        \brief Gear-down digital control value used by vehicle simulation.

        \note If true a gear change will be initiated towards currentGear-1 (or to reverse if in first).

        @see setDigitalInput, getDigitalInput
        */
        mGearDownPressed:   bool;

        /**
        \brief Current gear
        @see startGearChange, forceGearChange, getCurrentGear, PxVehicleGearsData
        */
        mCurrentGear:       PxU32;

        /**
        \brief Target gear (different from current gear if a gear change is underway)
        @see startGearChange, forceGearChange, getTargetGear, PxVehicleGearsData
        */
        mTargetGear:        PxU32;

        /**
        \brief Rotation speed of engine
        @see setToRestState, getEngineRotationSpeed
        */
        mEnginespeed:       PxReal;

        /**
        \brief Reported time that has passed since gear change started.
        @see setToRestState, startGearChange, PxVehicleGearsData::mSwitchTime
        */
        mGearSwitchTime:    PxReal;

        /**
        \brief Reported time that has passed since last autobox gearup/geardown decision.
        @see setToRestState, PxVehicleAutoBoxData::setLatency
        */
        mAutoBoxSwitchTime: PxReal;

        mPad:               [2] PxU32;

        Constructor :: (this: *PxVehicleDriveDynData, unknown0: PxEMPTY) -> void #cpp_method #foreign physx_lib "??0PxVehicleDriveDynData@physx@@QEAA@W4PxEMPTY@1@@Z";
        getNbAnalogInput :: (this: *PxVehicleDriveDynData) -> PxU32 #cpp_method #foreign physx_lib "?getNbAnalogInput@PxVehicleDriveDynData@physx@@QEBAIXZ";
        setGearChange :: (this: *PxVehicleDriveDynData, gearChange: PxU32) -> void #cpp_method #foreign physx_lib "?setGearChange@PxVehicleDriveDynData@physx@@QEAAXI@Z";
        getGearChange :: (this: *PxVehicleDriveDynData) -> PxU32 #cpp_method #foreign physx_lib "?getGearChange@PxVehicleDriveDynData@physx@@QEBAIXZ";
        setGearSwitchTime :: (this: *PxVehicleDriveDynData, switchTime: PxReal) -> void #cpp_method #foreign physx_lib "?setGearSwitchTime@PxVehicleDriveDynData@physx@@QEAAXM@Z";
        setAutoBoxSwitchTime :: (this: *PxVehicleDriveDynData, autoBoxSwitchTime: PxReal) -> void #cpp_method #foreign physx_lib "?setAutoBoxSwitchTime@PxVehicleDriveDynData@physx@@QEAAXM@Z";
    }
    #run {if true then return;
        instance: PxVehicleDriveDynData;
        assert(((cast(*void)(*instance.mControlAnalogVals)) - cast(*void)(*instance)) == 0, "PxVehicleDriveDynData.mControlAnalogVals has unexpected offset % instead of 0", ((cast(*void)(*instance.mControlAnalogVals)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleDriveDynData.mControlAnalogVals)) == 64, "PxVehicleDriveDynData.mControlAnalogVals has unexpected size % instead of 64", size_of(type_of(PxVehicleDriveDynData.mControlAnalogVals)));
        assert(((cast(*void)(*instance.mUseAutoGears)) - cast(*void)(*instance)) == 64, "PxVehicleDriveDynData.mUseAutoGears has unexpected offset % instead of 64", ((cast(*void)(*instance.mUseAutoGears)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleDriveDynData.mUseAutoGears)) == 1, "PxVehicleDriveDynData.mUseAutoGears has unexpected size % instead of 1", size_of(type_of(PxVehicleDriveDynData.mUseAutoGears)));
        assert(((cast(*void)(*instance.mGearUpPressed)) - cast(*void)(*instance)) == 65, "PxVehicleDriveDynData.mGearUpPressed has unexpected offset % instead of 65", ((cast(*void)(*instance.mGearUpPressed)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleDriveDynData.mGearUpPressed)) == 1, "PxVehicleDriveDynData.mGearUpPressed has unexpected size % instead of 1", size_of(type_of(PxVehicleDriveDynData.mGearUpPressed)));
        assert(((cast(*void)(*instance.mGearDownPressed)) - cast(*void)(*instance)) == 66, "PxVehicleDriveDynData.mGearDownPressed has unexpected offset % instead of 66", ((cast(*void)(*instance.mGearDownPressed)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleDriveDynData.mGearDownPressed)) == 1, "PxVehicleDriveDynData.mGearDownPressed has unexpected size % instead of 1", size_of(type_of(PxVehicleDriveDynData.mGearDownPressed)));
        assert(((cast(*void)(*instance.mCurrentGear)) - cast(*void)(*instance)) == 68, "PxVehicleDriveDynData.mCurrentGear has unexpected offset % instead of 68", ((cast(*void)(*instance.mCurrentGear)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleDriveDynData.mCurrentGear)) == 4, "PxVehicleDriveDynData.mCurrentGear has unexpected size % instead of 4", size_of(type_of(PxVehicleDriveDynData.mCurrentGear)));
        assert(((cast(*void)(*instance.mTargetGear)) - cast(*void)(*instance)) == 72, "PxVehicleDriveDynData.mTargetGear has unexpected offset % instead of 72", ((cast(*void)(*instance.mTargetGear)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleDriveDynData.mTargetGear)) == 4, "PxVehicleDriveDynData.mTargetGear has unexpected size % instead of 4", size_of(type_of(PxVehicleDriveDynData.mTargetGear)));
        assert(((cast(*void)(*instance.mEnginespeed)) - cast(*void)(*instance)) == 76, "PxVehicleDriveDynData.mEnginespeed has unexpected offset % instead of 76", ((cast(*void)(*instance.mEnginespeed)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleDriveDynData.mEnginespeed)) == 4, "PxVehicleDriveDynData.mEnginespeed has unexpected size % instead of 4", size_of(type_of(PxVehicleDriveDynData.mEnginespeed)));
        assert(((cast(*void)(*instance.mGearSwitchTime)) - cast(*void)(*instance)) == 80, "PxVehicleDriveDynData.mGearSwitchTime has unexpected offset % instead of 80", ((cast(*void)(*instance.mGearSwitchTime)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleDriveDynData.mGearSwitchTime)) == 4, "PxVehicleDriveDynData.mGearSwitchTime has unexpected size % instead of 4", size_of(type_of(PxVehicleDriveDynData.mGearSwitchTime)));
        assert(((cast(*void)(*instance.mAutoBoxSwitchTime)) - cast(*void)(*instance)) == 84, "PxVehicleDriveDynData.mAutoBoxSwitchTime has unexpected offset % instead of 84", ((cast(*void)(*instance.mAutoBoxSwitchTime)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleDriveDynData.mAutoBoxSwitchTime)) == 4, "PxVehicleDriveDynData.mAutoBoxSwitchTime has unexpected size % instead of 4", size_of(type_of(PxVehicleDriveDynData.mAutoBoxSwitchTime)));
        assert(((cast(*void)(*instance.mPad)) - cast(*void)(*instance)) == 88, "PxVehicleDriveDynData.mPad has unexpected offset % instead of 88", ((cast(*void)(*instance.mPad)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleDriveDynData.mPad)) == 8, "PxVehicleDriveDynData.mPad has unexpected size % instead of 8", size_of(type_of(PxVehicleDriveDynData.mPad)));
        assert(size_of(PxVehicleDriveDynData) == 96, "PxVehicleDriveDynData has size % instead of 96", size_of(PxVehicleDriveDynData));
    }

    PxCompileTimeAssert_Dummy21 :: [1] u8;

    /**
    \brief A complete vehicle with instance dynamics data and configuration data for wheels and engine,clutch,gears,autobox.
    @see PxVehicleDrive4W, PxVehicleDriveTank
    */
    PxVehicleDrive :: struct {
        #as using pxvehiclewheels: PxVehicleWheels;

        /**
        \brief Dynamics data of vehicle instance.
        @see setup
        */
        mDriveDynData: PxVehicleDriveDynData;

        Constructor :: (this: *PxVehicleDrive, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_lib "??0PxVehicleDrive@physx@@QEAA@V?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.
        virtual_getConcreteTypeName :: (this: *PxVehicleDrive) -> *u8 #cpp_method #foreign physx_lib "?getConcreteTypeName@PxVehicleDrive@physx@@UEBAPEBDXZ";

        virtual_Destructor :: (this: *PxVehicleDrive, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_lib "??1PxVehicleDrive@physx@@MEAA@XZ";
        virtual_isKindOf :: (this: *PxVehicleDrive, name: *u8) -> bool #cpp_method #foreign physx_lib "?isKindOf@PxVehicleDrive@physx@@MEBA_NPEBD@Z";
    }
    #run {if true then return;
        assert(size_of(type_of(PxVehicleDrive.pxvehiclewheels)) == 192, "PxVehicleDrive.pxvehiclewheels has unexpected size % instead of 192", size_of(type_of(PxVehicleDrive.pxvehiclewheels)));
        instance: PxVehicleDrive;
        assert(((cast(*void)(*instance.mDriveDynData)) - cast(*void)(*instance)) == 192, "PxVehicleDrive.mDriveDynData has unexpected offset % instead of 192", ((cast(*void)(*instance.mDriveDynData)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleDrive.mDriveDynData)) == 96, "PxVehicleDrive.mDriveDynData has unexpected size % instead of 96", size_of(type_of(PxVehicleDrive.mDriveDynData)));
        assert(size_of(PxVehicleDrive) == 288, "PxVehicleDrive has size % instead of 288", size_of(PxVehicleDrive));
    }

    PxCompileTimeAssert_Dummy22 :: [1] u8;

    /**
    \brief Data structure describing the drive model components of a vehicle with up to 4 driven wheels and up to 16 un-driven wheels.
    The drive model incorporates engine, clutch, gears, autobox, differential, and Ackermann steer correction.
    @see PxVehicleDriveSimData
    */
    PxVehicleDriveSimData4W :: struct {
        #as using pxvehicledrivesimdata: PxVehicleDriveSimData;

        Constructor :: (this: *PxVehicleDriveSimData4W) -> void #cpp_method #foreign physx_lib "??0PxVehicleDriveSimData4W@physx@@QEAA@XZ";

        /**
        \brief Return the data describing the differential.
        @see PxVehicleDifferential4WData
        */
        getDiffData :: (this: *PxVehicleDriveSimData4W) -> *PxVehicleDifferential4WData #cpp_method #foreign physx_lib "?getDiffData@PxVehicleDriveSimData4W@physx@@QEBAAEBVPxVehicleDifferential4WData@2@XZ";

        /**
        \brief Return the data describing the Ackermann steer-correction.
        @see PxVehicleAckermannGeometryData
        */
        getAckermannGeometryData :: (this: *PxVehicleDriveSimData4W) -> *PxVehicleAckermannGeometryData #cpp_method #foreign physx_lib "?getAckermannGeometryData@PxVehicleDriveSimData4W@physx@@QEBAAEBVPxVehicleAckermannGeometryData@2@XZ";

        /**
        \brief Differential simulation data
        @see setDiffData, getDiffData
        */
        mDiff:              PxVehicleDifferential4WData;

        /**
        \brief Data for ackermann steer angle computation.
        @see setAckermannGeometryData, getAckermannGeometryData
        */
        mAckermannGeometry: PxVehicleAckermannGeometryData;

        //serialization
        Constructor :: (this: *PxVehicleDriveSimData4W, unknown0: PxEMPTY) -> void #cpp_method #foreign physx_lib "??0PxVehicleDriveSimData4W@physx@@QEAA@W4PxEMPTY@1@@Z";
    }
    #run {if true then return;
        assert(size_of(type_of(PxVehicleDriveSimData4W.pxvehicledrivesimdata)) == 528, "PxVehicleDriveSimData4W.pxvehicledrivesimdata has unexpected size % instead of 528", size_of(type_of(PxVehicleDriveSimData4W.pxvehicledrivesimdata)));
        instance: PxVehicleDriveSimData4W;
        assert(((cast(*void)(*instance.mDiff)) - cast(*void)(*instance)) == 528, "PxVehicleDriveSimData4W.mDiff has unexpected offset % instead of 528", ((cast(*void)(*instance.mDiff)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleDriveSimData4W.mDiff)) == 32, "PxVehicleDriveSimData4W.mDiff has unexpected size % instead of 32", size_of(type_of(PxVehicleDriveSimData4W.mDiff)));
        assert(((cast(*void)(*instance.mAckermannGeometry)) - cast(*void)(*instance)) == 560, "PxVehicleDriveSimData4W.mAckermannGeometry has unexpected offset % instead of 560", ((cast(*void)(*instance.mAckermannGeometry)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleDriveSimData4W.mAckermannGeometry)) == 16, "PxVehicleDriveSimData4W.mAckermannGeometry has unexpected size % instead of 16", size_of(type_of(PxVehicleDriveSimData4W.mAckermannGeometry)));
        assert(size_of(PxVehicleDriveSimData4W) == 576, "PxVehicleDriveSimData4W has size % instead of 576", size_of(PxVehicleDriveSimData4W));
    }

    PxCompileTimeAssert_Dummy23 :: [1] u8;

    /**
    \brief The ordering of the driven and steered wheels of a PxVehicleDrive4W.

    @see PxVehicleWheelsSimData, PxVehicleWheelsDynData
    */
    PxVehicleDrive4WWheelOrder :: struct {
        Enum :: enum s32 {
            FRONT_LEFT  :: 0;
            FRONT_RIGHT :: 1;
            REAR_LEFT   :: 2;
            REAR_RIGHT  :: 3;

            eFRONT_LEFT  :: FRONT_LEFT;
            eFRONT_RIGHT :: FRONT_RIGHT;
            eREAR_LEFT   :: REAR_LEFT;
            eREAR_RIGHT  :: REAR_RIGHT;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxVehicleDrive4WWheelOrder) == 1, "PxVehicleDrive4WWheelOrder has size % instead of 1", size_of(PxVehicleDrive4WWheelOrder));
    }

    /**
    \brief The control inputs for a PxVehicleDrive4W.

    @see PxVehicleDriveDynData::setAnalogInput, PxVehicleDriveDynData::getAnalogInput
    */
    PxVehicleDrive4WControl :: struct {
        Enum :: enum s32 {
            ANALOG_INPUT_ACCEL           :: 0;
            ANALOG_INPUT_BRAKE           :: 1;
            ANALOG_INPUT_HANDBRAKE       :: 2;
            ANALOG_INPUT_STEER_LEFT      :: 3;
            ANALOG_INPUT_STEER_RIGHT     :: 4;
            MAX_NB_DRIVE4W_ANALOG_INPUTS :: 5;

            eANALOG_INPUT_ACCEL           :: ANALOG_INPUT_ACCEL;
            eANALOG_INPUT_BRAKE           :: ANALOG_INPUT_BRAKE;
            eANALOG_INPUT_HANDBRAKE       :: ANALOG_INPUT_HANDBRAKE;
            eANALOG_INPUT_STEER_LEFT      :: ANALOG_INPUT_STEER_LEFT;
            eANALOG_INPUT_STEER_RIGHT     :: ANALOG_INPUT_STEER_RIGHT;
            eMAX_NB_DRIVE4W_ANALOG_INPUTS :: MAX_NB_DRIVE4W_ANALOG_INPUTS;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxVehicleDrive4WControl) == 1, "PxVehicleDrive4WControl has size % instead of 1", size_of(PxVehicleDrive4WControl));
    }

    /**
    \brief Data structure with instanced dynamics data and configuration data of a vehicle with up to 4 driven wheels and up to 16 non-driven wheels.
    */
    PxVehicleDrive4W :: struct {
        #as using pxvehicledrive: PxVehicleDrive;

        /**
        \brief Simulation data that describes the configuration of the vehicle's drive model.
        @see setup, create
        */
        mDriveSimData: PxVehicleDriveSimData4W;

        Constructor :: (this: *PxVehicleDrive4W, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_lib "??0PxVehicleDrive4W@physx@@QEAA@V?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.

        virtual_Destructor :: (this: *PxVehicleDrive4W, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_lib "??1PxVehicleDrive4W@physx@@MEAA@XZ";
        virtual_isKindOf :: (this: *PxVehicleDrive4W, name: *u8) -> bool #cpp_method #foreign physx_lib "?isKindOf@PxVehicleDrive4W@physx@@MEBA_NPEBD@Z";

        virtual_getConcreteTypeName :: (this: *PxVehicleDrive4W) -> *u8 #cpp_method #foreign physx_lib "?getConcreteTypeName@PxVehicleDrive4W@physx@@UEBAPEBDXZ";
    }
    #run {if true then return;
        assert(size_of(type_of(PxVehicleDrive4W.pxvehicledrive)) == 288, "PxVehicleDrive4W.pxvehicledrive has unexpected size % instead of 288", size_of(type_of(PxVehicleDrive4W.pxvehicledrive)));
        instance: PxVehicleDrive4W;
        assert(((cast(*void)(*instance.mDriveSimData)) - cast(*void)(*instance)) == 288, "PxVehicleDrive4W.mDriveSimData has unexpected offset % instead of 288", ((cast(*void)(*instance.mDriveSimData)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleDrive4W.mDriveSimData)) == 576, "PxVehicleDrive4W.mDriveSimData has unexpected size % instead of 576", size_of(type_of(PxVehicleDrive4W.mDriveSimData)));
        assert(size_of(PxVehicleDrive4W) == 864, "PxVehicleDrive4W has size % instead of 864", size_of(PxVehicleDrive4W));
    }

    PxCompileTimeAssert_Dummy24 :: [1] u8;

    /**
    \brief The ordering of the wheels of a PxVehicleDriveTank.

    @see PxVehicleWheelsSimData, PxVehicleWheelsDynData
    */
    PxVehicleDriveTankWheelOrder :: struct {
        Enum :: enum s32 {
            FRONT_LEFT            :: 0;
            FRONT_RIGHT           :: 1;
            _1ST_FROM_FRONT_LEFT  :: 2;
            _1ST_FROM_FRONT_RIGHT :: 3;
            _2ND_FROM_FRONT_LEFT  :: 4;
            _2ND_FROM_FRONT_RIGHT :: 5;
            _3RD_FROM_FRONT_LEFT  :: 6;
            _3RD_FROM_FRONT_RIGHT :: 7;
            _4TH_FROM_FRONT_LEFT  :: 8;
            _4TH_FROM_FRONT_RIGHT :: 9;
            _5TH_FROM_FRONT_LEFT  :: 10;
            _5TH_FROM_FRONT_RIGHT :: 11;
            _6TH_FROM_FRONT_LEFT  :: 12;
            _6TH_FROM_FRONT_RIGHT :: 13;
            _7TH_FROM_FRONT_LEFT  :: 14;
            _7TH_FROM_FRONT_RIGHT :: 15;
            _8TH_FROM_FRONT_LEFT  :: 16;
            _8TH_FROM_FRONT_RIGHT :: 17;
            _9TH_FROM_FRONT_LEFT  :: 18;
            _9TH_FROM_FRONT_RIGHT :: 19;

            eFRONT_LEFT           :: FRONT_LEFT;
            eFRONT_RIGHT          :: FRONT_RIGHT;
            e1ST_FROM_FRONT_LEFT  :: _1ST_FROM_FRONT_LEFT;
            e1ST_FROM_FRONT_RIGHT :: _1ST_FROM_FRONT_RIGHT;
            e2ND_FROM_FRONT_LEFT  :: _2ND_FROM_FRONT_LEFT;
            e2ND_FROM_FRONT_RIGHT :: _2ND_FROM_FRONT_RIGHT;
            e3RD_FROM_FRONT_LEFT  :: _3RD_FROM_FRONT_LEFT;
            e3RD_FROM_FRONT_RIGHT :: _3RD_FROM_FRONT_RIGHT;
            e4TH_FROM_FRONT_LEFT  :: _4TH_FROM_FRONT_LEFT;
            e4TH_FROM_FRONT_RIGHT :: _4TH_FROM_FRONT_RIGHT;
            e5TH_FROM_FRONT_LEFT  :: _5TH_FROM_FRONT_LEFT;
            e5TH_FROM_FRONT_RIGHT :: _5TH_FROM_FRONT_RIGHT;
            e6TH_FROM_FRONT_LEFT  :: _6TH_FROM_FRONT_LEFT;
            e6TH_FROM_FRONT_RIGHT :: _6TH_FROM_FRONT_RIGHT;
            e7TH_FROM_FRONT_LEFT  :: _7TH_FROM_FRONT_LEFT;
            e7TH_FROM_FRONT_RIGHT :: _7TH_FROM_FRONT_RIGHT;
            e8TH_FROM_FRONT_LEFT  :: _8TH_FROM_FRONT_LEFT;
            e8TH_FROM_FRONT_RIGHT :: _8TH_FROM_FRONT_RIGHT;
            e9TH_FROM_FRONT_LEFT  :: _9TH_FROM_FRONT_LEFT;
            e9TH_FROM_FRONT_RIGHT :: _9TH_FROM_FRONT_RIGHT;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxVehicleDriveTankWheelOrder) == 1, "PxVehicleDriveTankWheelOrder has size % instead of 1", size_of(PxVehicleDriveTankWheelOrder));
    }

    /**
    \brief The control inputs for a PxVehicleDriveTank.

    \note The values of eANALOG_INPUT_THRUST_LEFT and eANALOG_INPUT_THRUST_RIGHT determine how much
    of the total available drive torque is diverted to the left and right wheels.  These entries in the
    enumerated list represent the state of the left and right control sticks of a tank. The total available
    drive torque available is controlled by eANALOG_INPUT_ACCEL, which represents the state of the acceleration
    pedal and controls how much torque will be applied to the engine.

    \note To accelerate forwards eANALOG_INPUT_ACCEL must be greater than zero so that torque is applied to drive the
    engine, while eANALOG_INPUT_THRUST_LEFT and eANALOG_INPUT_THRUST_RIGHT must also be greater than zero
    to divert the available drive torque to the left and wheels. If eANALOG_INPUT_THRUST_LEFT > eANALOG_INPUT_THRUST_RIGHT
    the tank will turn to the right.  If eANALOG_INPUT_THRUST_RIGHT > eANALOG_INPUT_THRUST_LEFT
    the tank will turn to the left.

    @see PxVehicleDriveDynData::setAnalogInput, PxVehicleDriveDynData::getAnalogInput
    */
    PxVehicleDriveTankControl :: struct {
        Enum :: enum s32 {
            ANALOG_INPUT_ACCEL             :: 0;
            ANALOG_INPUT_BRAKE_LEFT        :: 1;
            ANALOG_INPUT_BRAKE_RIGHT       :: 2;
            ANALOG_INPUT_THRUST_LEFT       :: 3;
            ANALOG_INPUT_THRUST_RIGHT      :: 4;
            MAX_NB_DRIVETANK_ANALOG_INPUTS :: 5;

            eANALOG_INPUT_ACCEL             :: ANALOG_INPUT_ACCEL;
            eANALOG_INPUT_BRAKE_LEFT        :: ANALOG_INPUT_BRAKE_LEFT;
            eANALOG_INPUT_BRAKE_RIGHT       :: ANALOG_INPUT_BRAKE_RIGHT;
            eANALOG_INPUT_THRUST_LEFT       :: ANALOG_INPUT_THRUST_LEFT;
            eANALOG_INPUT_THRUST_RIGHT      :: ANALOG_INPUT_THRUST_RIGHT;
            eMAX_NB_DRIVETANK_ANALOG_INPUTS :: MAX_NB_DRIVETANK_ANALOG_INPUTS;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxVehicleDriveTankControl) == 1, "PxVehicleDriveTankControl has size % instead of 1", size_of(PxVehicleDriveTankControl));
    }

    /**
    \brief Two driving models are supported.

    \note If eSTANDARD is chosen the left and right wheels are always driven in the same direction.  If the tank is in
    a forward gear the left and right wheels will all be driven forwards, while in reverse gear the left and right wheels
    will all be driven backwards. With eSTANDARD the legal range of left and right thrust is (0,1).

    \note If eSPECIAL is chosen it is possible to drive the left and right wheels in different directions.
    With eSPECIAL the legal range of left and right thrust is (-1,1).  In forward(reverse) gear negative thrust values drive the wheels
    backwards(forwards), while positive thrust values drives the wheels forwards(backwards).

    \note A sharp left turn can be achieved in eSTANDARD mode by braking with the left wheels and thrusting forward with the
    right wheels. A smaller turning circle can theoretically be achieved in eSPECIAL mode by applying negative thrust to the left wheels and positive
    thrust to the right wheels.

    \note In both modes the legal ranges of acceleration and left/right brake are all (0,1).

    @see PxVehicleDriveTank::setDriveModel
    */
    PxVehicleDriveTankControlModel :: struct {
        Enum :: enum s32 {
            TANDARD :: 0;
            PECIAL  :: 1;

            eSTANDARD :: TANDARD;
            eSPECIAL  :: PECIAL;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxVehicleDriveTankControlModel) == 1, "PxVehicleDriveTankControlModel has size % instead of 1", size_of(PxVehicleDriveTankControlModel));
    }

    /**
    \brief Data structure with instanced dynamics data and configuration data of a tank.
    */
    PxVehicleDriveTank :: struct {
        #as using pxvehicledrive: PxVehicleDrive;

        /**
        \brief Set the control model used by the tank.
        \note eDRIVE_MODEL_STANDARD: turning achieved by braking on one side, accelerating on the other side.
        \note eDRIVE_MODEL_SPECIAL: turning achieved by accelerating forwards on one side, accelerating backwards on the other side.
        \note The default value is eDRIVE_MODEL_STANDARD
        */
        setDriveModel :: (this: *PxVehicleDriveTank, driveModel: PxVehicleDriveTankControlModel.Enum) -> void #cpp_method #foreign physx_lib "?setDriveModel@PxVehicleDriveTank@physx@@QEAAXW4Enum@PxVehicleDriveTankControlModel@2@@Z";

        /**
        \brief Return the control model used by the tank.
        */
        getDriveModel :: (this: *PxVehicleDriveTank) -> PxVehicleDriveTankControlModel.Enum #cpp_method #foreign physx_lib "?getDriveModel@PxVehicleDriveTank@physx@@QEBA?AW4Enum@PxVehicleDriveTankControlModel@2@XZ";

        /**
        \brief Simulation data that models vehicle components
        @see setup, create
        */
        mDriveSimData: PxVehicleDriveSimData;

        /**
        \brief Drive model
        @see setDriveModel, getDriveModel, PxVehicleDriveTankControlModel
        */
        mDriveModel:   PxVehicleDriveTankControlModel.Enum;

        mPad:          [3] PxU32;

        //serialization
        Constructor :: (this: *PxVehicleDriveTank, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_lib "??0PxVehicleDriveTank@physx@@QEAA@V?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.

        virtual_getConcreteTypeName :: (this: *PxVehicleDriveTank) -> *u8 #cpp_method #foreign physx_lib "?getConcreteTypeName@PxVehicleDriveTank@physx@@UEBAPEBDXZ";
        virtual_isKindOf :: (this: *PxVehicleDriveTank, name: *u8) -> bool #cpp_method #foreign physx_lib "?isKindOf@PxVehicleDriveTank@physx@@UEBA_NPEBD@Z";

        virtual_Destructor :: (this: *PxVehicleDriveTank, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_lib "??1PxVehicleDriveTank@physx@@MEAA@XZ";
    }
    #run {if true then return;
        assert(size_of(type_of(PxVehicleDriveTank.pxvehicledrive)) == 288, "PxVehicleDriveTank.pxvehicledrive has unexpected size % instead of 288", size_of(type_of(PxVehicleDriveTank.pxvehicledrive)));
        instance: PxVehicleDriveTank;
        assert(((cast(*void)(*instance.mDriveSimData)) - cast(*void)(*instance)) == 288, "PxVehicleDriveTank.mDriveSimData has unexpected offset % instead of 288", ((cast(*void)(*instance.mDriveSimData)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleDriveTank.mDriveSimData)) == 528, "PxVehicleDriveTank.mDriveSimData has unexpected size % instead of 528", size_of(type_of(PxVehicleDriveTank.mDriveSimData)));
        assert(((cast(*void)(*instance.mDriveModel)) - cast(*void)(*instance)) == 816, "PxVehicleDriveTank.mDriveModel has unexpected offset % instead of 816", ((cast(*void)(*instance.mDriveModel)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleDriveTank.mDriveModel)) == 4, "PxVehicleDriveTank.mDriveModel has unexpected size % instead of 4", size_of(type_of(PxVehicleDriveTank.mDriveModel)));
        assert(((cast(*void)(*instance.mPad)) - cast(*void)(*instance)) == 820, "PxVehicleDriveTank.mPad has unexpected offset % instead of 820", ((cast(*void)(*instance.mPad)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleDriveTank.mPad)) == 12, "PxVehicleDriveTank.mPad has unexpected size % instead of 12", size_of(type_of(PxVehicleDriveTank.mPad)));
        assert(size_of(PxVehicleDriveTank) == 832, "PxVehicleDriveTank has size % instead of 832", size_of(PxVehicleDriveTank));
    }

    PxCompileTimeAssert_Dummy25 :: [1] u8;

    /**
    \brief Driving surface type. Each PxMaterial is associated with a corresponding PxVehicleDrivableSurfaceType.
    @see PxMaterial, PxVehicleDrivableSurfaceToTireFrictionPairs
    */
    PxVehicleDrivableSurfaceType :: struct {
        anon_enum_4 :: enum s32 {
            eSURFACE_TYPE_UNKNOWN :: -1;
        }

        mType: PxU32;
    }
    #run {if true then return;
        instance: PxVehicleDrivableSurfaceType;
        assert(((cast(*void)(*instance.mType)) - cast(*void)(*instance)) == 0, "PxVehicleDrivableSurfaceType.mType has unexpected offset % instead of 0", ((cast(*void)(*instance.mType)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleDrivableSurfaceType.mType)) == 4, "PxVehicleDrivableSurfaceType.mType has unexpected size % instead of 4", size_of(type_of(PxVehicleDrivableSurfaceType.mType)));
        assert(size_of(PxVehicleDrivableSurfaceType) == 4, "PxVehicleDrivableSurfaceType has size % instead of 4", size_of(PxVehicleDrivableSurfaceType));
    }

    /**
    \brief Friction for each combination of driving surface type and tire type.
    @see PxVehicleDrivableSurfaceType, PxVehicleTireData::mType
    */
    PxVehicleDrivableSurfaceToTireFrictionPairs :: struct {
        anon_enum_5 :: enum s32 {
            eMAX_NB_SURFACE_TYPES :: 256;
        }

        /**
        \brief Return the maximum number of surface types
        \return The maximum number of surface types
        @see allocate
        */
        getMaxNbSurfaceTypes :: (this: *PxVehicleDrivableSurfaceToTireFrictionPairs) -> PxU32 #cpp_method #foreign physx_lib "?getMaxNbSurfaceTypes@PxVehicleDrivableSurfaceToTireFrictionPairs@physx@@QEBAIXZ";

        /**
        \brief Return the maximum number of tire types
        \return The maximum number of tire types
        @see allocate
        */
        getMaxNbTireTypes :: (this: *PxVehicleDrivableSurfaceToTireFrictionPairs) -> PxU32 #cpp_method #foreign physx_lib "?getMaxNbTireTypes@PxVehicleDrivableSurfaceToTireFrictionPairs@physx@@QEBAIXZ";

        /**
        \brief Ptr to base address of a 2d PxReal array with dimensions [mNbSurfaceTypes][mNbTireTypes]

        \note Each element of the array describes the maximum friction provided by a surface type-tire type combination.
        eg the friction corresponding to a combination of surface type x and tire type y is  mPairs[x][y]
        */
        mPairs:                    *PxReal;

        /**
        \brief Ptr to 1d array of material ptrs that is of length mNbSurfaceTypes.

        \note If the PxMaterial that touches the tire corresponds to mDrivableSurfaceMaterials[x] then the drivable surface
        type is mDrivableSurfaceTypes[x].mType and the friction for that contact is mPairs[mDrivableSurfaceTypes[x].mType][y],
        assuming a tire type y.

        \note If the PxMaterial that touches the tire is not found in mDrivableSurfaceMaterials then the friction is
        mPairs[0][y], assuming a tire type y.
        */
        mDrivableSurfaceMaterials: **PxMaterial;

        /**
        \brief Ptr to 1d array of PxVehicleDrivableSurfaceType that is of length mNbSurfaceTypes.

        \note If the PxMaterial that touches the tire is found in mDrivableSurfaceMaterials[x] then the drivable surface
        type is mDrivableSurfaceTypes[x].mType and the friction for that contact is mPairs[mDrivableSurfaceTypes[x].mType][y],
        assuming a tire type y.

        \note If the PxMaterial that touches the tire is not found in mDrivableSurfaceMaterials then the friction is
        mPairs[0][y], assuming a tire type y.
        */
        mDrivableSurfaceTypes:     *PxVehicleDrivableSurfaceType;

        /**
        \brief Number of different driving surface types.

        \note mDrivableSurfaceMaterials and mDrivableSurfaceTypes are both 1d arrays of length mMaxNbSurfaceTypes.

        \note mNbSurfaceTypes must be less than or equal to mMaxNbSurfaceTypes.
        */
        mNbSurfaceTypes:           PxU32;

        /**
        \brief Maximum number of different driving surface types.

        \note mMaxNbSurfaceTypes must be less than or equal to eMAX_NB_SURFACE_TYPES.
        */
        mMaxNbSurfaceTypes:        PxU32;

        /**
        \brief Number of different tire types.

        \note Tire types stored in PxVehicleTireData.mType
        */
        mNbTireTypes:              PxU32;

        /**
        \brief Maximum number of different tire types.

        \note Tire types stored in PxVehicleTireData.mType
        */
        mMaxNbTireTypes:           PxU32;

        mPad:                      [2] PxU32;
    }
    #run {if true then return;
        instance: PxVehicleDrivableSurfaceToTireFrictionPairs;
        assert(((cast(*void)(*instance.mPairs)) - cast(*void)(*instance)) == 0, "PxVehicleDrivableSurfaceToTireFrictionPairs.mPairs has unexpected offset % instead of 0", ((cast(*void)(*instance.mPairs)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleDrivableSurfaceToTireFrictionPairs.mPairs)) == 8, "PxVehicleDrivableSurfaceToTireFrictionPairs.mPairs has unexpected size % instead of 8", size_of(type_of(PxVehicleDrivableSurfaceToTireFrictionPairs.mPairs)));
        assert(((cast(*void)(*instance.mDrivableSurfaceMaterials)) - cast(*void)(*instance)) == 8, "PxVehicleDrivableSurfaceToTireFrictionPairs.mDrivableSurfaceMaterials has unexpected offset % instead of 8", ((cast(*void)(*instance.mDrivableSurfaceMaterials)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleDrivableSurfaceToTireFrictionPairs.mDrivableSurfaceMaterials)) == 8, "PxVehicleDrivableSurfaceToTireFrictionPairs.mDrivableSurfaceMaterials has unexpected size % instead of 8", size_of(type_of(PxVehicleDrivableSurfaceToTireFrictionPairs.mDrivableSurfaceMaterials)));
        assert(((cast(*void)(*instance.mDrivableSurfaceTypes)) - cast(*void)(*instance)) == 16, "PxVehicleDrivableSurfaceToTireFrictionPairs.mDrivableSurfaceTypes has unexpected offset % instead of 16", ((cast(*void)(*instance.mDrivableSurfaceTypes)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleDrivableSurfaceToTireFrictionPairs.mDrivableSurfaceTypes)) == 8, "PxVehicleDrivableSurfaceToTireFrictionPairs.mDrivableSurfaceTypes has unexpected size % instead of 8", size_of(type_of(PxVehicleDrivableSurfaceToTireFrictionPairs.mDrivableSurfaceTypes)));
        assert(((cast(*void)(*instance.mNbSurfaceTypes)) - cast(*void)(*instance)) == 24, "PxVehicleDrivableSurfaceToTireFrictionPairs.mNbSurfaceTypes has unexpected offset % instead of 24", ((cast(*void)(*instance.mNbSurfaceTypes)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleDrivableSurfaceToTireFrictionPairs.mNbSurfaceTypes)) == 4, "PxVehicleDrivableSurfaceToTireFrictionPairs.mNbSurfaceTypes has unexpected size % instead of 4", size_of(type_of(PxVehicleDrivableSurfaceToTireFrictionPairs.mNbSurfaceTypes)));
        assert(((cast(*void)(*instance.mMaxNbSurfaceTypes)) - cast(*void)(*instance)) == 28, "PxVehicleDrivableSurfaceToTireFrictionPairs.mMaxNbSurfaceTypes has unexpected offset % instead of 28", ((cast(*void)(*instance.mMaxNbSurfaceTypes)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleDrivableSurfaceToTireFrictionPairs.mMaxNbSurfaceTypes)) == 4, "PxVehicleDrivableSurfaceToTireFrictionPairs.mMaxNbSurfaceTypes has unexpected size % instead of 4", size_of(type_of(PxVehicleDrivableSurfaceToTireFrictionPairs.mMaxNbSurfaceTypes)));
        assert(((cast(*void)(*instance.mNbTireTypes)) - cast(*void)(*instance)) == 32, "PxVehicleDrivableSurfaceToTireFrictionPairs.mNbTireTypes has unexpected offset % instead of 32", ((cast(*void)(*instance.mNbTireTypes)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleDrivableSurfaceToTireFrictionPairs.mNbTireTypes)) == 4, "PxVehicleDrivableSurfaceToTireFrictionPairs.mNbTireTypes has unexpected size % instead of 4", size_of(type_of(PxVehicleDrivableSurfaceToTireFrictionPairs.mNbTireTypes)));
        assert(((cast(*void)(*instance.mMaxNbTireTypes)) - cast(*void)(*instance)) == 36, "PxVehicleDrivableSurfaceToTireFrictionPairs.mMaxNbTireTypes has unexpected offset % instead of 36", ((cast(*void)(*instance.mMaxNbTireTypes)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleDrivableSurfaceToTireFrictionPairs.mMaxNbTireTypes)) == 4, "PxVehicleDrivableSurfaceToTireFrictionPairs.mMaxNbTireTypes has unexpected size % instead of 4", size_of(type_of(PxVehicleDrivableSurfaceToTireFrictionPairs.mMaxNbTireTypes)));
        assert(((cast(*void)(*instance.mPad)) - cast(*void)(*instance)) == 40, "PxVehicleDrivableSurfaceToTireFrictionPairs.mPad has unexpected offset % instead of 40", ((cast(*void)(*instance.mPad)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleDrivableSurfaceToTireFrictionPairs.mPad)) == 8, "PxVehicleDrivableSurfaceToTireFrictionPairs.mPad has unexpected size % instead of 8", size_of(type_of(PxVehicleDrivableSurfaceToTireFrictionPairs.mPad)));
        assert(size_of(PxVehicleDrivableSurfaceToTireFrictionPairs) == 48, "PxVehicleDrivableSurfaceToTireFrictionPairs has size % instead of 48", size_of(PxVehicleDrivableSurfaceToTireFrictionPairs));
    }

    PxCompileTimeAssert_Dummy26 :: [1] u8;

    /**
    \brief Structure containing data describing the non-persistent state of each suspension/wheel/tire unit.
    This structure is filled out in PxVehicleUpdates and PxVehicleUpdateSingleVehicleAndStoreTelemetryData
    @see PxVehicleUpdates, PxVehicleUpdateSingleVehicleAndStoreTelemetryData
    */
    PxWheelQueryResult :: struct {
        Constructor :: (this: *PxWheelQueryResult) -> void #cpp_method #foreign physx_lib "??0PxWheelQueryResult@physx@@QEAA@XZ";

        /**
        \brief Start point of suspension line raycast/sweep used in the raycast/sweep completed immediately before PxVehicleUpdates.
        \note If no raycast/sweep for the corresponding suspension was performed immediately prior to PxVehicleUpdates then (0,0,0) is stored.
        @see PxVehicleSuspensionRaycasts, PxVehicleSuspensionRaycasts
        */
        suspLineStart:       PxVec3;

        /**
        \brief Directions of suspension line raycast/sweep used in the raycast/sweep completed immediately before PxVehicleUpdates.
        \note If no raycast/sweep for the corresponding suspension was performed immediately prior to PxVehicleUpdates then (0,0,0) is stored.
        @see PxVehicleSuspensionRaycasts, PxVehicleSuspensionRaycasts
        */
        suspLineDir:         PxVec3;

        /**
        \brief Lengths of suspension line raycast/sweep used in raycast/sweep completed immediately before PxVehicleUpdates.
        \note If no raycast/sweep for the corresponding suspension was performed immediately prior to PxVehicleUpdates then 0 is stored.
        @see PxVehicleSuspensionRaycasts, PxVehicleSuspensionRaycasts
        */
        suspLineLength:      PxReal;

        /**
        \brief If suspension travel limits forbid the wheel from touching the drivable surface then isInAir is true.
        \note If the wheel can be placed on the contact plane of the most recent suspension line raycast/sweep then isInAir is false.
        \note If #PxVehicleWheelsSimFlag::eLIMIT_SUSPENSION_EXPANSION_VELOCITY is set, then isInAir will also be true if the suspension
        force is not large enough to expand to the target length in the given simulation time step.
        \note If no raycast/sweep for the corresponding suspension was performed immediately prior to PxVehicleUpdates then isInAir
        is computed using the contact plane that was hit by the most recent suspension line raycast/sweep.
        */
        isInAir:             bool;

        /**
        \brief PxActor instance of the driving surface under the corresponding vehicle wheel.
        \note If suspension travel limits forbid the wheel from touching the drivable surface then tireContactActor is NULL.
        \note If no raycast/sweep for the corresponding suspension was performed immediately prior to PxVehicleUpdates then NULL is stored.
        */
        tireContactActor:    *PxActor;

        /**
        \brief PxShape instance of the driving surface under the corresponding vehicle wheel.
        \note If suspension travel limits forbid the wheel from touching the drivable surface then tireContactShape is NULL.
        \note If no raycast/sweep for the corresponding suspension was performed immediately prior to PxVehicleUpdates then NULL is stored.
        */
        tireContactShape:    *PxShape;

        /**
        \brief PxMaterial instance of the driving surface under the corresponding vehicle wheel.
        \note If suspension travel limits forbid the wheel from touching the drivable surface then tireSurfaceMaterial is NULL.
        \note If no raycast/sweep for the corresponding suspension was performed immediately prior to PxVehicleUpdates then NULL is stored.
        */
        tireSurfaceMaterial: *PxMaterial;

        /**
        \brief Surface type integer that corresponds to the mapping between tireSurfaceMaterial and integer as
        described in PxVehicleDrivableSurfaceToTireFrictionPairs.
        \note If suspension travel limits forbid the wheel from touching the drivable surface then tireSurfaceType is
        PxVehicleDrivableSurfaceType::eSURFACE_TYPE_UNKNOWN.
        \note If no raycast/sweep for the corresponding suspension was performed immediately prior to PxVehicleUpdates then
        PxVehicleDrivableSurfaceType::eSURFACE_TYPE_UNKNOWN is stored.
        @see PxVehicleDrivableSurfaceToTireFrictionPairs
        */
        tireSurfaceType:     PxU32;

        /**
        \brief Point on the drivable surface hit by the most recent suspension raycast or sweep.
        \note If suspension travel limits forbid the wheel from touching the drivable surface then the contact point is (0,0,0).
        \note If no raycast or sweep for the corresponding suspension was performed immediately prior to PxVehicleUpdates then (0,0,0) is stored.
        */
        tireContactPoint:    PxVec3;

        /**
        \brief Normal on the drivable surface at the hit point of the most recent suspension raycast or sweep.
        \note If suspension travel limits forbid the wheel from touching the drivable surface then the contact normal is (0,0,0).
        \note If no raycast or sweep for the corresponding suspension was performed immediately prior to PxVehicleUpdates then (0,0,0) is stored.
        */
        tireContactNormal:   PxVec3;

        /**
        \brief Friction experienced by the tire for the combination of tire type and surface type after accounting
        for the friction vs slip graph.
        \note If suspension travel limits forbid the wheel from touching the drivable surface then the tire friction is 0.
        \note If no raycast or sweep for the corresponding suspension was performed immediately prior to PxVehicleUpdates then the
        stored tire friction is the value computed in PxVehicleUpdates that immediately followed the last raycast or sweep.
        @see PxVehicleDrivableSurfaceToTireFrictionPairs, PxVehicleTireData
        */
        tireFriction:        PxReal;

        /**
        \brief Compression of the suspension spring.
        \note If suspension travel limits forbid the wheel from touching the drivable surface then the jounce is -PxVehicleSuspensionData.mMaxDroop
        The jounce can never exceed PxVehicleSuspensionData.mMaxCompression. Positive values result when the suspension is compressed from
        the rest position, while negative values mean the suspension is elongated from the rest position.
        \note If no raycast or sweep for the corresponding suspension was performed immediately prior to PxVehicleUpdates then the
        suspension compression is computed using the contact plane that was hit by the most recent suspension line raycast or sweep.
        */
        suspJounce:          PxReal;

        /**
        \brief Magnitude of force applied by the suspension spring along the direction of suspension travel.
        \note If suspension travel limits forbid the wheel from touching the drivable surface then the force is 0
        \note If no raycast or sweep for the corresponding suspension was performed immediately prior to PxVehicleUpdates then the
        suspension spring force is computed using the contact plane that was hit by the most recent suspension line raycast or sweep.
        @see PxVehicleWheelsSimData::getSuspTravelDirection
        */
        suspSpringForce:     PxReal;

        /**
        \brief Forward direction of the wheel/tire accounting for steer/toe/camber angle projected on to the contact plane of the drivable surface.
        \note If suspension travel limits forbid the wheel from touching the drivable surface then tireLongitudinalDir is (0,0,0)
        \note If no raycast or sweep for the corresponding suspension was performed immediately prior to PxVehicleUpdates then the
        tire longitudinal direction is computed using the contact plane that was hit by the most recent suspension line raycast or sweep.
        */
        tireLongitudinalDir: PxVec3;

        /**
        \brief Lateral direction of the wheel/tire accounting for steer/toe/camber angle projected on to the contact plan of the drivable surface.
        \note If suspension travel limits forbid the wheel from touching the drivable surface then tireLateralDir is (0,0,0)
        \note If no raycast or sweep for the corresponding suspension was performed immediately prior to PxVehicleUpdates then the
        tire lateral direction is computed using the contact plane that was hit by the most recent suspension line raycast or sweep.
        */
        tireLateralDir:      PxVec3;

        /**
        \brief Longitudinal slip of the tire.
        \note If suspension travel limits forbid the wheel from touching the drivable surface then longitudinalSlip is 0.0
        \note The longitudinal slip is approximately (w*r - vz) / PxAbs(vz) where w is the angular speed of the wheel, r is the radius of the wheel, and
        vz component of rigid body velocity computed at the wheel base along the longitudinal direction of the tire.
        \note If no raycast or sweep for the corresponding suspension was performed immediately prior to PxVehicleUpdates then the
        tire longitudinal slip is computed using the contact plane that was hit by the most recent suspension line raycast or sweep.
        */
        longitudinalSlip:    PxReal;

        /**
        \brief Lateral slip of the tire.
        \note If suspension travel limits forbid the wheel from touching the drivable surface then lateralSlip is 0.0
        \note The lateral slip angle is approximately PxAtan(vx / PxAbs(vz)) where vx and vz are the components of rigid body velocity at the wheel base
        along the wheel's lateral and longitudinal directions, respectively.
        \note If no raycast or sweep for the corresponding suspension was performed immediately prior to PxVehicleUpdates then the
        tire lateral slip is computed using the contact plane that was hit by the most recent suspension line raycast or sweep.
        */
        lateralSlip:         PxReal;

        /**
        \brief Steer angle of the wheel about the "up" vector accounting for input steer and toe and, if applicable, Ackermann steer correction.
        @see PxVehicleWheelData::mToeAngle
        */
        steerAngle:          PxReal;

        /**
        \brief Local pose of the wheel.
        */
        localPose:           PxTransform;
    }
    #run {if true then return;
        instance: PxWheelQueryResult;
        assert(((cast(*void)(*instance.suspLineStart)) - cast(*void)(*instance)) == 0, "PxWheelQueryResult.suspLineStart has unexpected offset % instead of 0", ((cast(*void)(*instance.suspLineStart)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxWheelQueryResult.suspLineStart)) == 12, "PxWheelQueryResult.suspLineStart has unexpected size % instead of 12", size_of(type_of(PxWheelQueryResult.suspLineStart)));
        assert(((cast(*void)(*instance.suspLineDir)) - cast(*void)(*instance)) == 12, "PxWheelQueryResult.suspLineDir has unexpected offset % instead of 12", ((cast(*void)(*instance.suspLineDir)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxWheelQueryResult.suspLineDir)) == 12, "PxWheelQueryResult.suspLineDir has unexpected size % instead of 12", size_of(type_of(PxWheelQueryResult.suspLineDir)));
        assert(((cast(*void)(*instance.suspLineLength)) - cast(*void)(*instance)) == 24, "PxWheelQueryResult.suspLineLength has unexpected offset % instead of 24", ((cast(*void)(*instance.suspLineLength)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxWheelQueryResult.suspLineLength)) == 4, "PxWheelQueryResult.suspLineLength has unexpected size % instead of 4", size_of(type_of(PxWheelQueryResult.suspLineLength)));
        assert(((cast(*void)(*instance.isInAir)) - cast(*void)(*instance)) == 28, "PxWheelQueryResult.isInAir has unexpected offset % instead of 28", ((cast(*void)(*instance.isInAir)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxWheelQueryResult.isInAir)) == 1, "PxWheelQueryResult.isInAir has unexpected size % instead of 1", size_of(type_of(PxWheelQueryResult.isInAir)));
        assert(((cast(*void)(*instance.tireContactActor)) - cast(*void)(*instance)) == 32, "PxWheelQueryResult.tireContactActor has unexpected offset % instead of 32", ((cast(*void)(*instance.tireContactActor)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxWheelQueryResult.tireContactActor)) == 8, "PxWheelQueryResult.tireContactActor has unexpected size % instead of 8", size_of(type_of(PxWheelQueryResult.tireContactActor)));
        assert(((cast(*void)(*instance.tireContactShape)) - cast(*void)(*instance)) == 40, "PxWheelQueryResult.tireContactShape has unexpected offset % instead of 40", ((cast(*void)(*instance.tireContactShape)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxWheelQueryResult.tireContactShape)) == 8, "PxWheelQueryResult.tireContactShape has unexpected size % instead of 8", size_of(type_of(PxWheelQueryResult.tireContactShape)));
        assert(((cast(*void)(*instance.tireSurfaceMaterial)) - cast(*void)(*instance)) == 48, "PxWheelQueryResult.tireSurfaceMaterial has unexpected offset % instead of 48", ((cast(*void)(*instance.tireSurfaceMaterial)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxWheelQueryResult.tireSurfaceMaterial)) == 8, "PxWheelQueryResult.tireSurfaceMaterial has unexpected size % instead of 8", size_of(type_of(PxWheelQueryResult.tireSurfaceMaterial)));
        assert(((cast(*void)(*instance.tireSurfaceType)) - cast(*void)(*instance)) == 56, "PxWheelQueryResult.tireSurfaceType has unexpected offset % instead of 56", ((cast(*void)(*instance.tireSurfaceType)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxWheelQueryResult.tireSurfaceType)) == 4, "PxWheelQueryResult.tireSurfaceType has unexpected size % instead of 4", size_of(type_of(PxWheelQueryResult.tireSurfaceType)));
        assert(((cast(*void)(*instance.tireContactPoint)) - cast(*void)(*instance)) == 60, "PxWheelQueryResult.tireContactPoint has unexpected offset % instead of 60", ((cast(*void)(*instance.tireContactPoint)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxWheelQueryResult.tireContactPoint)) == 12, "PxWheelQueryResult.tireContactPoint has unexpected size % instead of 12", size_of(type_of(PxWheelQueryResult.tireContactPoint)));
        assert(((cast(*void)(*instance.tireContactNormal)) - cast(*void)(*instance)) == 72, "PxWheelQueryResult.tireContactNormal has unexpected offset % instead of 72", ((cast(*void)(*instance.tireContactNormal)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxWheelQueryResult.tireContactNormal)) == 12, "PxWheelQueryResult.tireContactNormal has unexpected size % instead of 12", size_of(type_of(PxWheelQueryResult.tireContactNormal)));
        assert(((cast(*void)(*instance.tireFriction)) - cast(*void)(*instance)) == 84, "PxWheelQueryResult.tireFriction has unexpected offset % instead of 84", ((cast(*void)(*instance.tireFriction)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxWheelQueryResult.tireFriction)) == 4, "PxWheelQueryResult.tireFriction has unexpected size % instead of 4", size_of(type_of(PxWheelQueryResult.tireFriction)));
        assert(((cast(*void)(*instance.suspJounce)) - cast(*void)(*instance)) == 88, "PxWheelQueryResult.suspJounce has unexpected offset % instead of 88", ((cast(*void)(*instance.suspJounce)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxWheelQueryResult.suspJounce)) == 4, "PxWheelQueryResult.suspJounce has unexpected size % instead of 4", size_of(type_of(PxWheelQueryResult.suspJounce)));
        assert(((cast(*void)(*instance.suspSpringForce)) - cast(*void)(*instance)) == 92, "PxWheelQueryResult.suspSpringForce has unexpected offset % instead of 92", ((cast(*void)(*instance.suspSpringForce)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxWheelQueryResult.suspSpringForce)) == 4, "PxWheelQueryResult.suspSpringForce has unexpected size % instead of 4", size_of(type_of(PxWheelQueryResult.suspSpringForce)));
        assert(((cast(*void)(*instance.tireLongitudinalDir)) - cast(*void)(*instance)) == 96, "PxWheelQueryResult.tireLongitudinalDir has unexpected offset % instead of 96", ((cast(*void)(*instance.tireLongitudinalDir)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxWheelQueryResult.tireLongitudinalDir)) == 12, "PxWheelQueryResult.tireLongitudinalDir has unexpected size % instead of 12", size_of(type_of(PxWheelQueryResult.tireLongitudinalDir)));
        assert(((cast(*void)(*instance.tireLateralDir)) - cast(*void)(*instance)) == 108, "PxWheelQueryResult.tireLateralDir has unexpected offset % instead of 108", ((cast(*void)(*instance.tireLateralDir)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxWheelQueryResult.tireLateralDir)) == 12, "PxWheelQueryResult.tireLateralDir has unexpected size % instead of 12", size_of(type_of(PxWheelQueryResult.tireLateralDir)));
        assert(((cast(*void)(*instance.longitudinalSlip)) - cast(*void)(*instance)) == 120, "PxWheelQueryResult.longitudinalSlip has unexpected offset % instead of 120", ((cast(*void)(*instance.longitudinalSlip)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxWheelQueryResult.longitudinalSlip)) == 4, "PxWheelQueryResult.longitudinalSlip has unexpected size % instead of 4", size_of(type_of(PxWheelQueryResult.longitudinalSlip)));
        assert(((cast(*void)(*instance.lateralSlip)) - cast(*void)(*instance)) == 124, "PxWheelQueryResult.lateralSlip has unexpected offset % instead of 124", ((cast(*void)(*instance.lateralSlip)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxWheelQueryResult.lateralSlip)) == 4, "PxWheelQueryResult.lateralSlip has unexpected size % instead of 4", size_of(type_of(PxWheelQueryResult.lateralSlip)));
        assert(((cast(*void)(*instance.steerAngle)) - cast(*void)(*instance)) == 128, "PxWheelQueryResult.steerAngle has unexpected offset % instead of 128", ((cast(*void)(*instance.steerAngle)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxWheelQueryResult.steerAngle)) == 4, "PxWheelQueryResult.steerAngle has unexpected size % instead of 4", size_of(type_of(PxWheelQueryResult.steerAngle)));
        assert(((cast(*void)(*instance.localPose)) - cast(*void)(*instance)) == 132, "PxWheelQueryResult.localPose has unexpected offset % instead of 132", ((cast(*void)(*instance.localPose)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxWheelQueryResult.localPose)) == 28, "PxWheelQueryResult.localPose has unexpected size % instead of 28", size_of(type_of(PxWheelQueryResult.localPose)));
        assert(size_of(PxWheelQueryResult) == 160, "PxWheelQueryResult has size % instead of 160", size_of(PxWheelQueryResult));
    }

    PxVehicleWheelQueryResult :: struct {
        /**
        \brief Pointer to an PxWheelQueryResult buffer of length nbWheelQueryResults
        The wheelQueryResults buffer must persist until the end of PxVehicleUpdates
        A NULL pointer is permitted.
        The wheelQueryResults buffer is left unmodified in PxVehicleUpdates for vehicles with sleeping rigid bodies
        whose control inputs indicate they should remain inert.
        @see PxVehicleUpdates
        */
        wheelQueryResults:   *PxWheelQueryResult;

        /**
        \brief The length of the wheelQueryResults buffer.  This value corresponds to the
        number of wheels in the associated vehicle in PxVehicleUpdates.
        */
        nbWheelQueryResults: PxU32;
    }
    #run {if true then return;
        instance: PxVehicleWheelQueryResult;
        assert(((cast(*void)(*instance.wheelQueryResults)) - cast(*void)(*instance)) == 0, "PxVehicleWheelQueryResult.wheelQueryResults has unexpected offset % instead of 0", ((cast(*void)(*instance.wheelQueryResults)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleWheelQueryResult.wheelQueryResults)) == 8, "PxVehicleWheelQueryResult.wheelQueryResults has unexpected size % instead of 8", size_of(type_of(PxVehicleWheelQueryResult.wheelQueryResults)));
        assert(((cast(*void)(*instance.nbWheelQueryResults)) - cast(*void)(*instance)) == 8, "PxVehicleWheelQueryResult.nbWheelQueryResults has unexpected offset % instead of 8", ((cast(*void)(*instance.nbWheelQueryResults)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleWheelQueryResult.nbWheelQueryResults)) == 4, "PxVehicleWheelQueryResult.nbWheelQueryResults has unexpected size % instead of 4", size_of(type_of(PxVehicleWheelQueryResult.nbWheelQueryResults)));
        assert(size_of(PxVehicleWheelQueryResult) == 16, "PxVehicleWheelQueryResult has size % instead of 16", size_of(PxVehicleWheelQueryResult));
    }

    /**
    \brief Structure containing data that is computed for a wheel during concurrent calls to PxVehicleUpdates
    but which cannot be safely concurrently applied.

    @see PxVehicleUpdates, PxVehiclePostUpdates, PxVehicleConcurrentUpdate
    */
    PxVehicleWheelConcurrentUpdateData :: struct {
        Constructor :: (this: *PxVehicleWheelConcurrentUpdateData) -> void #cpp_method #foreign physx_lib "??0PxVehicleWheelConcurrentUpdateData@physx@@QEAA@XZ";

        localPose:             PxTransform;
        hitActor:              *PxRigidDynamic;
        hitActorForce:         PxVec3;
        hitActorForcePosition: PxVec3;
    }
    #run {if true then return;
        instance: PxVehicleWheelConcurrentUpdateData;
        assert(((cast(*void)(*instance.localPose)) - cast(*void)(*instance)) == 0, "PxVehicleWheelConcurrentUpdateData.localPose has unexpected offset % instead of 0", ((cast(*void)(*instance.localPose)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleWheelConcurrentUpdateData.localPose)) == 28, "PxVehicleWheelConcurrentUpdateData.localPose has unexpected size % instead of 28", size_of(type_of(PxVehicleWheelConcurrentUpdateData.localPose)));
        assert(((cast(*void)(*instance.hitActor)) - cast(*void)(*instance)) == 32, "PxVehicleWheelConcurrentUpdateData.hitActor has unexpected offset % instead of 32", ((cast(*void)(*instance.hitActor)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleWheelConcurrentUpdateData.hitActor)) == 8, "PxVehicleWheelConcurrentUpdateData.hitActor has unexpected size % instead of 8", size_of(type_of(PxVehicleWheelConcurrentUpdateData.hitActor)));
        assert(((cast(*void)(*instance.hitActorForce)) - cast(*void)(*instance)) == 40, "PxVehicleWheelConcurrentUpdateData.hitActorForce has unexpected offset % instead of 40", ((cast(*void)(*instance.hitActorForce)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleWheelConcurrentUpdateData.hitActorForce)) == 12, "PxVehicleWheelConcurrentUpdateData.hitActorForce has unexpected size % instead of 12", size_of(type_of(PxVehicleWheelConcurrentUpdateData.hitActorForce)));
        assert(((cast(*void)(*instance.hitActorForcePosition)) - cast(*void)(*instance)) == 52, "PxVehicleWheelConcurrentUpdateData.hitActorForcePosition has unexpected offset % instead of 52", ((cast(*void)(*instance.hitActorForcePosition)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleWheelConcurrentUpdateData.hitActorForcePosition)) == 12, "PxVehicleWheelConcurrentUpdateData.hitActorForcePosition has unexpected size % instead of 12", size_of(type_of(PxVehicleWheelConcurrentUpdateData.hitActorForcePosition)));
        assert(size_of(PxVehicleWheelConcurrentUpdateData) == 64, "PxVehicleWheelConcurrentUpdateData has size % instead of 64", size_of(PxVehicleWheelConcurrentUpdateData));
    }

    /**
    \brief Structure containing data that is computed for a vehicle and its wheels during concurrent calls to PxVehicleUpdates
    but which cannot be safely concurrently applied.

    @see PxVehicleUpdates, PxVehiclePostUpdates, PxVehicleWheelConcurrentUpdateData
    */
    PxVehicleConcurrentUpdateData :: struct {
        Constructor :: (this: *PxVehicleConcurrentUpdateData) -> void #cpp_method #foreign physx_lib "??0PxVehicleConcurrentUpdateData@physx@@QEAA@XZ";

        /**
        \brief Pointer to an PxVehicleWheelConcurrentUpdate buffer of length nbConcurrentWheelUpdates
        The concurrentWheelUpdates buffer must persist until the end of PxVehiclePostUpdates
        A NULL pointer is not permitted.
        @see PxVehicleUpdates, PxVehiclePostUpdates
        */
        concurrentWheelUpdates:   *PxVehicleWheelConcurrentUpdateData;

        /**
        \brief The length of the concurrentWheelUpdates buffer.  This value corresponds to the
        number of wheels in the associated vehicle passed to PxVehicleUpdates.
        */
        nbConcurrentWheelUpdates: PxU32;

        linearMomentumChange:     PxVec3;
        angularMomentumChange:    PxVec3;
        staySleeping:             bool;
        wakeup:                   bool;
    }
    #run {if true then return;
        instance: PxVehicleConcurrentUpdateData;
        assert(((cast(*void)(*instance.concurrentWheelUpdates)) - cast(*void)(*instance)) == 0, "PxVehicleConcurrentUpdateData.concurrentWheelUpdates has unexpected offset % instead of 0", ((cast(*void)(*instance.concurrentWheelUpdates)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleConcurrentUpdateData.concurrentWheelUpdates)) == 8, "PxVehicleConcurrentUpdateData.concurrentWheelUpdates has unexpected size % instead of 8", size_of(type_of(PxVehicleConcurrentUpdateData.concurrentWheelUpdates)));
        assert(((cast(*void)(*instance.nbConcurrentWheelUpdates)) - cast(*void)(*instance)) == 8, "PxVehicleConcurrentUpdateData.nbConcurrentWheelUpdates has unexpected offset % instead of 8", ((cast(*void)(*instance.nbConcurrentWheelUpdates)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleConcurrentUpdateData.nbConcurrentWheelUpdates)) == 4, "PxVehicleConcurrentUpdateData.nbConcurrentWheelUpdates has unexpected size % instead of 4", size_of(type_of(PxVehicleConcurrentUpdateData.nbConcurrentWheelUpdates)));
        assert(((cast(*void)(*instance.linearMomentumChange)) - cast(*void)(*instance)) == 12, "PxVehicleConcurrentUpdateData.linearMomentumChange has unexpected offset % instead of 12", ((cast(*void)(*instance.linearMomentumChange)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleConcurrentUpdateData.linearMomentumChange)) == 12, "PxVehicleConcurrentUpdateData.linearMomentumChange has unexpected size % instead of 12", size_of(type_of(PxVehicleConcurrentUpdateData.linearMomentumChange)));
        assert(((cast(*void)(*instance.angularMomentumChange)) - cast(*void)(*instance)) == 24, "PxVehicleConcurrentUpdateData.angularMomentumChange has unexpected offset % instead of 24", ((cast(*void)(*instance.angularMomentumChange)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleConcurrentUpdateData.angularMomentumChange)) == 12, "PxVehicleConcurrentUpdateData.angularMomentumChange has unexpected size % instead of 12", size_of(type_of(PxVehicleConcurrentUpdateData.angularMomentumChange)));
        assert(((cast(*void)(*instance.staySleeping)) - cast(*void)(*instance)) == 36, "PxVehicleConcurrentUpdateData.staySleeping has unexpected offset % instead of 36", ((cast(*void)(*instance.staySleeping)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleConcurrentUpdateData.staySleeping)) == 1, "PxVehicleConcurrentUpdateData.staySleeping has unexpected size % instead of 1", size_of(type_of(PxVehicleConcurrentUpdateData.staySleeping)));
        assert(((cast(*void)(*instance.wakeup)) - cast(*void)(*instance)) == 37, "PxVehicleConcurrentUpdateData.wakeup has unexpected offset % instead of 37", ((cast(*void)(*instance.wakeup)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleConcurrentUpdateData.wakeup)) == 1, "PxVehicleConcurrentUpdateData.wakeup has unexpected size % instead of 1", size_of(type_of(PxVehicleConcurrentUpdateData.wakeup)));
        assert(size_of(PxVehicleConcurrentUpdateData) == 40, "PxVehicleConcurrentUpdateData has size % instead of 40", size_of(PxVehicleConcurrentUpdateData));
    }

    /**
    \brief Data structure describing configuration data of a vehicle with up to PX_MAX_NB_WHEELS driven equally through the differential. The vehicle has an
    engine, clutch, gears, autobox, differential.
    @see PxVehicleDriveSimData
    */
    PxVehicleDriveSimDataNW :: struct {
        #as using pxvehicledrivesimdata: PxVehicleDriveSimData;

        Constructor :: (this: *PxVehicleDriveSimDataNW) -> void #cpp_method #foreign physx_lib "??0PxVehicleDriveSimDataNW@physx@@QEAA@XZ";

        /**
        \brief Return the data describing the differential of a vehicle with up to PX_MAX_NB_WHEELS driven wheels.
        */
        getDiffData :: (this: *PxVehicleDriveSimDataNW) -> *PxVehicleDifferentialNWData #cpp_method #foreign physx_lib "?getDiffData@PxVehicleDriveSimDataNW@physx@@QEBAAEBVPxVehicleDifferentialNWData@2@XZ";

        /**
        \brief Differential simulation data
        @see setDiffData, getDiffData
        */
        mDiff: PxVehicleDifferentialNWData;

        //serialization
        Constructor :: (this: *PxVehicleDriveSimDataNW, unknown0: PxEMPTY) -> void #cpp_method #foreign physx_lib "??0PxVehicleDriveSimDataNW@physx@@QEAA@W4PxEMPTY@1@@Z";
    }
    #run {if true then return;
        assert(size_of(type_of(PxVehicleDriveSimDataNW.pxvehicledrivesimdata)) == 528, "PxVehicleDriveSimDataNW.pxvehicledrivesimdata has unexpected size % instead of 528", size_of(type_of(PxVehicleDriveSimDataNW.pxvehicledrivesimdata)));
        instance: PxVehicleDriveSimDataNW;
        assert(((cast(*void)(*instance.mDiff)) - cast(*void)(*instance)) == 528, "PxVehicleDriveSimDataNW.mDiff has unexpected offset % instead of 528", ((cast(*void)(*instance.mDiff)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleDriveSimDataNW.mDiff)) == 16, "PxVehicleDriveSimDataNW.mDiff has unexpected size % instead of 16", size_of(type_of(PxVehicleDriveSimDataNW.mDiff)));
        assert(size_of(PxVehicleDriveSimDataNW) == 544, "PxVehicleDriveSimDataNW has size % instead of 544", size_of(PxVehicleDriveSimDataNW));
    }

    PxCompileTimeAssert_Dummy27 :: [1] u8;

    /**
    \brief The control inputs for a PxVehicleDriveNW.

    @see PxVehicleDriveDynData::setAnalogInput, PxVehicleDriveDynData::getAnalogInput
    */
    PxVehicleDriveNWControl :: struct {
        Enum :: enum s32 {
            ANALOG_INPUT_ACCEL           :: 0;
            ANALOG_INPUT_BRAKE           :: 1;
            ANALOG_INPUT_HANDBRAKE       :: 2;
            ANALOG_INPUT_STEER_LEFT      :: 3;
            ANALOG_INPUT_STEER_RIGHT     :: 4;
            MAX_NB_DRIVENW_ANALOG_INPUTS :: 5;

            eANALOG_INPUT_ACCEL           :: ANALOG_INPUT_ACCEL;
            eANALOG_INPUT_BRAKE           :: ANALOG_INPUT_BRAKE;
            eANALOG_INPUT_HANDBRAKE       :: ANALOG_INPUT_HANDBRAKE;
            eANALOG_INPUT_STEER_LEFT      :: ANALOG_INPUT_STEER_LEFT;
            eANALOG_INPUT_STEER_RIGHT     :: ANALOG_INPUT_STEER_RIGHT;
            eMAX_NB_DRIVENW_ANALOG_INPUTS :: MAX_NB_DRIVENW_ANALOG_INPUTS;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxVehicleDriveNWControl) == 1, "PxVehicleDriveNWControl has size % instead of 1", size_of(PxVehicleDriveNWControl));
    }

    /**
    \brief Data structure with instanced dynamics data and configuration data of a vehicle with up to PX_MAX_NB_WHEELS driven wheels.
    */
    PxVehicleDriveNW :: struct {
        #as using pxvehicledrive: PxVehicleDrive;

        /**
        \brief Simulation data that describes the configuration of the vehicle's drive model.
        @see setup, create
        */
        mDriveSimData: PxVehicleDriveSimDataNW;

        //serialization
        Constructor :: (this: *PxVehicleDriveNW, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_lib "??0PxVehicleDriveNW@physx@@QEAA@V?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.

        virtual_Destructor :: (this: *PxVehicleDriveNW, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_lib "??1PxVehicleDriveNW@physx@@UEAA@XZ";

        virtual_getConcreteTypeName :: (this: *PxVehicleDriveNW) -> *u8 #cpp_method #foreign physx_lib "?getConcreteTypeName@PxVehicleDriveNW@physx@@UEBAPEBDXZ";
        virtual_isKindOf :: (this: *PxVehicleDriveNW, name: *u8) -> bool #cpp_method #foreign physx_lib "?isKindOf@PxVehicleDriveNW@physx@@UEBA_NPEBD@Z";
    }
    #run {if true then return;
        assert(size_of(type_of(PxVehicleDriveNW.pxvehicledrive)) == 288, "PxVehicleDriveNW.pxvehicledrive has unexpected size % instead of 288", size_of(type_of(PxVehicleDriveNW.pxvehicledrive)));
        instance: PxVehicleDriveNW;
        assert(((cast(*void)(*instance.mDriveSimData)) - cast(*void)(*instance)) == 288, "PxVehicleDriveNW.mDriveSimData has unexpected offset % instead of 288", ((cast(*void)(*instance.mDriveSimData)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleDriveNW.mDriveSimData)) == 544, "PxVehicleDriveNW.mDriveSimData has unexpected size % instead of 544", size_of(type_of(PxVehicleDriveNW.mDriveSimData)));
        assert(size_of(PxVehicleDriveNW) == 832, "PxVehicleDriveNW has size % instead of 832", size_of(PxVehicleDriveNW));
    }

    PxCompileTimeAssert_Dummy28 :: [1] u8;

    /**
    \brief Used to produce smooth vehicle driving control values from key inputs.
    @see PxVehicle4WSmoothDigitalRawInputsAndSetAnalogInputs, PxVehicle4WSmoothAnalogRawInputsAndSetAnalogInputs
    */
    PxVehicleKeySmoothingData :: struct {
        /**
        \brief Rise rate of each analog value if digital value is 1
        */
        mRiseRates: [16] PxReal;

        /**
        \brief Fall rate of each analog value if digital value is 0
        */
        mFallRates: [16] PxReal;
    }
    #run {if true then return;
        instance: PxVehicleKeySmoothingData;
        assert(((cast(*void)(*instance.mRiseRates)) - cast(*void)(*instance)) == 0, "PxVehicleKeySmoothingData.mRiseRates has unexpected offset % instead of 0", ((cast(*void)(*instance.mRiseRates)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleKeySmoothingData.mRiseRates)) == 64, "PxVehicleKeySmoothingData.mRiseRates has unexpected size % instead of 64", size_of(type_of(PxVehicleKeySmoothingData.mRiseRates)));
        assert(((cast(*void)(*instance.mFallRates)) - cast(*void)(*instance)) == 64, "PxVehicleKeySmoothingData.mFallRates has unexpected offset % instead of 64", ((cast(*void)(*instance.mFallRates)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleKeySmoothingData.mFallRates)) == 64, "PxVehicleKeySmoothingData.mFallRates has unexpected size % instead of 64", size_of(type_of(PxVehicleKeySmoothingData.mFallRates)));
        assert(size_of(PxVehicleKeySmoothingData) == 128, "PxVehicleKeySmoothingData has size % instead of 128", size_of(PxVehicleKeySmoothingData));
    }

    PxCompileTimeAssert_Dummy29 :: [1] u8;

    /**
    \brief Used to produce smooth analog vehicle control values from analog inputs.
    @see PxVehicleDrive4WSmoothDigitalRawInputsAndSetAnalogInputs, PxVehicleDrive4WSmoothAnalogRawInputsAndSetAnalogInputs
    */
    PxVehiclePadSmoothingData :: struct {
        /**
        \brief Rise rate of each analog value from previous value towards target if target>previous
        */
        mRiseRates: [16] PxReal;

        /**
        \brief Rise rate of each analog value from previous value towards target if target<previous
        */
        mFallRates: [16] PxReal;
    }
    #run {if true then return;
        instance: PxVehiclePadSmoothingData;
        assert(((cast(*void)(*instance.mRiseRates)) - cast(*void)(*instance)) == 0, "PxVehiclePadSmoothingData.mRiseRates has unexpected offset % instead of 0", ((cast(*void)(*instance.mRiseRates)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehiclePadSmoothingData.mRiseRates)) == 64, "PxVehiclePadSmoothingData.mRiseRates has unexpected size % instead of 64", size_of(type_of(PxVehiclePadSmoothingData.mRiseRates)));
        assert(((cast(*void)(*instance.mFallRates)) - cast(*void)(*instance)) == 64, "PxVehiclePadSmoothingData.mFallRates has unexpected offset % instead of 64", ((cast(*void)(*instance.mFallRates)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehiclePadSmoothingData.mFallRates)) == 64, "PxVehiclePadSmoothingData.mFallRates has unexpected size % instead of 64", size_of(type_of(PxVehiclePadSmoothingData.mFallRates)));
        assert(size_of(PxVehiclePadSmoothingData) == 128, "PxVehiclePadSmoothingData has size % instead of 128", size_of(PxVehiclePadSmoothingData));
    }

    PxCompileTimeAssert_Dummy30 :: [1] u8;

    /**
    \brief Used to produce smooth vehicle driving control values from analog and digital inputs.
    @see PxVehicleDrive4WSmoothDigitalRawInputsAndSetAnalogInputs, PxVehicleDrive4WSmoothAnalogRawInputsAndSetAnalogInputs
    */
    PxVehicleDrive4WRawInputData :: struct {
        vtable: *PxVehicleDrive4WRawInputData_VTable;
        Constructor :: (this: *PxVehicleDrive4WRawInputData) -> void #cpp_method #foreign physx_lib "??0PxVehicleDrive4WRawInputData@physx@@QEAA@XZ";

        /**
        \brief Record if the accel button has been pressed on keyboard.
        \param[in] accelKeyPressed is true if the accelerator key has been pressed and false otherwise.
        */
        setDigitalAccel :: (this: *PxVehicleDrive4WRawInputData, accelKeyPressed: bool) -> void #cpp_method #foreign physx_lib "?setDigitalAccel@PxVehicleDrive4WRawInputData@physx@@QEAAX_N@Z";

        /**
        \brief Record if the brake button has been pressed on keyboard.
        \param[in] brakeKeyPressed is true if the brake key has been pressed and false otherwise.
        */
        setDigitalBrake :: (this: *PxVehicleDrive4WRawInputData, brakeKeyPressed: bool) -> void #cpp_method #foreign physx_lib "?setDigitalBrake@PxVehicleDrive4WRawInputData@physx@@QEAAX_N@Z";

        /**
        \brief Record if the handbrake button has been pressed on keyboard.
        \param[in] handbrakeKeyPressed is true if the handbrake key has been pressed and false otherwise.
        */
        setDigitalHandbrake :: (this: *PxVehicleDrive4WRawInputData, handbrakeKeyPressed: bool) -> void #cpp_method #foreign physx_lib "?setDigitalHandbrake@PxVehicleDrive4WRawInputData@physx@@QEAAX_N@Z";

        /**
        \brief Record if the left steer button has been pressed on keyboard.
        \param[in] steerLeftKeyPressed is true if the steer-left key has been pressed and false otherwise.
        */
        setDigitalSteerLeft :: (this: *PxVehicleDrive4WRawInputData, steerLeftKeyPressed: bool) -> void #cpp_method #foreign physx_lib "?setDigitalSteerLeft@PxVehicleDrive4WRawInputData@physx@@QEAAX_N@Z";

        /**
        \brief Record if the right steer button has been pressed on keyboard.
        \param[in] steerRightKeyPressed is true if the steer-right key has been pressed and false otherwise.
        */
        setDigitalSteerRight :: (this: *PxVehicleDrive4WRawInputData, steerRightKeyPressed: bool) -> void #cpp_method #foreign physx_lib "?setDigitalSteerRight@PxVehicleDrive4WRawInputData@physx@@QEAAX_N@Z";

        /**
        \brief Return if the accel button has been pressed on keyboard.
        \return True if the accel button has been pressed, false otherwise.
        */
        getDigitalAccel :: (this: *PxVehicleDrive4WRawInputData) -> bool #cpp_method #foreign physx_lib "?getDigitalAccel@PxVehicleDrive4WRawInputData@physx@@QEBA_NXZ";

        /**
        \brief Return if the brake button has been pressed on keyboard.
        \return True if the brake button has been pressed, false otherwise.
        */
        getDigitalBrake :: (this: *PxVehicleDrive4WRawInputData) -> bool #cpp_method #foreign physx_lib "?getDigitalBrake@PxVehicleDrive4WRawInputData@physx@@QEBA_NXZ";

        /**
        \brief Return if the handbrake button has been pressed on keyboard.
        \return True if the handbrake button has been pressed, false otherwise.
        */
        getDigitalHandbrake :: (this: *PxVehicleDrive4WRawInputData) -> bool #cpp_method #foreign physx_lib "?getDigitalHandbrake@PxVehicleDrive4WRawInputData@physx@@QEBA_NXZ";

        /**
        \brief Return if the left steer button has been pressed on keyboard.
        \return True if the steer-left button has been pressed, false otherwise.
        */
        getDigitalSteerLeft :: (this: *PxVehicleDrive4WRawInputData) -> bool #cpp_method #foreign physx_lib "?getDigitalSteerLeft@PxVehicleDrive4WRawInputData@physx@@QEBA_NXZ";

        /**
        \brief Return if the right steer button has been pressed on keyboard.
        \return True if the steer-right button has been pressed, false otherwise.
        */
        getDigitalSteerRight :: (this: *PxVehicleDrive4WRawInputData) -> bool #cpp_method #foreign physx_lib "?getDigitalSteerRight@PxVehicleDrive4WRawInputData@physx@@QEBA_NXZ";

        /**
        \brief Set the analog accel value from the gamepad
        \param[in] accel is the analog accelerator pedal value in range(0,1) where 1 represents the pedal fully pressed and 0 represents the pedal in its rest state.
        */
        setAnalogAccel :: (this: *PxVehicleDrive4WRawInputData, accel: PxReal) -> void #cpp_method #foreign physx_lib "?setAnalogAccel@PxVehicleDrive4WRawInputData@physx@@QEAAXM@Z";

        /**
        \brief Set the analog brake value from the gamepad
        \param[in] brake is the analog brake pedal value in range(0,1) where 1 represents the pedal fully pressed and 0 represents the pedal in its rest state.
        */
        setAnalogBrake :: (this: *PxVehicleDrive4WRawInputData, brake: PxReal) -> void #cpp_method #foreign physx_lib "?setAnalogBrake@PxVehicleDrive4WRawInputData@physx@@QEAAXM@Z";

        /**
        \brief Set the analog handbrake value from the gamepad
        \param[in] handbrake is the analog handbrake value in range(0,1) where 1 represents the handbrake fully engaged and 0 represents the handbrake in its rest state.
        */
        setAnalogHandbrake :: (this: *PxVehicleDrive4WRawInputData, handbrake: PxReal) -> void #cpp_method #foreign physx_lib "?setAnalogHandbrake@PxVehicleDrive4WRawInputData@physx@@QEAAXM@Z";

        /**
        \brief Set the analog steer value from the gamepad
        \param[in] steer is the analog steer value in range(-1,1) where -1 represents the steering wheel at left lock and +1 represents the steering wheel at right lock.
        */
        setAnalogSteer :: (this: *PxVehicleDrive4WRawInputData, steer: PxReal) -> void #cpp_method #foreign physx_lib "?setAnalogSteer@PxVehicleDrive4WRawInputData@physx@@QEAAXM@Z";

        /**
        \brief Return the analog accel value from the gamepad
        \return The analog accel value.
        */
        getAnalogAccel :: (this: *PxVehicleDrive4WRawInputData) -> PxReal #cpp_method #foreign physx_lib "?getAnalogAccel@PxVehicleDrive4WRawInputData@physx@@QEBAMXZ";

        /**
        \brief Return the analog brake value from the gamepad
        \return The analog brake value.
        */
        getAnalogBrake :: (this: *PxVehicleDrive4WRawInputData) -> PxReal #cpp_method #foreign physx_lib "?getAnalogBrake@PxVehicleDrive4WRawInputData@physx@@QEBAMXZ";

        /**
        \brief Return the analog handbrake value from the gamepad
        \return The analog handbrake value.
        */
        getAnalogHandbrake :: (this: *PxVehicleDrive4WRawInputData) -> PxReal #cpp_method #foreign physx_lib "?getAnalogHandbrake@PxVehicleDrive4WRawInputData@physx@@QEBAMXZ";

        /**
        \brief Return the analog steer value from the gamepad
        */
        getAnalogSteer :: (this: *PxVehicleDrive4WRawInputData) -> PxReal #cpp_method #foreign physx_lib "?getAnalogSteer@PxVehicleDrive4WRawInputData@physx@@QEBAMXZ";

        /**
        \brief Record if the gearup button has been pressed on keyboard or gamepad
        \param[in] gearUpKeyPressed is true if the gear-up button has been pressed, false otherwise.
        */
        setGearUp :: (this: *PxVehicleDrive4WRawInputData, gearUpKeyPressed: bool) -> void #cpp_method #foreign physx_lib "?setGearUp@PxVehicleDrive4WRawInputData@physx@@QEAAX_N@Z";

        /**
        \brief Record if the geardown button has been pressed on keyboard or gamepad
        \param[in] gearDownKeyPressed is true if the gear-down button has been pressed, false otherwise.
        */
        setGearDown :: (this: *PxVehicleDrive4WRawInputData, gearDownKeyPressed: bool) -> void #cpp_method #foreign physx_lib "?setGearDown@PxVehicleDrive4WRawInputData@physx@@QEAAX_N@Z";

        /**
        \brief Return if the gearup button has been pressed on keyboard or gamepad
        \return The value of the gear-up button.
        */
        getGearUp :: (this: *PxVehicleDrive4WRawInputData) -> bool #cpp_method #foreign physx_lib "?getGearUp@PxVehicleDrive4WRawInputData@physx@@QEBA_NXZ";

        /**
        \brief Record if the geardown button has been pressed on keyboard or gamepad
        \return The value of the gear-down button.
        */
        getGearDown :: (this: *PxVehicleDrive4WRawInputData) -> bool #cpp_method #foreign physx_lib "?getGearDown@PxVehicleDrive4WRawInputData@physx@@QEBA_NXZ";

        mRawDigitalInputs: [5] bool;
        mRawAnalogInputs:  [5] PxReal;

        mGearUp:           bool;
        mGearDown:         bool;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.

        virtual_Destructor :: (this: *PxVehicleDrive4WRawInputData, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_lib "??1PxVehicleDrive4WRawInputData@physx@@UEAA@XZ";
    }
    PxVehicleDrive4WRawInputData_VTable :: struct #type_info_none {
        Destructor: (this: *PxVehicleDrive4WRawInputData, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }
    PxVehicleDrive4WRawInputData_Destructor :: inline (this: *PxVehicleDrive4WRawInputData, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxVehicleDrive4WRawInputData) -> *PxVehicleDrive4WRawInputData_VTable { return obj.vtable; }

    #run {if true then return;
        instance: PxVehicleDrive4WRawInputData;
        assert(((cast(*void)(*instance.mRawDigitalInputs)) - cast(*void)(*instance)) == 8, "PxVehicleDrive4WRawInputData.mRawDigitalInputs has unexpected offset % instead of 8", ((cast(*void)(*instance.mRawDigitalInputs)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleDrive4WRawInputData.mRawDigitalInputs)) == 5, "PxVehicleDrive4WRawInputData.mRawDigitalInputs has unexpected size % instead of 5", size_of(type_of(PxVehicleDrive4WRawInputData.mRawDigitalInputs)));
        assert(((cast(*void)(*instance.mRawAnalogInputs)) - cast(*void)(*instance)) == 16, "PxVehicleDrive4WRawInputData.mRawAnalogInputs has unexpected offset % instead of 16", ((cast(*void)(*instance.mRawAnalogInputs)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleDrive4WRawInputData.mRawAnalogInputs)) == 20, "PxVehicleDrive4WRawInputData.mRawAnalogInputs has unexpected size % instead of 20", size_of(type_of(PxVehicleDrive4WRawInputData.mRawAnalogInputs)));
        assert(((cast(*void)(*instance.mGearUp)) - cast(*void)(*instance)) == 36, "PxVehicleDrive4WRawInputData.mGearUp has unexpected offset % instead of 36", ((cast(*void)(*instance.mGearUp)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleDrive4WRawInputData.mGearUp)) == 1, "PxVehicleDrive4WRawInputData.mGearUp has unexpected size % instead of 1", size_of(type_of(PxVehicleDrive4WRawInputData.mGearUp)));
        assert(((cast(*void)(*instance.mGearDown)) - cast(*void)(*instance)) == 37, "PxVehicleDrive4WRawInputData.mGearDown has unexpected offset % instead of 37", ((cast(*void)(*instance.mGearDown)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleDrive4WRawInputData.mGearDown)) == 1, "PxVehicleDrive4WRawInputData.mGearDown has unexpected size % instead of 1", size_of(type_of(PxVehicleDrive4WRawInputData.mGearDown)));
        assert(size_of(PxVehicleDrive4WRawInputData) == 40, "PxVehicleDrive4WRawInputData has size % instead of 40", size_of(PxVehicleDrive4WRawInputData));
    }

    /**
    \brief Used to produce smooth vehicle driving control values from analog and digital inputs.
    @see PxVehicleDriveNWSmoothDigitalRawInputsAndSetAnalogInputs, PxVehicleDriveNWSmoothAnalogRawInputsAndSetAnalogInputs
    */
    PxVehicleDriveNWRawInputData :: struct {
        #as using pxvehicledrive4wrawinputdata: PxVehicleDrive4WRawInputData;

        Constructor :: (this: *PxVehicleDriveNWRawInputData) -> void #cpp_method #foreign physx_lib "??0PxVehicleDriveNWRawInputData@physx@@QEAA@XZ";

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.
        virtual_Destructor :: (this: *PxVehicleDriveNWRawInputData, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_lib "??1PxVehicleDriveNWRawInputData@physx@@UEAA@XZ";
    }
    #run {if true then return;
        assert(size_of(type_of(PxVehicleDriveNWRawInputData.pxvehicledrive4wrawinputdata)) == 40, "PxVehicleDriveNWRawInputData.pxvehicledrive4wrawinputdata has unexpected size % instead of 40", size_of(type_of(PxVehicleDriveNWRawInputData.pxvehicledrive4wrawinputdata)));
        assert(size_of(PxVehicleDriveNWRawInputData) == 40, "PxVehicleDriveNWRawInputData has size % instead of 40", size_of(PxVehicleDriveNWRawInputData));
    }

    /**
    \brief Used to produce smooth analog tank control values from analog and digital inputs.
    @see PxVehicleDriveTankSmoothDigitalRawInputsAndSetAnalogInputs, PxVehicleDriveTankSmoothAnalogRawInputsAndSetAnalogInputs
    */
    PxVehicleDriveTankRawInputData :: struct {
        Constructor :: (this: *PxVehicleDriveTankRawInputData, mode: PxVehicleDriveTankControlModel.Enum) -> void #cpp_method #foreign physx_lib "??0PxVehicleDriveTankRawInputData@physx@@QEAA@W4Enum@PxVehicleDriveTankControlModel@1@@Z";

        Destructor :: (this: *PxVehicleDriveTankRawInputData) -> void #cpp_method #foreign physx_lib "??1PxVehicleDriveTankRawInputData@physx@@QEAA@XZ";

        /**
        \brief Return the drive model (eDRIVE_MODEL_SPECIAL or eDRIVE_MODEL_STANDARD)
        \return The chosen tank drive model.
        */
        getDriveModel :: (this: *PxVehicleDriveTankRawInputData) -> PxVehicleDriveTankControlModel.Enum #cpp_method #foreign physx_lib "?getDriveModel@PxVehicleDriveTankRawInputData@physx@@QEBA?AW4Enum@PxVehicleDriveTankControlModel@2@XZ";

        /**
        \brief Set if the accel button has been pressed on the keyboard
        \param[in] b is true if the digital accel button has been pressed, false otherwise.
        */
        setDigitalAccel :: (this: *PxVehicleDriveTankRawInputData, b: bool) -> void #cpp_method #foreign physx_lib "?setDigitalAccel@PxVehicleDriveTankRawInputData@physx@@QEAAX_N@Z";

        /**
        \brief Set if the left thrust button has been pressed on the keyboard
        \param[in] b is true if the digital left thrust button has been pressed, false otherwise.
        */
        setDigitalLeftThrust :: (this: *PxVehicleDriveTankRawInputData, b: bool) -> void #cpp_method #foreign physx_lib "?setDigitalLeftThrust@PxVehicleDriveTankRawInputData@physx@@QEAAX_N@Z";

        /**
        \brief Set if the right thrust button has been pressed on the keyboard
        \param[in] b is true if the digital right thrust button has been pressed, false otherwise.
        */
        setDigitalRightThrust :: (this: *PxVehicleDriveTankRawInputData, b: bool) -> void #cpp_method #foreign physx_lib "?setDigitalRightThrust@PxVehicleDriveTankRawInputData@physx@@QEAAX_N@Z";

        /**
        \brief Set if the left brake button has been pressed on the keyboard
        \param[in] b is true if the digital left brake button has been pressed, false otherwise.
        */
        setDigitalLeftBrake :: (this: *PxVehicleDriveTankRawInputData, b: bool) -> void #cpp_method #foreign physx_lib "?setDigitalLeftBrake@PxVehicleDriveTankRawInputData@physx@@QEAAX_N@Z";

        /**
        \brief Set if the right brake button has been pressed on the keyboard
        \param[in] b is true if the digital right brake button has been pressed, false otherwise.
        */
        setDigitalRightBrake :: (this: *PxVehicleDriveTankRawInputData, b: bool) -> void #cpp_method #foreign physx_lib "?setDigitalRightBrake@PxVehicleDriveTankRawInputData@physx@@QEAAX_N@Z";

        /**
        \brief Return if the accel button has been pressed on the keyboard
        \return True if the accel button has been pressed, false otherwise.
        */
        getDigitalAccel :: (this: *PxVehicleDriveTankRawInputData) -> bool #cpp_method #foreign physx_lib "?getDigitalAccel@PxVehicleDriveTankRawInputData@physx@@QEBA_NXZ";

        /**
        \brief Return if the left thrust button has been pressed on the keyboard
        \return True if the left thrust button has been pressed, false otherwise.
        */
        getDigitalLeftThrust :: (this: *PxVehicleDriveTankRawInputData) -> bool #cpp_method #foreign physx_lib "?getDigitalLeftThrust@PxVehicleDriveTankRawInputData@physx@@QEBA_NXZ";

        /**
        \brief Return if the right thrust button has been pressed on the keyboard
        \return True if the right thrust button has been pressed, false otherwise.
        */
        getDigitalRightThrust :: (this: *PxVehicleDriveTankRawInputData) -> bool #cpp_method #foreign physx_lib "?getDigitalRightThrust@PxVehicleDriveTankRawInputData@physx@@QEBA_NXZ";

        /**
        \brief Return if the left brake button has been pressed on the keyboard
        \return True if the left brake button has been pressed, false otherwise.
        */
        getDigitalLeftBrake :: (this: *PxVehicleDriveTankRawInputData) -> bool #cpp_method #foreign physx_lib "?getDigitalLeftBrake@PxVehicleDriveTankRawInputData@physx@@QEBA_NXZ";

        /**
        \brief Return if the right brake button has been pressed on the keyboard
        \return True if the right brake button has been pressed, false otherwise.
        */
        getDigitalRightBrake :: (this: *PxVehicleDriveTankRawInputData) -> bool #cpp_method #foreign physx_lib "?getDigitalRightBrake@PxVehicleDriveTankRawInputData@physx@@QEBA_NXZ";

        /**
        \brief Set the analog accel value from the gamepad
        \param[in] accel is a value in range (0,1) where 1 represents the accelerator pedal fully pressed and 0 represents the pedal in its rest state.
        In range (0,1).
        */
        setAnalogAccel :: (this: *PxVehicleDriveTankRawInputData, accel: PxF32) -> void #cpp_method #foreign physx_lib "?setAnalogAccel@PxVehicleDriveTankRawInputData@physx@@QEAAXM@Z";

        /**
        \brief Set the analog left thrust value from the gamepad
        \param[in] leftThrust represents the state of the left stick.
        \note In range (0,1) for standard mode (eSTANDARD), in range (-1,1) for special mode (eSPECIAL)
        */
        setAnalogLeftThrust :: (this: *PxVehicleDriveTankRawInputData, leftThrust: PxF32) -> void #cpp_method #foreign physx_lib "?setAnalogLeftThrust@PxVehicleDriveTankRawInputData@physx@@QEAAXM@Z";

        /**
        \brief Set the analog right thrust value from the gamepad
        \param[in] rightThrust represents the state of the right stick.
        \note In range (0,1) for standard mode (eSTANDARD), in range (-1,1) for special mode (eSPECIAL)
        */
        setAnalogRightThrust :: (this: *PxVehicleDriveTankRawInputData, rightThrust: PxF32) -> void #cpp_method #foreign physx_lib "?setAnalogRightThrust@PxVehicleDriveTankRawInputData@physx@@QEAAXM@Z";

        /**
        \brief Set the analog left brake value from the gamepad
        \param[in] leftBrake is a value in range (0,1) where 1 represents the left brake pedal fully pressed and 0 represents the left brake pedal in its rest state.
        \note In range (0,1).
        */
        setAnalogLeftBrake :: (this: *PxVehicleDriveTankRawInputData, leftBrake: PxF32) -> void #cpp_method #foreign physx_lib "?setAnalogLeftBrake@PxVehicleDriveTankRawInputData@physx@@QEAAXM@Z";

        /**
        \brief Set the analog right brake value from the gamepad
        \param[in] rightBrake is a value in range (0,1) where 1 represents the right brake pedal fully pressed and 0 represents the right brake pedal in its rest state.
        \note In range (0,1).
        */
        setAnalogRightBrake :: (this: *PxVehicleDriveTankRawInputData, rightBrake: PxF32) -> void #cpp_method #foreign physx_lib "?setAnalogRightBrake@PxVehicleDriveTankRawInputData@physx@@QEAAXM@Z";

        /**
        \brief Return the analog accel value from the gamepad
        \return The analog accel value.
        */
        getAnalogAccel :: (this: *PxVehicleDriveTankRawInputData) -> PxF32 #cpp_method #foreign physx_lib "?getAnalogAccel@PxVehicleDriveTankRawInputData@physx@@QEBAMXZ";

        /**
        \brief Return the analog left thrust value from the gamepad
        \return The analog left thrust value.
        */
        getAnalogLeftThrust :: (this: *PxVehicleDriveTankRawInputData) -> PxF32 #cpp_method #foreign physx_lib "?getAnalogLeftThrust@PxVehicleDriveTankRawInputData@physx@@QEBAMXZ";

        /**
        \brief Return the analog right thrust value from the gamepad
        \return The analog right thrust value.
        */
        getAnalogRightThrust :: (this: *PxVehicleDriveTankRawInputData) -> PxF32 #cpp_method #foreign physx_lib "?getAnalogRightThrust@PxVehicleDriveTankRawInputData@physx@@QEBAMXZ";

        /**
        \brief Return the analog left brake value from the gamepad
        \return The analog left brake value.
        */
        getAnalogLeftBrake :: (this: *PxVehicleDriveTankRawInputData) -> PxF32 #cpp_method #foreign physx_lib "?getAnalogLeftBrake@PxVehicleDriveTankRawInputData@physx@@QEBAMXZ";

        /**
        \brief Return the analog right brake value from the gamepad
        \return The analog right brake value.
        */
        getAnalogRightBrake :: (this: *PxVehicleDriveTankRawInputData) -> PxF32 #cpp_method #foreign physx_lib "?getAnalogRightBrake@PxVehicleDriveTankRawInputData@physx@@QEBAMXZ";

        /**
        \brief Record if the gear-up button has been pressed on keyboard or gamepad
        \param[in] gearUp is true if the gear-up button has been pressed, false otherwise.
        */
        setGearUp :: (this: *PxVehicleDriveTankRawInputData, gearUp: bool) -> void #cpp_method #foreign physx_lib "?setGearUp@PxVehicleDriveTankRawInputData@physx@@QEAAX_N@Z";

        /**
        \brief Record if the gear-down button has been pressed on keyboard or gamepad
        \param[in] gearDown is true if the gear-down button has been pressed, false otherwise.
        */
        setGearDown :: (this: *PxVehicleDriveTankRawInputData, gearDown: bool) -> void #cpp_method #foreign physx_lib "?setGearDown@PxVehicleDriveTankRawInputData@physx@@QEAAX_N@Z";

        /**
        \brief Return if the gear-up button has been pressed on keyboard or gamepad
        \return True if the gear-up button has been pressed, false otherwise.
        */
        getGearUp :: (this: *PxVehicleDriveTankRawInputData) -> bool #cpp_method #foreign physx_lib "?getGearUp@PxVehicleDriveTankRawInputData@physx@@QEBA_NXZ";

        /**
        \brief Return if the gear-down button has been pressed on keyboard or gamepad
        \return True if the gear-down button has been pressed, false otherwise.
        */
        getGearDown :: (this: *PxVehicleDriveTankRawInputData) -> bool #cpp_method #foreign physx_lib "?getGearDown@PxVehicleDriveTankRawInputData@physx@@QEBA_NXZ";

        mMode:             PxVehicleDriveTankControlModel.Enum;

        mRawAnalogInputs:  [5] PxReal;
        mRawDigitalInputs: [5] bool;

        mGearUp:           bool;
        mGearDown:         bool;
    }
    #run {if true then return;
        instance: PxVehicleDriveTankRawInputData;
        assert(((cast(*void)(*instance.mMode)) - cast(*void)(*instance)) == 0, "PxVehicleDriveTankRawInputData.mMode has unexpected offset % instead of 0", ((cast(*void)(*instance.mMode)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleDriveTankRawInputData.mMode)) == 4, "PxVehicleDriveTankRawInputData.mMode has unexpected size % instead of 4", size_of(type_of(PxVehicleDriveTankRawInputData.mMode)));
        assert(((cast(*void)(*instance.mRawAnalogInputs)) - cast(*void)(*instance)) == 4, "PxVehicleDriveTankRawInputData.mRawAnalogInputs has unexpected offset % instead of 4", ((cast(*void)(*instance.mRawAnalogInputs)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleDriveTankRawInputData.mRawAnalogInputs)) == 20, "PxVehicleDriveTankRawInputData.mRawAnalogInputs has unexpected size % instead of 20", size_of(type_of(PxVehicleDriveTankRawInputData.mRawAnalogInputs)));
        assert(((cast(*void)(*instance.mRawDigitalInputs)) - cast(*void)(*instance)) == 24, "PxVehicleDriveTankRawInputData.mRawDigitalInputs has unexpected offset % instead of 24", ((cast(*void)(*instance.mRawDigitalInputs)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleDriveTankRawInputData.mRawDigitalInputs)) == 5, "PxVehicleDriveTankRawInputData.mRawDigitalInputs has unexpected size % instead of 5", size_of(type_of(PxVehicleDriveTankRawInputData.mRawDigitalInputs)));
        assert(((cast(*void)(*instance.mGearUp)) - cast(*void)(*instance)) == 29, "PxVehicleDriveTankRawInputData.mGearUp has unexpected offset % instead of 29", ((cast(*void)(*instance.mGearUp)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleDriveTankRawInputData.mGearUp)) == 1, "PxVehicleDriveTankRawInputData.mGearUp has unexpected size % instead of 1", size_of(type_of(PxVehicleDriveTankRawInputData.mGearUp)));
        assert(((cast(*void)(*instance.mGearDown)) - cast(*void)(*instance)) == 30, "PxVehicleDriveTankRawInputData.mGearDown has unexpected offset % instead of 30", ((cast(*void)(*instance.mGearDown)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleDriveTankRawInputData.mGearDown)) == 1, "PxVehicleDriveTankRawInputData.mGearDown has unexpected size % instead of 1", size_of(type_of(PxVehicleDriveTankRawInputData.mGearDown)));
        assert(size_of(PxVehicleDriveTankRawInputData) == 32, "PxVehicleDriveTankRawInputData has size % instead of 32", size_of(PxVehicleDriveTankRawInputData));
    }

    /**
    \brief Used by PxVehicleCopyDynamicsData
    @see PxVehicleCopyDynamicsData
    */
    PxVehicleCopyDynamicsMap :: struct {
        Constructor :: (this: *PxVehicleCopyDynamicsMap) -> void #cpp_method #foreign physx_lib "??0PxVehicleCopyDynamicsMap@physx@@QEAA@XZ";

        sourceWheelIds: [20] PxU8;
        targetWheelIds: [20] PxU8;
    }
    #run {if true then return;
        instance: PxVehicleCopyDynamicsMap;
        assert(((cast(*void)(*instance.sourceWheelIds)) - cast(*void)(*instance)) == 0, "PxVehicleCopyDynamicsMap.sourceWheelIds has unexpected offset % instead of 0", ((cast(*void)(*instance.sourceWheelIds)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleCopyDynamicsMap.sourceWheelIds)) == 20, "PxVehicleCopyDynamicsMap.sourceWheelIds has unexpected size % instead of 20", size_of(type_of(PxVehicleCopyDynamicsMap.sourceWheelIds)));
        assert(((cast(*void)(*instance.targetWheelIds)) - cast(*void)(*instance)) == 20, "PxVehicleCopyDynamicsMap.targetWheelIds has unexpected offset % instead of 20", ((cast(*void)(*instance.targetWheelIds)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleCopyDynamicsMap.targetWheelIds)) == 20, "PxVehicleCopyDynamicsMap.targetWheelIds has unexpected size % instead of 20", size_of(type_of(PxVehicleCopyDynamicsMap.targetWheelIds)));
        assert(size_of(PxVehicleCopyDynamicsMap) == 40, "PxVehicleCopyDynamicsMap has size % instead of 40", size_of(PxVehicleCopyDynamicsMap));
    }

    PxVehicleGraphDesc :: struct {
        /**
        \brief x-coord of graph centre.
        <b>Range:</b> (0,1)<br>
        */
        mPosX:            PxReal;

        /**
        \brief y-coord of graph centre.
        <b>Range:</b> (0,1)<br>
        */
        mPosY:            PxReal;

        /**
        \brief x-extents of graph (from mPosX-0.5f*mSizeX to mPosX+0.5f*mSizeX).
        <b>Range:</b> (0,1)<br>
        */
        mSizeX:           PxReal;

        /**
        \brief y-extents of graph (from mPosY-0.5f*mSizeY to mPosY+0.5f*mSizeY).
        <b>Range:</b> (0,1)<br>
        */
        mSizeY:           PxReal;

        /**
        \brief Background color of graph.
        */
        mBackgroundColor: PxVec3;

        /**
        \brief Alpha value of background color.
        */
        mAlpha:           PxReal;
    }
    #run {if true then return;
        instance: PxVehicleGraphDesc;
        assert(((cast(*void)(*instance.mPosX)) - cast(*void)(*instance)) == 0, "PxVehicleGraphDesc.mPosX has unexpected offset % instead of 0", ((cast(*void)(*instance.mPosX)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleGraphDesc.mPosX)) == 4, "PxVehicleGraphDesc.mPosX has unexpected size % instead of 4", size_of(type_of(PxVehicleGraphDesc.mPosX)));
        assert(((cast(*void)(*instance.mPosY)) - cast(*void)(*instance)) == 4, "PxVehicleGraphDesc.mPosY has unexpected offset % instead of 4", ((cast(*void)(*instance.mPosY)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleGraphDesc.mPosY)) == 4, "PxVehicleGraphDesc.mPosY has unexpected size % instead of 4", size_of(type_of(PxVehicleGraphDesc.mPosY)));
        assert(((cast(*void)(*instance.mSizeX)) - cast(*void)(*instance)) == 8, "PxVehicleGraphDesc.mSizeX has unexpected offset % instead of 8", ((cast(*void)(*instance.mSizeX)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleGraphDesc.mSizeX)) == 4, "PxVehicleGraphDesc.mSizeX has unexpected size % instead of 4", size_of(type_of(PxVehicleGraphDesc.mSizeX)));
        assert(((cast(*void)(*instance.mSizeY)) - cast(*void)(*instance)) == 12, "PxVehicleGraphDesc.mSizeY has unexpected offset % instead of 12", ((cast(*void)(*instance.mSizeY)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleGraphDesc.mSizeY)) == 4, "PxVehicleGraphDesc.mSizeY has unexpected size % instead of 4", size_of(type_of(PxVehicleGraphDesc.mSizeY)));
        assert(((cast(*void)(*instance.mBackgroundColor)) - cast(*void)(*instance)) == 16, "PxVehicleGraphDesc.mBackgroundColor has unexpected offset % instead of 16", ((cast(*void)(*instance.mBackgroundColor)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleGraphDesc.mBackgroundColor)) == 12, "PxVehicleGraphDesc.mBackgroundColor has unexpected size % instead of 12", size_of(type_of(PxVehicleGraphDesc.mBackgroundColor)));
        assert(((cast(*void)(*instance.mAlpha)) - cast(*void)(*instance)) == 28, "PxVehicleGraphDesc.mAlpha has unexpected offset % instead of 28", ((cast(*void)(*instance.mAlpha)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleGraphDesc.mAlpha)) == 4, "PxVehicleGraphDesc.mAlpha has unexpected size % instead of 4", size_of(type_of(PxVehicleGraphDesc.mAlpha)));
        assert(size_of(PxVehicleGraphDesc) == 32, "PxVehicleGraphDesc has size % instead of 32", size_of(PxVehicleGraphDesc));
    }

    PxVehicleGraphChannelDesc :: struct {
        /**
        \brief Data values less than mMinY will be clamped at mMinY.
        */
        mMinY:      PxReal;

        /**
        \brief Data values greater than mMaxY will be clamped at mMaxY.
        */
        mMaxY:      PxReal;

        /**
        \brief Data values greater than mMidY will be drawn with color mColorHigh.
        Data values less than mMidY will be drawn with color mColorLow.
        */
        mMidY:      PxReal;

        /**
        \brief Color used to render data values lower than mMidY.
        */
        mColorLow:  PxVec3;

        /**
        \brief Color used to render data values greater than mMidY.
        */
        mColorHigh: PxVec3;

        /**
        \brief String to describe data channel.
        */
        mTitle:     *u8;
    }
    #run {if true then return;
        instance: PxVehicleGraphChannelDesc;
        assert(((cast(*void)(*instance.mMinY)) - cast(*void)(*instance)) == 0, "PxVehicleGraphChannelDesc.mMinY has unexpected offset % instead of 0", ((cast(*void)(*instance.mMinY)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleGraphChannelDesc.mMinY)) == 4, "PxVehicleGraphChannelDesc.mMinY has unexpected size % instead of 4", size_of(type_of(PxVehicleGraphChannelDesc.mMinY)));
        assert(((cast(*void)(*instance.mMaxY)) - cast(*void)(*instance)) == 4, "PxVehicleGraphChannelDesc.mMaxY has unexpected offset % instead of 4", ((cast(*void)(*instance.mMaxY)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleGraphChannelDesc.mMaxY)) == 4, "PxVehicleGraphChannelDesc.mMaxY has unexpected size % instead of 4", size_of(type_of(PxVehicleGraphChannelDesc.mMaxY)));
        assert(((cast(*void)(*instance.mMidY)) - cast(*void)(*instance)) == 8, "PxVehicleGraphChannelDesc.mMidY has unexpected offset % instead of 8", ((cast(*void)(*instance.mMidY)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleGraphChannelDesc.mMidY)) == 4, "PxVehicleGraphChannelDesc.mMidY has unexpected size % instead of 4", size_of(type_of(PxVehicleGraphChannelDesc.mMidY)));
        assert(((cast(*void)(*instance.mColorLow)) - cast(*void)(*instance)) == 12, "PxVehicleGraphChannelDesc.mColorLow has unexpected offset % instead of 12", ((cast(*void)(*instance.mColorLow)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleGraphChannelDesc.mColorLow)) == 12, "PxVehicleGraphChannelDesc.mColorLow has unexpected size % instead of 12", size_of(type_of(PxVehicleGraphChannelDesc.mColorLow)));
        assert(((cast(*void)(*instance.mColorHigh)) - cast(*void)(*instance)) == 24, "PxVehicleGraphChannelDesc.mColorHigh has unexpected offset % instead of 24", ((cast(*void)(*instance.mColorHigh)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleGraphChannelDesc.mColorHigh)) == 12, "PxVehicleGraphChannelDesc.mColorHigh has unexpected size % instead of 12", size_of(type_of(PxVehicleGraphChannelDesc.mColorHigh)));
        assert(((cast(*void)(*instance.mTitle)) - cast(*void)(*instance)) == 40, "PxVehicleGraphChannelDesc.mTitle has unexpected offset % instead of 40", ((cast(*void)(*instance.mTitle)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleGraphChannelDesc.mTitle)) == 8, "PxVehicleGraphChannelDesc.mTitle has unexpected size % instead of 8", size_of(type_of(PxVehicleGraphChannelDesc.mTitle)));
        assert(size_of(PxVehicleGraphChannelDesc) == 48, "PxVehicleGraphChannelDesc has size % instead of 48", size_of(PxVehicleGraphChannelDesc));
    }

    PxVehicleWheelGraphChannel :: struct {
        Enum :: enum s32 {
            JOUNCE                    :: 0;
            SUSPFORCE                 :: 1;
            TIRELOAD                  :: 2;
            NORMALIZED_TIRELOAD       :: 3;
            WHEEL_OMEGA               :: 4;
            TIRE_FRICTION             :: 5;
            TIRE_LONG_SLIP            :: 6;
            NORM_TIRE_LONG_FORCE      :: 7;
            TIRE_LAT_SLIP             :: 8;
            NORM_TIRE_LAT_FORCE       :: 9;
            NORM_TIRE_ALIGNING_MOMENT :: 10;
            MAX_NB_WHEEL_CHANNELS     :: 11;

            eJOUNCE                    :: JOUNCE;
            eSUSPFORCE                 :: SUSPFORCE;
            eTIRELOAD                  :: TIRELOAD;
            eNORMALIZED_TIRELOAD       :: NORMALIZED_TIRELOAD;
            eWHEEL_OMEGA               :: WHEEL_OMEGA;
            eTIRE_FRICTION             :: TIRE_FRICTION;
            eTIRE_LONG_SLIP            :: TIRE_LONG_SLIP;
            eNORM_TIRE_LONG_FORCE      :: NORM_TIRE_LONG_FORCE;
            eTIRE_LAT_SLIP             :: TIRE_LAT_SLIP;
            eNORM_TIRE_LAT_FORCE       :: NORM_TIRE_LAT_FORCE;
            eNORM_TIRE_ALIGNING_MOMENT :: NORM_TIRE_ALIGNING_MOMENT;
            eMAX_NB_WHEEL_CHANNELS     :: MAX_NB_WHEEL_CHANNELS;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxVehicleWheelGraphChannel) == 1, "PxVehicleWheelGraphChannel has size % instead of 1", size_of(PxVehicleWheelGraphChannel));
    }

    PxVehicleDriveGraphChannel :: struct {
        Enum :: enum s32 {
            ENGINE_REVS           :: 0;
            ENGINE_DRIVE_TORQUE   :: 1;
            CLUTCH_SLIP           :: 2;
            ACCEL_CONTROL         :: 3;
            BRAKE_CONTROL         :: 4;
            HANDBRAKE_CONTROL     :: 5;
            STEER_LEFT_CONTROL    :: 6;
            STEER_RIGHT_CONTROL   :: 7;
            GEAR_RATIO            :: 8;
            MAX_NB_DRIVE_CHANNELS :: 9;

            eENGINE_REVS           :: ENGINE_REVS;
            eENGINE_DRIVE_TORQUE   :: ENGINE_DRIVE_TORQUE;
            eCLUTCH_SLIP           :: CLUTCH_SLIP;
            eACCEL_CONTROL         :: ACCEL_CONTROL;
            eBRAKE_CONTROL         :: BRAKE_CONTROL;
            eHANDBRAKE_CONTROL     :: HANDBRAKE_CONTROL;
            eSTEER_LEFT_CONTROL    :: STEER_LEFT_CONTROL;
            eSTEER_RIGHT_CONTROL   :: STEER_RIGHT_CONTROL;
            eGEAR_RATIO            :: GEAR_RATIO;
            eMAX_NB_DRIVE_CHANNELS :: MAX_NB_DRIVE_CHANNELS;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxVehicleDriveGraphChannel) == 1, "PxVehicleDriveGraphChannel has size % instead of 1", size_of(PxVehicleDriveGraphChannel));
    }

    PxVehicleGraphType :: struct {
        Enum :: enum s32 {
            WHEEL :: 0;
            DRIVE :: 1;

            eWHEEL :: WHEEL;
            eDRIVE :: DRIVE;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxVehicleGraphType) == 1, "PxVehicleGraphType has size % instead of 1", size_of(PxVehicleGraphType));
    }

    PxVehicleGraph :: struct {
        anon_enum_6 :: enum s32 {
            eMAX_NB_SAMPLES :: 256;
        }

        anon_enum_7 :: enum s32 {
            eMAX_NB_TITLE_CHARS :: 256;
        }

        anon_enum_8 :: enum s32 {
            eMAX_NB_CHANNELS :: 12;
        }

        /**
        \brief Get the color of the graph background.  Used for rendering a graph.
        */
        getBackgroundColor :: (this: *PxVehicleGraph) -> *PxVec3 #cpp_method #foreign physx_lib "?getBackgroundColor@PxVehicleGraph@physx@@QEBAAEBVPxVec3@2@XZ";

        /**
        \brief Get the alpha transparency of the color of the graph background.  Used for rendering a graph.
        */
        getBackgroundAlpha :: (this: *PxVehicleGraph) -> PxReal #cpp_method #foreign physx_lib "?getBackgroundAlpha@PxVehicleGraph@physx@@QEBAMXZ";

        /**
        \brief Get the coordinates of the graph background.  Used for rendering a graph

        \param[out] xMin is the x-coord of the lower-left corner
        \param[out] yMin is the y-coord of the lower-left corner
        \param[out] xMax is the x-coord of the upper-right corner
        \param[out] yMax is the y-coord of the upper-right corner
        */
        getBackgroundCoords :: (this: *PxVehicleGraph, xMin: *PxReal, yMin: *PxReal, xMax: *PxReal, yMax: *PxReal) -> void #cpp_method #foreign physx_lib "?getBackgroundCoords@PxVehicleGraph@physx@@QEBAXAEAM000@Z";

        //Min and max of each sample.
        mChannelMinY:      [12] PxReal;
        mChannelMaxY:      [12] PxReal;

        //Discriminate between high and low values with different colors.
        mChannelMidY:      [12] PxReal;

        //Different colors for values than midY and less than midY.
        mChannelColorLow:  [12] PxVec3;
        mChannelColorHigh: [12] PxVec3;

        //Title of graph
        mChannelTitle:     [12] [256] u8;

        //Graph data.
        mChannelSamples:   [12] [256] PxReal;

        //Background color,alpha,coords
        mBackgroundColor:  PxVec3;
        mBackgroundAlpha:  PxReal;
        mBackgroundMinX:   PxReal;
        mBackgroundMaxX:   PxReal;
        mBackgroundMinY:   PxReal;
        mBackgroundMaxY:   PxReal;

        mSampleTide:       PxU32;

        mNbChannels:       PxU32;

        mPad:              [2] PxU32;
    }
    #run {if true then return;
        instance: PxVehicleGraph;
        assert(((cast(*void)(*instance.mChannelMinY)) - cast(*void)(*instance)) == 0, "PxVehicleGraph.mChannelMinY has unexpected offset % instead of 0", ((cast(*void)(*instance.mChannelMinY)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleGraph.mChannelMinY)) == 48, "PxVehicleGraph.mChannelMinY has unexpected size % instead of 48", size_of(type_of(PxVehicleGraph.mChannelMinY)));
        assert(((cast(*void)(*instance.mChannelMaxY)) - cast(*void)(*instance)) == 48, "PxVehicleGraph.mChannelMaxY has unexpected offset % instead of 48", ((cast(*void)(*instance.mChannelMaxY)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleGraph.mChannelMaxY)) == 48, "PxVehicleGraph.mChannelMaxY has unexpected size % instead of 48", size_of(type_of(PxVehicleGraph.mChannelMaxY)));
        assert(((cast(*void)(*instance.mChannelMidY)) - cast(*void)(*instance)) == 96, "PxVehicleGraph.mChannelMidY has unexpected offset % instead of 96", ((cast(*void)(*instance.mChannelMidY)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleGraph.mChannelMidY)) == 48, "PxVehicleGraph.mChannelMidY has unexpected size % instead of 48", size_of(type_of(PxVehicleGraph.mChannelMidY)));
        assert(((cast(*void)(*instance.mChannelColorLow)) - cast(*void)(*instance)) == 144, "PxVehicleGraph.mChannelColorLow has unexpected offset % instead of 144", ((cast(*void)(*instance.mChannelColorLow)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleGraph.mChannelColorLow)) == 144, "PxVehicleGraph.mChannelColorLow has unexpected size % instead of 144", size_of(type_of(PxVehicleGraph.mChannelColorLow)));
        assert(((cast(*void)(*instance.mChannelColorHigh)) - cast(*void)(*instance)) == 288, "PxVehicleGraph.mChannelColorHigh has unexpected offset % instead of 288", ((cast(*void)(*instance.mChannelColorHigh)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleGraph.mChannelColorHigh)) == 144, "PxVehicleGraph.mChannelColorHigh has unexpected size % instead of 144", size_of(type_of(PxVehicleGraph.mChannelColorHigh)));
        assert(((cast(*void)(*instance.mChannelTitle)) - cast(*void)(*instance)) == 432, "PxVehicleGraph.mChannelTitle has unexpected offset % instead of 432", ((cast(*void)(*instance.mChannelTitle)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleGraph.mChannelTitle)) == 3072, "PxVehicleGraph.mChannelTitle has unexpected size % instead of 3072", size_of(type_of(PxVehicleGraph.mChannelTitle)));
        assert(((cast(*void)(*instance.mChannelSamples)) - cast(*void)(*instance)) == 3504, "PxVehicleGraph.mChannelSamples has unexpected offset % instead of 3504", ((cast(*void)(*instance.mChannelSamples)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleGraph.mChannelSamples)) == 12288, "PxVehicleGraph.mChannelSamples has unexpected size % instead of 12288", size_of(type_of(PxVehicleGraph.mChannelSamples)));
        assert(((cast(*void)(*instance.mBackgroundColor)) - cast(*void)(*instance)) == 15792, "PxVehicleGraph.mBackgroundColor has unexpected offset % instead of 15792", ((cast(*void)(*instance.mBackgroundColor)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleGraph.mBackgroundColor)) == 12, "PxVehicleGraph.mBackgroundColor has unexpected size % instead of 12", size_of(type_of(PxVehicleGraph.mBackgroundColor)));
        assert(((cast(*void)(*instance.mBackgroundAlpha)) - cast(*void)(*instance)) == 15804, "PxVehicleGraph.mBackgroundAlpha has unexpected offset % instead of 15804", ((cast(*void)(*instance.mBackgroundAlpha)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleGraph.mBackgroundAlpha)) == 4, "PxVehicleGraph.mBackgroundAlpha has unexpected size % instead of 4", size_of(type_of(PxVehicleGraph.mBackgroundAlpha)));
        assert(((cast(*void)(*instance.mBackgroundMinX)) - cast(*void)(*instance)) == 15808, "PxVehicleGraph.mBackgroundMinX has unexpected offset % instead of 15808", ((cast(*void)(*instance.mBackgroundMinX)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleGraph.mBackgroundMinX)) == 4, "PxVehicleGraph.mBackgroundMinX has unexpected size % instead of 4", size_of(type_of(PxVehicleGraph.mBackgroundMinX)));
        assert(((cast(*void)(*instance.mBackgroundMaxX)) - cast(*void)(*instance)) == 15812, "PxVehicleGraph.mBackgroundMaxX has unexpected offset % instead of 15812", ((cast(*void)(*instance.mBackgroundMaxX)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleGraph.mBackgroundMaxX)) == 4, "PxVehicleGraph.mBackgroundMaxX has unexpected size % instead of 4", size_of(type_of(PxVehicleGraph.mBackgroundMaxX)));
        assert(((cast(*void)(*instance.mBackgroundMinY)) - cast(*void)(*instance)) == 15816, "PxVehicleGraph.mBackgroundMinY has unexpected offset % instead of 15816", ((cast(*void)(*instance.mBackgroundMinY)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleGraph.mBackgroundMinY)) == 4, "PxVehicleGraph.mBackgroundMinY has unexpected size % instead of 4", size_of(type_of(PxVehicleGraph.mBackgroundMinY)));
        assert(((cast(*void)(*instance.mBackgroundMaxY)) - cast(*void)(*instance)) == 15820, "PxVehicleGraph.mBackgroundMaxY has unexpected offset % instead of 15820", ((cast(*void)(*instance.mBackgroundMaxY)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleGraph.mBackgroundMaxY)) == 4, "PxVehicleGraph.mBackgroundMaxY has unexpected size % instead of 4", size_of(type_of(PxVehicleGraph.mBackgroundMaxY)));
        assert(((cast(*void)(*instance.mSampleTide)) - cast(*void)(*instance)) == 15824, "PxVehicleGraph.mSampleTide has unexpected offset % instead of 15824", ((cast(*void)(*instance.mSampleTide)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleGraph.mSampleTide)) == 4, "PxVehicleGraph.mSampleTide has unexpected size % instead of 4", size_of(type_of(PxVehicleGraph.mSampleTide)));
        assert(((cast(*void)(*instance.mNbChannels)) - cast(*void)(*instance)) == 15828, "PxVehicleGraph.mNbChannels has unexpected offset % instead of 15828", ((cast(*void)(*instance.mNbChannels)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleGraph.mNbChannels)) == 4, "PxVehicleGraph.mNbChannels has unexpected size % instead of 4", size_of(type_of(PxVehicleGraph.mNbChannels)));
        assert(((cast(*void)(*instance.mPad)) - cast(*void)(*instance)) == 15832, "PxVehicleGraph.mPad has unexpected offset % instead of 15832", ((cast(*void)(*instance.mPad)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleGraph.mPad)) == 8, "PxVehicleGraph.mPad has unexpected size % instead of 8", size_of(type_of(PxVehicleGraph.mPad)));
        assert(size_of(PxVehicleGraph) == 15840, "PxVehicleGraph has size % instead of 15840", size_of(PxVehicleGraph));
    }

    PxCompileTimeAssert_Dummy31 :: [1] u8;
    PxCompileTimeAssert_Dummy32 :: [1] u8;

    PxVehicleTelemetryData :: struct {
        /**
        \brief Get the graph data for the engine
        */
        getEngineGraph :: (this: *PxVehicleTelemetryData) -> *PxVehicleGraph #cpp_method #foreign physx_lib "?getEngineGraph@PxVehicleTelemetryData@physx@@QEBAAEBVPxVehicleGraph@2@XZ";

        /**
        \brief Get the number of wheel graphs
        */
        getNbWheelGraphs :: (this: *PxVehicleTelemetryData) -> PxU32 #cpp_method #foreign physx_lib "?getNbWheelGraphs@PxVehicleTelemetryData@physx@@QEBAIXZ";

        /**
        \brief Get the graph data for the kth wheel
        */
        getWheelGraph :: (this: *PxVehicleTelemetryData, k: PxU32) -> *PxVehicleGraph #cpp_method #foreign physx_lib "?getWheelGraph@PxVehicleTelemetryData@physx@@QEBAAEBVPxVehicleGraph@2@I@Z";

        /**
        \brief Get the array of tire force application points so they can be rendered
        */
        getTireforceAppPoints :: (this: *PxVehicleTelemetryData) -> *PxVec3 #cpp_method #foreign physx_lib "?getTireforceAppPoints@PxVehicleTelemetryData@physx@@QEBAPEBVPxVec3@2@XZ";

        /**
        \brief Get the array of susp force application points so they can be rendered
        */
        getSuspforceAppPoints :: (this: *PxVehicleTelemetryData) -> *PxVec3 #cpp_method #foreign physx_lib "?getSuspforceAppPoints@PxVehicleTelemetryData@physx@@QEBAPEBVPxVec3@2@XZ";

        /**
        \brief Graph data for engine.
        Used for storing single timeslices of debug data for engine graph.
        @see PxVehicleGraph
        */
        mEngineGraph:        *PxVehicleGraph;

        /**
        \brief Graph data for each wheel.
        Used for storing single timeslices of debug data for wheel graphs.
        @see PxVehicleGraph
        */
        mWheelGraphs:        *PxVehicleGraph;

        /**
        \brief Application point of tire forces.
        */
        mTireforceAppPoints: *PxVec3;

        /**
        \brief Application point of susp forces.
        */
        mSuspforceAppPoints: *PxVec3;

        /**
        \brief Total number of active wheels
        */
        mNbActiveWheels:     PxU32;

        mPad:                [3] PxU32;
    }
    #run {if true then return;
        instance: PxVehicleTelemetryData;
        assert(((cast(*void)(*instance.mEngineGraph)) - cast(*void)(*instance)) == 0, "PxVehicleTelemetryData.mEngineGraph has unexpected offset % instead of 0", ((cast(*void)(*instance.mEngineGraph)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleTelemetryData.mEngineGraph)) == 8, "PxVehicleTelemetryData.mEngineGraph has unexpected size % instead of 8", size_of(type_of(PxVehicleTelemetryData.mEngineGraph)));
        assert(((cast(*void)(*instance.mWheelGraphs)) - cast(*void)(*instance)) == 8, "PxVehicleTelemetryData.mWheelGraphs has unexpected offset % instead of 8", ((cast(*void)(*instance.mWheelGraphs)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleTelemetryData.mWheelGraphs)) == 8, "PxVehicleTelemetryData.mWheelGraphs has unexpected size % instead of 8", size_of(type_of(PxVehicleTelemetryData.mWheelGraphs)));
        assert(((cast(*void)(*instance.mTireforceAppPoints)) - cast(*void)(*instance)) == 16, "PxVehicleTelemetryData.mTireforceAppPoints has unexpected offset % instead of 16", ((cast(*void)(*instance.mTireforceAppPoints)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleTelemetryData.mTireforceAppPoints)) == 8, "PxVehicleTelemetryData.mTireforceAppPoints has unexpected size % instead of 8", size_of(type_of(PxVehicleTelemetryData.mTireforceAppPoints)));
        assert(((cast(*void)(*instance.mSuspforceAppPoints)) - cast(*void)(*instance)) == 24, "PxVehicleTelemetryData.mSuspforceAppPoints has unexpected offset % instead of 24", ((cast(*void)(*instance.mSuspforceAppPoints)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleTelemetryData.mSuspforceAppPoints)) == 8, "PxVehicleTelemetryData.mSuspforceAppPoints has unexpected size % instead of 8", size_of(type_of(PxVehicleTelemetryData.mSuspforceAppPoints)));
        assert(((cast(*void)(*instance.mNbActiveWheels)) - cast(*void)(*instance)) == 32, "PxVehicleTelemetryData.mNbActiveWheels has unexpected offset % instead of 32", ((cast(*void)(*instance.mNbActiveWheels)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleTelemetryData.mNbActiveWheels)) == 4, "PxVehicleTelemetryData.mNbActiveWheels has unexpected size % instead of 4", size_of(type_of(PxVehicleTelemetryData.mNbActiveWheels)));
        assert(((cast(*void)(*instance.mPad)) - cast(*void)(*instance)) == 36, "PxVehicleTelemetryData.mPad has unexpected offset % instead of 36", ((cast(*void)(*instance.mPad)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleTelemetryData.mPad)) == 12, "PxVehicleTelemetryData.mPad has unexpected size % instead of 12", size_of(type_of(PxVehicleTelemetryData.mPad)));
        assert(size_of(PxVehicleTelemetryData) == 48, "PxVehicleTelemetryData has size % instead of 48", size_of(PxVehicleTelemetryData));
    }

    PxCompileTimeAssert_Dummy33 :: [1] u8;

    /**
    \brief Data structure with instanced dynamics data and configuration data of a vehicle with no drive model.
    */
    PxVehicleNoDrive :: struct {
        #as using pxvehiclewheels: PxVehicleWheels;

        mSteerAngles:  *PxReal;
        mDriveTorques: *PxReal;
        mBrakeTorques: *PxReal;

        mPad:          [2] PxU32;

        //serialization
        Constructor :: (this: *PxVehicleNoDrive, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_lib "??0PxVehicleNoDrive@physx@@QEAA@V?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";

        getNbSteerAngle :: (this: *PxVehicleNoDrive) -> PxU32 #cpp_method #foreign physx_lib "?getNbSteerAngle@PxVehicleNoDrive@physx@@QEBAIXZ";
        getNbDriveTorque :: (this: *PxVehicleNoDrive) -> PxU32 #cpp_method #foreign physx_lib "?getNbDriveTorque@PxVehicleNoDrive@physx@@QEBAIXZ";
        getNbBrakeTorque :: (this: *PxVehicleNoDrive) -> PxU32 #cpp_method #foreign physx_lib "?getNbBrakeTorque@PxVehicleNoDrive@physx@@QEBAIXZ";

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.

        virtual_getConcreteTypeName :: (this: *PxVehicleNoDrive) -> *u8 #cpp_method #foreign physx_lib "?getConcreteTypeName@PxVehicleNoDrive@physx@@UEBAPEBDXZ";
        virtual_isKindOf :: (this: *PxVehicleNoDrive, name: *u8) -> bool #cpp_method #foreign physx_lib "?isKindOf@PxVehicleNoDrive@physx@@UEBA_NPEBD@Z";

        virtual_Destructor :: (this: *PxVehicleNoDrive, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_lib "??1PxVehicleNoDrive@physx@@MEAA@XZ";
    }
    #run {if true then return;
        assert(size_of(type_of(PxVehicleNoDrive.pxvehiclewheels)) == 192, "PxVehicleNoDrive.pxvehiclewheels has unexpected size % instead of 192", size_of(type_of(PxVehicleNoDrive.pxvehiclewheels)));
        instance: PxVehicleNoDrive;
        assert(((cast(*void)(*instance.mSteerAngles)) - cast(*void)(*instance)) == 192, "PxVehicleNoDrive.mSteerAngles has unexpected offset % instead of 192", ((cast(*void)(*instance.mSteerAngles)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleNoDrive.mSteerAngles)) == 8, "PxVehicleNoDrive.mSteerAngles has unexpected size % instead of 8", size_of(type_of(PxVehicleNoDrive.mSteerAngles)));
        assert(((cast(*void)(*instance.mDriveTorques)) - cast(*void)(*instance)) == 200, "PxVehicleNoDrive.mDriveTorques has unexpected offset % instead of 200", ((cast(*void)(*instance.mDriveTorques)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleNoDrive.mDriveTorques)) == 8, "PxVehicleNoDrive.mDriveTorques has unexpected size % instead of 8", size_of(type_of(PxVehicleNoDrive.mDriveTorques)));
        assert(((cast(*void)(*instance.mBrakeTorques)) - cast(*void)(*instance)) == 208, "PxVehicleNoDrive.mBrakeTorques has unexpected offset % instead of 208", ((cast(*void)(*instance.mBrakeTorques)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleNoDrive.mBrakeTorques)) == 8, "PxVehicleNoDrive.mBrakeTorques has unexpected size % instead of 8", size_of(type_of(PxVehicleNoDrive.mBrakeTorques)));
        assert(((cast(*void)(*instance.mPad)) - cast(*void)(*instance)) == 216, "PxVehicleNoDrive.mPad has unexpected offset % instead of 216", ((cast(*void)(*instance.mPad)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxVehicleNoDrive.mPad)) == 8, "PxVehicleNoDrive.mPad has unexpected size % instead of 8", size_of(type_of(PxVehicleNoDrive.mPad)));
        assert(size_of(PxVehicleNoDrive) == 224, "PxVehicleNoDrive has size % instead of 224", size_of(PxVehicleNoDrive));
    }

    PxCompileTimeAssert_Dummy34 :: [1] u8;

    /**
    \brief The pure virtual callback interface for general purpose instrumentation and profiling of GameWorks modules as
    well as applications
    */
    PxProfilerCallback :: struct {
        vtable: *PxProfilerCallback_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.
        virtual_Destructor :: (this: *PxProfilerCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_lib "??1PxProfilerCallback@physx@@MEAA@XZ";
    }
    PxProfilerCallback_VTable :: struct #type_info_none {
        Destructor: (this: *PxProfilerCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

        zoneStart: (this: *PxProfilerCallback, eventName: *u8, detached: bool, contextId: u64) -> *void #cpp_method;

        zoneEnd: (this: *PxProfilerCallback, profilerData: *void, eventName: *u8, detached: bool, contextId: u64) -> void #cpp_method;
    }

    PxProfilerCallback_Destructor :: inline (this: *PxProfilerCallback, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    PxProfilerCallback_zoneStart :: inline (this: *PxProfilerCallback, eventName: *u8, detached: bool, contextId: u64) -> *void { return this.vtable.zoneStart(this, eventName, detached, contextId); }

    PxProfilerCallback_zoneEnd :: inline (this: *PxProfilerCallback, profilerData: *void, eventName: *u8, detached: bool, contextId: u64) { this.vtable.zoneEnd(this, profilerData, eventName, detached, contextId); }

    vtable :: (obj: *PxProfilerCallback) -> *PxProfilerCallback_VTable { return obj.vtable; }

    #run {if true then return;
        assert(size_of(PxProfilerCallback) == 8, "PxProfilerCallback has size % instead of 8", size_of(PxProfilerCallback));
    }

    PxProfileScoped :: struct {
        Constructor :: (this: *PxProfileScoped, callback: *PxProfilerCallback, eventName: *u8, detached: bool, contextId: u64) -> void #cpp_method #foreign physx_lib "??0PxProfileScoped@physx@@QEAA@PEAVPxProfilerCallback@1@PEBD_N_K@Z";

        Destructor :: (this: *PxProfileScoped) -> void #cpp_method #foreign physx_lib "??1PxProfileScoped@physx@@QEAA@XZ";

        mCallback:     *PxProfilerCallback;
        mEventName:    *u8;
        mProfilerData: *void;
        mContextId:    u64;
        mDetached:     bool;
    }
    #run {if true then return;
        instance: PxProfileScoped;
        assert(((cast(*void)(*instance.mCallback)) - cast(*void)(*instance)) == 0, "PxProfileScoped.mCallback has unexpected offset % instead of 0", ((cast(*void)(*instance.mCallback)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxProfileScoped.mCallback)) == 8, "PxProfileScoped.mCallback has unexpected size % instead of 8", size_of(type_of(PxProfileScoped.mCallback)));
        assert(((cast(*void)(*instance.mEventName)) - cast(*void)(*instance)) == 8, "PxProfileScoped.mEventName has unexpected offset % instead of 8", ((cast(*void)(*instance.mEventName)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxProfileScoped.mEventName)) == 8, "PxProfileScoped.mEventName has unexpected size % instead of 8", size_of(type_of(PxProfileScoped.mEventName)));
        assert(((cast(*void)(*instance.mProfilerData)) - cast(*void)(*instance)) == 16, "PxProfileScoped.mProfilerData has unexpected offset % instead of 16", ((cast(*void)(*instance.mProfilerData)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxProfileScoped.mProfilerData)) == 8, "PxProfileScoped.mProfilerData has unexpected size % instead of 8", size_of(type_of(PxProfileScoped.mProfilerData)));
        assert(((cast(*void)(*instance.mContextId)) - cast(*void)(*instance)) == 24, "PxProfileScoped.mContextId has unexpected offset % instead of 24", ((cast(*void)(*instance.mContextId)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxProfileScoped.mContextId)) == 8, "PxProfileScoped.mContextId has unexpected size % instead of 8", size_of(type_of(PxProfileScoped.mContextId)));
        assert(((cast(*void)(*instance.mDetached)) - cast(*void)(*instance)) == 32, "PxProfileScoped.mDetached has unexpected offset % instead of 32", ((cast(*void)(*instance.mDetached)) - cast(*void)(*instance)));
        assert(size_of(type_of(PxProfileScoped.mDetached)) == 1, "PxProfileScoped.mDetached has unexpected size % instead of 1", size_of(type_of(PxProfileScoped.mDetached)));
        assert(size_of(PxProfileScoped) == 40, "PxProfileScoped has size % instead of 40", size_of(PxProfileScoped));
    }

    /**
    \brief types of instrumentation that PVD can do.
    */
    PxPvdInstrumentationFlag :: struct {
        Enum :: enum s32 {
            DEBUG   :: 1;

            PROFILE :: 2;

            MEMORY  :: 4;

            ALL     :: 7;

            eDEBUG   :: DEBUG;

            ePROFILE :: PROFILE;

            eMEMORY  :: MEMORY;

            eALL     :: ALL;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    #run {if true then return;
        assert(size_of(PxPvdInstrumentationFlag) == 1, "PxPvdInstrumentationFlag has size % instead of 1", size_of(PxPvdInstrumentationFlag));
    }

    /**
    \brief Bitfield that contains a set of raised flags defined in PxPvdInstrumentationFlag.

    @see PxPvdInstrumentationFlag
    */
    PxPvdInstrumentationFlags :: PxFlags(PxPvdInstrumentationFlag.Enum, u8);

    /**
    \brief PxPvd is the top-level class for the PVD framework, and the main customer interface for PVD
    configuration.It is a singleton class, instantiated and owned by the application.
    */
    PxPvd :: struct {
        #as using pxprofilercallback: PxProfilerCallback;
        #place pxprofilercallback; pxpvd_vtable: *PxPvd_VTable;
    }
    PxPvd_VTable :: struct #type_info_none {
        using pxprofilercallback: PxProfilerCallback_VTable;
        connect: (this: *PxPvd, transport: *PxPvdTransport, flags: PxPvdInstrumentationFlags) -> bool #cpp_method;

        disconnect: (this: *PxPvd) -> void #cpp_method;

        isConnected: (this: *PxPvd, useCachedStatus := true) -> bool #cpp_method;

        getTransport: (this: *PxPvd) -> *PxPvdTransport #cpp_method;

        getInstrumentationFlags: (this: *PxPvd) -> PxPvdInstrumentationFlags #cpp_method;

        release: (this: *PxPvd) -> void #cpp_method;
    }

    PxPvd_connect :: inline (this: *PxPvd, transport: *PxPvdTransport, flags: PxPvdInstrumentationFlags) -> bool { return this.pxpvd_vtable.connect(this, transport, flags); }

    PxPvd_disconnect :: inline (this: *PxPvd) { this.pxpvd_vtable.disconnect(this); }

    PxPvd_isConnected :: inline (this: *PxPvd, useCachedStatus := true) -> bool { return this.pxpvd_vtable.isConnected(this, useCachedStatus); }

    PxPvd_getTransport :: inline (this: *PxPvd) -> *PxPvdTransport { return this.pxpvd_vtable.getTransport(this); }

    PxPvd_getInstrumentationFlags :: inline (this: *PxPvd) -> PxPvdInstrumentationFlags { return this.pxpvd_vtable.getInstrumentationFlags(this); }

    PxPvd_release :: inline (this: *PxPvd) { this.pxpvd_vtable.release(this); }

    vtable :: (obj: *PxPvd) -> *PxPvd_VTable { return obj.pxpvd_vtable; }

    #run {if true then return;
        assert(size_of(type_of(PxPvd.pxprofilercallback)) == 8, "PxPvd.pxprofilercallback has unexpected size % instead of 8", size_of(type_of(PxPvd.pxprofilercallback)));
        assert(size_of(PxPvd) == 8, "PxPvd has size % instead of 8", size_of(PxPvd));
    }

    /**
    \brief	PxPvdTransport is an interface representing the data transport mechanism.
    This class defines all services associated with the transport: configuration, connection, reading, writing etc.
    It is owned by the application, and can be realized as a file or a socket (using one-line PxDefault<...> methods in
    PhysXExtensions) or in a custom implementation. This is a class that is intended for use by PVD, not by the
    application, the application entry points are PxPvd and PvdClient.
    */
    PxPvdTransport :: struct {
        vtable: *PxPvdTransport_VTable;
    }
    PxPvdTransport_VTable :: struct #type_info_none {
        connect: (this: *PxPvdTransport) -> bool #cpp_method;

        disconnect: (this: *PxPvdTransport) -> void #cpp_method;

        isConnected: (this: *PxPvdTransport) -> bool #cpp_method;

        write: (this: *PxPvdTransport, inBytes: *u8, inLength: u32) -> bool #cpp_method;

        lock: (this: *PxPvdTransport) -> *PxPvdTransport #cpp_method;

        unlock: (this: *PxPvdTransport) -> void #cpp_method;

        flush: (this: *PxPvdTransport) -> void #cpp_method;

        getWrittenDataSize: (this: *PxPvdTransport) -> u64 #cpp_method;

        release: (this: *PxPvdTransport) -> void #cpp_method;

        Destructor: (this: *PxPvdTransport, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxPvdTransport_connect :: inline (this: *PxPvdTransport) -> bool { return this.vtable.connect(this); }

    PxPvdTransport_disconnect :: inline (this: *PxPvdTransport) { this.vtable.disconnect(this); }

    PxPvdTransport_isConnected :: inline (this: *PxPvdTransport) -> bool { return this.vtable.isConnected(this); }

    PxPvdTransport_write :: inline (this: *PxPvdTransport, inBytes: *u8, inLength: u32) -> bool { return this.vtable.write(this, inBytes, inLength); }

    PxPvdTransport_lock :: inline (this: *PxPvdTransport) -> *PxPvdTransport { return this.vtable.lock(this); }

    PxPvdTransport_unlock :: inline (this: *PxPvdTransport) { this.vtable.unlock(this); }

    PxPvdTransport_flush :: inline (this: *PxPvdTransport) { this.vtable.flush(this); }

    PxPvdTransport_getWrittenDataSize :: inline (this: *PxPvdTransport) -> u64 { return this.vtable.getWrittenDataSize(this); }

    PxPvdTransport_release :: inline (this: *PxPvdTransport) { this.vtable.release(this); }

    PxPvdTransport_Destructor :: inline (this: *PxPvdTransport, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxPvdTransport) -> *PxPvdTransport_VTable { return obj.vtable; }

    #run {if true then return;
        assert(size_of(PxPvdTransport) == 8, "PxPvdTransport has size % instead of 8", size_of(PxPvdTransport));
    }
}

CUctx_st :: struct {}
/* Forward decl to avoid inclusion of cuda.h */
CUcontext :: *CUctx_st;
CUgraphicsResource_st :: struct {}
CUgraphicsResource :: *CUgraphicsResource_st;
CUdevice :: s32;

/**
\brief PxGpuLoadHook

This is a helper class for loading the PhysXGpu dll.
If a PhysXGpu dll with a non-default file name needs to be loaded,
PxGpuLoadHook can be sub-classed to provide the custom filenames.

Once the names are set, the instance must be set for use by PhysX.dll using PxSetPhysXGpuLoadHook(),

@see PxSetPhysXGpuLoadHook()
*/
PxGpuLoadHook :: struct {
    vtable: *PxGpuLoadHook_VTable;
}
PxGpuLoadHook_VTable :: struct #type_info_none {
    Destructor: (this: *PxGpuLoadHook, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

    getPhysXGpuDllName: (this: *PxGpuLoadHook) -> *u8 #cpp_method;
}

PxGpuLoadHook_Destructor :: inline (this: *PxGpuLoadHook, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

PxGpuLoadHook_getPhysXGpuDllName :: inline (this: *PxGpuLoadHook) -> *u8 { return this.vtable.getPhysXGpuDllName(this); }

vtable :: (obj: *PxGpuLoadHook) -> *PxGpuLoadHook_VTable { return obj.vtable; }

#run {
    assert(size_of(PxGpuLoadHook) == 8, "PxGpuLoadHook has size % instead of 8", size_of(PxGpuLoadHook));
}

/**
\brief Creates an instance of the physics SDK.

Creates an instance of this class. May not be a class member to avoid name mangling.
Pass the constant #PX_PHYSICS_VERSION as the argument.
There may be only one instance of this class per process. Calling this method after an instance
has been created already will result in an error message and NULL will be returned.

Calling this will register all optional code modules (Articulations and HeightFields), preparing them for use.
If you do not need some of these modules, consider calling PxCreateBasePhysics() instead and registering needed
modules manually.

\param version Version number we are expecting(should be #PX_PHYSICS_VERSION)
\param foundation Foundation instance (see PxFoundation)
\param scale values used to determine default tolerances for objects at creation time
\param trackOutstandingAllocations true if you want to track memory allocations
so a debugger connection partway through your physics simulation will get
an accurate map of everything that has been allocated so far.  This could have a memory
and performance impact on your simulation hence it defaults to off.
\param pvd When pvd points to a valid PxPvd instance (PhysX Visual Debugger), a connection to the specified PxPvd instance is created.
If pvd is NULL no connection will be attempted.
\return PxPhysics instance on success, NULL if operation failed

@see PxPhysics, PxCreateBasePhysics, PxRegisterArticulations, PxRegisterArticulationsReducedCoordinate, PxRegisterHeightFields
*/
PxCreatePhysics :: (version: physx.PxU32, foundation: *physx.PxFoundation, scale: *physx.PxTolerancesScale, trackOutstandingAllocations := false, pvd: *physx.PxPvd = null) -> *physx.PxPhysics #foreign physx_lib "?PxCreatePhysics@@YAPEAVPxPhysics@physx@@IAEAVPxFoundation@2@AEBVPxTolerancesScale@2@_NPEAVPxPvd@2@@Z";
PxCreatePhysics :: (version: physx.PxU32, foundation: *physx.PxFoundation, scale: physx.PxTolerancesScale, trackOutstandingAllocations := false, pvd: *physx.PxPvd = null) -> *physx.PxPhysics #no_context {
    return PxCreatePhysics(version, foundation, *scale, trackOutstandingAllocations, pvd);
}

PxFileHandle :: *void;

/**
\brief Inline helper function to create PxRepXObject from a PxBase instance.
*/
PxCreateRepXObject :: (inType: *physx.PxBase, inId: physx.PxSerialObjectId) -> physx.PxRepXObject #cpp_return_type_is_non_pod #foreign physx_lib "?PxCreateRepXObject@@YA?AUPxRepXObject@physx@@PEBVPxBase@2@_K@Z";

physx_PxAllocatorCallback_Pod :: struct {
    vtable_: *void;
}
#run {
    instance: physx_PxAllocatorCallback_Pod;
    assert(((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)) == 0, "physx_PxAllocatorCallback_Pod.vtable_ has unexpected offset % instead of 0", ((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxAllocatorCallback_Pod.vtable_)) == 8, "physx_PxAllocatorCallback_Pod.vtable_ has unexpected size % instead of 8", size_of(type_of(physx_PxAllocatorCallback_Pod.vtable_)));
    assert(size_of(physx_PxAllocatorCallback_Pod) == 8, "physx_PxAllocatorCallback_Pod has size % instead of 8", size_of(physx_PxAllocatorCallback_Pod));
}

physx_PxAssertHandler_Pod :: struct {
    vtable_: *void;
}
#run {
    instance: physx_PxAssertHandler_Pod;
    assert(((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)) == 0, "physx_PxAssertHandler_Pod.vtable_ has unexpected offset % instead of 0", ((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxAssertHandler_Pod.vtable_)) == 8, "physx_PxAssertHandler_Pod.vtable_ has unexpected size % instead of 8", size_of(type_of(physx_PxAssertHandler_Pod.vtable_)));
    assert(size_of(physx_PxAssertHandler_Pod) == 8, "physx_PxAssertHandler_Pod has size % instead of 8", size_of(physx_PxAssertHandler_Pod));
}

physx_PxVec3_Pod :: struct {
    x: float;
    y: float;
    z: float;
}
#run {
    instance: physx_PxVec3_Pod;
    assert(((cast(*void)(*instance.x)) - cast(*void)(*instance)) == 0, "physx_PxVec3_Pod.x has unexpected offset % instead of 0", ((cast(*void)(*instance.x)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVec3_Pod.x)) == 4, "physx_PxVec3_Pod.x has unexpected size % instead of 4", size_of(type_of(physx_PxVec3_Pod.x)));
    assert(((cast(*void)(*instance.y)) - cast(*void)(*instance)) == 4, "physx_PxVec3_Pod.y has unexpected offset % instead of 4", ((cast(*void)(*instance.y)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVec3_Pod.y)) == 4, "physx_PxVec3_Pod.y has unexpected size % instead of 4", size_of(type_of(physx_PxVec3_Pod.y)));
    assert(((cast(*void)(*instance.z)) - cast(*void)(*instance)) == 8, "physx_PxVec3_Pod.z has unexpected offset % instead of 8", ((cast(*void)(*instance.z)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVec3_Pod.z)) == 4, "physx_PxVec3_Pod.z has unexpected size % instead of 4", size_of(type_of(physx_PxVec3_Pod.z)));
    assert(size_of(physx_PxVec3_Pod) == 12, "physx_PxVec3_Pod has size % instead of 12", size_of(physx_PxVec3_Pod));
}

physx_PxQuat_Pod :: struct {
    x: float;
    y: float;
    z: float;
    w: float;
}
#run {
    instance: physx_PxQuat_Pod;
    assert(((cast(*void)(*instance.x)) - cast(*void)(*instance)) == 0, "physx_PxQuat_Pod.x has unexpected offset % instead of 0", ((cast(*void)(*instance.x)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxQuat_Pod.x)) == 4, "physx_PxQuat_Pod.x has unexpected size % instead of 4", size_of(type_of(physx_PxQuat_Pod.x)));
    assert(((cast(*void)(*instance.y)) - cast(*void)(*instance)) == 4, "physx_PxQuat_Pod.y has unexpected offset % instead of 4", ((cast(*void)(*instance.y)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxQuat_Pod.y)) == 4, "physx_PxQuat_Pod.y has unexpected size % instead of 4", size_of(type_of(physx_PxQuat_Pod.y)));
    assert(((cast(*void)(*instance.z)) - cast(*void)(*instance)) == 8, "physx_PxQuat_Pod.z has unexpected offset % instead of 8", ((cast(*void)(*instance.z)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxQuat_Pod.z)) == 4, "physx_PxQuat_Pod.z has unexpected size % instead of 4", size_of(type_of(physx_PxQuat_Pod.z)));
    assert(((cast(*void)(*instance.w)) - cast(*void)(*instance)) == 12, "physx_PxQuat_Pod.w has unexpected offset % instead of 12", ((cast(*void)(*instance.w)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxQuat_Pod.w)) == 4, "physx_PxQuat_Pod.w has unexpected size % instead of 4", size_of(type_of(physx_PxQuat_Pod.w)));
    assert(size_of(physx_PxQuat_Pod) == 16, "physx_PxQuat_Pod has size % instead of 16", size_of(physx_PxQuat_Pod));
}

physx_PxMat33_Pod :: struct {
    column0: physx_PxVec3_Pod;
    column1: physx_PxVec3_Pod;
    column2: physx_PxVec3_Pod;
}
#run {
    instance: physx_PxMat33_Pod;
    assert(((cast(*void)(*instance.column0)) - cast(*void)(*instance)) == 0, "physx_PxMat33_Pod.column0 has unexpected offset % instead of 0", ((cast(*void)(*instance.column0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxMat33_Pod.column0)) == 12, "physx_PxMat33_Pod.column0 has unexpected size % instead of 12", size_of(type_of(physx_PxMat33_Pod.column0)));
    assert(((cast(*void)(*instance.column1)) - cast(*void)(*instance)) == 12, "physx_PxMat33_Pod.column1 has unexpected offset % instead of 12", ((cast(*void)(*instance.column1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxMat33_Pod.column1)) == 12, "physx_PxMat33_Pod.column1 has unexpected size % instead of 12", size_of(type_of(physx_PxMat33_Pod.column1)));
    assert(((cast(*void)(*instance.column2)) - cast(*void)(*instance)) == 24, "physx_PxMat33_Pod.column2 has unexpected offset % instead of 24", ((cast(*void)(*instance.column2)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxMat33_Pod.column2)) == 12, "physx_PxMat33_Pod.column2 has unexpected size % instead of 12", size_of(type_of(physx_PxMat33_Pod.column2)));
    assert(size_of(physx_PxMat33_Pod) == 36, "physx_PxMat33_Pod has size % instead of 36", size_of(physx_PxMat33_Pod));
}

physx_PxPlane_Pod :: struct {
    n: physx_PxVec3_Pod;
    d: float;
}
#run {
    instance: physx_PxPlane_Pod;
    assert(((cast(*void)(*instance.n)) - cast(*void)(*instance)) == 0, "physx_PxPlane_Pod.n has unexpected offset % instead of 0", ((cast(*void)(*instance.n)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxPlane_Pod.n)) == 12, "physx_PxPlane_Pod.n has unexpected size % instead of 12", size_of(type_of(physx_PxPlane_Pod.n)));
    assert(((cast(*void)(*instance.d)) - cast(*void)(*instance)) == 12, "physx_PxPlane_Pod.d has unexpected offset % instead of 12", ((cast(*void)(*instance.d)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxPlane_Pod.d)) == 4, "physx_PxPlane_Pod.d has unexpected size % instead of 4", size_of(type_of(physx_PxPlane_Pod.d)));
    assert(size_of(physx_PxPlane_Pod) == 16, "physx_PxPlane_Pod has size % instead of 16", size_of(physx_PxPlane_Pod));
}

physx_PxTransform_Pod :: struct {
    q: physx_PxQuat_Pod;
    p: physx_PxVec3_Pod;
}
#run {
    instance: physx_PxTransform_Pod;
    assert(((cast(*void)(*instance.q)) - cast(*void)(*instance)) == 0, "physx_PxTransform_Pod.q has unexpected offset % instead of 0", ((cast(*void)(*instance.q)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxTransform_Pod.q)) == 16, "physx_PxTransform_Pod.q has unexpected size % instead of 16", size_of(type_of(physx_PxTransform_Pod.q)));
    assert(((cast(*void)(*instance.p)) - cast(*void)(*instance)) == 16, "physx_PxTransform_Pod.p has unexpected offset % instead of 16", ((cast(*void)(*instance.p)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxTransform_Pod.p)) == 12, "physx_PxTransform_Pod.p has unexpected size % instead of 12", size_of(type_of(physx_PxTransform_Pod.p)));
    assert(size_of(physx_PxTransform_Pod) == 28, "physx_PxTransform_Pod has size % instead of 28", size_of(physx_PxTransform_Pod));
}

physx_PxVec4_Pod :: struct {
    x: float;
    y: float;
    z: float;
    w: float;
}
#run {
    instance: physx_PxVec4_Pod;
    assert(((cast(*void)(*instance.x)) - cast(*void)(*instance)) == 0, "physx_PxVec4_Pod.x has unexpected offset % instead of 0", ((cast(*void)(*instance.x)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVec4_Pod.x)) == 4, "physx_PxVec4_Pod.x has unexpected size % instead of 4", size_of(type_of(physx_PxVec4_Pod.x)));
    assert(((cast(*void)(*instance.y)) - cast(*void)(*instance)) == 4, "physx_PxVec4_Pod.y has unexpected offset % instead of 4", ((cast(*void)(*instance.y)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVec4_Pod.y)) == 4, "physx_PxVec4_Pod.y has unexpected size % instead of 4", size_of(type_of(physx_PxVec4_Pod.y)));
    assert(((cast(*void)(*instance.z)) - cast(*void)(*instance)) == 8, "physx_PxVec4_Pod.z has unexpected offset % instead of 8", ((cast(*void)(*instance.z)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVec4_Pod.z)) == 4, "physx_PxVec4_Pod.z has unexpected size % instead of 4", size_of(type_of(physx_PxVec4_Pod.z)));
    assert(((cast(*void)(*instance.w)) - cast(*void)(*instance)) == 12, "physx_PxVec4_Pod.w has unexpected offset % instead of 12", ((cast(*void)(*instance.w)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVec4_Pod.w)) == 4, "physx_PxVec4_Pod.w has unexpected size % instead of 4", size_of(type_of(physx_PxVec4_Pod.w)));
    assert(size_of(physx_PxVec4_Pod) == 16, "physx_PxVec4_Pod has size % instead of 16", size_of(physx_PxVec4_Pod));
}

physx_PxMat44_Pod :: struct {
    column0: physx_PxVec4_Pod;
    column1: physx_PxVec4_Pod;
    column2: physx_PxVec4_Pod;
    column3: physx_PxVec4_Pod;
}
#run {
    instance: physx_PxMat44_Pod;
    assert(((cast(*void)(*instance.column0)) - cast(*void)(*instance)) == 0, "physx_PxMat44_Pod.column0 has unexpected offset % instead of 0", ((cast(*void)(*instance.column0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxMat44_Pod.column0)) == 16, "physx_PxMat44_Pod.column0 has unexpected size % instead of 16", size_of(type_of(physx_PxMat44_Pod.column0)));
    assert(((cast(*void)(*instance.column1)) - cast(*void)(*instance)) == 16, "physx_PxMat44_Pod.column1 has unexpected offset % instead of 16", ((cast(*void)(*instance.column1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxMat44_Pod.column1)) == 16, "physx_PxMat44_Pod.column1 has unexpected size % instead of 16", size_of(type_of(physx_PxMat44_Pod.column1)));
    assert(((cast(*void)(*instance.column2)) - cast(*void)(*instance)) == 32, "physx_PxMat44_Pod.column2 has unexpected offset % instead of 32", ((cast(*void)(*instance.column2)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxMat44_Pod.column2)) == 16, "physx_PxMat44_Pod.column2 has unexpected size % instead of 16", size_of(type_of(physx_PxMat44_Pod.column2)));
    assert(((cast(*void)(*instance.column3)) - cast(*void)(*instance)) == 48, "physx_PxMat44_Pod.column3 has unexpected offset % instead of 48", ((cast(*void)(*instance.column3)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxMat44_Pod.column3)) == 16, "physx_PxMat44_Pod.column3 has unexpected size % instead of 16", size_of(type_of(physx_PxMat44_Pod.column3)));
    assert(size_of(physx_PxMat44_Pod) == 64, "physx_PxMat44_Pod has size % instead of 64", size_of(physx_PxMat44_Pod));
}

physx_PxBounds3_Pod :: struct {
    minimum: physx_PxVec3_Pod;
    maximum: physx_PxVec3_Pod;
}
#run {
    instance: physx_PxBounds3_Pod;
    assert(((cast(*void)(*instance.minimum)) - cast(*void)(*instance)) == 0, "physx_PxBounds3_Pod.minimum has unexpected offset % instead of 0", ((cast(*void)(*instance.minimum)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBounds3_Pod.minimum)) == 12, "physx_PxBounds3_Pod.minimum has unexpected size % instead of 12", size_of(type_of(physx_PxBounds3_Pod.minimum)));
    assert(((cast(*void)(*instance.maximum)) - cast(*void)(*instance)) == 12, "physx_PxBounds3_Pod.maximum has unexpected offset % instead of 12", ((cast(*void)(*instance.maximum)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBounds3_Pod.maximum)) == 12, "physx_PxBounds3_Pod.maximum has unexpected size % instead of 12", size_of(type_of(physx_PxBounds3_Pod.maximum)));
    assert(size_of(physx_PxBounds3_Pod) == 24, "physx_PxBounds3_Pod has size % instead of 24", size_of(physx_PxBounds3_Pod));
}

physx_PxErrorCallback_Pod :: struct {
    vtable_: *void;
}
#run {
    instance: physx_PxErrorCallback_Pod;
    assert(((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)) == 0, "physx_PxErrorCallback_Pod.vtable_ has unexpected offset % instead of 0", ((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxErrorCallback_Pod.vtable_)) == 8, "physx_PxErrorCallback_Pod.vtable_ has unexpected size % instead of 8", size_of(type_of(physx_PxErrorCallback_Pod.vtable_)));
    assert(size_of(physx_PxErrorCallback_Pod) == 8, "physx_PxErrorCallback_Pod has size % instead of 8", size_of(physx_PxErrorCallback_Pod));
}

physx_PxInputStream_Pod :: struct {
    vtable_: *void;
}
#run {
    instance: physx_PxInputStream_Pod;
    assert(((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)) == 0, "physx_PxInputStream_Pod.vtable_ has unexpected offset % instead of 0", ((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxInputStream_Pod.vtable_)) == 8, "physx_PxInputStream_Pod.vtable_ has unexpected size % instead of 8", size_of(type_of(physx_PxInputStream_Pod.vtable_)));
    assert(size_of(physx_PxInputStream_Pod) == 8, "physx_PxInputStream_Pod has size % instead of 8", size_of(physx_PxInputStream_Pod));
}

physx_PxInputData_Pod :: struct {
    vtable_: *void;
}
#run {
    instance: physx_PxInputData_Pod;
    assert(((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)) == 0, "physx_PxInputData_Pod.vtable_ has unexpected offset % instead of 0", ((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxInputData_Pod.vtable_)) == 8, "physx_PxInputData_Pod.vtable_ has unexpected size % instead of 8", size_of(type_of(physx_PxInputData_Pod.vtable_)));
    assert(size_of(physx_PxInputData_Pod) == 8, "physx_PxInputData_Pod has size % instead of 8", size_of(physx_PxInputData_Pod));
}

physx_PxOutputStream_Pod :: struct {
    vtable_: *void;
}
#run {
    instance: physx_PxOutputStream_Pod;
    assert(((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)) == 0, "physx_PxOutputStream_Pod.vtable_ has unexpected offset % instead of 0", ((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxOutputStream_Pod.vtable_)) == 8, "physx_PxOutputStream_Pod.vtable_ has unexpected size % instead of 8", size_of(type_of(physx_PxOutputStream_Pod.vtable_)));
    assert(size_of(physx_PxOutputStream_Pod) == 8, "physx_PxOutputStream_Pod has size % instead of 8", size_of(physx_PxOutputStream_Pod));
}

physx_PxVec2_Pod :: struct {
    x: float;
    y: float;
}
#run {
    instance: physx_PxVec2_Pod;
    assert(((cast(*void)(*instance.x)) - cast(*void)(*instance)) == 0, "physx_PxVec2_Pod.x has unexpected offset % instead of 0", ((cast(*void)(*instance.x)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVec2_Pod.x)) == 4, "physx_PxVec2_Pod.x has unexpected size % instead of 4", size_of(type_of(physx_PxVec2_Pod.x)));
    assert(((cast(*void)(*instance.y)) - cast(*void)(*instance)) == 4, "physx_PxVec2_Pod.y has unexpected offset % instead of 4", ((cast(*void)(*instance.y)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVec2_Pod.y)) == 4, "physx_PxVec2_Pod.y has unexpected size % instead of 4", size_of(type_of(physx_PxVec2_Pod.y)));
    assert(size_of(physx_PxVec2_Pod) == 8, "physx_PxVec2_Pod has size % instead of 8", size_of(physx_PxVec2_Pod));
}

physx_PxStridedData_Pod :: struct {
    stride:         u32;
    structgen_pad0: [4] u8;
    data:           *void;
}
#run {
    instance: physx_PxStridedData_Pod;
    assert(((cast(*void)(*instance.stride)) - cast(*void)(*instance)) == 0, "physx_PxStridedData_Pod.stride has unexpected offset % instead of 0", ((cast(*void)(*instance.stride)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxStridedData_Pod.stride)) == 4, "physx_PxStridedData_Pod.stride has unexpected size % instead of 4", size_of(type_of(physx_PxStridedData_Pod.stride)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 4, "physx_PxStridedData_Pod.structgen_pad0 has unexpected offset % instead of 4", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxStridedData_Pod.structgen_pad0)) == 4, "physx_PxStridedData_Pod.structgen_pad0 has unexpected size % instead of 4", size_of(type_of(physx_PxStridedData_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.data)) - cast(*void)(*instance)) == 8, "physx_PxStridedData_Pod.data has unexpected offset % instead of 8", ((cast(*void)(*instance.data)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxStridedData_Pod.data)) == 8, "physx_PxStridedData_Pod.data has unexpected size % instead of 8", size_of(type_of(physx_PxStridedData_Pod.data)));
    assert(size_of(physx_PxStridedData_Pod) == 16, "physx_PxStridedData_Pod has size % instead of 16", size_of(physx_PxStridedData_Pod));
}

physx_PxBoundedData_Pod :: struct {
    stride:         u32;
    structgen_pad0: [4] u8;
    data:           *void;
    count:          u32;
    structgen_pad1: [4] u8;
}
#run {
    instance: physx_PxBoundedData_Pod;
    assert(((cast(*void)(*instance.stride)) - cast(*void)(*instance)) == 0, "physx_PxBoundedData_Pod.stride has unexpected offset % instead of 0", ((cast(*void)(*instance.stride)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBoundedData_Pod.stride)) == 4, "physx_PxBoundedData_Pod.stride has unexpected size % instead of 4", size_of(type_of(physx_PxBoundedData_Pod.stride)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 4, "physx_PxBoundedData_Pod.structgen_pad0 has unexpected offset % instead of 4", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBoundedData_Pod.structgen_pad0)) == 4, "physx_PxBoundedData_Pod.structgen_pad0 has unexpected size % instead of 4", size_of(type_of(physx_PxBoundedData_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.data)) - cast(*void)(*instance)) == 8, "physx_PxBoundedData_Pod.data has unexpected offset % instead of 8", ((cast(*void)(*instance.data)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBoundedData_Pod.data)) == 8, "physx_PxBoundedData_Pod.data has unexpected size % instead of 8", size_of(type_of(physx_PxBoundedData_Pod.data)));
    assert(((cast(*void)(*instance.count)) - cast(*void)(*instance)) == 16, "physx_PxBoundedData_Pod.count has unexpected offset % instead of 16", ((cast(*void)(*instance.count)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBoundedData_Pod.count)) == 4, "physx_PxBoundedData_Pod.count has unexpected size % instead of 4", size_of(type_of(physx_PxBoundedData_Pod.count)));
    assert(((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)) == 20, "physx_PxBoundedData_Pod.structgen_pad1 has unexpected offset % instead of 20", ((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBoundedData_Pod.structgen_pad1)) == 4, "physx_PxBoundedData_Pod.structgen_pad1 has unexpected size % instead of 4", size_of(type_of(physx_PxBoundedData_Pod.structgen_pad1)));
    assert(size_of(physx_PxBoundedData_Pod) == 24, "physx_PxBoundedData_Pod has size % instead of 24", size_of(physx_PxBoundedData_Pod));
}

physx_PxDebugPoint_Pod :: struct {
    pos:   physx_PxVec3_Pod;
    color: u32;
}
#run {
    instance: physx_PxDebugPoint_Pod;
    assert(((cast(*void)(*instance.pos)) - cast(*void)(*instance)) == 0, "physx_PxDebugPoint_Pod.pos has unexpected offset % instead of 0", ((cast(*void)(*instance.pos)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxDebugPoint_Pod.pos)) == 12, "physx_PxDebugPoint_Pod.pos has unexpected size % instead of 12", size_of(type_of(physx_PxDebugPoint_Pod.pos)));
    assert(((cast(*void)(*instance.color)) - cast(*void)(*instance)) == 12, "physx_PxDebugPoint_Pod.color has unexpected offset % instead of 12", ((cast(*void)(*instance.color)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxDebugPoint_Pod.color)) == 4, "physx_PxDebugPoint_Pod.color has unexpected size % instead of 4", size_of(type_of(physx_PxDebugPoint_Pod.color)));
    assert(size_of(physx_PxDebugPoint_Pod) == 16, "physx_PxDebugPoint_Pod has size % instead of 16", size_of(physx_PxDebugPoint_Pod));
}

physx_PxDebugLine_Pod :: struct {
    pos0:   physx_PxVec3_Pod;
    color0: u32;
    pos1:   physx_PxVec3_Pod;
    color1: u32;
}
#run {
    instance: physx_PxDebugLine_Pod;
    assert(((cast(*void)(*instance.pos0)) - cast(*void)(*instance)) == 0, "physx_PxDebugLine_Pod.pos0 has unexpected offset % instead of 0", ((cast(*void)(*instance.pos0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxDebugLine_Pod.pos0)) == 12, "physx_PxDebugLine_Pod.pos0 has unexpected size % instead of 12", size_of(type_of(physx_PxDebugLine_Pod.pos0)));
    assert(((cast(*void)(*instance.color0)) - cast(*void)(*instance)) == 12, "physx_PxDebugLine_Pod.color0 has unexpected offset % instead of 12", ((cast(*void)(*instance.color0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxDebugLine_Pod.color0)) == 4, "physx_PxDebugLine_Pod.color0 has unexpected size % instead of 4", size_of(type_of(physx_PxDebugLine_Pod.color0)));
    assert(((cast(*void)(*instance.pos1)) - cast(*void)(*instance)) == 16, "physx_PxDebugLine_Pod.pos1 has unexpected offset % instead of 16", ((cast(*void)(*instance.pos1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxDebugLine_Pod.pos1)) == 12, "physx_PxDebugLine_Pod.pos1 has unexpected size % instead of 12", size_of(type_of(physx_PxDebugLine_Pod.pos1)));
    assert(((cast(*void)(*instance.color1)) - cast(*void)(*instance)) == 28, "physx_PxDebugLine_Pod.color1 has unexpected offset % instead of 28", ((cast(*void)(*instance.color1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxDebugLine_Pod.color1)) == 4, "physx_PxDebugLine_Pod.color1 has unexpected size % instead of 4", size_of(type_of(physx_PxDebugLine_Pod.color1)));
    assert(size_of(physx_PxDebugLine_Pod) == 32, "physx_PxDebugLine_Pod has size % instead of 32", size_of(physx_PxDebugLine_Pod));
}

physx_PxDebugTriangle_Pod :: struct {
    pos0:   physx_PxVec3_Pod;
    color0: u32;
    pos1:   physx_PxVec3_Pod;
    color1: u32;
    pos2:   physx_PxVec3_Pod;
    color2: u32;
}
#run {
    instance: physx_PxDebugTriangle_Pod;
    assert(((cast(*void)(*instance.pos0)) - cast(*void)(*instance)) == 0, "physx_PxDebugTriangle_Pod.pos0 has unexpected offset % instead of 0", ((cast(*void)(*instance.pos0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxDebugTriangle_Pod.pos0)) == 12, "physx_PxDebugTriangle_Pod.pos0 has unexpected size % instead of 12", size_of(type_of(physx_PxDebugTriangle_Pod.pos0)));
    assert(((cast(*void)(*instance.color0)) - cast(*void)(*instance)) == 12, "physx_PxDebugTriangle_Pod.color0 has unexpected offset % instead of 12", ((cast(*void)(*instance.color0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxDebugTriangle_Pod.color0)) == 4, "physx_PxDebugTriangle_Pod.color0 has unexpected size % instead of 4", size_of(type_of(physx_PxDebugTriangle_Pod.color0)));
    assert(((cast(*void)(*instance.pos1)) - cast(*void)(*instance)) == 16, "physx_PxDebugTriangle_Pod.pos1 has unexpected offset % instead of 16", ((cast(*void)(*instance.pos1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxDebugTriangle_Pod.pos1)) == 12, "physx_PxDebugTriangle_Pod.pos1 has unexpected size % instead of 12", size_of(type_of(physx_PxDebugTriangle_Pod.pos1)));
    assert(((cast(*void)(*instance.color1)) - cast(*void)(*instance)) == 28, "physx_PxDebugTriangle_Pod.color1 has unexpected offset % instead of 28", ((cast(*void)(*instance.color1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxDebugTriangle_Pod.color1)) == 4, "physx_PxDebugTriangle_Pod.color1 has unexpected size % instead of 4", size_of(type_of(physx_PxDebugTriangle_Pod.color1)));
    assert(((cast(*void)(*instance.pos2)) - cast(*void)(*instance)) == 32, "physx_PxDebugTriangle_Pod.pos2 has unexpected offset % instead of 32", ((cast(*void)(*instance.pos2)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxDebugTriangle_Pod.pos2)) == 12, "physx_PxDebugTriangle_Pod.pos2 has unexpected size % instead of 12", size_of(type_of(physx_PxDebugTriangle_Pod.pos2)));
    assert(((cast(*void)(*instance.color2)) - cast(*void)(*instance)) == 44, "physx_PxDebugTriangle_Pod.color2 has unexpected offset % instead of 44", ((cast(*void)(*instance.color2)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxDebugTriangle_Pod.color2)) == 4, "physx_PxDebugTriangle_Pod.color2 has unexpected size % instead of 4", size_of(type_of(physx_PxDebugTriangle_Pod.color2)));
    assert(size_of(physx_PxDebugTriangle_Pod) == 48, "physx_PxDebugTriangle_Pod has size % instead of 48", size_of(physx_PxDebugTriangle_Pod));
}

physx_PxDebugText_Pod :: struct {
    position:       physx_PxVec3_Pod;
    size:           float;
    color:          u32;
    structgen_pad0: [4] u8;
    _string:        *u8;
}
#run {
    instance: physx_PxDebugText_Pod;
    assert(((cast(*void)(*instance.position)) - cast(*void)(*instance)) == 0, "physx_PxDebugText_Pod.position has unexpected offset % instead of 0", ((cast(*void)(*instance.position)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxDebugText_Pod.position)) == 12, "physx_PxDebugText_Pod.position has unexpected size % instead of 12", size_of(type_of(physx_PxDebugText_Pod.position)));
    assert(((cast(*void)(*instance.size)) - cast(*void)(*instance)) == 12, "physx_PxDebugText_Pod.size has unexpected offset % instead of 12", ((cast(*void)(*instance.size)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxDebugText_Pod.size)) == 4, "physx_PxDebugText_Pod.size has unexpected size % instead of 4", size_of(type_of(physx_PxDebugText_Pod.size)));
    assert(((cast(*void)(*instance.color)) - cast(*void)(*instance)) == 16, "physx_PxDebugText_Pod.color has unexpected offset % instead of 16", ((cast(*void)(*instance.color)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxDebugText_Pod.color)) == 4, "physx_PxDebugText_Pod.color has unexpected size % instead of 4", size_of(type_of(physx_PxDebugText_Pod.color)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 20, "physx_PxDebugText_Pod.structgen_pad0 has unexpected offset % instead of 20", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxDebugText_Pod.structgen_pad0)) == 4, "physx_PxDebugText_Pod.structgen_pad0 has unexpected size % instead of 4", size_of(type_of(physx_PxDebugText_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance._string)) - cast(*void)(*instance)) == 24, "physx_PxDebugText_Pod._string has unexpected offset % instead of 24", ((cast(*void)(*instance._string)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxDebugText_Pod._string)) == 8, "physx_PxDebugText_Pod._string has unexpected size % instead of 8", size_of(type_of(physx_PxDebugText_Pod._string)));
    assert(size_of(physx_PxDebugText_Pod) == 32, "physx_PxDebugText_Pod has size % instead of 32", size_of(physx_PxDebugText_Pod));
}

physx_PxRenderBuffer_Pod :: struct {
    vtable_: *void;
}
#run {
    instance: physx_PxRenderBuffer_Pod;
    assert(((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)) == 0, "physx_PxRenderBuffer_Pod.vtable_ has unexpected offset % instead of 0", ((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxRenderBuffer_Pod.vtable_)) == 8, "physx_PxRenderBuffer_Pod.vtable_ has unexpected size % instead of 8", size_of(type_of(physx_PxRenderBuffer_Pod.vtable_)));
    assert(size_of(physx_PxRenderBuffer_Pod) == 8, "physx_PxRenderBuffer_Pod has size % instead of 8", size_of(physx_PxRenderBuffer_Pod));
}

physx_PxProcessPxBaseCallback_Pod :: struct {
    vtable_: *void;
}
#run {
    instance: physx_PxProcessPxBaseCallback_Pod;
    assert(((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)) == 0, "physx_PxProcessPxBaseCallback_Pod.vtable_ has unexpected offset % instead of 0", ((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxProcessPxBaseCallback_Pod.vtable_)) == 8, "physx_PxProcessPxBaseCallback_Pod.vtable_ has unexpected size % instead of 8", size_of(type_of(physx_PxProcessPxBaseCallback_Pod.vtable_)));
    assert(size_of(physx_PxProcessPxBaseCallback_Pod) == 8, "physx_PxProcessPxBaseCallback_Pod has size % instead of 8", size_of(physx_PxProcessPxBaseCallback_Pod));
}

physx_PxBaseFlags_Pod :: struct {
    mBits: u16;
}
#run {
    instance: physx_PxBaseFlags_Pod;
    assert(((cast(*void)(*instance.mBits)) - cast(*void)(*instance)) == 0, "physx_PxBaseFlags_Pod.mBits has unexpected offset % instead of 0", ((cast(*void)(*instance.mBits)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBaseFlags_Pod.mBits)) == 2, "physx_PxBaseFlags_Pod.mBits has unexpected size % instead of 2", size_of(type_of(physx_PxBaseFlags_Pod.mBits)));
    assert(size_of(physx_PxBaseFlags_Pod) == 2, "physx_PxBaseFlags_Pod has size % instead of 2", size_of(physx_PxBaseFlags_Pod));
}

physx_PxBase_Pod :: struct {
    structgen_pad0: [8] u8;
    mConcreteType:  u16;
    mBaseFlags:     physx_PxBaseFlags_Pod;
    structgen_pad1: [4] u8;
}
#run {
    instance: physx_PxBase_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxBase_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBase_Pod.structgen_pad0)) == 8, "physx_PxBase_Pod.structgen_pad0 has unexpected size % instead of 8", size_of(type_of(physx_PxBase_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)) == 8, "physx_PxBase_Pod.mConcreteType has unexpected offset % instead of 8", ((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBase_Pod.mConcreteType)) == 2, "physx_PxBase_Pod.mConcreteType has unexpected size % instead of 2", size_of(type_of(physx_PxBase_Pod.mConcreteType)));
    assert(((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)) == 10, "physx_PxBase_Pod.mBaseFlags has unexpected offset % instead of 10", ((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBase_Pod.mBaseFlags)) == 2, "physx_PxBase_Pod.mBaseFlags has unexpected size % instead of 2", size_of(type_of(physx_PxBase_Pod.mBaseFlags)));
    assert(((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)) == 12, "physx_PxBase_Pod.structgen_pad1 has unexpected offset % instead of 12", ((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBase_Pod.structgen_pad1)) == 4, "physx_PxBase_Pod.structgen_pad1 has unexpected size % instead of 4", size_of(type_of(physx_PxBase_Pod.structgen_pad1)));
    assert(size_of(physx_PxBase_Pod) == 16, "physx_PxBase_Pod has size % instead of 16", size_of(physx_PxBase_Pod));
}

physx_PxSerializationContext_Pod :: struct {
    vtable_: *void;
}
#run {
    instance: physx_PxSerializationContext_Pod;
    assert(((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)) == 0, "physx_PxSerializationContext_Pod.vtable_ has unexpected offset % instead of 0", ((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSerializationContext_Pod.vtable_)) == 8, "physx_PxSerializationContext_Pod.vtable_ has unexpected size % instead of 8", size_of(type_of(physx_PxSerializationContext_Pod.vtable_)));
    assert(size_of(physx_PxSerializationContext_Pod) == 8, "physx_PxSerializationContext_Pod has size % instead of 8", size_of(physx_PxSerializationContext_Pod));
}

physx_PxCollection_Pod :: struct {
    vtable_: *void;
}
#run {
    instance: physx_PxCollection_Pod;
    assert(((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)) == 0, "physx_PxCollection_Pod.vtable_ has unexpected offset % instead of 0", ((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxCollection_Pod.vtable_)) == 8, "physx_PxCollection_Pod.vtable_ has unexpected size % instead of 8", size_of(type_of(physx_PxCollection_Pod.vtable_)));
    assert(size_of(physx_PxCollection_Pod) == 8, "physx_PxCollection_Pod has size % instead of 8", size_of(physx_PxCollection_Pod));
}

physx_PxDeserializationContext_Pod :: struct {
    structgen_pad0:    [8] u8;
    mExtraDataAddress: *u8;
}
#run {
    instance: physx_PxDeserializationContext_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxDeserializationContext_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxDeserializationContext_Pod.structgen_pad0)) == 8, "physx_PxDeserializationContext_Pod.structgen_pad0 has unexpected size % instead of 8", size_of(type_of(physx_PxDeserializationContext_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.mExtraDataAddress)) - cast(*void)(*instance)) == 8, "physx_PxDeserializationContext_Pod.mExtraDataAddress has unexpected offset % instead of 8", ((cast(*void)(*instance.mExtraDataAddress)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxDeserializationContext_Pod.mExtraDataAddress)) == 8, "physx_PxDeserializationContext_Pod.mExtraDataAddress has unexpected size % instead of 8", size_of(type_of(physx_PxDeserializationContext_Pod.mExtraDataAddress)));
    assert(size_of(physx_PxDeserializationContext_Pod) == 16, "physx_PxDeserializationContext_Pod has size % instead of 16", size_of(physx_PxDeserializationContext_Pod));
}

physx_PxSerializationRegistry_Pod :: struct {
    vtable_: *void;
}
#run {
    instance: physx_PxSerializationRegistry_Pod;
    assert(((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)) == 0, "physx_PxSerializationRegistry_Pod.vtable_ has unexpected offset % instead of 0", ((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSerializationRegistry_Pod.vtable_)) == 8, "physx_PxSerializationRegistry_Pod.vtable_ has unexpected size % instead of 8", size_of(type_of(physx_PxSerializationRegistry_Pod.vtable_)));
    assert(size_of(physx_PxSerializationRegistry_Pod) == 8, "physx_PxSerializationRegistry_Pod has size % instead of 8", size_of(physx_PxSerializationRegistry_Pod));
}

physx_PxSerializer_Pod :: struct {
    vtable_: *void;
}
#run {
    instance: physx_PxSerializer_Pod;
    assert(((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)) == 0, "physx_PxSerializer_Pod.vtable_ has unexpected offset % instead of 0", ((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSerializer_Pod.vtable_)) == 8, "physx_PxSerializer_Pod.vtable_ has unexpected size % instead of 8", size_of(type_of(physx_PxSerializer_Pod.vtable_)));
    assert(size_of(physx_PxSerializer_Pod) == 8, "physx_PxSerializer_Pod has size % instead of 8", size_of(physx_PxSerializer_Pod));
}

physx_PxRepXSerializer_Pod :: struct {
    vtable_: *void;
}
#run {
    instance: physx_PxRepXSerializer_Pod;
    assert(((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)) == 0, "physx_PxRepXSerializer_Pod.vtable_ has unexpected offset % instead of 0", ((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxRepXSerializer_Pod.vtable_)) == 8, "physx_PxRepXSerializer_Pod.vtable_ has unexpected size % instead of 8", size_of(type_of(physx_PxRepXSerializer_Pod.vtable_)));
    assert(size_of(physx_PxRepXSerializer_Pod) == 8, "physx_PxRepXSerializer_Pod has size % instead of 8", size_of(physx_PxRepXSerializer_Pod));
}

physx_PxTolerancesScale_Pod :: struct {
    length: float;
    speed:  float;
}
#run {
    instance: physx_PxTolerancesScale_Pod;
    assert(((cast(*void)(*instance.length)) - cast(*void)(*instance)) == 0, "physx_PxTolerancesScale_Pod.length has unexpected offset % instead of 0", ((cast(*void)(*instance.length)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxTolerancesScale_Pod.length)) == 4, "physx_PxTolerancesScale_Pod.length has unexpected size % instead of 4", size_of(type_of(physx_PxTolerancesScale_Pod.length)));
    assert(((cast(*void)(*instance.speed)) - cast(*void)(*instance)) == 4, "physx_PxTolerancesScale_Pod.speed has unexpected offset % instead of 4", ((cast(*void)(*instance.speed)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxTolerancesScale_Pod.speed)) == 4, "physx_PxTolerancesScale_Pod.speed has unexpected size % instead of 4", size_of(type_of(physx_PxTolerancesScale_Pod.speed)));
    assert(size_of(physx_PxTolerancesScale_Pod) == 8, "physx_PxTolerancesScale_Pod has size % instead of 8", size_of(physx_PxTolerancesScale_Pod));
}

physx_PxStringTable_Pod :: struct {
    vtable_: *void;
}
#run {
    instance: physx_PxStringTable_Pod;
    assert(((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)) == 0, "physx_PxStringTable_Pod.vtable_ has unexpected offset % instead of 0", ((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxStringTable_Pod.vtable_)) == 8, "physx_PxStringTable_Pod.vtable_ has unexpected size % instead of 8", size_of(type_of(physx_PxStringTable_Pod.vtable_)));
    assert(size_of(physx_PxStringTable_Pod) == 8, "physx_PxStringTable_Pod has size % instead of 8", size_of(physx_PxStringTable_Pod));
}

physx_PxFoundation_Pod :: struct {
    vtable_: *void;
}
#run {
    instance: physx_PxFoundation_Pod;
    assert(((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)) == 0, "physx_PxFoundation_Pod.vtable_ has unexpected offset % instead of 0", ((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxFoundation_Pod.vtable_)) == 8, "physx_PxFoundation_Pod.vtable_ has unexpected size % instead of 8", size_of(type_of(physx_PxFoundation_Pod.vtable_)));
    assert(size_of(physx_PxFoundation_Pod) == 8, "physx_PxFoundation_Pod has size % instead of 8", size_of(physx_PxFoundation_Pod));
}

physx_PxProfilerCallback_Pod :: struct {
    vtable_: *void;
}
#run {
    instance: physx_PxProfilerCallback_Pod;
    assert(((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)) == 0, "physx_PxProfilerCallback_Pod.vtable_ has unexpected offset % instead of 0", ((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxProfilerCallback_Pod.vtable_)) == 8, "physx_PxProfilerCallback_Pod.vtable_ has unexpected size % instead of 8", size_of(type_of(physx_PxProfilerCallback_Pod.vtable_)));
    assert(size_of(physx_PxProfilerCallback_Pod) == 8, "physx_PxProfilerCallback_Pod has size % instead of 8", size_of(physx_PxProfilerCallback_Pod));
}

physx_PxPhysicsInsertionCallback_Pod :: struct {
    vtable_: *void;
}
#run {
    instance: physx_PxPhysicsInsertionCallback_Pod;
    assert(((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)) == 0, "physx_PxPhysicsInsertionCallback_Pod.vtable_ has unexpected offset % instead of 0", ((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxPhysicsInsertionCallback_Pod.vtable_)) == 8, "physx_PxPhysicsInsertionCallback_Pod.vtable_ has unexpected size % instead of 8", size_of(type_of(physx_PxPhysicsInsertionCallback_Pod.vtable_)));
    assert(size_of(physx_PxPhysicsInsertionCallback_Pod) == 8, "physx_PxPhysicsInsertionCallback_Pod has size % instead of 8", size_of(physx_PxPhysicsInsertionCallback_Pod));
}

physx_PxTaskManager_Pod :: struct {
    vtable_: *void;
}
#run {
    instance: physx_PxTaskManager_Pod;
    assert(((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)) == 0, "physx_PxTaskManager_Pod.vtable_ has unexpected offset % instead of 0", ((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxTaskManager_Pod.vtable_)) == 8, "physx_PxTaskManager_Pod.vtable_ has unexpected size % instead of 8", size_of(type_of(physx_PxTaskManager_Pod.vtable_)));
    assert(size_of(physx_PxTaskManager_Pod) == 8, "physx_PxTaskManager_Pod has size % instead of 8", size_of(physx_PxTaskManager_Pod));
}

physx_PxCpuDispatcher_Pod :: struct {
    vtable_: *void;
}
#run {
    instance: physx_PxCpuDispatcher_Pod;
    assert(((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)) == 0, "physx_PxCpuDispatcher_Pod.vtable_ has unexpected offset % instead of 0", ((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxCpuDispatcher_Pod.vtable_)) == 8, "physx_PxCpuDispatcher_Pod.vtable_ has unexpected size % instead of 8", size_of(type_of(physx_PxCpuDispatcher_Pod.vtable_)));
    assert(size_of(physx_PxCpuDispatcher_Pod) == 8, "physx_PxCpuDispatcher_Pod has size % instead of 8", size_of(physx_PxCpuDispatcher_Pod));
}

physx_PxTask_Pod :: struct {
    structgen_pad0: [8] u8;
    mContextID:     u64;
    mTm:            *physx_PxTaskManager_Pod;
    mTaskID:        u32;
    structgen_pad1: [4] u8;
}
#run {
    instance: physx_PxTask_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxTask_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxTask_Pod.structgen_pad0)) == 8, "physx_PxTask_Pod.structgen_pad0 has unexpected size % instead of 8", size_of(type_of(physx_PxTask_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.mContextID)) - cast(*void)(*instance)) == 8, "physx_PxTask_Pod.mContextID has unexpected offset % instead of 8", ((cast(*void)(*instance.mContextID)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxTask_Pod.mContextID)) == 8, "physx_PxTask_Pod.mContextID has unexpected size % instead of 8", size_of(type_of(physx_PxTask_Pod.mContextID)));
    assert(((cast(*void)(*instance.mTm)) - cast(*void)(*instance)) == 16, "physx_PxTask_Pod.mTm has unexpected offset % instead of 16", ((cast(*void)(*instance.mTm)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxTask_Pod.mTm)) == 8, "physx_PxTask_Pod.mTm has unexpected size % instead of 8", size_of(type_of(physx_PxTask_Pod.mTm)));
    assert(((cast(*void)(*instance.mTaskID)) - cast(*void)(*instance)) == 24, "physx_PxTask_Pod.mTaskID has unexpected offset % instead of 24", ((cast(*void)(*instance.mTaskID)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxTask_Pod.mTaskID)) == 4, "physx_PxTask_Pod.mTaskID has unexpected size % instead of 4", size_of(type_of(physx_PxTask_Pod.mTaskID)));
    assert(((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)) == 28, "physx_PxTask_Pod.structgen_pad1 has unexpected offset % instead of 28", ((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxTask_Pod.structgen_pad1)) == 4, "physx_PxTask_Pod.structgen_pad1 has unexpected size % instead of 4", size_of(type_of(physx_PxTask_Pod.structgen_pad1)));
    assert(size_of(physx_PxTask_Pod) == 32, "physx_PxTask_Pod has size % instead of 32", size_of(physx_PxTask_Pod));
}

physx_PxBaseTask_Pod :: struct {
    structgen_pad0: [8] u8;
    mContextID:     u64;
    mTm:            *physx_PxTaskManager_Pod;
}
#run {
    instance: physx_PxBaseTask_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxBaseTask_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBaseTask_Pod.structgen_pad0)) == 8, "physx_PxBaseTask_Pod.structgen_pad0 has unexpected size % instead of 8", size_of(type_of(physx_PxBaseTask_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.mContextID)) - cast(*void)(*instance)) == 8, "physx_PxBaseTask_Pod.mContextID has unexpected offset % instead of 8", ((cast(*void)(*instance.mContextID)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBaseTask_Pod.mContextID)) == 8, "physx_PxBaseTask_Pod.mContextID has unexpected size % instead of 8", size_of(type_of(physx_PxBaseTask_Pod.mContextID)));
    assert(((cast(*void)(*instance.mTm)) - cast(*void)(*instance)) == 16, "physx_PxBaseTask_Pod.mTm has unexpected offset % instead of 16", ((cast(*void)(*instance.mTm)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBaseTask_Pod.mTm)) == 8, "physx_PxBaseTask_Pod.mTm has unexpected size % instead of 8", size_of(type_of(physx_PxBaseTask_Pod.mTm)));
    assert(size_of(physx_PxBaseTask_Pod) == 24, "physx_PxBaseTask_Pod has size % instead of 24", size_of(physx_PxBaseTask_Pod));
}

physx_PxLightCpuTask_Pod :: struct {
    structgen_pad0: [8] u8;
    mContextID:     u64;
    mTm:            *physx_PxTaskManager_Pod;
    mCont:          *physx_PxBaseTask_Pod;
    mRefCount:      s32;
    structgen_pad1: [4] u8;
}
#run {
    instance: physx_PxLightCpuTask_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxLightCpuTask_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxLightCpuTask_Pod.structgen_pad0)) == 8, "physx_PxLightCpuTask_Pod.structgen_pad0 has unexpected size % instead of 8", size_of(type_of(physx_PxLightCpuTask_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.mContextID)) - cast(*void)(*instance)) == 8, "physx_PxLightCpuTask_Pod.mContextID has unexpected offset % instead of 8", ((cast(*void)(*instance.mContextID)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxLightCpuTask_Pod.mContextID)) == 8, "physx_PxLightCpuTask_Pod.mContextID has unexpected size % instead of 8", size_of(type_of(physx_PxLightCpuTask_Pod.mContextID)));
    assert(((cast(*void)(*instance.mTm)) - cast(*void)(*instance)) == 16, "physx_PxLightCpuTask_Pod.mTm has unexpected offset % instead of 16", ((cast(*void)(*instance.mTm)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxLightCpuTask_Pod.mTm)) == 8, "physx_PxLightCpuTask_Pod.mTm has unexpected size % instead of 8", size_of(type_of(physx_PxLightCpuTask_Pod.mTm)));
    assert(((cast(*void)(*instance.mCont)) - cast(*void)(*instance)) == 24, "physx_PxLightCpuTask_Pod.mCont has unexpected offset % instead of 24", ((cast(*void)(*instance.mCont)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxLightCpuTask_Pod.mCont)) == 8, "physx_PxLightCpuTask_Pod.mCont has unexpected size % instead of 8", size_of(type_of(physx_PxLightCpuTask_Pod.mCont)));
    assert(((cast(*void)(*instance.mRefCount)) - cast(*void)(*instance)) == 32, "physx_PxLightCpuTask_Pod.mRefCount has unexpected offset % instead of 32", ((cast(*void)(*instance.mRefCount)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxLightCpuTask_Pod.mRefCount)) == 4, "physx_PxLightCpuTask_Pod.mRefCount has unexpected size % instead of 4", size_of(type_of(physx_PxLightCpuTask_Pod.mRefCount)));
    assert(((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)) == 36, "physx_PxLightCpuTask_Pod.structgen_pad1 has unexpected offset % instead of 36", ((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxLightCpuTask_Pod.structgen_pad1)) == 4, "physx_PxLightCpuTask_Pod.structgen_pad1 has unexpected size % instead of 4", size_of(type_of(physx_PxLightCpuTask_Pod.structgen_pad1)));
    assert(size_of(physx_PxLightCpuTask_Pod) == 40, "physx_PxLightCpuTask_Pod has size % instead of 40", size_of(physx_PxLightCpuTask_Pod));
}

physx_PxGeometry_Pod :: struct {
    mType: s32;
}
#run {
    instance: physx_PxGeometry_Pod;
    assert(((cast(*void)(*instance.mType)) - cast(*void)(*instance)) == 0, "physx_PxGeometry_Pod.mType has unexpected offset % instead of 0", ((cast(*void)(*instance.mType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxGeometry_Pod.mType)) == 4, "physx_PxGeometry_Pod.mType has unexpected size % instead of 4", size_of(type_of(physx_PxGeometry_Pod.mType)));
    assert(size_of(physx_PxGeometry_Pod) == 4, "physx_PxGeometry_Pod has size % instead of 4", size_of(physx_PxGeometry_Pod));
}

physx_PxBoxGeometry_Pod :: struct {
    mType:       s32;
    halfExtents: physx_PxVec3_Pod;
}
#run {
    instance: physx_PxBoxGeometry_Pod;
    assert(((cast(*void)(*instance.mType)) - cast(*void)(*instance)) == 0, "physx_PxBoxGeometry_Pod.mType has unexpected offset % instead of 0", ((cast(*void)(*instance.mType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBoxGeometry_Pod.mType)) == 4, "physx_PxBoxGeometry_Pod.mType has unexpected size % instead of 4", size_of(type_of(physx_PxBoxGeometry_Pod.mType)));
    assert(((cast(*void)(*instance.halfExtents)) - cast(*void)(*instance)) == 4, "physx_PxBoxGeometry_Pod.halfExtents has unexpected offset % instead of 4", ((cast(*void)(*instance.halfExtents)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBoxGeometry_Pod.halfExtents)) == 12, "physx_PxBoxGeometry_Pod.halfExtents has unexpected size % instead of 12", size_of(type_of(physx_PxBoxGeometry_Pod.halfExtents)));
    assert(size_of(physx_PxBoxGeometry_Pod) == 16, "physx_PxBoxGeometry_Pod has size % instead of 16", size_of(physx_PxBoxGeometry_Pod));
}

physx_PxBVHStructure_Pod :: struct {
    structgen_pad0: [8] u8;
    mConcreteType:  u16;
    mBaseFlags:     physx_PxBaseFlags_Pod;
    structgen_pad1: [4] u8;
}
#run {
    instance: physx_PxBVHStructure_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxBVHStructure_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBVHStructure_Pod.structgen_pad0)) == 8, "physx_PxBVHStructure_Pod.structgen_pad0 has unexpected size % instead of 8", size_of(type_of(physx_PxBVHStructure_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)) == 8, "physx_PxBVHStructure_Pod.mConcreteType has unexpected offset % instead of 8", ((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBVHStructure_Pod.mConcreteType)) == 2, "physx_PxBVHStructure_Pod.mConcreteType has unexpected size % instead of 2", size_of(type_of(physx_PxBVHStructure_Pod.mConcreteType)));
    assert(((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)) == 10, "physx_PxBVHStructure_Pod.mBaseFlags has unexpected offset % instead of 10", ((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBVHStructure_Pod.mBaseFlags)) == 2, "physx_PxBVHStructure_Pod.mBaseFlags has unexpected size % instead of 2", size_of(type_of(physx_PxBVHStructure_Pod.mBaseFlags)));
    assert(((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)) == 12, "physx_PxBVHStructure_Pod.structgen_pad1 has unexpected offset % instead of 12", ((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBVHStructure_Pod.structgen_pad1)) == 4, "physx_PxBVHStructure_Pod.structgen_pad1 has unexpected size % instead of 4", size_of(type_of(physx_PxBVHStructure_Pod.structgen_pad1)));
    assert(size_of(physx_PxBVHStructure_Pod) == 16, "physx_PxBVHStructure_Pod has size % instead of 16", size_of(physx_PxBVHStructure_Pod));
}

physx_PxCapsuleGeometry_Pod :: struct {
    mType:      s32;
    radius:     float;
    halfHeight: float;
}
#run {
    instance: physx_PxCapsuleGeometry_Pod;
    assert(((cast(*void)(*instance.mType)) - cast(*void)(*instance)) == 0, "physx_PxCapsuleGeometry_Pod.mType has unexpected offset % instead of 0", ((cast(*void)(*instance.mType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxCapsuleGeometry_Pod.mType)) == 4, "physx_PxCapsuleGeometry_Pod.mType has unexpected size % instead of 4", size_of(type_of(physx_PxCapsuleGeometry_Pod.mType)));
    assert(((cast(*void)(*instance.radius)) - cast(*void)(*instance)) == 4, "physx_PxCapsuleGeometry_Pod.radius has unexpected offset % instead of 4", ((cast(*void)(*instance.radius)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxCapsuleGeometry_Pod.radius)) == 4, "physx_PxCapsuleGeometry_Pod.radius has unexpected size % instead of 4", size_of(type_of(physx_PxCapsuleGeometry_Pod.radius)));
    assert(((cast(*void)(*instance.halfHeight)) - cast(*void)(*instance)) == 8, "physx_PxCapsuleGeometry_Pod.halfHeight has unexpected offset % instead of 8", ((cast(*void)(*instance.halfHeight)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxCapsuleGeometry_Pod.halfHeight)) == 4, "physx_PxCapsuleGeometry_Pod.halfHeight has unexpected size % instead of 4", size_of(type_of(physx_PxCapsuleGeometry_Pod.halfHeight)));
    assert(size_of(physx_PxCapsuleGeometry_Pod) == 12, "physx_PxCapsuleGeometry_Pod has size % instead of 12", size_of(physx_PxCapsuleGeometry_Pod));
}

physx_PxConvexMesh_Pod :: struct {
    structgen_pad0: [8] u8;
    mConcreteType:  u16;
    mBaseFlags:     physx_PxBaseFlags_Pod;
    structgen_pad1: [4] u8;
}
#run {
    instance: physx_PxConvexMesh_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxConvexMesh_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxConvexMesh_Pod.structgen_pad0)) == 8, "physx_PxConvexMesh_Pod.structgen_pad0 has unexpected size % instead of 8", size_of(type_of(physx_PxConvexMesh_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)) == 8, "physx_PxConvexMesh_Pod.mConcreteType has unexpected offset % instead of 8", ((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxConvexMesh_Pod.mConcreteType)) == 2, "physx_PxConvexMesh_Pod.mConcreteType has unexpected size % instead of 2", size_of(type_of(physx_PxConvexMesh_Pod.mConcreteType)));
    assert(((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)) == 10, "physx_PxConvexMesh_Pod.mBaseFlags has unexpected offset % instead of 10", ((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxConvexMesh_Pod.mBaseFlags)) == 2, "physx_PxConvexMesh_Pod.mBaseFlags has unexpected size % instead of 2", size_of(type_of(physx_PxConvexMesh_Pod.mBaseFlags)));
    assert(((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)) == 12, "physx_PxConvexMesh_Pod.structgen_pad1 has unexpected offset % instead of 12", ((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxConvexMesh_Pod.structgen_pad1)) == 4, "physx_PxConvexMesh_Pod.structgen_pad1 has unexpected size % instead of 4", size_of(type_of(physx_PxConvexMesh_Pod.structgen_pad1)));
    assert(size_of(physx_PxConvexMesh_Pod) == 16, "physx_PxConvexMesh_Pod has size % instead of 16", size_of(physx_PxConvexMesh_Pod));
}

physx_PxHullPolygon_Pod :: struct {
    mPlane:     [4] float;
    mNbVerts:   u16;
    mIndexBase: u16;
}
#run {
    instance: physx_PxHullPolygon_Pod;
    assert(((cast(*void)(*instance.mPlane)) - cast(*void)(*instance)) == 0, "physx_PxHullPolygon_Pod.mPlane has unexpected offset % instead of 0", ((cast(*void)(*instance.mPlane)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxHullPolygon_Pod.mPlane)) == 16, "physx_PxHullPolygon_Pod.mPlane has unexpected size % instead of 16", size_of(type_of(physx_PxHullPolygon_Pod.mPlane)));
    assert(((cast(*void)(*instance.mNbVerts)) - cast(*void)(*instance)) == 16, "physx_PxHullPolygon_Pod.mNbVerts has unexpected offset % instead of 16", ((cast(*void)(*instance.mNbVerts)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxHullPolygon_Pod.mNbVerts)) == 2, "physx_PxHullPolygon_Pod.mNbVerts has unexpected size % instead of 2", size_of(type_of(physx_PxHullPolygon_Pod.mNbVerts)));
    assert(((cast(*void)(*instance.mIndexBase)) - cast(*void)(*instance)) == 18, "physx_PxHullPolygon_Pod.mIndexBase has unexpected offset % instead of 18", ((cast(*void)(*instance.mIndexBase)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxHullPolygon_Pod.mIndexBase)) == 2, "physx_PxHullPolygon_Pod.mIndexBase has unexpected size % instead of 2", size_of(type_of(physx_PxHullPolygon_Pod.mIndexBase)));
    assert(size_of(physx_PxHullPolygon_Pod) == 20, "physx_PxHullPolygon_Pod has size % instead of 20", size_of(physx_PxHullPolygon_Pod));
}

physx_PxMeshScale_Pod :: struct {
    scale:    physx_PxVec3_Pod;
    rotation: physx_PxQuat_Pod;
}
#run {
    instance: physx_PxMeshScale_Pod;
    assert(((cast(*void)(*instance.scale)) - cast(*void)(*instance)) == 0, "physx_PxMeshScale_Pod.scale has unexpected offset % instead of 0", ((cast(*void)(*instance.scale)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxMeshScale_Pod.scale)) == 12, "physx_PxMeshScale_Pod.scale has unexpected size % instead of 12", size_of(type_of(physx_PxMeshScale_Pod.scale)));
    assert(((cast(*void)(*instance.rotation)) - cast(*void)(*instance)) == 12, "physx_PxMeshScale_Pod.rotation has unexpected offset % instead of 12", ((cast(*void)(*instance.rotation)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxMeshScale_Pod.rotation)) == 16, "physx_PxMeshScale_Pod.rotation has unexpected size % instead of 16", size_of(type_of(physx_PxMeshScale_Pod.rotation)));
    assert(size_of(physx_PxMeshScale_Pod) == 28, "physx_PxMeshScale_Pod has size % instead of 28", size_of(physx_PxMeshScale_Pod));
}

physx_PxConvexMeshGeometryFlags_Pod :: struct {
    mBits: u8;
}
#run {
    instance: physx_PxConvexMeshGeometryFlags_Pod;
    assert(((cast(*void)(*instance.mBits)) - cast(*void)(*instance)) == 0, "physx_PxConvexMeshGeometryFlags_Pod.mBits has unexpected offset % instead of 0", ((cast(*void)(*instance.mBits)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxConvexMeshGeometryFlags_Pod.mBits)) == 1, "physx_PxConvexMeshGeometryFlags_Pod.mBits has unexpected size % instead of 1", size_of(type_of(physx_PxConvexMeshGeometryFlags_Pod.mBits)));
    assert(size_of(physx_PxConvexMeshGeometryFlags_Pod) == 1, "physx_PxConvexMeshGeometryFlags_Pod has size % instead of 1", size_of(physx_PxConvexMeshGeometryFlags_Pod));
}

PxPadding_3__Pod :: struct {
    mPadding: [3] u8;
}
#run {
    instance: PxPadding_3__Pod;
    assert(((cast(*void)(*instance.mPadding)) - cast(*void)(*instance)) == 0, "PxPadding_3__Pod.mPadding has unexpected offset % instead of 0", ((cast(*void)(*instance.mPadding)) - cast(*void)(*instance)));
    assert(size_of(type_of(PxPadding_3__Pod.mPadding)) == 3, "PxPadding_3__Pod.mPadding has unexpected size % instead of 3", size_of(type_of(PxPadding_3__Pod.mPadding)));
    assert(size_of(PxPadding_3__Pod) == 3, "PxPadding_3__Pod has size % instead of 3", size_of(PxPadding_3__Pod));
}

physx_PxConvexMeshGeometry_Pod :: struct {
    mType:            s32;
    scale:            physx_PxMeshScale_Pod;
    convexMesh:       *physx_PxConvexMesh_Pod;
    meshFlags:        physx_PxConvexMeshGeometryFlags_Pod;
    paddingFromFlags: PxPadding_3__Pod;
    structgen_pad0:   [4] u8;
}
#run {
    instance: physx_PxConvexMeshGeometry_Pod;
    assert(((cast(*void)(*instance.mType)) - cast(*void)(*instance)) == 0, "physx_PxConvexMeshGeometry_Pod.mType has unexpected offset % instead of 0", ((cast(*void)(*instance.mType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxConvexMeshGeometry_Pod.mType)) == 4, "physx_PxConvexMeshGeometry_Pod.mType has unexpected size % instead of 4", size_of(type_of(physx_PxConvexMeshGeometry_Pod.mType)));
    assert(((cast(*void)(*instance.scale)) - cast(*void)(*instance)) == 4, "physx_PxConvexMeshGeometry_Pod.scale has unexpected offset % instead of 4", ((cast(*void)(*instance.scale)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxConvexMeshGeometry_Pod.scale)) == 28, "physx_PxConvexMeshGeometry_Pod.scale has unexpected size % instead of 28", size_of(type_of(physx_PxConvexMeshGeometry_Pod.scale)));
    assert(((cast(*void)(*instance.convexMesh)) - cast(*void)(*instance)) == 32, "physx_PxConvexMeshGeometry_Pod.convexMesh has unexpected offset % instead of 32", ((cast(*void)(*instance.convexMesh)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxConvexMeshGeometry_Pod.convexMesh)) == 8, "physx_PxConvexMeshGeometry_Pod.convexMesh has unexpected size % instead of 8", size_of(type_of(physx_PxConvexMeshGeometry_Pod.convexMesh)));
    assert(((cast(*void)(*instance.meshFlags)) - cast(*void)(*instance)) == 40, "physx_PxConvexMeshGeometry_Pod.meshFlags has unexpected offset % instead of 40", ((cast(*void)(*instance.meshFlags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxConvexMeshGeometry_Pod.meshFlags)) == 1, "physx_PxConvexMeshGeometry_Pod.meshFlags has unexpected size % instead of 1", size_of(type_of(physx_PxConvexMeshGeometry_Pod.meshFlags)));
    assert(((cast(*void)(*instance.paddingFromFlags)) - cast(*void)(*instance)) == 41, "physx_PxConvexMeshGeometry_Pod.paddingFromFlags has unexpected offset % instead of 41", ((cast(*void)(*instance.paddingFromFlags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxConvexMeshGeometry_Pod.paddingFromFlags)) == 3, "physx_PxConvexMeshGeometry_Pod.paddingFromFlags has unexpected size % instead of 3", size_of(type_of(physx_PxConvexMeshGeometry_Pod.paddingFromFlags)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 44, "physx_PxConvexMeshGeometry_Pod.structgen_pad0 has unexpected offset % instead of 44", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxConvexMeshGeometry_Pod.structgen_pad0)) == 4, "physx_PxConvexMeshGeometry_Pod.structgen_pad0 has unexpected size % instead of 4", size_of(type_of(physx_PxConvexMeshGeometry_Pod.structgen_pad0)));
    assert(size_of(physx_PxConvexMeshGeometry_Pod) == 48, "physx_PxConvexMeshGeometry_Pod has size % instead of 48", size_of(physx_PxConvexMeshGeometry_Pod));
}

physx_PxSphereGeometry_Pod :: struct {
    mType:  s32;
    radius: float;
}
#run {
    instance: physx_PxSphereGeometry_Pod;
    assert(((cast(*void)(*instance.mType)) - cast(*void)(*instance)) == 0, "physx_PxSphereGeometry_Pod.mType has unexpected offset % instead of 0", ((cast(*void)(*instance.mType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSphereGeometry_Pod.mType)) == 4, "physx_PxSphereGeometry_Pod.mType has unexpected size % instead of 4", size_of(type_of(physx_PxSphereGeometry_Pod.mType)));
    assert(((cast(*void)(*instance.radius)) - cast(*void)(*instance)) == 4, "physx_PxSphereGeometry_Pod.radius has unexpected offset % instead of 4", ((cast(*void)(*instance.radius)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSphereGeometry_Pod.radius)) == 4, "physx_PxSphereGeometry_Pod.radius has unexpected size % instead of 4", size_of(type_of(physx_PxSphereGeometry_Pod.radius)));
    assert(size_of(physx_PxSphereGeometry_Pod) == 8, "physx_PxSphereGeometry_Pod has size % instead of 8", size_of(physx_PxSphereGeometry_Pod));
}

physx_PxPlaneGeometry_Pod :: struct {
    mType: s32;
}
#run {
    instance: physx_PxPlaneGeometry_Pod;
    assert(((cast(*void)(*instance.mType)) - cast(*void)(*instance)) == 0, "physx_PxPlaneGeometry_Pod.mType has unexpected offset % instead of 0", ((cast(*void)(*instance.mType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxPlaneGeometry_Pod.mType)) == 4, "physx_PxPlaneGeometry_Pod.mType has unexpected size % instead of 4", size_of(type_of(physx_PxPlaneGeometry_Pod.mType)));
    assert(size_of(physx_PxPlaneGeometry_Pod) == 4, "physx_PxPlaneGeometry_Pod has size % instead of 4", size_of(physx_PxPlaneGeometry_Pod));
}

physx_PxMeshGeometryFlags_Pod :: struct {
    mBits: u8;
}
#run {
    instance: physx_PxMeshGeometryFlags_Pod;
    assert(((cast(*void)(*instance.mBits)) - cast(*void)(*instance)) == 0, "physx_PxMeshGeometryFlags_Pod.mBits has unexpected offset % instead of 0", ((cast(*void)(*instance.mBits)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxMeshGeometryFlags_Pod.mBits)) == 1, "physx_PxMeshGeometryFlags_Pod.mBits has unexpected size % instead of 1", size_of(type_of(physx_PxMeshGeometryFlags_Pod.mBits)));
    assert(size_of(physx_PxMeshGeometryFlags_Pod) == 1, "physx_PxMeshGeometryFlags_Pod has size % instead of 1", size_of(physx_PxMeshGeometryFlags_Pod));
}

physx_PxTriangleMesh_Pod :: struct {
    structgen_pad0: [8] u8;
    mConcreteType:  u16;
    mBaseFlags:     physx_PxBaseFlags_Pod;
    structgen_pad1: [4] u8;
}
#run {
    instance: physx_PxTriangleMesh_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxTriangleMesh_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxTriangleMesh_Pod.structgen_pad0)) == 8, "physx_PxTriangleMesh_Pod.structgen_pad0 has unexpected size % instead of 8", size_of(type_of(physx_PxTriangleMesh_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)) == 8, "physx_PxTriangleMesh_Pod.mConcreteType has unexpected offset % instead of 8", ((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxTriangleMesh_Pod.mConcreteType)) == 2, "physx_PxTriangleMesh_Pod.mConcreteType has unexpected size % instead of 2", size_of(type_of(physx_PxTriangleMesh_Pod.mConcreteType)));
    assert(((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)) == 10, "physx_PxTriangleMesh_Pod.mBaseFlags has unexpected offset % instead of 10", ((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxTriangleMesh_Pod.mBaseFlags)) == 2, "physx_PxTriangleMesh_Pod.mBaseFlags has unexpected size % instead of 2", size_of(type_of(physx_PxTriangleMesh_Pod.mBaseFlags)));
    assert(((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)) == 12, "physx_PxTriangleMesh_Pod.structgen_pad1 has unexpected offset % instead of 12", ((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxTriangleMesh_Pod.structgen_pad1)) == 4, "physx_PxTriangleMesh_Pod.structgen_pad1 has unexpected size % instead of 4", size_of(type_of(physx_PxTriangleMesh_Pod.structgen_pad1)));
    assert(size_of(physx_PxTriangleMesh_Pod) == 16, "physx_PxTriangleMesh_Pod has size % instead of 16", size_of(physx_PxTriangleMesh_Pod));
}

physx_PxTriangleMeshGeometry_Pod :: struct {
    mType:            s32;
    scale:            physx_PxMeshScale_Pod;
    meshFlags:        physx_PxMeshGeometryFlags_Pod;
    paddingFromFlags: PxPadding_3__Pod;
    structgen_pad0:   [4] u8;
    triangleMesh:     *physx_PxTriangleMesh_Pod;
}
#run {
    instance: physx_PxTriangleMeshGeometry_Pod;
    assert(((cast(*void)(*instance.mType)) - cast(*void)(*instance)) == 0, "physx_PxTriangleMeshGeometry_Pod.mType has unexpected offset % instead of 0", ((cast(*void)(*instance.mType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxTriangleMeshGeometry_Pod.mType)) == 4, "physx_PxTriangleMeshGeometry_Pod.mType has unexpected size % instead of 4", size_of(type_of(physx_PxTriangleMeshGeometry_Pod.mType)));
    assert(((cast(*void)(*instance.scale)) - cast(*void)(*instance)) == 4, "physx_PxTriangleMeshGeometry_Pod.scale has unexpected offset % instead of 4", ((cast(*void)(*instance.scale)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxTriangleMeshGeometry_Pod.scale)) == 28, "physx_PxTriangleMeshGeometry_Pod.scale has unexpected size % instead of 28", size_of(type_of(physx_PxTriangleMeshGeometry_Pod.scale)));
    assert(((cast(*void)(*instance.meshFlags)) - cast(*void)(*instance)) == 32, "physx_PxTriangleMeshGeometry_Pod.meshFlags has unexpected offset % instead of 32", ((cast(*void)(*instance.meshFlags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxTriangleMeshGeometry_Pod.meshFlags)) == 1, "physx_PxTriangleMeshGeometry_Pod.meshFlags has unexpected size % instead of 1", size_of(type_of(physx_PxTriangleMeshGeometry_Pod.meshFlags)));
    assert(((cast(*void)(*instance.paddingFromFlags)) - cast(*void)(*instance)) == 33, "physx_PxTriangleMeshGeometry_Pod.paddingFromFlags has unexpected offset % instead of 33", ((cast(*void)(*instance.paddingFromFlags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxTriangleMeshGeometry_Pod.paddingFromFlags)) == 3, "physx_PxTriangleMeshGeometry_Pod.paddingFromFlags has unexpected size % instead of 3", size_of(type_of(physx_PxTriangleMeshGeometry_Pod.paddingFromFlags)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 36, "physx_PxTriangleMeshGeometry_Pod.structgen_pad0 has unexpected offset % instead of 36", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxTriangleMeshGeometry_Pod.structgen_pad0)) == 4, "physx_PxTriangleMeshGeometry_Pod.structgen_pad0 has unexpected size % instead of 4", size_of(type_of(physx_PxTriangleMeshGeometry_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.triangleMesh)) - cast(*void)(*instance)) == 40, "physx_PxTriangleMeshGeometry_Pod.triangleMesh has unexpected offset % instead of 40", ((cast(*void)(*instance.triangleMesh)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxTriangleMeshGeometry_Pod.triangleMesh)) == 8, "physx_PxTriangleMeshGeometry_Pod.triangleMesh has unexpected size % instead of 8", size_of(type_of(physx_PxTriangleMeshGeometry_Pod.triangleMesh)));
    assert(size_of(physx_PxTriangleMeshGeometry_Pod) == 48, "physx_PxTriangleMeshGeometry_Pod has size % instead of 48", size_of(physx_PxTriangleMeshGeometry_Pod));
}

physx_PxHeightField_Pod :: struct {
    structgen_pad0: [8] u8;
    mConcreteType:  u16;
    mBaseFlags:     physx_PxBaseFlags_Pod;
    structgen_pad1: [4] u8;
}
#run {
    instance: physx_PxHeightField_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxHeightField_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxHeightField_Pod.structgen_pad0)) == 8, "physx_PxHeightField_Pod.structgen_pad0 has unexpected size % instead of 8", size_of(type_of(physx_PxHeightField_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)) == 8, "physx_PxHeightField_Pod.mConcreteType has unexpected offset % instead of 8", ((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxHeightField_Pod.mConcreteType)) == 2, "physx_PxHeightField_Pod.mConcreteType has unexpected size % instead of 2", size_of(type_of(physx_PxHeightField_Pod.mConcreteType)));
    assert(((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)) == 10, "physx_PxHeightField_Pod.mBaseFlags has unexpected offset % instead of 10", ((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxHeightField_Pod.mBaseFlags)) == 2, "physx_PxHeightField_Pod.mBaseFlags has unexpected size % instead of 2", size_of(type_of(physx_PxHeightField_Pod.mBaseFlags)));
    assert(((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)) == 12, "physx_PxHeightField_Pod.structgen_pad1 has unexpected offset % instead of 12", ((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxHeightField_Pod.structgen_pad1)) == 4, "physx_PxHeightField_Pod.structgen_pad1 has unexpected size % instead of 4", size_of(type_of(physx_PxHeightField_Pod.structgen_pad1)));
    assert(size_of(physx_PxHeightField_Pod) == 16, "physx_PxHeightField_Pod has size % instead of 16", size_of(physx_PxHeightField_Pod));
}

physx_PxHeightFieldGeometry_Pod :: struct {
    mType:            s32;
    structgen_pad0:   [4] u8;
    heightField:      *physx_PxHeightField_Pod;
    heightScale:      float;
    rowScale:         float;
    columnScale:      float;
    heightFieldFlags: physx_PxMeshGeometryFlags_Pod;
    paddingFromFlags: PxPadding_3__Pod;
}
#run {
    instance: physx_PxHeightFieldGeometry_Pod;
    assert(((cast(*void)(*instance.mType)) - cast(*void)(*instance)) == 0, "physx_PxHeightFieldGeometry_Pod.mType has unexpected offset % instead of 0", ((cast(*void)(*instance.mType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxHeightFieldGeometry_Pod.mType)) == 4, "physx_PxHeightFieldGeometry_Pod.mType has unexpected size % instead of 4", size_of(type_of(physx_PxHeightFieldGeometry_Pod.mType)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 4, "physx_PxHeightFieldGeometry_Pod.structgen_pad0 has unexpected offset % instead of 4", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxHeightFieldGeometry_Pod.structgen_pad0)) == 4, "physx_PxHeightFieldGeometry_Pod.structgen_pad0 has unexpected size % instead of 4", size_of(type_of(physx_PxHeightFieldGeometry_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.heightField)) - cast(*void)(*instance)) == 8, "physx_PxHeightFieldGeometry_Pod.heightField has unexpected offset % instead of 8", ((cast(*void)(*instance.heightField)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxHeightFieldGeometry_Pod.heightField)) == 8, "physx_PxHeightFieldGeometry_Pod.heightField has unexpected size % instead of 8", size_of(type_of(physx_PxHeightFieldGeometry_Pod.heightField)));
    assert(((cast(*void)(*instance.heightScale)) - cast(*void)(*instance)) == 16, "physx_PxHeightFieldGeometry_Pod.heightScale has unexpected offset % instead of 16", ((cast(*void)(*instance.heightScale)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxHeightFieldGeometry_Pod.heightScale)) == 4, "physx_PxHeightFieldGeometry_Pod.heightScale has unexpected size % instead of 4", size_of(type_of(physx_PxHeightFieldGeometry_Pod.heightScale)));
    assert(((cast(*void)(*instance.rowScale)) - cast(*void)(*instance)) == 20, "physx_PxHeightFieldGeometry_Pod.rowScale has unexpected offset % instead of 20", ((cast(*void)(*instance.rowScale)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxHeightFieldGeometry_Pod.rowScale)) == 4, "physx_PxHeightFieldGeometry_Pod.rowScale has unexpected size % instead of 4", size_of(type_of(physx_PxHeightFieldGeometry_Pod.rowScale)));
    assert(((cast(*void)(*instance.columnScale)) - cast(*void)(*instance)) == 24, "physx_PxHeightFieldGeometry_Pod.columnScale has unexpected offset % instead of 24", ((cast(*void)(*instance.columnScale)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxHeightFieldGeometry_Pod.columnScale)) == 4, "physx_PxHeightFieldGeometry_Pod.columnScale has unexpected size % instead of 4", size_of(type_of(physx_PxHeightFieldGeometry_Pod.columnScale)));
    assert(((cast(*void)(*instance.heightFieldFlags)) - cast(*void)(*instance)) == 28, "physx_PxHeightFieldGeometry_Pod.heightFieldFlags has unexpected offset % instead of 28", ((cast(*void)(*instance.heightFieldFlags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxHeightFieldGeometry_Pod.heightFieldFlags)) == 1, "physx_PxHeightFieldGeometry_Pod.heightFieldFlags has unexpected size % instead of 1", size_of(type_of(physx_PxHeightFieldGeometry_Pod.heightFieldFlags)));
    assert(((cast(*void)(*instance.paddingFromFlags)) - cast(*void)(*instance)) == 29, "physx_PxHeightFieldGeometry_Pod.paddingFromFlags has unexpected offset % instead of 29", ((cast(*void)(*instance.paddingFromFlags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxHeightFieldGeometry_Pod.paddingFromFlags)) == 3, "physx_PxHeightFieldGeometry_Pod.paddingFromFlags has unexpected size % instead of 3", size_of(type_of(physx_PxHeightFieldGeometry_Pod.paddingFromFlags)));
    assert(size_of(physx_PxHeightFieldGeometry_Pod) == 32, "physx_PxHeightFieldGeometry_Pod has size % instead of 32", size_of(physx_PxHeightFieldGeometry_Pod));
}

Anonymous59_Pod :: struct {
    geometry:    [4] u8;
    box:         [16] u8;
    sphere:      [8] u8;
    capsule:     [12] u8;
    plane:       [4] u8;
    convex:      [48] u8;
    mesh:        [48] u8;
    heightfield: [32] u8;
}
#run {
    instance: Anonymous59_Pod;
    assert(((cast(*void)(*instance.geometry)) - cast(*void)(*instance)) == 0, "Anonymous59_Pod.geometry has unexpected offset % instead of 0", ((cast(*void)(*instance.geometry)) - cast(*void)(*instance)));
    assert(size_of(type_of(Anonymous59_Pod.geometry)) == 4, "Anonymous59_Pod.geometry has unexpected size % instead of 4", size_of(type_of(Anonymous59_Pod.geometry)));
    assert(((cast(*void)(*instance.box)) - cast(*void)(*instance)) == 4, "Anonymous59_Pod.box has unexpected offset % instead of 4", ((cast(*void)(*instance.box)) - cast(*void)(*instance)));
    assert(size_of(type_of(Anonymous59_Pod.box)) == 16, "Anonymous59_Pod.box has unexpected size % instead of 16", size_of(type_of(Anonymous59_Pod.box)));
    assert(((cast(*void)(*instance.sphere)) - cast(*void)(*instance)) == 20, "Anonymous59_Pod.sphere has unexpected offset % instead of 20", ((cast(*void)(*instance.sphere)) - cast(*void)(*instance)));
    assert(size_of(type_of(Anonymous59_Pod.sphere)) == 8, "Anonymous59_Pod.sphere has unexpected size % instead of 8", size_of(type_of(Anonymous59_Pod.sphere)));
    assert(((cast(*void)(*instance.capsule)) - cast(*void)(*instance)) == 28, "Anonymous59_Pod.capsule has unexpected offset % instead of 28", ((cast(*void)(*instance.capsule)) - cast(*void)(*instance)));
    assert(size_of(type_of(Anonymous59_Pod.capsule)) == 12, "Anonymous59_Pod.capsule has unexpected size % instead of 12", size_of(type_of(Anonymous59_Pod.capsule)));
    assert(((cast(*void)(*instance.plane)) - cast(*void)(*instance)) == 40, "Anonymous59_Pod.plane has unexpected offset % instead of 40", ((cast(*void)(*instance.plane)) - cast(*void)(*instance)));
    assert(size_of(type_of(Anonymous59_Pod.plane)) == 4, "Anonymous59_Pod.plane has unexpected size % instead of 4", size_of(type_of(Anonymous59_Pod.plane)));
    assert(((cast(*void)(*instance.convex)) - cast(*void)(*instance)) == 44, "Anonymous59_Pod.convex has unexpected offset % instead of 44", ((cast(*void)(*instance.convex)) - cast(*void)(*instance)));
    assert(size_of(type_of(Anonymous59_Pod.convex)) == 48, "Anonymous59_Pod.convex has unexpected size % instead of 48", size_of(type_of(Anonymous59_Pod.convex)));
    assert(((cast(*void)(*instance.mesh)) - cast(*void)(*instance)) == 92, "Anonymous59_Pod.mesh has unexpected offset % instead of 92", ((cast(*void)(*instance.mesh)) - cast(*void)(*instance)));
    assert(size_of(type_of(Anonymous59_Pod.mesh)) == 48, "Anonymous59_Pod.mesh has unexpected size % instead of 48", size_of(type_of(Anonymous59_Pod.mesh)));
    assert(((cast(*void)(*instance.heightfield)) - cast(*void)(*instance)) == 140, "Anonymous59_Pod.heightfield has unexpected offset % instead of 140", ((cast(*void)(*instance.heightfield)) - cast(*void)(*instance)));
    assert(size_of(type_of(Anonymous59_Pod.heightfield)) == 32, "Anonymous59_Pod.heightfield has unexpected size % instead of 32", size_of(type_of(Anonymous59_Pod.heightfield)));
    assert(size_of(Anonymous59_Pod) == 172, "Anonymous59_Pod has size % instead of 172", size_of(Anonymous59_Pod));
}

physx_PxGeometryHolder_Pod :: struct {
    structgen_pad0: [48] u8;
}
#run {
    instance: physx_PxGeometryHolder_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxGeometryHolder_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxGeometryHolder_Pod.structgen_pad0)) == 48, "physx_PxGeometryHolder_Pod.structgen_pad0 has unexpected size % instead of 48", size_of(type_of(physx_PxGeometryHolder_Pod.structgen_pad0)));
    assert(size_of(physx_PxGeometryHolder_Pod) == 48, "physx_PxGeometryHolder_Pod has size % instead of 48", size_of(physx_PxGeometryHolder_Pod));
}

physx_PxRigidActor_Pod :: struct {
    structgen_pad0: [8] u8;
    mConcreteType:  u16;
    mBaseFlags:     physx_PxBaseFlags_Pod;
    structgen_pad1: [4] u8;
    userData:       *void;
}
#run {
    instance: physx_PxRigidActor_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxRigidActor_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxRigidActor_Pod.structgen_pad0)) == 8, "physx_PxRigidActor_Pod.structgen_pad0 has unexpected size % instead of 8", size_of(type_of(physx_PxRigidActor_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)) == 8, "physx_PxRigidActor_Pod.mConcreteType has unexpected offset % instead of 8", ((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxRigidActor_Pod.mConcreteType)) == 2, "physx_PxRigidActor_Pod.mConcreteType has unexpected size % instead of 2", size_of(type_of(physx_PxRigidActor_Pod.mConcreteType)));
    assert(((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)) == 10, "physx_PxRigidActor_Pod.mBaseFlags has unexpected offset % instead of 10", ((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxRigidActor_Pod.mBaseFlags)) == 2, "physx_PxRigidActor_Pod.mBaseFlags has unexpected size % instead of 2", size_of(type_of(physx_PxRigidActor_Pod.mBaseFlags)));
    assert(((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)) == 12, "physx_PxRigidActor_Pod.structgen_pad1 has unexpected offset % instead of 12", ((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxRigidActor_Pod.structgen_pad1)) == 4, "physx_PxRigidActor_Pod.structgen_pad1 has unexpected size % instead of 4", size_of(type_of(physx_PxRigidActor_Pod.structgen_pad1)));
    assert(((cast(*void)(*instance.userData)) - cast(*void)(*instance)) == 16, "physx_PxRigidActor_Pod.userData has unexpected offset % instead of 16", ((cast(*void)(*instance.userData)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxRigidActor_Pod.userData)) == 8, "physx_PxRigidActor_Pod.userData has unexpected size % instead of 8", size_of(type_of(physx_PxRigidActor_Pod.userData)));
    assert(size_of(physx_PxRigidActor_Pod) == 24, "physx_PxRigidActor_Pod has size % instead of 24", size_of(physx_PxRigidActor_Pod));
}

physx_PxShape_Pod :: struct {
    structgen_pad0: [8] u8;
    mConcreteType:  u16;
    mBaseFlags:     physx_PxBaseFlags_Pod;
    structgen_pad1: [4] u8;
    userData:       *void;
}
#run {
    instance: physx_PxShape_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxShape_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxShape_Pod.structgen_pad0)) == 8, "physx_PxShape_Pod.structgen_pad0 has unexpected size % instead of 8", size_of(type_of(physx_PxShape_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)) == 8, "physx_PxShape_Pod.mConcreteType has unexpected offset % instead of 8", ((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxShape_Pod.mConcreteType)) == 2, "physx_PxShape_Pod.mConcreteType has unexpected size % instead of 2", size_of(type_of(physx_PxShape_Pod.mConcreteType)));
    assert(((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)) == 10, "physx_PxShape_Pod.mBaseFlags has unexpected offset % instead of 10", ((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxShape_Pod.mBaseFlags)) == 2, "physx_PxShape_Pod.mBaseFlags has unexpected size % instead of 2", size_of(type_of(physx_PxShape_Pod.mBaseFlags)));
    assert(((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)) == 12, "physx_PxShape_Pod.structgen_pad1 has unexpected offset % instead of 12", ((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxShape_Pod.structgen_pad1)) == 4, "physx_PxShape_Pod.structgen_pad1 has unexpected size % instead of 4", size_of(type_of(physx_PxShape_Pod.structgen_pad1)));
    assert(((cast(*void)(*instance.userData)) - cast(*void)(*instance)) == 16, "physx_PxShape_Pod.userData has unexpected offset % instead of 16", ((cast(*void)(*instance.userData)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxShape_Pod.userData)) == 8, "physx_PxShape_Pod.userData has unexpected size % instead of 8", size_of(type_of(physx_PxShape_Pod.userData)));
    assert(size_of(physx_PxShape_Pod) == 24, "physx_PxShape_Pod has size % instead of 24", size_of(physx_PxShape_Pod));
}

physx_PxActorShape_Pod :: struct {
    actor: *physx_PxRigidActor_Pod;
    shape: *physx_PxShape_Pod;
}
#run {
    instance: physx_PxActorShape_Pod;
    assert(((cast(*void)(*instance.actor)) - cast(*void)(*instance)) == 0, "physx_PxActorShape_Pod.actor has unexpected offset % instead of 0", ((cast(*void)(*instance.actor)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxActorShape_Pod.actor)) == 8, "physx_PxActorShape_Pod.actor has unexpected size % instead of 8", size_of(type_of(physx_PxActorShape_Pod.actor)));
    assert(((cast(*void)(*instance.shape)) - cast(*void)(*instance)) == 8, "physx_PxActorShape_Pod.shape has unexpected offset % instead of 8", ((cast(*void)(*instance.shape)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxActorShape_Pod.shape)) == 8, "physx_PxActorShape_Pod.shape has unexpected size % instead of 8", size_of(type_of(physx_PxActorShape_Pod.shape)));
    assert(size_of(physx_PxActorShape_Pod) == 16, "physx_PxActorShape_Pod has size % instead of 16", size_of(physx_PxActorShape_Pod));
}

physx_PxQueryHit_Pod :: struct {
    actor:          *physx_PxRigidActor_Pod;
    shape:          *physx_PxShape_Pod;
    faceIndex:      u32;
    structgen_pad0: [4] u8;
}
#run {
    instance: physx_PxQueryHit_Pod;
    assert(((cast(*void)(*instance.actor)) - cast(*void)(*instance)) == 0, "physx_PxQueryHit_Pod.actor has unexpected offset % instead of 0", ((cast(*void)(*instance.actor)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxQueryHit_Pod.actor)) == 8, "physx_PxQueryHit_Pod.actor has unexpected size % instead of 8", size_of(type_of(physx_PxQueryHit_Pod.actor)));
    assert(((cast(*void)(*instance.shape)) - cast(*void)(*instance)) == 8, "physx_PxQueryHit_Pod.shape has unexpected offset % instead of 8", ((cast(*void)(*instance.shape)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxQueryHit_Pod.shape)) == 8, "physx_PxQueryHit_Pod.shape has unexpected size % instead of 8", size_of(type_of(physx_PxQueryHit_Pod.shape)));
    assert(((cast(*void)(*instance.faceIndex)) - cast(*void)(*instance)) == 16, "physx_PxQueryHit_Pod.faceIndex has unexpected offset % instead of 16", ((cast(*void)(*instance.faceIndex)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxQueryHit_Pod.faceIndex)) == 4, "physx_PxQueryHit_Pod.faceIndex has unexpected size % instead of 4", size_of(type_of(physx_PxQueryHit_Pod.faceIndex)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 20, "physx_PxQueryHit_Pod.structgen_pad0 has unexpected offset % instead of 20", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxQueryHit_Pod.structgen_pad0)) == 4, "physx_PxQueryHit_Pod.structgen_pad0 has unexpected size % instead of 4", size_of(type_of(physx_PxQueryHit_Pod.structgen_pad0)));
    assert(size_of(physx_PxQueryHit_Pod) == 24, "physx_PxQueryHit_Pod has size % instead of 24", size_of(physx_PxQueryHit_Pod));
}

physx_PxHitFlags_Pod :: struct {
    mBits: u16;
}
#run {
    instance: physx_PxHitFlags_Pod;
    assert(((cast(*void)(*instance.mBits)) - cast(*void)(*instance)) == 0, "physx_PxHitFlags_Pod.mBits has unexpected offset % instead of 0", ((cast(*void)(*instance.mBits)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxHitFlags_Pod.mBits)) == 2, "physx_PxHitFlags_Pod.mBits has unexpected size % instead of 2", size_of(type_of(physx_PxHitFlags_Pod.mBits)));
    assert(size_of(physx_PxHitFlags_Pod) == 2, "physx_PxHitFlags_Pod has size % instead of 2", size_of(physx_PxHitFlags_Pod));
}

physx_PxLocationHit_Pod :: struct {
    actor:          *physx_PxRigidActor_Pod;
    shape:          *physx_PxShape_Pod;
    faceIndex:      u32;
    structgen_pad0: [4] u8;
    flags:          physx_PxHitFlags_Pod;
    structgen_pad1: [2] u8;
    position:       physx_PxVec3_Pod;
    normal:         physx_PxVec3_Pod;
    distance:       float;
}
#run {
    instance: physx_PxLocationHit_Pod;
    assert(((cast(*void)(*instance.actor)) - cast(*void)(*instance)) == 0, "physx_PxLocationHit_Pod.actor has unexpected offset % instead of 0", ((cast(*void)(*instance.actor)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxLocationHit_Pod.actor)) == 8, "physx_PxLocationHit_Pod.actor has unexpected size % instead of 8", size_of(type_of(physx_PxLocationHit_Pod.actor)));
    assert(((cast(*void)(*instance.shape)) - cast(*void)(*instance)) == 8, "physx_PxLocationHit_Pod.shape has unexpected offset % instead of 8", ((cast(*void)(*instance.shape)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxLocationHit_Pod.shape)) == 8, "physx_PxLocationHit_Pod.shape has unexpected size % instead of 8", size_of(type_of(physx_PxLocationHit_Pod.shape)));
    assert(((cast(*void)(*instance.faceIndex)) - cast(*void)(*instance)) == 16, "physx_PxLocationHit_Pod.faceIndex has unexpected offset % instead of 16", ((cast(*void)(*instance.faceIndex)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxLocationHit_Pod.faceIndex)) == 4, "physx_PxLocationHit_Pod.faceIndex has unexpected size % instead of 4", size_of(type_of(physx_PxLocationHit_Pod.faceIndex)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 20, "physx_PxLocationHit_Pod.structgen_pad0 has unexpected offset % instead of 20", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxLocationHit_Pod.structgen_pad0)) == 4, "physx_PxLocationHit_Pod.structgen_pad0 has unexpected size % instead of 4", size_of(type_of(physx_PxLocationHit_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.flags)) - cast(*void)(*instance)) == 24, "physx_PxLocationHit_Pod.flags has unexpected offset % instead of 24", ((cast(*void)(*instance.flags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxLocationHit_Pod.flags)) == 2, "physx_PxLocationHit_Pod.flags has unexpected size % instead of 2", size_of(type_of(physx_PxLocationHit_Pod.flags)));
    assert(((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)) == 26, "physx_PxLocationHit_Pod.structgen_pad1 has unexpected offset % instead of 26", ((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxLocationHit_Pod.structgen_pad1)) == 2, "physx_PxLocationHit_Pod.structgen_pad1 has unexpected size % instead of 2", size_of(type_of(physx_PxLocationHit_Pod.structgen_pad1)));
    assert(((cast(*void)(*instance.position)) - cast(*void)(*instance)) == 28, "physx_PxLocationHit_Pod.position has unexpected offset % instead of 28", ((cast(*void)(*instance.position)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxLocationHit_Pod.position)) == 12, "physx_PxLocationHit_Pod.position has unexpected size % instead of 12", size_of(type_of(physx_PxLocationHit_Pod.position)));
    assert(((cast(*void)(*instance.normal)) - cast(*void)(*instance)) == 40, "physx_PxLocationHit_Pod.normal has unexpected offset % instead of 40", ((cast(*void)(*instance.normal)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxLocationHit_Pod.normal)) == 12, "physx_PxLocationHit_Pod.normal has unexpected size % instead of 12", size_of(type_of(physx_PxLocationHit_Pod.normal)));
    assert(((cast(*void)(*instance.distance)) - cast(*void)(*instance)) == 52, "physx_PxLocationHit_Pod.distance has unexpected offset % instead of 52", ((cast(*void)(*instance.distance)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxLocationHit_Pod.distance)) == 4, "physx_PxLocationHit_Pod.distance has unexpected size % instead of 4", size_of(type_of(physx_PxLocationHit_Pod.distance)));
    assert(size_of(physx_PxLocationHit_Pod) == 56, "physx_PxLocationHit_Pod has size % instead of 56", size_of(physx_PxLocationHit_Pod));
}

physx_PxRaycastHit_Pod :: struct {
    actor:          *physx_PxRigidActor_Pod;
    shape:          *physx_PxShape_Pod;
    faceIndex:      u32;
    structgen_pad0: [4] u8;
    flags:          physx_PxHitFlags_Pod;
    structgen_pad1: [2] u8;
    position:       physx_PxVec3_Pod;
    normal:         physx_PxVec3_Pod;
    distance:       float;
    u:              float;
    v:              float;
}
#run {
    instance: physx_PxRaycastHit_Pod;
    assert(((cast(*void)(*instance.actor)) - cast(*void)(*instance)) == 0, "physx_PxRaycastHit_Pod.actor has unexpected offset % instead of 0", ((cast(*void)(*instance.actor)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxRaycastHit_Pod.actor)) == 8, "physx_PxRaycastHit_Pod.actor has unexpected size % instead of 8", size_of(type_of(physx_PxRaycastHit_Pod.actor)));
    assert(((cast(*void)(*instance.shape)) - cast(*void)(*instance)) == 8, "physx_PxRaycastHit_Pod.shape has unexpected offset % instead of 8", ((cast(*void)(*instance.shape)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxRaycastHit_Pod.shape)) == 8, "physx_PxRaycastHit_Pod.shape has unexpected size % instead of 8", size_of(type_of(physx_PxRaycastHit_Pod.shape)));
    assert(((cast(*void)(*instance.faceIndex)) - cast(*void)(*instance)) == 16, "physx_PxRaycastHit_Pod.faceIndex has unexpected offset % instead of 16", ((cast(*void)(*instance.faceIndex)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxRaycastHit_Pod.faceIndex)) == 4, "physx_PxRaycastHit_Pod.faceIndex has unexpected size % instead of 4", size_of(type_of(physx_PxRaycastHit_Pod.faceIndex)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 20, "physx_PxRaycastHit_Pod.structgen_pad0 has unexpected offset % instead of 20", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxRaycastHit_Pod.structgen_pad0)) == 4, "physx_PxRaycastHit_Pod.structgen_pad0 has unexpected size % instead of 4", size_of(type_of(physx_PxRaycastHit_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.flags)) - cast(*void)(*instance)) == 24, "physx_PxRaycastHit_Pod.flags has unexpected offset % instead of 24", ((cast(*void)(*instance.flags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxRaycastHit_Pod.flags)) == 2, "physx_PxRaycastHit_Pod.flags has unexpected size % instead of 2", size_of(type_of(physx_PxRaycastHit_Pod.flags)));
    assert(((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)) == 26, "physx_PxRaycastHit_Pod.structgen_pad1 has unexpected offset % instead of 26", ((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxRaycastHit_Pod.structgen_pad1)) == 2, "physx_PxRaycastHit_Pod.structgen_pad1 has unexpected size % instead of 2", size_of(type_of(physx_PxRaycastHit_Pod.structgen_pad1)));
    assert(((cast(*void)(*instance.position)) - cast(*void)(*instance)) == 28, "physx_PxRaycastHit_Pod.position has unexpected offset % instead of 28", ((cast(*void)(*instance.position)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxRaycastHit_Pod.position)) == 12, "physx_PxRaycastHit_Pod.position has unexpected size % instead of 12", size_of(type_of(physx_PxRaycastHit_Pod.position)));
    assert(((cast(*void)(*instance.normal)) - cast(*void)(*instance)) == 40, "physx_PxRaycastHit_Pod.normal has unexpected offset % instead of 40", ((cast(*void)(*instance.normal)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxRaycastHit_Pod.normal)) == 12, "physx_PxRaycastHit_Pod.normal has unexpected size % instead of 12", size_of(type_of(physx_PxRaycastHit_Pod.normal)));
    assert(((cast(*void)(*instance.distance)) - cast(*void)(*instance)) == 52, "physx_PxRaycastHit_Pod.distance has unexpected offset % instead of 52", ((cast(*void)(*instance.distance)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxRaycastHit_Pod.distance)) == 4, "physx_PxRaycastHit_Pod.distance has unexpected size % instead of 4", size_of(type_of(physx_PxRaycastHit_Pod.distance)));
    assert(((cast(*void)(*instance.u)) - cast(*void)(*instance)) == 56, "physx_PxRaycastHit_Pod.u has unexpected offset % instead of 56", ((cast(*void)(*instance.u)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxRaycastHit_Pod.u)) == 4, "physx_PxRaycastHit_Pod.u has unexpected size % instead of 4", size_of(type_of(physx_PxRaycastHit_Pod.u)));
    assert(((cast(*void)(*instance.v)) - cast(*void)(*instance)) == 60, "physx_PxRaycastHit_Pod.v has unexpected offset % instead of 60", ((cast(*void)(*instance.v)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxRaycastHit_Pod.v)) == 4, "physx_PxRaycastHit_Pod.v has unexpected size % instead of 4", size_of(type_of(physx_PxRaycastHit_Pod.v)));
    assert(size_of(physx_PxRaycastHit_Pod) == 64, "physx_PxRaycastHit_Pod has size % instead of 64", size_of(physx_PxRaycastHit_Pod));
}

physx_PxSweepHit_Pod :: struct {
    actor:          *physx_PxRigidActor_Pod;
    shape:          *physx_PxShape_Pod;
    faceIndex:      u32;
    structgen_pad0: [4] u8;
    flags:          physx_PxHitFlags_Pod;
    structgen_pad1: [2] u8;
    position:       physx_PxVec3_Pod;
    normal:         physx_PxVec3_Pod;
    distance:       float;
    padTo16Bytes:   u32;
    structgen_pad2: [4] u8;
}
#run {
    instance: physx_PxSweepHit_Pod;
    assert(((cast(*void)(*instance.actor)) - cast(*void)(*instance)) == 0, "physx_PxSweepHit_Pod.actor has unexpected offset % instead of 0", ((cast(*void)(*instance.actor)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSweepHit_Pod.actor)) == 8, "physx_PxSweepHit_Pod.actor has unexpected size % instead of 8", size_of(type_of(physx_PxSweepHit_Pod.actor)));
    assert(((cast(*void)(*instance.shape)) - cast(*void)(*instance)) == 8, "physx_PxSweepHit_Pod.shape has unexpected offset % instead of 8", ((cast(*void)(*instance.shape)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSweepHit_Pod.shape)) == 8, "physx_PxSweepHit_Pod.shape has unexpected size % instead of 8", size_of(type_of(physx_PxSweepHit_Pod.shape)));
    assert(((cast(*void)(*instance.faceIndex)) - cast(*void)(*instance)) == 16, "physx_PxSweepHit_Pod.faceIndex has unexpected offset % instead of 16", ((cast(*void)(*instance.faceIndex)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSweepHit_Pod.faceIndex)) == 4, "physx_PxSweepHit_Pod.faceIndex has unexpected size % instead of 4", size_of(type_of(physx_PxSweepHit_Pod.faceIndex)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 20, "physx_PxSweepHit_Pod.structgen_pad0 has unexpected offset % instead of 20", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSweepHit_Pod.structgen_pad0)) == 4, "physx_PxSweepHit_Pod.structgen_pad0 has unexpected size % instead of 4", size_of(type_of(physx_PxSweepHit_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.flags)) - cast(*void)(*instance)) == 24, "physx_PxSweepHit_Pod.flags has unexpected offset % instead of 24", ((cast(*void)(*instance.flags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSweepHit_Pod.flags)) == 2, "physx_PxSweepHit_Pod.flags has unexpected size % instead of 2", size_of(type_of(physx_PxSweepHit_Pod.flags)));
    assert(((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)) == 26, "physx_PxSweepHit_Pod.structgen_pad1 has unexpected offset % instead of 26", ((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSweepHit_Pod.structgen_pad1)) == 2, "physx_PxSweepHit_Pod.structgen_pad1 has unexpected size % instead of 2", size_of(type_of(physx_PxSweepHit_Pod.structgen_pad1)));
    assert(((cast(*void)(*instance.position)) - cast(*void)(*instance)) == 28, "physx_PxSweepHit_Pod.position has unexpected offset % instead of 28", ((cast(*void)(*instance.position)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSweepHit_Pod.position)) == 12, "physx_PxSweepHit_Pod.position has unexpected size % instead of 12", size_of(type_of(physx_PxSweepHit_Pod.position)));
    assert(((cast(*void)(*instance.normal)) - cast(*void)(*instance)) == 40, "physx_PxSweepHit_Pod.normal has unexpected offset % instead of 40", ((cast(*void)(*instance.normal)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSweepHit_Pod.normal)) == 12, "physx_PxSweepHit_Pod.normal has unexpected size % instead of 12", size_of(type_of(physx_PxSweepHit_Pod.normal)));
    assert(((cast(*void)(*instance.distance)) - cast(*void)(*instance)) == 52, "physx_PxSweepHit_Pod.distance has unexpected offset % instead of 52", ((cast(*void)(*instance.distance)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSweepHit_Pod.distance)) == 4, "physx_PxSweepHit_Pod.distance has unexpected size % instead of 4", size_of(type_of(physx_PxSweepHit_Pod.distance)));
    assert(((cast(*void)(*instance.padTo16Bytes)) - cast(*void)(*instance)) == 56, "physx_PxSweepHit_Pod.padTo16Bytes has unexpected offset % instead of 56", ((cast(*void)(*instance.padTo16Bytes)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSweepHit_Pod.padTo16Bytes)) == 4, "physx_PxSweepHit_Pod.padTo16Bytes has unexpected size % instead of 4", size_of(type_of(physx_PxSweepHit_Pod.padTo16Bytes)));
    assert(((cast(*void)(*instance.structgen_pad2)) - cast(*void)(*instance)) == 60, "physx_PxSweepHit_Pod.structgen_pad2 has unexpected offset % instead of 60", ((cast(*void)(*instance.structgen_pad2)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSweepHit_Pod.structgen_pad2)) == 4, "physx_PxSweepHit_Pod.structgen_pad2 has unexpected size % instead of 4", size_of(type_of(physx_PxSweepHit_Pod.structgen_pad2)));
    assert(size_of(physx_PxSweepHit_Pod) == 64, "physx_PxSweepHit_Pod has size % instead of 64", size_of(physx_PxSweepHit_Pod));
}

physx_PxBitAndByte_Pod :: struct {
    mData: u8;
}
#run {
    instance: physx_PxBitAndByte_Pod;
    assert(((cast(*void)(*instance.mData)) - cast(*void)(*instance)) == 0, "physx_PxBitAndByte_Pod.mData has unexpected offset % instead of 0", ((cast(*void)(*instance.mData)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBitAndByte_Pod.mData)) == 1, "physx_PxBitAndByte_Pod.mData has unexpected size % instead of 1", size_of(type_of(physx_PxBitAndByte_Pod.mData)));
    assert(size_of(physx_PxBitAndByte_Pod) == 1, "physx_PxBitAndByte_Pod has size % instead of 1", size_of(physx_PxBitAndByte_Pod));
}

physx_PxHeightFieldSample_Pod :: struct {
    height:         s16;
    materialIndex0: physx_PxBitAndByte_Pod;
    materialIndex1: physx_PxBitAndByte_Pod;
}
#run {
    instance: physx_PxHeightFieldSample_Pod;
    assert(((cast(*void)(*instance.height)) - cast(*void)(*instance)) == 0, "physx_PxHeightFieldSample_Pod.height has unexpected offset % instead of 0", ((cast(*void)(*instance.height)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxHeightFieldSample_Pod.height)) == 2, "physx_PxHeightFieldSample_Pod.height has unexpected size % instead of 2", size_of(type_of(physx_PxHeightFieldSample_Pod.height)));
    assert(((cast(*void)(*instance.materialIndex0)) - cast(*void)(*instance)) == 2, "physx_PxHeightFieldSample_Pod.materialIndex0 has unexpected offset % instead of 2", ((cast(*void)(*instance.materialIndex0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxHeightFieldSample_Pod.materialIndex0)) == 1, "physx_PxHeightFieldSample_Pod.materialIndex0 has unexpected size % instead of 1", size_of(type_of(physx_PxHeightFieldSample_Pod.materialIndex0)));
    assert(((cast(*void)(*instance.materialIndex1)) - cast(*void)(*instance)) == 3, "physx_PxHeightFieldSample_Pod.materialIndex1 has unexpected offset % instead of 3", ((cast(*void)(*instance.materialIndex1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxHeightFieldSample_Pod.materialIndex1)) == 1, "physx_PxHeightFieldSample_Pod.materialIndex1 has unexpected size % instead of 1", size_of(type_of(physx_PxHeightFieldSample_Pod.materialIndex1)));
    assert(size_of(physx_PxHeightFieldSample_Pod) == 4, "physx_PxHeightFieldSample_Pod has size % instead of 4", size_of(physx_PxHeightFieldSample_Pod));
}

physx_PxHeightFieldFlags_Pod :: struct {
    mBits: u16;
}
#run {
    instance: physx_PxHeightFieldFlags_Pod;
    assert(((cast(*void)(*instance.mBits)) - cast(*void)(*instance)) == 0, "physx_PxHeightFieldFlags_Pod.mBits has unexpected offset % instead of 0", ((cast(*void)(*instance.mBits)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxHeightFieldFlags_Pod.mBits)) == 2, "physx_PxHeightFieldFlags_Pod.mBits has unexpected size % instead of 2", size_of(type_of(physx_PxHeightFieldFlags_Pod.mBits)));
    assert(size_of(physx_PxHeightFieldFlags_Pod) == 2, "physx_PxHeightFieldFlags_Pod has size % instead of 2", size_of(physx_PxHeightFieldFlags_Pod));
}

physx_PxHeightFieldDesc_Pod :: struct {
    nbRows:              u32;
    nbColumns:           u32;
    format:              u32;
    structgen_pad0:      [4] u8;
    samples:             physx_PxStridedData_Pod;
    convexEdgeThreshold: float;
    flags:               physx_PxHeightFieldFlags_Pod;
    structgen_pad1:      [2] u8;
}
#run {
    instance: physx_PxHeightFieldDesc_Pod;
    assert(((cast(*void)(*instance.nbRows)) - cast(*void)(*instance)) == 0, "physx_PxHeightFieldDesc_Pod.nbRows has unexpected offset % instead of 0", ((cast(*void)(*instance.nbRows)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxHeightFieldDesc_Pod.nbRows)) == 4, "physx_PxHeightFieldDesc_Pod.nbRows has unexpected size % instead of 4", size_of(type_of(physx_PxHeightFieldDesc_Pod.nbRows)));
    assert(((cast(*void)(*instance.nbColumns)) - cast(*void)(*instance)) == 4, "physx_PxHeightFieldDesc_Pod.nbColumns has unexpected offset % instead of 4", ((cast(*void)(*instance.nbColumns)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxHeightFieldDesc_Pod.nbColumns)) == 4, "physx_PxHeightFieldDesc_Pod.nbColumns has unexpected size % instead of 4", size_of(type_of(physx_PxHeightFieldDesc_Pod.nbColumns)));
    assert(((cast(*void)(*instance.format)) - cast(*void)(*instance)) == 8, "physx_PxHeightFieldDesc_Pod.format has unexpected offset % instead of 8", ((cast(*void)(*instance.format)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxHeightFieldDesc_Pod.format)) == 4, "physx_PxHeightFieldDesc_Pod.format has unexpected size % instead of 4", size_of(type_of(physx_PxHeightFieldDesc_Pod.format)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 12, "physx_PxHeightFieldDesc_Pod.structgen_pad0 has unexpected offset % instead of 12", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxHeightFieldDesc_Pod.structgen_pad0)) == 4, "physx_PxHeightFieldDesc_Pod.structgen_pad0 has unexpected size % instead of 4", size_of(type_of(physx_PxHeightFieldDesc_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.samples)) - cast(*void)(*instance)) == 16, "physx_PxHeightFieldDesc_Pod.samples has unexpected offset % instead of 16", ((cast(*void)(*instance.samples)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxHeightFieldDesc_Pod.samples)) == 16, "physx_PxHeightFieldDesc_Pod.samples has unexpected size % instead of 16", size_of(type_of(physx_PxHeightFieldDesc_Pod.samples)));
    assert(((cast(*void)(*instance.convexEdgeThreshold)) - cast(*void)(*instance)) == 32, "physx_PxHeightFieldDesc_Pod.convexEdgeThreshold has unexpected offset % instead of 32", ((cast(*void)(*instance.convexEdgeThreshold)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxHeightFieldDesc_Pod.convexEdgeThreshold)) == 4, "physx_PxHeightFieldDesc_Pod.convexEdgeThreshold has unexpected size % instead of 4", size_of(type_of(physx_PxHeightFieldDesc_Pod.convexEdgeThreshold)));
    assert(((cast(*void)(*instance.flags)) - cast(*void)(*instance)) == 36, "physx_PxHeightFieldDesc_Pod.flags has unexpected offset % instead of 36", ((cast(*void)(*instance.flags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxHeightFieldDesc_Pod.flags)) == 2, "physx_PxHeightFieldDesc_Pod.flags has unexpected size % instead of 2", size_of(type_of(physx_PxHeightFieldDesc_Pod.flags)));
    assert(((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)) == 38, "physx_PxHeightFieldDesc_Pod.structgen_pad1 has unexpected offset % instead of 38", ((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxHeightFieldDesc_Pod.structgen_pad1)) == 2, "physx_PxHeightFieldDesc_Pod.structgen_pad1 has unexpected size % instead of 2", size_of(type_of(physx_PxHeightFieldDesc_Pod.structgen_pad1)));
    assert(size_of(physx_PxHeightFieldDesc_Pod) == 40, "physx_PxHeightFieldDesc_Pod has size % instead of 40", size_of(physx_PxHeightFieldDesc_Pod));
}

physx_PxTriangle_Pod :: struct {
    verts: [3] physx_PxVec3_Pod;
}
#run {
    instance: physx_PxTriangle_Pod;
    assert(((cast(*void)(*instance.verts)) - cast(*void)(*instance)) == 0, "physx_PxTriangle_Pod.verts has unexpected offset % instead of 0", ((cast(*void)(*instance.verts)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxTriangle_Pod.verts)) == 36, "physx_PxTriangle_Pod.verts has unexpected size % instead of 36", size_of(type_of(physx_PxTriangle_Pod.verts)));
    assert(size_of(physx_PxTriangle_Pod) == 36, "physx_PxTriangle_Pod has size % instead of 36", size_of(physx_PxTriangle_Pod));
}

physx_PxMeshFlags_Pod :: struct {
    mBits: u16;
}
#run {
    instance: physx_PxMeshFlags_Pod;
    assert(((cast(*void)(*instance.mBits)) - cast(*void)(*instance)) == 0, "physx_PxMeshFlags_Pod.mBits has unexpected offset % instead of 0", ((cast(*void)(*instance.mBits)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxMeshFlags_Pod.mBits)) == 2, "physx_PxMeshFlags_Pod.mBits has unexpected size % instead of 2", size_of(type_of(physx_PxMeshFlags_Pod.mBits)));
    assert(size_of(physx_PxMeshFlags_Pod) == 2, "physx_PxMeshFlags_Pod has size % instead of 2", size_of(physx_PxMeshFlags_Pod));
}

physx_PxSimpleTriangleMesh_Pod :: struct {
    points:         physx_PxBoundedData_Pod;
    triangles:      physx_PxBoundedData_Pod;
    flags:          physx_PxMeshFlags_Pod;
    structgen_pad0: [6] u8;
}
#run {
    instance: physx_PxSimpleTriangleMesh_Pod;
    assert(((cast(*void)(*instance.points)) - cast(*void)(*instance)) == 0, "physx_PxSimpleTriangleMesh_Pod.points has unexpected offset % instead of 0", ((cast(*void)(*instance.points)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSimpleTriangleMesh_Pod.points)) == 24, "physx_PxSimpleTriangleMesh_Pod.points has unexpected size % instead of 24", size_of(type_of(physx_PxSimpleTriangleMesh_Pod.points)));
    assert(((cast(*void)(*instance.triangles)) - cast(*void)(*instance)) == 24, "physx_PxSimpleTriangleMesh_Pod.triangles has unexpected offset % instead of 24", ((cast(*void)(*instance.triangles)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSimpleTriangleMesh_Pod.triangles)) == 24, "physx_PxSimpleTriangleMesh_Pod.triangles has unexpected size % instead of 24", size_of(type_of(physx_PxSimpleTriangleMesh_Pod.triangles)));
    assert(((cast(*void)(*instance.flags)) - cast(*void)(*instance)) == 48, "physx_PxSimpleTriangleMesh_Pod.flags has unexpected offset % instead of 48", ((cast(*void)(*instance.flags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSimpleTriangleMesh_Pod.flags)) == 2, "physx_PxSimpleTriangleMesh_Pod.flags has unexpected size % instead of 2", size_of(type_of(physx_PxSimpleTriangleMesh_Pod.flags)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 50, "physx_PxSimpleTriangleMesh_Pod.structgen_pad0 has unexpected offset % instead of 50", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSimpleTriangleMesh_Pod.structgen_pad0)) == 6, "physx_PxSimpleTriangleMesh_Pod.structgen_pad0 has unexpected size % instead of 6", size_of(type_of(physx_PxSimpleTriangleMesh_Pod.structgen_pad0)));
    assert(size_of(physx_PxSimpleTriangleMesh_Pod) == 56, "physx_PxSimpleTriangleMesh_Pod has size % instead of 56", size_of(physx_PxSimpleTriangleMesh_Pod));
}

physx_PxTriangleMeshFlags_Pod :: struct {
    mBits: u8;
}
#run {
    instance: physx_PxTriangleMeshFlags_Pod;
    assert(((cast(*void)(*instance.mBits)) - cast(*void)(*instance)) == 0, "physx_PxTriangleMeshFlags_Pod.mBits has unexpected offset % instead of 0", ((cast(*void)(*instance.mBits)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxTriangleMeshFlags_Pod.mBits)) == 1, "physx_PxTriangleMeshFlags_Pod.mBits has unexpected size % instead of 1", size_of(type_of(physx_PxTriangleMeshFlags_Pod.mBits)));
    assert(size_of(physx_PxTriangleMeshFlags_Pod) == 1, "physx_PxTriangleMeshFlags_Pod has size % instead of 1", size_of(physx_PxTriangleMeshFlags_Pod));
}

physx_PxActor_Pod :: struct {
    structgen_pad0: [8] u8;
    mConcreteType:  u16;
    mBaseFlags:     physx_PxBaseFlags_Pod;
    structgen_pad1: [4] u8;
    userData:       *void;
}
#run {
    instance: physx_PxActor_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxActor_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxActor_Pod.structgen_pad0)) == 8, "physx_PxActor_Pod.structgen_pad0 has unexpected size % instead of 8", size_of(type_of(physx_PxActor_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)) == 8, "physx_PxActor_Pod.mConcreteType has unexpected offset % instead of 8", ((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxActor_Pod.mConcreteType)) == 2, "physx_PxActor_Pod.mConcreteType has unexpected size % instead of 2", size_of(type_of(physx_PxActor_Pod.mConcreteType)));
    assert(((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)) == 10, "physx_PxActor_Pod.mBaseFlags has unexpected offset % instead of 10", ((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxActor_Pod.mBaseFlags)) == 2, "physx_PxActor_Pod.mBaseFlags has unexpected size % instead of 2", size_of(type_of(physx_PxActor_Pod.mBaseFlags)));
    assert(((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)) == 12, "physx_PxActor_Pod.structgen_pad1 has unexpected offset % instead of 12", ((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxActor_Pod.structgen_pad1)) == 4, "physx_PxActor_Pod.structgen_pad1 has unexpected size % instead of 4", size_of(type_of(physx_PxActor_Pod.structgen_pad1)));
    assert(((cast(*void)(*instance.userData)) - cast(*void)(*instance)) == 16, "physx_PxActor_Pod.userData has unexpected offset % instead of 16", ((cast(*void)(*instance.userData)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxActor_Pod.userData)) == 8, "physx_PxActor_Pod.userData has unexpected size % instead of 8", size_of(type_of(physx_PxActor_Pod.userData)));
    assert(size_of(physx_PxActor_Pod) == 24, "physx_PxActor_Pod has size % instead of 24", size_of(physx_PxActor_Pod));
}

physx_PxScene_Pod :: struct {
    structgen_pad0: [8] u8;
    userData:       *void;
}
#run {
    instance: physx_PxScene_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxScene_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxScene_Pod.structgen_pad0)) == 8, "physx_PxScene_Pod.structgen_pad0 has unexpected size % instead of 8", size_of(type_of(physx_PxScene_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.userData)) - cast(*void)(*instance)) == 8, "physx_PxScene_Pod.userData has unexpected offset % instead of 8", ((cast(*void)(*instance.userData)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxScene_Pod.userData)) == 8, "physx_PxScene_Pod.userData has unexpected size % instead of 8", size_of(type_of(physx_PxScene_Pod.userData)));
    assert(size_of(physx_PxScene_Pod) == 16, "physx_PxScene_Pod has size % instead of 16", size_of(physx_PxScene_Pod));
}

physx_PxActorFlags_Pod :: struct {
    mBits: u8;
}
#run {
    instance: physx_PxActorFlags_Pod;
    assert(((cast(*void)(*instance.mBits)) - cast(*void)(*instance)) == 0, "physx_PxActorFlags_Pod.mBits has unexpected offset % instead of 0", ((cast(*void)(*instance.mBits)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxActorFlags_Pod.mBits)) == 1, "physx_PxActorFlags_Pod.mBits has unexpected size % instead of 1", size_of(type_of(physx_PxActorFlags_Pod.mBits)));
    assert(size_of(physx_PxActorFlags_Pod) == 1, "physx_PxActorFlags_Pod has size % instead of 1", size_of(physx_PxActorFlags_Pod));
}

physx_PxAggregate_Pod :: struct {
    structgen_pad0: [8] u8;
    mConcreteType:  u16;
    mBaseFlags:     physx_PxBaseFlags_Pod;
    structgen_pad1: [4] u8;
}
#run {
    instance: physx_PxAggregate_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxAggregate_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxAggregate_Pod.structgen_pad0)) == 8, "physx_PxAggregate_Pod.structgen_pad0 has unexpected size % instead of 8", size_of(type_of(physx_PxAggregate_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)) == 8, "physx_PxAggregate_Pod.mConcreteType has unexpected offset % instead of 8", ((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxAggregate_Pod.mConcreteType)) == 2, "physx_PxAggregate_Pod.mConcreteType has unexpected size % instead of 2", size_of(type_of(physx_PxAggregate_Pod.mConcreteType)));
    assert(((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)) == 10, "physx_PxAggregate_Pod.mBaseFlags has unexpected offset % instead of 10", ((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxAggregate_Pod.mBaseFlags)) == 2, "physx_PxAggregate_Pod.mBaseFlags has unexpected size % instead of 2", size_of(type_of(physx_PxAggregate_Pod.mBaseFlags)));
    assert(((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)) == 12, "physx_PxAggregate_Pod.structgen_pad1 has unexpected offset % instead of 12", ((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxAggregate_Pod.structgen_pad1)) == 4, "physx_PxAggregate_Pod.structgen_pad1 has unexpected size % instead of 4", size_of(type_of(physx_PxAggregate_Pod.structgen_pad1)));
    assert(size_of(physx_PxAggregate_Pod) == 16, "physx_PxAggregate_Pod has size % instead of 16", size_of(physx_PxAggregate_Pod));
}

physx_PxArticulationBase_Pod :: struct {
    structgen_pad0: [8] u8;
    mConcreteType:  u16;
    mBaseFlags:     physx_PxBaseFlags_Pod;
    structgen_pad1: [4] u8;
    userData:       *void;
}
#run {
    instance: physx_PxArticulationBase_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxArticulationBase_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxArticulationBase_Pod.structgen_pad0)) == 8, "physx_PxArticulationBase_Pod.structgen_pad0 has unexpected size % instead of 8", size_of(type_of(physx_PxArticulationBase_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)) == 8, "physx_PxArticulationBase_Pod.mConcreteType has unexpected offset % instead of 8", ((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxArticulationBase_Pod.mConcreteType)) == 2, "physx_PxArticulationBase_Pod.mConcreteType has unexpected size % instead of 2", size_of(type_of(physx_PxArticulationBase_Pod.mConcreteType)));
    assert(((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)) == 10, "physx_PxArticulationBase_Pod.mBaseFlags has unexpected offset % instead of 10", ((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxArticulationBase_Pod.mBaseFlags)) == 2, "physx_PxArticulationBase_Pod.mBaseFlags has unexpected size % instead of 2", size_of(type_of(physx_PxArticulationBase_Pod.mBaseFlags)));
    assert(((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)) == 12, "physx_PxArticulationBase_Pod.structgen_pad1 has unexpected offset % instead of 12", ((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxArticulationBase_Pod.structgen_pad1)) == 4, "physx_PxArticulationBase_Pod.structgen_pad1 has unexpected size % instead of 4", size_of(type_of(physx_PxArticulationBase_Pod.structgen_pad1)));
    assert(((cast(*void)(*instance.userData)) - cast(*void)(*instance)) == 16, "physx_PxArticulationBase_Pod.userData has unexpected offset % instead of 16", ((cast(*void)(*instance.userData)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxArticulationBase_Pod.userData)) == 8, "physx_PxArticulationBase_Pod.userData has unexpected size % instead of 8", size_of(type_of(physx_PxArticulationBase_Pod.userData)));
    assert(size_of(physx_PxArticulationBase_Pod) == 24, "physx_PxArticulationBase_Pod has size % instead of 24", size_of(physx_PxArticulationBase_Pod));
}

physx_PxArticulationLink_Pod :: struct {
    structgen_pad0: [8] u8;
    mConcreteType:  u16;
    mBaseFlags:     physx_PxBaseFlags_Pod;
    structgen_pad1: [4] u8;
    userData:       *void;
}
#run {
    instance: physx_PxArticulationLink_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxArticulationLink_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxArticulationLink_Pod.structgen_pad0)) == 8, "physx_PxArticulationLink_Pod.structgen_pad0 has unexpected size % instead of 8", size_of(type_of(physx_PxArticulationLink_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)) == 8, "physx_PxArticulationLink_Pod.mConcreteType has unexpected offset % instead of 8", ((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxArticulationLink_Pod.mConcreteType)) == 2, "physx_PxArticulationLink_Pod.mConcreteType has unexpected size % instead of 2", size_of(type_of(physx_PxArticulationLink_Pod.mConcreteType)));
    assert(((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)) == 10, "physx_PxArticulationLink_Pod.mBaseFlags has unexpected offset % instead of 10", ((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxArticulationLink_Pod.mBaseFlags)) == 2, "physx_PxArticulationLink_Pod.mBaseFlags has unexpected size % instead of 2", size_of(type_of(physx_PxArticulationLink_Pod.mBaseFlags)));
    assert(((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)) == 12, "physx_PxArticulationLink_Pod.structgen_pad1 has unexpected offset % instead of 12", ((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxArticulationLink_Pod.structgen_pad1)) == 4, "physx_PxArticulationLink_Pod.structgen_pad1 has unexpected size % instead of 4", size_of(type_of(physx_PxArticulationLink_Pod.structgen_pad1)));
    assert(((cast(*void)(*instance.userData)) - cast(*void)(*instance)) == 16, "physx_PxArticulationLink_Pod.userData has unexpected offset % instead of 16", ((cast(*void)(*instance.userData)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxArticulationLink_Pod.userData)) == 8, "physx_PxArticulationLink_Pod.userData has unexpected size % instead of 8", size_of(type_of(physx_PxArticulationLink_Pod.userData)));
    assert(size_of(physx_PxArticulationLink_Pod) == 24, "physx_PxArticulationLink_Pod has size % instead of 24", size_of(physx_PxArticulationLink_Pod));
}

physx_PxArticulationImpl_Pod :: struct {}
physx_PxArticulationJointBase_Pod :: struct {
    structgen_pad0: [8] u8;
    mConcreteType:  u16;
    mBaseFlags:     physx_PxBaseFlags_Pod;
    structgen_pad1: [4] u8;
}
#run {
    instance: physx_PxArticulationJointBase_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxArticulationJointBase_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxArticulationJointBase_Pod.structgen_pad0)) == 8, "physx_PxArticulationJointBase_Pod.structgen_pad0 has unexpected size % instead of 8", size_of(type_of(physx_PxArticulationJointBase_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)) == 8, "physx_PxArticulationJointBase_Pod.mConcreteType has unexpected offset % instead of 8", ((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxArticulationJointBase_Pod.mConcreteType)) == 2, "physx_PxArticulationJointBase_Pod.mConcreteType has unexpected size % instead of 2", size_of(type_of(physx_PxArticulationJointBase_Pod.mConcreteType)));
    assert(((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)) == 10, "physx_PxArticulationJointBase_Pod.mBaseFlags has unexpected offset % instead of 10", ((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxArticulationJointBase_Pod.mBaseFlags)) == 2, "physx_PxArticulationJointBase_Pod.mBaseFlags has unexpected size % instead of 2", size_of(type_of(physx_PxArticulationJointBase_Pod.mBaseFlags)));
    assert(((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)) == 12, "physx_PxArticulationJointBase_Pod.structgen_pad1 has unexpected offset % instead of 12", ((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxArticulationJointBase_Pod.structgen_pad1)) == 4, "physx_PxArticulationJointBase_Pod.structgen_pad1 has unexpected size % instead of 4", size_of(type_of(physx_PxArticulationJointBase_Pod.structgen_pad1)));
    assert(size_of(physx_PxArticulationJointBase_Pod) == 16, "physx_PxArticulationJointBase_Pod has size % instead of 16", size_of(physx_PxArticulationJointBase_Pod));
}

physx_PxArticulation_Pod :: struct {
    structgen_pad0: [8] u8;
    mConcreteType:  u16;
    mBaseFlags:     physx_PxBaseFlags_Pod;
    structgen_pad1: [4] u8;
    userData:       *void;
}
#run {
    instance: physx_PxArticulation_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxArticulation_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxArticulation_Pod.structgen_pad0)) == 8, "physx_PxArticulation_Pod.structgen_pad0 has unexpected size % instead of 8", size_of(type_of(physx_PxArticulation_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)) == 8, "physx_PxArticulation_Pod.mConcreteType has unexpected offset % instead of 8", ((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxArticulation_Pod.mConcreteType)) == 2, "physx_PxArticulation_Pod.mConcreteType has unexpected size % instead of 2", size_of(type_of(physx_PxArticulation_Pod.mConcreteType)));
    assert(((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)) == 10, "physx_PxArticulation_Pod.mBaseFlags has unexpected offset % instead of 10", ((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxArticulation_Pod.mBaseFlags)) == 2, "physx_PxArticulation_Pod.mBaseFlags has unexpected size % instead of 2", size_of(type_of(physx_PxArticulation_Pod.mBaseFlags)));
    assert(((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)) == 12, "physx_PxArticulation_Pod.structgen_pad1 has unexpected offset % instead of 12", ((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxArticulation_Pod.structgen_pad1)) == 4, "physx_PxArticulation_Pod.structgen_pad1 has unexpected size % instead of 4", size_of(type_of(physx_PxArticulation_Pod.structgen_pad1)));
    assert(((cast(*void)(*instance.userData)) - cast(*void)(*instance)) == 16, "physx_PxArticulation_Pod.userData has unexpected offset % instead of 16", ((cast(*void)(*instance.userData)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxArticulation_Pod.userData)) == 8, "physx_PxArticulation_Pod.userData has unexpected size % instead of 8", size_of(type_of(physx_PxArticulation_Pod.userData)));
    assert(size_of(physx_PxArticulation_Pod) == 24, "physx_PxArticulation_Pod has size % instead of 24", size_of(physx_PxArticulation_Pod));
}

physx_PxArticulationDriveCache_Pod :: struct {
    structgen_pad0: [1] u8;
}
#run {
    instance: physx_PxArticulationDriveCache_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxArticulationDriveCache_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxArticulationDriveCache_Pod.structgen_pad0)) == 1, "physx_PxArticulationDriveCache_Pod.structgen_pad0 has unexpected size % instead of 1", size_of(type_of(physx_PxArticulationDriveCache_Pod.structgen_pad0)));
    assert(size_of(physx_PxArticulationDriveCache_Pod) == 1, "physx_PxArticulationDriveCache_Pod has size % instead of 1", size_of(physx_PxArticulationDriveCache_Pod));
}

physx_PxConstraintInvMassScale_Pod :: struct {
    linear0:  float;
    angular0: float;
    linear1:  float;
    angular1: float;
}
#run {
    instance: physx_PxConstraintInvMassScale_Pod;
    assert(((cast(*void)(*instance.linear0)) - cast(*void)(*instance)) == 0, "physx_PxConstraintInvMassScale_Pod.linear0 has unexpected offset % instead of 0", ((cast(*void)(*instance.linear0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxConstraintInvMassScale_Pod.linear0)) == 4, "physx_PxConstraintInvMassScale_Pod.linear0 has unexpected size % instead of 4", size_of(type_of(physx_PxConstraintInvMassScale_Pod.linear0)));
    assert(((cast(*void)(*instance.angular0)) - cast(*void)(*instance)) == 4, "physx_PxConstraintInvMassScale_Pod.angular0 has unexpected offset % instead of 4", ((cast(*void)(*instance.angular0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxConstraintInvMassScale_Pod.angular0)) == 4, "physx_PxConstraintInvMassScale_Pod.angular0 has unexpected size % instead of 4", size_of(type_of(physx_PxConstraintInvMassScale_Pod.angular0)));
    assert(((cast(*void)(*instance.linear1)) - cast(*void)(*instance)) == 8, "physx_PxConstraintInvMassScale_Pod.linear1 has unexpected offset % instead of 8", ((cast(*void)(*instance.linear1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxConstraintInvMassScale_Pod.linear1)) == 4, "physx_PxConstraintInvMassScale_Pod.linear1 has unexpected size % instead of 4", size_of(type_of(physx_PxConstraintInvMassScale_Pod.linear1)));
    assert(((cast(*void)(*instance.angular1)) - cast(*void)(*instance)) == 12, "physx_PxConstraintInvMassScale_Pod.angular1 has unexpected offset % instead of 12", ((cast(*void)(*instance.angular1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxConstraintInvMassScale_Pod.angular1)) == 4, "physx_PxConstraintInvMassScale_Pod.angular1 has unexpected size % instead of 4", size_of(type_of(physx_PxConstraintInvMassScale_Pod.angular1)));
    assert(size_of(physx_PxConstraintInvMassScale_Pod) == 16, "physx_PxConstraintInvMassScale_Pod has size % instead of 16", size_of(physx_PxConstraintInvMassScale_Pod));
}

physx_PxConstraintVisualizer_Pod :: struct {
    vtable_: *void;
}
#run {
    instance: physx_PxConstraintVisualizer_Pod;
    assert(((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)) == 0, "physx_PxConstraintVisualizer_Pod.vtable_ has unexpected offset % instead of 0", ((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxConstraintVisualizer_Pod.vtable_)) == 8, "physx_PxConstraintVisualizer_Pod.vtable_ has unexpected size % instead of 8", size_of(type_of(physx_PxConstraintVisualizer_Pod.vtable_)));
    assert(size_of(physx_PxConstraintVisualizer_Pod) == 8, "physx_PxConstraintVisualizer_Pod has size % instead of 8", size_of(physx_PxConstraintVisualizer_Pod));
}

physx_PxConstraintConnector_Pod :: struct {
    vtable_: *void;
}
#run {
    instance: physx_PxConstraintConnector_Pod;
    assert(((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)) == 0, "physx_PxConstraintConnector_Pod.vtable_ has unexpected offset % instead of 0", ((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxConstraintConnector_Pod.vtable_)) == 8, "physx_PxConstraintConnector_Pod.vtable_ has unexpected size % instead of 8", size_of(type_of(physx_PxConstraintConnector_Pod.vtable_)));
    assert(size_of(physx_PxConstraintConnector_Pod) == 8, "physx_PxConstraintConnector_Pod has size % instead of 8", size_of(physx_PxConstraintConnector_Pod));
}

physx_pvdsdk_PvdDataStream_Pod :: struct {}
physx_PxConstraint_Pod :: struct {
    structgen_pad0: [8] u8;
    mConcreteType:  u16;
    mBaseFlags:     physx_PxBaseFlags_Pod;
    structgen_pad1: [4] u8;
}
#run {
    instance: physx_PxConstraint_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxConstraint_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxConstraint_Pod.structgen_pad0)) == 8, "physx_PxConstraint_Pod.structgen_pad0 has unexpected size % instead of 8", size_of(type_of(physx_PxConstraint_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)) == 8, "physx_PxConstraint_Pod.mConcreteType has unexpected offset % instead of 8", ((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxConstraint_Pod.mConcreteType)) == 2, "physx_PxConstraint_Pod.mConcreteType has unexpected size % instead of 2", size_of(type_of(physx_PxConstraint_Pod.mConcreteType)));
    assert(((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)) == 10, "physx_PxConstraint_Pod.mBaseFlags has unexpected offset % instead of 10", ((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxConstraint_Pod.mBaseFlags)) == 2, "physx_PxConstraint_Pod.mBaseFlags has unexpected size % instead of 2", size_of(type_of(physx_PxConstraint_Pod.mBaseFlags)));
    assert(((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)) == 12, "physx_PxConstraint_Pod.structgen_pad1 has unexpected offset % instead of 12", ((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxConstraint_Pod.structgen_pad1)) == 4, "physx_PxConstraint_Pod.structgen_pad1 has unexpected size % instead of 4", size_of(type_of(physx_PxConstraint_Pod.structgen_pad1)));
    assert(size_of(physx_PxConstraint_Pod) == 16, "physx_PxConstraint_Pod has size % instead of 16", size_of(physx_PxConstraint_Pod));
}

physx_PxSolverBody_Pod :: struct {
    linearVelocity:            physx_PxVec3_Pod;
    maxSolverNormalProgress:   u16;
    maxSolverFrictionProgress: u16;
    angularState:              physx_PxVec3_Pod;
    solverProgress:            u32;
}
#run {
    instance: physx_PxSolverBody_Pod;
    assert(((cast(*void)(*instance.linearVelocity)) - cast(*void)(*instance)) == 0, "physx_PxSolverBody_Pod.linearVelocity has unexpected offset % instead of 0", ((cast(*void)(*instance.linearVelocity)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSolverBody_Pod.linearVelocity)) == 12, "physx_PxSolverBody_Pod.linearVelocity has unexpected size % instead of 12", size_of(type_of(physx_PxSolverBody_Pod.linearVelocity)));
    assert(((cast(*void)(*instance.maxSolverNormalProgress)) - cast(*void)(*instance)) == 12, "physx_PxSolverBody_Pod.maxSolverNormalProgress has unexpected offset % instead of 12", ((cast(*void)(*instance.maxSolverNormalProgress)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSolverBody_Pod.maxSolverNormalProgress)) == 2, "physx_PxSolverBody_Pod.maxSolverNormalProgress has unexpected size % instead of 2", size_of(type_of(physx_PxSolverBody_Pod.maxSolverNormalProgress)));
    assert(((cast(*void)(*instance.maxSolverFrictionProgress)) - cast(*void)(*instance)) == 14, "physx_PxSolverBody_Pod.maxSolverFrictionProgress has unexpected offset % instead of 14", ((cast(*void)(*instance.maxSolverFrictionProgress)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSolverBody_Pod.maxSolverFrictionProgress)) == 2, "physx_PxSolverBody_Pod.maxSolverFrictionProgress has unexpected size % instead of 2", size_of(type_of(physx_PxSolverBody_Pod.maxSolverFrictionProgress)));
    assert(((cast(*void)(*instance.angularState)) - cast(*void)(*instance)) == 16, "physx_PxSolverBody_Pod.angularState has unexpected offset % instead of 16", ((cast(*void)(*instance.angularState)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSolverBody_Pod.angularState)) == 12, "physx_PxSolverBody_Pod.angularState has unexpected size % instead of 12", size_of(type_of(physx_PxSolverBody_Pod.angularState)));
    assert(((cast(*void)(*instance.solverProgress)) - cast(*void)(*instance)) == 28, "physx_PxSolverBody_Pod.solverProgress has unexpected offset % instead of 28", ((cast(*void)(*instance.solverProgress)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSolverBody_Pod.solverProgress)) == 4, "physx_PxSolverBody_Pod.solverProgress has unexpected size % instead of 4", size_of(type_of(physx_PxSolverBody_Pod.solverProgress)));
    assert(size_of(physx_PxSolverBody_Pod) == 32, "physx_PxSolverBody_Pod has size % instead of 32", size_of(physx_PxSolverBody_Pod));
}

physx_PxSolverBodyData_Pod :: struct {
    linearVelocity:    physx_PxVec3_Pod;
    invMass:           float;
    angularVelocity:   physx_PxVec3_Pod;
    reportThreshold:   float;
    sqrtInvInertia:    physx_PxMat33_Pod;
    penBiasClamp:      float;
    nodeIndex:         u32;
    maxContactImpulse: float;
    body2World:        physx_PxTransform_Pod;
    lockFlags:         u16;
    pad:               u16;
}
#run {
    instance: physx_PxSolverBodyData_Pod;
    assert(((cast(*void)(*instance.linearVelocity)) - cast(*void)(*instance)) == 0, "physx_PxSolverBodyData_Pod.linearVelocity has unexpected offset % instead of 0", ((cast(*void)(*instance.linearVelocity)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSolverBodyData_Pod.linearVelocity)) == 12, "physx_PxSolverBodyData_Pod.linearVelocity has unexpected size % instead of 12", size_of(type_of(physx_PxSolverBodyData_Pod.linearVelocity)));
    assert(((cast(*void)(*instance.invMass)) - cast(*void)(*instance)) == 12, "physx_PxSolverBodyData_Pod.invMass has unexpected offset % instead of 12", ((cast(*void)(*instance.invMass)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSolverBodyData_Pod.invMass)) == 4, "physx_PxSolverBodyData_Pod.invMass has unexpected size % instead of 4", size_of(type_of(physx_PxSolverBodyData_Pod.invMass)));
    assert(((cast(*void)(*instance.angularVelocity)) - cast(*void)(*instance)) == 16, "physx_PxSolverBodyData_Pod.angularVelocity has unexpected offset % instead of 16", ((cast(*void)(*instance.angularVelocity)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSolverBodyData_Pod.angularVelocity)) == 12, "physx_PxSolverBodyData_Pod.angularVelocity has unexpected size % instead of 12", size_of(type_of(physx_PxSolverBodyData_Pod.angularVelocity)));
    assert(((cast(*void)(*instance.reportThreshold)) - cast(*void)(*instance)) == 28, "physx_PxSolverBodyData_Pod.reportThreshold has unexpected offset % instead of 28", ((cast(*void)(*instance.reportThreshold)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSolverBodyData_Pod.reportThreshold)) == 4, "physx_PxSolverBodyData_Pod.reportThreshold has unexpected size % instead of 4", size_of(type_of(physx_PxSolverBodyData_Pod.reportThreshold)));
    assert(((cast(*void)(*instance.sqrtInvInertia)) - cast(*void)(*instance)) == 32, "physx_PxSolverBodyData_Pod.sqrtInvInertia has unexpected offset % instead of 32", ((cast(*void)(*instance.sqrtInvInertia)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSolverBodyData_Pod.sqrtInvInertia)) == 36, "physx_PxSolverBodyData_Pod.sqrtInvInertia has unexpected size % instead of 36", size_of(type_of(physx_PxSolverBodyData_Pod.sqrtInvInertia)));
    assert(((cast(*void)(*instance.penBiasClamp)) - cast(*void)(*instance)) == 68, "physx_PxSolverBodyData_Pod.penBiasClamp has unexpected offset % instead of 68", ((cast(*void)(*instance.penBiasClamp)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSolverBodyData_Pod.penBiasClamp)) == 4, "physx_PxSolverBodyData_Pod.penBiasClamp has unexpected size % instead of 4", size_of(type_of(physx_PxSolverBodyData_Pod.penBiasClamp)));
    assert(((cast(*void)(*instance.nodeIndex)) - cast(*void)(*instance)) == 72, "physx_PxSolverBodyData_Pod.nodeIndex has unexpected offset % instead of 72", ((cast(*void)(*instance.nodeIndex)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSolverBodyData_Pod.nodeIndex)) == 4, "physx_PxSolverBodyData_Pod.nodeIndex has unexpected size % instead of 4", size_of(type_of(physx_PxSolverBodyData_Pod.nodeIndex)));
    assert(((cast(*void)(*instance.maxContactImpulse)) - cast(*void)(*instance)) == 76, "physx_PxSolverBodyData_Pod.maxContactImpulse has unexpected offset % instead of 76", ((cast(*void)(*instance.maxContactImpulse)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSolverBodyData_Pod.maxContactImpulse)) == 4, "physx_PxSolverBodyData_Pod.maxContactImpulse has unexpected size % instead of 4", size_of(type_of(physx_PxSolverBodyData_Pod.maxContactImpulse)));
    assert(((cast(*void)(*instance.body2World)) - cast(*void)(*instance)) == 80, "physx_PxSolverBodyData_Pod.body2World has unexpected offset % instead of 80", ((cast(*void)(*instance.body2World)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSolverBodyData_Pod.body2World)) == 28, "physx_PxSolverBodyData_Pod.body2World has unexpected size % instead of 28", size_of(type_of(physx_PxSolverBodyData_Pod.body2World)));
    assert(((cast(*void)(*instance.lockFlags)) - cast(*void)(*instance)) == 108, "physx_PxSolverBodyData_Pod.lockFlags has unexpected offset % instead of 108", ((cast(*void)(*instance.lockFlags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSolverBodyData_Pod.lockFlags)) == 2, "physx_PxSolverBodyData_Pod.lockFlags has unexpected size % instead of 2", size_of(type_of(physx_PxSolverBodyData_Pod.lockFlags)));
    assert(((cast(*void)(*instance.pad)) - cast(*void)(*instance)) == 110, "physx_PxSolverBodyData_Pod.pad has unexpected offset % instead of 110", ((cast(*void)(*instance.pad)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSolverBodyData_Pod.pad)) == 2, "physx_PxSolverBodyData_Pod.pad has unexpected size % instead of 2", size_of(type_of(physx_PxSolverBodyData_Pod.pad)));
    assert(size_of(physx_PxSolverBodyData_Pod) == 112, "physx_PxSolverBodyData_Pod has size % instead of 112", size_of(physx_PxSolverBodyData_Pod));
}

physx_PxConstraintAllocator_Pod :: struct {
    vtable_: *void;
}
#run {
    instance: physx_PxConstraintAllocator_Pod;
    assert(((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)) == 0, "physx_PxConstraintAllocator_Pod.vtable_ has unexpected offset % instead of 0", ((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxConstraintAllocator_Pod.vtable_)) == 8, "physx_PxConstraintAllocator_Pod.vtable_ has unexpected size % instead of 8", size_of(type_of(physx_PxConstraintAllocator_Pod.vtable_)));
    assert(size_of(physx_PxConstraintAllocator_Pod) == 8, "physx_PxConstraintAllocator_Pod has size % instead of 8", size_of(physx_PxConstraintAllocator_Pod));
}

physx_PxTGSSolverBodyVel_Pod :: struct {
    linearVelocity:       physx_PxVec3_Pod;
    nbStaticInteractions: u16;
    maxDynamicPartition:  u16;
    angularVelocity:      physx_PxVec3_Pod;
    partitionMask:        u32;
    deltaAngDt:           physx_PxVec3_Pod;
    maxAngVel:            float;
    deltaLinDt:           physx_PxVec3_Pod;
    lockFlags:            u16;
    isKinematic:          bool;
    pad:                  u8;
}
#run {
    instance: physx_PxTGSSolverBodyVel_Pod;
    assert(((cast(*void)(*instance.linearVelocity)) - cast(*void)(*instance)) == 0, "physx_PxTGSSolverBodyVel_Pod.linearVelocity has unexpected offset % instead of 0", ((cast(*void)(*instance.linearVelocity)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxTGSSolverBodyVel_Pod.linearVelocity)) == 12, "physx_PxTGSSolverBodyVel_Pod.linearVelocity has unexpected size % instead of 12", size_of(type_of(physx_PxTGSSolverBodyVel_Pod.linearVelocity)));
    assert(((cast(*void)(*instance.nbStaticInteractions)) - cast(*void)(*instance)) == 12, "physx_PxTGSSolverBodyVel_Pod.nbStaticInteractions has unexpected offset % instead of 12", ((cast(*void)(*instance.nbStaticInteractions)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxTGSSolverBodyVel_Pod.nbStaticInteractions)) == 2, "physx_PxTGSSolverBodyVel_Pod.nbStaticInteractions has unexpected size % instead of 2", size_of(type_of(physx_PxTGSSolverBodyVel_Pod.nbStaticInteractions)));
    assert(((cast(*void)(*instance.maxDynamicPartition)) - cast(*void)(*instance)) == 14, "physx_PxTGSSolverBodyVel_Pod.maxDynamicPartition has unexpected offset % instead of 14", ((cast(*void)(*instance.maxDynamicPartition)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxTGSSolverBodyVel_Pod.maxDynamicPartition)) == 2, "physx_PxTGSSolverBodyVel_Pod.maxDynamicPartition has unexpected size % instead of 2", size_of(type_of(physx_PxTGSSolverBodyVel_Pod.maxDynamicPartition)));
    assert(((cast(*void)(*instance.angularVelocity)) - cast(*void)(*instance)) == 16, "physx_PxTGSSolverBodyVel_Pod.angularVelocity has unexpected offset % instead of 16", ((cast(*void)(*instance.angularVelocity)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxTGSSolverBodyVel_Pod.angularVelocity)) == 12, "physx_PxTGSSolverBodyVel_Pod.angularVelocity has unexpected size % instead of 12", size_of(type_of(physx_PxTGSSolverBodyVel_Pod.angularVelocity)));
    assert(((cast(*void)(*instance.partitionMask)) - cast(*void)(*instance)) == 28, "physx_PxTGSSolverBodyVel_Pod.partitionMask has unexpected offset % instead of 28", ((cast(*void)(*instance.partitionMask)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxTGSSolverBodyVel_Pod.partitionMask)) == 4, "physx_PxTGSSolverBodyVel_Pod.partitionMask has unexpected size % instead of 4", size_of(type_of(physx_PxTGSSolverBodyVel_Pod.partitionMask)));
    assert(((cast(*void)(*instance.deltaAngDt)) - cast(*void)(*instance)) == 32, "physx_PxTGSSolverBodyVel_Pod.deltaAngDt has unexpected offset % instead of 32", ((cast(*void)(*instance.deltaAngDt)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxTGSSolverBodyVel_Pod.deltaAngDt)) == 12, "physx_PxTGSSolverBodyVel_Pod.deltaAngDt has unexpected size % instead of 12", size_of(type_of(physx_PxTGSSolverBodyVel_Pod.deltaAngDt)));
    assert(((cast(*void)(*instance.maxAngVel)) - cast(*void)(*instance)) == 44, "physx_PxTGSSolverBodyVel_Pod.maxAngVel has unexpected offset % instead of 44", ((cast(*void)(*instance.maxAngVel)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxTGSSolverBodyVel_Pod.maxAngVel)) == 4, "physx_PxTGSSolverBodyVel_Pod.maxAngVel has unexpected size % instead of 4", size_of(type_of(physx_PxTGSSolverBodyVel_Pod.maxAngVel)));
    assert(((cast(*void)(*instance.deltaLinDt)) - cast(*void)(*instance)) == 48, "physx_PxTGSSolverBodyVel_Pod.deltaLinDt has unexpected offset % instead of 48", ((cast(*void)(*instance.deltaLinDt)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxTGSSolverBodyVel_Pod.deltaLinDt)) == 12, "physx_PxTGSSolverBodyVel_Pod.deltaLinDt has unexpected size % instead of 12", size_of(type_of(physx_PxTGSSolverBodyVel_Pod.deltaLinDt)));
    assert(((cast(*void)(*instance.lockFlags)) - cast(*void)(*instance)) == 60, "physx_PxTGSSolverBodyVel_Pod.lockFlags has unexpected offset % instead of 60", ((cast(*void)(*instance.lockFlags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxTGSSolverBodyVel_Pod.lockFlags)) == 2, "physx_PxTGSSolverBodyVel_Pod.lockFlags has unexpected size % instead of 2", size_of(type_of(physx_PxTGSSolverBodyVel_Pod.lockFlags)));
    assert(((cast(*void)(*instance.isKinematic)) - cast(*void)(*instance)) == 62, "physx_PxTGSSolverBodyVel_Pod.isKinematic has unexpected offset % instead of 62", ((cast(*void)(*instance.isKinematic)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxTGSSolverBodyVel_Pod.isKinematic)) == 1, "physx_PxTGSSolverBodyVel_Pod.isKinematic has unexpected size % instead of 1", size_of(type_of(physx_PxTGSSolverBodyVel_Pod.isKinematic)));
    assert(((cast(*void)(*instance.pad)) - cast(*void)(*instance)) == 63, "physx_PxTGSSolverBodyVel_Pod.pad has unexpected offset % instead of 63", ((cast(*void)(*instance.pad)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxTGSSolverBodyVel_Pod.pad)) == 1, "physx_PxTGSSolverBodyVel_Pod.pad has unexpected size % instead of 1", size_of(type_of(physx_PxTGSSolverBodyVel_Pod.pad)));
    assert(size_of(physx_PxTGSSolverBodyVel_Pod) == 64, "physx_PxTGSSolverBodyVel_Pod has size % instead of 64", size_of(physx_PxTGSSolverBodyVel_Pod));
}

physx_PxTGSSolverBodyData_Pod :: struct {
    originalLinearVelocity:  physx_PxVec3_Pod;
    maxContactImpulse:       float;
    originalAngularVelocity: physx_PxVec3_Pod;
    penBiasClamp:            float;
    invMass:                 float;
    nodeIndex:               u32;
    reportThreshold:         float;
    pad:                     u32;
}
#run {
    instance: physx_PxTGSSolverBodyData_Pod;
    assert(((cast(*void)(*instance.originalLinearVelocity)) - cast(*void)(*instance)) == 0, "physx_PxTGSSolverBodyData_Pod.originalLinearVelocity has unexpected offset % instead of 0", ((cast(*void)(*instance.originalLinearVelocity)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxTGSSolverBodyData_Pod.originalLinearVelocity)) == 12, "physx_PxTGSSolverBodyData_Pod.originalLinearVelocity has unexpected size % instead of 12", size_of(type_of(physx_PxTGSSolverBodyData_Pod.originalLinearVelocity)));
    assert(((cast(*void)(*instance.maxContactImpulse)) - cast(*void)(*instance)) == 12, "physx_PxTGSSolverBodyData_Pod.maxContactImpulse has unexpected offset % instead of 12", ((cast(*void)(*instance.maxContactImpulse)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxTGSSolverBodyData_Pod.maxContactImpulse)) == 4, "physx_PxTGSSolverBodyData_Pod.maxContactImpulse has unexpected size % instead of 4", size_of(type_of(physx_PxTGSSolverBodyData_Pod.maxContactImpulse)));
    assert(((cast(*void)(*instance.originalAngularVelocity)) - cast(*void)(*instance)) == 16, "physx_PxTGSSolverBodyData_Pod.originalAngularVelocity has unexpected offset % instead of 16", ((cast(*void)(*instance.originalAngularVelocity)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxTGSSolverBodyData_Pod.originalAngularVelocity)) == 12, "physx_PxTGSSolverBodyData_Pod.originalAngularVelocity has unexpected size % instead of 12", size_of(type_of(physx_PxTGSSolverBodyData_Pod.originalAngularVelocity)));
    assert(((cast(*void)(*instance.penBiasClamp)) - cast(*void)(*instance)) == 28, "physx_PxTGSSolverBodyData_Pod.penBiasClamp has unexpected offset % instead of 28", ((cast(*void)(*instance.penBiasClamp)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxTGSSolverBodyData_Pod.penBiasClamp)) == 4, "physx_PxTGSSolverBodyData_Pod.penBiasClamp has unexpected size % instead of 4", size_of(type_of(physx_PxTGSSolverBodyData_Pod.penBiasClamp)));
    assert(((cast(*void)(*instance.invMass)) - cast(*void)(*instance)) == 32, "physx_PxTGSSolverBodyData_Pod.invMass has unexpected offset % instead of 32", ((cast(*void)(*instance.invMass)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxTGSSolverBodyData_Pod.invMass)) == 4, "physx_PxTGSSolverBodyData_Pod.invMass has unexpected size % instead of 4", size_of(type_of(physx_PxTGSSolverBodyData_Pod.invMass)));
    assert(((cast(*void)(*instance.nodeIndex)) - cast(*void)(*instance)) == 36, "physx_PxTGSSolverBodyData_Pod.nodeIndex has unexpected offset % instead of 36", ((cast(*void)(*instance.nodeIndex)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxTGSSolverBodyData_Pod.nodeIndex)) == 4, "physx_PxTGSSolverBodyData_Pod.nodeIndex has unexpected size % instead of 4", size_of(type_of(physx_PxTGSSolverBodyData_Pod.nodeIndex)));
    assert(((cast(*void)(*instance.reportThreshold)) - cast(*void)(*instance)) == 40, "physx_PxTGSSolverBodyData_Pod.reportThreshold has unexpected offset % instead of 40", ((cast(*void)(*instance.reportThreshold)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxTGSSolverBodyData_Pod.reportThreshold)) == 4, "physx_PxTGSSolverBodyData_Pod.reportThreshold has unexpected size % instead of 4", size_of(type_of(physx_PxTGSSolverBodyData_Pod.reportThreshold)));
    assert(((cast(*void)(*instance.pad)) - cast(*void)(*instance)) == 44, "physx_PxTGSSolverBodyData_Pod.pad has unexpected offset % instead of 44", ((cast(*void)(*instance.pad)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxTGSSolverBodyData_Pod.pad)) == 4, "physx_PxTGSSolverBodyData_Pod.pad has unexpected size % instead of 4", size_of(type_of(physx_PxTGSSolverBodyData_Pod.pad)));
    assert(size_of(physx_PxTGSSolverBodyData_Pod) == 48, "physx_PxTGSSolverBodyData_Pod has size % instead of 48", size_of(physx_PxTGSSolverBodyData_Pod));
}

physx_PxSpatialForce_Pod :: struct {
    force:  physx_PxVec3_Pod;
    pad0:   float;
    torque: physx_PxVec3_Pod;
    pad1:   float;
}
#run {
    instance: physx_PxSpatialForce_Pod;
    assert(((cast(*void)(*instance.force)) - cast(*void)(*instance)) == 0, "physx_PxSpatialForce_Pod.force has unexpected offset % instead of 0", ((cast(*void)(*instance.force)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSpatialForce_Pod.force)) == 12, "physx_PxSpatialForce_Pod.force has unexpected size % instead of 12", size_of(type_of(physx_PxSpatialForce_Pod.force)));
    assert(((cast(*void)(*instance.pad0)) - cast(*void)(*instance)) == 12, "physx_PxSpatialForce_Pod.pad0 has unexpected offset % instead of 12", ((cast(*void)(*instance.pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSpatialForce_Pod.pad0)) == 4, "physx_PxSpatialForce_Pod.pad0 has unexpected size % instead of 4", size_of(type_of(physx_PxSpatialForce_Pod.pad0)));
    assert(((cast(*void)(*instance.torque)) - cast(*void)(*instance)) == 16, "physx_PxSpatialForce_Pod.torque has unexpected offset % instead of 16", ((cast(*void)(*instance.torque)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSpatialForce_Pod.torque)) == 12, "physx_PxSpatialForce_Pod.torque has unexpected size % instead of 12", size_of(type_of(physx_PxSpatialForce_Pod.torque)));
    assert(((cast(*void)(*instance.pad1)) - cast(*void)(*instance)) == 28, "physx_PxSpatialForce_Pod.pad1 has unexpected offset % instead of 28", ((cast(*void)(*instance.pad1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSpatialForce_Pod.pad1)) == 4, "physx_PxSpatialForce_Pod.pad1 has unexpected size % instead of 4", size_of(type_of(physx_PxSpatialForce_Pod.pad1)));
    assert(size_of(physx_PxSpatialForce_Pod) == 32, "physx_PxSpatialForce_Pod has size % instead of 32", size_of(physx_PxSpatialForce_Pod));
}

physx_PxSpatialVelocity_Pod :: struct {
    linear:  physx_PxVec3_Pod;
    pad0:    float;
    angular: physx_PxVec3_Pod;
    pad1:    float;
}
#run {
    instance: physx_PxSpatialVelocity_Pod;
    assert(((cast(*void)(*instance.linear)) - cast(*void)(*instance)) == 0, "physx_PxSpatialVelocity_Pod.linear has unexpected offset % instead of 0", ((cast(*void)(*instance.linear)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSpatialVelocity_Pod.linear)) == 12, "physx_PxSpatialVelocity_Pod.linear has unexpected size % instead of 12", size_of(type_of(physx_PxSpatialVelocity_Pod.linear)));
    assert(((cast(*void)(*instance.pad0)) - cast(*void)(*instance)) == 12, "physx_PxSpatialVelocity_Pod.pad0 has unexpected offset % instead of 12", ((cast(*void)(*instance.pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSpatialVelocity_Pod.pad0)) == 4, "physx_PxSpatialVelocity_Pod.pad0 has unexpected size % instead of 4", size_of(type_of(physx_PxSpatialVelocity_Pod.pad0)));
    assert(((cast(*void)(*instance.angular)) - cast(*void)(*instance)) == 16, "physx_PxSpatialVelocity_Pod.angular has unexpected offset % instead of 16", ((cast(*void)(*instance.angular)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSpatialVelocity_Pod.angular)) == 12, "physx_PxSpatialVelocity_Pod.angular has unexpected size % instead of 12", size_of(type_of(physx_PxSpatialVelocity_Pod.angular)));
    assert(((cast(*void)(*instance.pad1)) - cast(*void)(*instance)) == 28, "physx_PxSpatialVelocity_Pod.pad1 has unexpected offset % instead of 28", ((cast(*void)(*instance.pad1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSpatialVelocity_Pod.pad1)) == 4, "physx_PxSpatialVelocity_Pod.pad1 has unexpected size % instead of 4", size_of(type_of(physx_PxSpatialVelocity_Pod.pad1)));
    assert(size_of(physx_PxSpatialVelocity_Pod) == 32, "physx_PxSpatialVelocity_Pod has size % instead of 32", size_of(physx_PxSpatialVelocity_Pod));
}

physx_PxArticulationRootLinkData_Pod :: struct {
    transform:     physx_PxTransform_Pod;
    worldLinVel:   physx_PxVec3_Pod;
    worldAngVel:   physx_PxVec3_Pod;
    worldLinAccel: physx_PxVec3_Pod;
    worldAngAccel: physx_PxVec3_Pod;
}
#run {
    instance: physx_PxArticulationRootLinkData_Pod;
    assert(((cast(*void)(*instance.transform)) - cast(*void)(*instance)) == 0, "physx_PxArticulationRootLinkData_Pod.transform has unexpected offset % instead of 0", ((cast(*void)(*instance.transform)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxArticulationRootLinkData_Pod.transform)) == 28, "physx_PxArticulationRootLinkData_Pod.transform has unexpected size % instead of 28", size_of(type_of(physx_PxArticulationRootLinkData_Pod.transform)));
    assert(((cast(*void)(*instance.worldLinVel)) - cast(*void)(*instance)) == 28, "physx_PxArticulationRootLinkData_Pod.worldLinVel has unexpected offset % instead of 28", ((cast(*void)(*instance.worldLinVel)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxArticulationRootLinkData_Pod.worldLinVel)) == 12, "physx_PxArticulationRootLinkData_Pod.worldLinVel has unexpected size % instead of 12", size_of(type_of(physx_PxArticulationRootLinkData_Pod.worldLinVel)));
    assert(((cast(*void)(*instance.worldAngVel)) - cast(*void)(*instance)) == 40, "physx_PxArticulationRootLinkData_Pod.worldAngVel has unexpected offset % instead of 40", ((cast(*void)(*instance.worldAngVel)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxArticulationRootLinkData_Pod.worldAngVel)) == 12, "physx_PxArticulationRootLinkData_Pod.worldAngVel has unexpected size % instead of 12", size_of(type_of(physx_PxArticulationRootLinkData_Pod.worldAngVel)));
    assert(((cast(*void)(*instance.worldLinAccel)) - cast(*void)(*instance)) == 52, "physx_PxArticulationRootLinkData_Pod.worldLinAccel has unexpected offset % instead of 52", ((cast(*void)(*instance.worldLinAccel)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxArticulationRootLinkData_Pod.worldLinAccel)) == 12, "physx_PxArticulationRootLinkData_Pod.worldLinAccel has unexpected size % instead of 12", size_of(type_of(physx_PxArticulationRootLinkData_Pod.worldLinAccel)));
    assert(((cast(*void)(*instance.worldAngAccel)) - cast(*void)(*instance)) == 64, "physx_PxArticulationRootLinkData_Pod.worldAngAccel has unexpected offset % instead of 64", ((cast(*void)(*instance.worldAngAccel)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxArticulationRootLinkData_Pod.worldAngAccel)) == 12, "physx_PxArticulationRootLinkData_Pod.worldAngAccel has unexpected size % instead of 12", size_of(type_of(physx_PxArticulationRootLinkData_Pod.worldAngAccel)));
    assert(size_of(physx_PxArticulationRootLinkData_Pod) == 76, "physx_PxArticulationRootLinkData_Pod has size % instead of 76", size_of(physx_PxArticulationRootLinkData_Pod));
}

physx_PxArticulationCache_Pod :: struct {
    externalForces:    *physx_PxSpatialForce_Pod;
    denseJacobian:     *float;
    massMatrix:        *float;
    jointVelocity:     *float;
    jointAcceleration: *float;
    jointPosition:     *float;
    jointForce:        *float;
    linkVelocity:      *physx_PxSpatialVelocity_Pod;
    linkAcceleration:  *physx_PxSpatialVelocity_Pod;
    rootLinkData:      *physx_PxArticulationRootLinkData_Pod;
    coefficientMatrix: *float;
    lambda:            *float;
    scratchMemory:     *void;
    scratchAllocator:  *void;
    version:           u32;
    structgen_pad0:    [4] u8;
}
#run {
    instance: physx_PxArticulationCache_Pod;
    assert(((cast(*void)(*instance.externalForces)) - cast(*void)(*instance)) == 0, "physx_PxArticulationCache_Pod.externalForces has unexpected offset % instead of 0", ((cast(*void)(*instance.externalForces)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxArticulationCache_Pod.externalForces)) == 8, "physx_PxArticulationCache_Pod.externalForces has unexpected size % instead of 8", size_of(type_of(physx_PxArticulationCache_Pod.externalForces)));
    assert(((cast(*void)(*instance.denseJacobian)) - cast(*void)(*instance)) == 8, "physx_PxArticulationCache_Pod.denseJacobian has unexpected offset % instead of 8", ((cast(*void)(*instance.denseJacobian)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxArticulationCache_Pod.denseJacobian)) == 8, "physx_PxArticulationCache_Pod.denseJacobian has unexpected size % instead of 8", size_of(type_of(physx_PxArticulationCache_Pod.denseJacobian)));
    assert(((cast(*void)(*instance.massMatrix)) - cast(*void)(*instance)) == 16, "physx_PxArticulationCache_Pod.massMatrix has unexpected offset % instead of 16", ((cast(*void)(*instance.massMatrix)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxArticulationCache_Pod.massMatrix)) == 8, "physx_PxArticulationCache_Pod.massMatrix has unexpected size % instead of 8", size_of(type_of(physx_PxArticulationCache_Pod.massMatrix)));
    assert(((cast(*void)(*instance.jointVelocity)) - cast(*void)(*instance)) == 24, "physx_PxArticulationCache_Pod.jointVelocity has unexpected offset % instead of 24", ((cast(*void)(*instance.jointVelocity)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxArticulationCache_Pod.jointVelocity)) == 8, "physx_PxArticulationCache_Pod.jointVelocity has unexpected size % instead of 8", size_of(type_of(physx_PxArticulationCache_Pod.jointVelocity)));
    assert(((cast(*void)(*instance.jointAcceleration)) - cast(*void)(*instance)) == 32, "physx_PxArticulationCache_Pod.jointAcceleration has unexpected offset % instead of 32", ((cast(*void)(*instance.jointAcceleration)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxArticulationCache_Pod.jointAcceleration)) == 8, "physx_PxArticulationCache_Pod.jointAcceleration has unexpected size % instead of 8", size_of(type_of(physx_PxArticulationCache_Pod.jointAcceleration)));
    assert(((cast(*void)(*instance.jointPosition)) - cast(*void)(*instance)) == 40, "physx_PxArticulationCache_Pod.jointPosition has unexpected offset % instead of 40", ((cast(*void)(*instance.jointPosition)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxArticulationCache_Pod.jointPosition)) == 8, "physx_PxArticulationCache_Pod.jointPosition has unexpected size % instead of 8", size_of(type_of(physx_PxArticulationCache_Pod.jointPosition)));
    assert(((cast(*void)(*instance.jointForce)) - cast(*void)(*instance)) == 48, "physx_PxArticulationCache_Pod.jointForce has unexpected offset % instead of 48", ((cast(*void)(*instance.jointForce)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxArticulationCache_Pod.jointForce)) == 8, "physx_PxArticulationCache_Pod.jointForce has unexpected size % instead of 8", size_of(type_of(physx_PxArticulationCache_Pod.jointForce)));
    assert(((cast(*void)(*instance.linkVelocity)) - cast(*void)(*instance)) == 56, "physx_PxArticulationCache_Pod.linkVelocity has unexpected offset % instead of 56", ((cast(*void)(*instance.linkVelocity)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxArticulationCache_Pod.linkVelocity)) == 8, "physx_PxArticulationCache_Pod.linkVelocity has unexpected size % instead of 8", size_of(type_of(physx_PxArticulationCache_Pod.linkVelocity)));
    assert(((cast(*void)(*instance.linkAcceleration)) - cast(*void)(*instance)) == 64, "physx_PxArticulationCache_Pod.linkAcceleration has unexpected offset % instead of 64", ((cast(*void)(*instance.linkAcceleration)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxArticulationCache_Pod.linkAcceleration)) == 8, "physx_PxArticulationCache_Pod.linkAcceleration has unexpected size % instead of 8", size_of(type_of(physx_PxArticulationCache_Pod.linkAcceleration)));
    assert(((cast(*void)(*instance.rootLinkData)) - cast(*void)(*instance)) == 72, "physx_PxArticulationCache_Pod.rootLinkData has unexpected offset % instead of 72", ((cast(*void)(*instance.rootLinkData)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxArticulationCache_Pod.rootLinkData)) == 8, "physx_PxArticulationCache_Pod.rootLinkData has unexpected size % instead of 8", size_of(type_of(physx_PxArticulationCache_Pod.rootLinkData)));
    assert(((cast(*void)(*instance.coefficientMatrix)) - cast(*void)(*instance)) == 80, "physx_PxArticulationCache_Pod.coefficientMatrix has unexpected offset % instead of 80", ((cast(*void)(*instance.coefficientMatrix)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxArticulationCache_Pod.coefficientMatrix)) == 8, "physx_PxArticulationCache_Pod.coefficientMatrix has unexpected size % instead of 8", size_of(type_of(physx_PxArticulationCache_Pod.coefficientMatrix)));
    assert(((cast(*void)(*instance.lambda)) - cast(*void)(*instance)) == 88, "physx_PxArticulationCache_Pod.lambda has unexpected offset % instead of 88", ((cast(*void)(*instance.lambda)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxArticulationCache_Pod.lambda)) == 8, "physx_PxArticulationCache_Pod.lambda has unexpected size % instead of 8", size_of(type_of(physx_PxArticulationCache_Pod.lambda)));
    assert(((cast(*void)(*instance.scratchMemory)) - cast(*void)(*instance)) == 96, "physx_PxArticulationCache_Pod.scratchMemory has unexpected offset % instead of 96", ((cast(*void)(*instance.scratchMemory)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxArticulationCache_Pod.scratchMemory)) == 8, "physx_PxArticulationCache_Pod.scratchMemory has unexpected size % instead of 8", size_of(type_of(physx_PxArticulationCache_Pod.scratchMemory)));
    assert(((cast(*void)(*instance.scratchAllocator)) - cast(*void)(*instance)) == 104, "physx_PxArticulationCache_Pod.scratchAllocator has unexpected offset % instead of 104", ((cast(*void)(*instance.scratchAllocator)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxArticulationCache_Pod.scratchAllocator)) == 8, "physx_PxArticulationCache_Pod.scratchAllocator has unexpected size % instead of 8", size_of(type_of(physx_PxArticulationCache_Pod.scratchAllocator)));
    assert(((cast(*void)(*instance.version)) - cast(*void)(*instance)) == 112, "physx_PxArticulationCache_Pod.version has unexpected offset % instead of 112", ((cast(*void)(*instance.version)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxArticulationCache_Pod.version)) == 4, "physx_PxArticulationCache_Pod.version has unexpected size % instead of 4", size_of(type_of(physx_PxArticulationCache_Pod.version)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 116, "physx_PxArticulationCache_Pod.structgen_pad0 has unexpected offset % instead of 116", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxArticulationCache_Pod.structgen_pad0)) == 4, "physx_PxArticulationCache_Pod.structgen_pad0 has unexpected size % instead of 4", size_of(type_of(physx_PxArticulationCache_Pod.structgen_pad0)));
    assert(size_of(physx_PxArticulationCache_Pod) == 120, "physx_PxArticulationCache_Pod has size % instead of 120", size_of(physx_PxArticulationCache_Pod));
}

physx_PxArticulationReducedCoordinate_Pod :: struct {
    structgen_pad0: [8] u8;
    mConcreteType:  u16;
    mBaseFlags:     physx_PxBaseFlags_Pod;
    structgen_pad1: [4] u8;
    userData:       *void;
}
#run {
    instance: physx_PxArticulationReducedCoordinate_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxArticulationReducedCoordinate_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxArticulationReducedCoordinate_Pod.structgen_pad0)) == 8, "physx_PxArticulationReducedCoordinate_Pod.structgen_pad0 has unexpected size % instead of 8", size_of(type_of(physx_PxArticulationReducedCoordinate_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)) == 8, "physx_PxArticulationReducedCoordinate_Pod.mConcreteType has unexpected offset % instead of 8", ((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxArticulationReducedCoordinate_Pod.mConcreteType)) == 2, "physx_PxArticulationReducedCoordinate_Pod.mConcreteType has unexpected size % instead of 2", size_of(type_of(physx_PxArticulationReducedCoordinate_Pod.mConcreteType)));
    assert(((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)) == 10, "physx_PxArticulationReducedCoordinate_Pod.mBaseFlags has unexpected offset % instead of 10", ((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxArticulationReducedCoordinate_Pod.mBaseFlags)) == 2, "physx_PxArticulationReducedCoordinate_Pod.mBaseFlags has unexpected size % instead of 2", size_of(type_of(physx_PxArticulationReducedCoordinate_Pod.mBaseFlags)));
    assert(((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)) == 12, "physx_PxArticulationReducedCoordinate_Pod.structgen_pad1 has unexpected offset % instead of 12", ((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxArticulationReducedCoordinate_Pod.structgen_pad1)) == 4, "physx_PxArticulationReducedCoordinate_Pod.structgen_pad1 has unexpected size % instead of 4", size_of(type_of(physx_PxArticulationReducedCoordinate_Pod.structgen_pad1)));
    assert(((cast(*void)(*instance.userData)) - cast(*void)(*instance)) == 16, "physx_PxArticulationReducedCoordinate_Pod.userData has unexpected offset % instead of 16", ((cast(*void)(*instance.userData)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxArticulationReducedCoordinate_Pod.userData)) == 8, "physx_PxArticulationReducedCoordinate_Pod.userData has unexpected size % instead of 8", size_of(type_of(physx_PxArticulationReducedCoordinate_Pod.userData)));
    assert(size_of(physx_PxArticulationReducedCoordinate_Pod) == 24, "physx_PxArticulationReducedCoordinate_Pod has size % instead of 24", size_of(physx_PxArticulationReducedCoordinate_Pod));
}

physx_PxArticulationFlags_Pod :: struct {
    mBits: u8;
}
#run {
    instance: physx_PxArticulationFlags_Pod;
    assert(((cast(*void)(*instance.mBits)) - cast(*void)(*instance)) == 0, "physx_PxArticulationFlags_Pod.mBits has unexpected offset % instead of 0", ((cast(*void)(*instance.mBits)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxArticulationFlags_Pod.mBits)) == 1, "physx_PxArticulationFlags_Pod.mBits has unexpected size % instead of 1", size_of(type_of(physx_PxArticulationFlags_Pod.mBits)));
    assert(size_of(physx_PxArticulationFlags_Pod) == 1, "physx_PxArticulationFlags_Pod has size % instead of 1", size_of(physx_PxArticulationFlags_Pod));
}

physx_PxArticulationCacheFlags_Pod :: struct {
    mBits: u8;
}
#run {
    instance: physx_PxArticulationCacheFlags_Pod;
    assert(((cast(*void)(*instance.mBits)) - cast(*void)(*instance)) == 0, "physx_PxArticulationCacheFlags_Pod.mBits has unexpected offset % instead of 0", ((cast(*void)(*instance.mBits)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxArticulationCacheFlags_Pod.mBits)) == 1, "physx_PxArticulationCacheFlags_Pod.mBits has unexpected size % instead of 1", size_of(type_of(physx_PxArticulationCacheFlags_Pod.mBits)));
    assert(size_of(physx_PxArticulationCacheFlags_Pod) == 1, "physx_PxArticulationCacheFlags_Pod has size % instead of 1", size_of(physx_PxArticulationCacheFlags_Pod));
}

physx_PxJoint_Pod :: struct {
    structgen_pad0: [8] u8;
    mConcreteType:  u16;
    mBaseFlags:     physx_PxBaseFlags_Pod;
    structgen_pad1: [4] u8;
    userData:       *void;
}
#run {
    instance: physx_PxJoint_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxJoint_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxJoint_Pod.structgen_pad0)) == 8, "physx_PxJoint_Pod.structgen_pad0 has unexpected size % instead of 8", size_of(type_of(physx_PxJoint_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)) == 8, "physx_PxJoint_Pod.mConcreteType has unexpected offset % instead of 8", ((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxJoint_Pod.mConcreteType)) == 2, "physx_PxJoint_Pod.mConcreteType has unexpected size % instead of 2", size_of(type_of(physx_PxJoint_Pod.mConcreteType)));
    assert(((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)) == 10, "physx_PxJoint_Pod.mBaseFlags has unexpected offset % instead of 10", ((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxJoint_Pod.mBaseFlags)) == 2, "physx_PxJoint_Pod.mBaseFlags has unexpected size % instead of 2", size_of(type_of(physx_PxJoint_Pod.mBaseFlags)));
    assert(((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)) == 12, "physx_PxJoint_Pod.structgen_pad1 has unexpected offset % instead of 12", ((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxJoint_Pod.structgen_pad1)) == 4, "physx_PxJoint_Pod.structgen_pad1 has unexpected size % instead of 4", size_of(type_of(physx_PxJoint_Pod.structgen_pad1)));
    assert(((cast(*void)(*instance.userData)) - cast(*void)(*instance)) == 16, "physx_PxJoint_Pod.userData has unexpected offset % instead of 16", ((cast(*void)(*instance.userData)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxJoint_Pod.userData)) == 8, "physx_PxJoint_Pod.userData has unexpected size % instead of 8", size_of(type_of(physx_PxJoint_Pod.userData)));
    assert(size_of(physx_PxJoint_Pod) == 24, "physx_PxJoint_Pod has size % instead of 24", size_of(physx_PxJoint_Pod));
}

physx_PxArticulationJointImpl_Pod :: struct {}
physx_PxArticulationJoint_Pod :: struct {
    structgen_pad0: [8] u8;
    mConcreteType:  u16;
    mBaseFlags:     physx_PxBaseFlags_Pod;
    structgen_pad1: [4] u8;
}
#run {
    instance: physx_PxArticulationJoint_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxArticulationJoint_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxArticulationJoint_Pod.structgen_pad0)) == 8, "physx_PxArticulationJoint_Pod.structgen_pad0 has unexpected size % instead of 8", size_of(type_of(physx_PxArticulationJoint_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)) == 8, "physx_PxArticulationJoint_Pod.mConcreteType has unexpected offset % instead of 8", ((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxArticulationJoint_Pod.mConcreteType)) == 2, "physx_PxArticulationJoint_Pod.mConcreteType has unexpected size % instead of 2", size_of(type_of(physx_PxArticulationJoint_Pod.mConcreteType)));
    assert(((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)) == 10, "physx_PxArticulationJoint_Pod.mBaseFlags has unexpected offset % instead of 10", ((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxArticulationJoint_Pod.mBaseFlags)) == 2, "physx_PxArticulationJoint_Pod.mBaseFlags has unexpected size % instead of 2", size_of(type_of(physx_PxArticulationJoint_Pod.mBaseFlags)));
    assert(((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)) == 12, "physx_PxArticulationJoint_Pod.structgen_pad1 has unexpected offset % instead of 12", ((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxArticulationJoint_Pod.structgen_pad1)) == 4, "physx_PxArticulationJoint_Pod.structgen_pad1 has unexpected size % instead of 4", size_of(type_of(physx_PxArticulationJoint_Pod.structgen_pad1)));
    assert(size_of(physx_PxArticulationJoint_Pod) == 16, "physx_PxArticulationJoint_Pod has size % instead of 16", size_of(physx_PxArticulationJoint_Pod));
}

physx_PxArticulationJointReducedCoordinate_Pod :: struct {
    structgen_pad0: [8] u8;
    mConcreteType:  u16;
    mBaseFlags:     physx_PxBaseFlags_Pod;
    structgen_pad1: [4] u8;
}
#run {
    instance: physx_PxArticulationJointReducedCoordinate_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxArticulationJointReducedCoordinate_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxArticulationJointReducedCoordinate_Pod.structgen_pad0)) == 8, "physx_PxArticulationJointReducedCoordinate_Pod.structgen_pad0 has unexpected size % instead of 8", size_of(type_of(physx_PxArticulationJointReducedCoordinate_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)) == 8, "physx_PxArticulationJointReducedCoordinate_Pod.mConcreteType has unexpected offset % instead of 8", ((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxArticulationJointReducedCoordinate_Pod.mConcreteType)) == 2, "physx_PxArticulationJointReducedCoordinate_Pod.mConcreteType has unexpected size % instead of 2", size_of(type_of(physx_PxArticulationJointReducedCoordinate_Pod.mConcreteType)));
    assert(((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)) == 10, "physx_PxArticulationJointReducedCoordinate_Pod.mBaseFlags has unexpected offset % instead of 10", ((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxArticulationJointReducedCoordinate_Pod.mBaseFlags)) == 2, "physx_PxArticulationJointReducedCoordinate_Pod.mBaseFlags has unexpected size % instead of 2", size_of(type_of(physx_PxArticulationJointReducedCoordinate_Pod.mBaseFlags)));
    assert(((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)) == 12, "physx_PxArticulationJointReducedCoordinate_Pod.structgen_pad1 has unexpected offset % instead of 12", ((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxArticulationJointReducedCoordinate_Pod.structgen_pad1)) == 4, "physx_PxArticulationJointReducedCoordinate_Pod.structgen_pad1 has unexpected size % instead of 4", size_of(type_of(physx_PxArticulationJointReducedCoordinate_Pod.structgen_pad1)));
    assert(size_of(physx_PxArticulationJointReducedCoordinate_Pod) == 16, "physx_PxArticulationJointReducedCoordinate_Pod has size % instead of 16", size_of(physx_PxArticulationJointReducedCoordinate_Pod));
}

physx_PxFilterData_Pod :: struct {
    word0: u32;
    word1: u32;
    word2: u32;
    word3: u32;
}
#run {
    instance: physx_PxFilterData_Pod;
    assert(((cast(*void)(*instance.word0)) - cast(*void)(*instance)) == 0, "physx_PxFilterData_Pod.word0 has unexpected offset % instead of 0", ((cast(*void)(*instance.word0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxFilterData_Pod.word0)) == 4, "physx_PxFilterData_Pod.word0 has unexpected size % instead of 4", size_of(type_of(physx_PxFilterData_Pod.word0)));
    assert(((cast(*void)(*instance.word1)) - cast(*void)(*instance)) == 4, "physx_PxFilterData_Pod.word1 has unexpected offset % instead of 4", ((cast(*void)(*instance.word1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxFilterData_Pod.word1)) == 4, "physx_PxFilterData_Pod.word1 has unexpected size % instead of 4", size_of(type_of(physx_PxFilterData_Pod.word1)));
    assert(((cast(*void)(*instance.word2)) - cast(*void)(*instance)) == 8, "physx_PxFilterData_Pod.word2 has unexpected offset % instead of 8", ((cast(*void)(*instance.word2)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxFilterData_Pod.word2)) == 4, "physx_PxFilterData_Pod.word2 has unexpected size % instead of 4", size_of(type_of(physx_PxFilterData_Pod.word2)));
    assert(((cast(*void)(*instance.word3)) - cast(*void)(*instance)) == 12, "physx_PxFilterData_Pod.word3 has unexpected offset % instead of 12", ((cast(*void)(*instance.word3)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxFilterData_Pod.word3)) == 4, "physx_PxFilterData_Pod.word3 has unexpected size % instead of 4", size_of(type_of(physx_PxFilterData_Pod.word3)));
    assert(size_of(physx_PxFilterData_Pod) == 16, "physx_PxFilterData_Pod has size % instead of 16", size_of(physx_PxFilterData_Pod));
}

physx_PxMaterial_Pod :: struct {
    structgen_pad0: [8] u8;
    mConcreteType:  u16;
    mBaseFlags:     physx_PxBaseFlags_Pod;
    structgen_pad1: [4] u8;
    userData:       *void;
}
#run {
    instance: physx_PxMaterial_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxMaterial_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxMaterial_Pod.structgen_pad0)) == 8, "physx_PxMaterial_Pod.structgen_pad0 has unexpected size % instead of 8", size_of(type_of(physx_PxMaterial_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)) == 8, "physx_PxMaterial_Pod.mConcreteType has unexpected offset % instead of 8", ((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxMaterial_Pod.mConcreteType)) == 2, "physx_PxMaterial_Pod.mConcreteType has unexpected size % instead of 2", size_of(type_of(physx_PxMaterial_Pod.mConcreteType)));
    assert(((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)) == 10, "physx_PxMaterial_Pod.mBaseFlags has unexpected offset % instead of 10", ((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxMaterial_Pod.mBaseFlags)) == 2, "physx_PxMaterial_Pod.mBaseFlags has unexpected size % instead of 2", size_of(type_of(physx_PxMaterial_Pod.mBaseFlags)));
    assert(((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)) == 12, "physx_PxMaterial_Pod.structgen_pad1 has unexpected offset % instead of 12", ((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxMaterial_Pod.structgen_pad1)) == 4, "physx_PxMaterial_Pod.structgen_pad1 has unexpected size % instead of 4", size_of(type_of(physx_PxMaterial_Pod.structgen_pad1)));
    assert(((cast(*void)(*instance.userData)) - cast(*void)(*instance)) == 16, "physx_PxMaterial_Pod.userData has unexpected offset % instead of 16", ((cast(*void)(*instance.userData)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxMaterial_Pod.userData)) == 8, "physx_PxMaterial_Pod.userData has unexpected size % instead of 8", size_of(type_of(physx_PxMaterial_Pod.userData)));
    assert(size_of(physx_PxMaterial_Pod) == 24, "physx_PxMaterial_Pod has size % instead of 24", size_of(physx_PxMaterial_Pod));
}

physx_PxShapeFlags_Pod :: struct {
    mBits: u8;
}
#run {
    instance: physx_PxShapeFlags_Pod;
    assert(((cast(*void)(*instance.mBits)) - cast(*void)(*instance)) == 0, "physx_PxShapeFlags_Pod.mBits has unexpected offset % instead of 0", ((cast(*void)(*instance.mBits)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxShapeFlags_Pod.mBits)) == 1, "physx_PxShapeFlags_Pod.mBits has unexpected size % instead of 1", size_of(type_of(physx_PxShapeFlags_Pod.mBits)));
    assert(size_of(physx_PxShapeFlags_Pod) == 1, "physx_PxShapeFlags_Pod has size % instead of 1", size_of(physx_PxShapeFlags_Pod));
}

physx_PxRigidBody_Pod :: struct {
    structgen_pad0: [8] u8;
    mConcreteType:  u16;
    mBaseFlags:     physx_PxBaseFlags_Pod;
    structgen_pad1: [4] u8;
    userData:       *void;
}
#run {
    instance: physx_PxRigidBody_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxRigidBody_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxRigidBody_Pod.structgen_pad0)) == 8, "physx_PxRigidBody_Pod.structgen_pad0 has unexpected size % instead of 8", size_of(type_of(physx_PxRigidBody_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)) == 8, "physx_PxRigidBody_Pod.mConcreteType has unexpected offset % instead of 8", ((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxRigidBody_Pod.mConcreteType)) == 2, "physx_PxRigidBody_Pod.mConcreteType has unexpected size % instead of 2", size_of(type_of(physx_PxRigidBody_Pod.mConcreteType)));
    assert(((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)) == 10, "physx_PxRigidBody_Pod.mBaseFlags has unexpected offset % instead of 10", ((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxRigidBody_Pod.mBaseFlags)) == 2, "physx_PxRigidBody_Pod.mBaseFlags has unexpected size % instead of 2", size_of(type_of(physx_PxRigidBody_Pod.mBaseFlags)));
    assert(((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)) == 12, "physx_PxRigidBody_Pod.structgen_pad1 has unexpected offset % instead of 12", ((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxRigidBody_Pod.structgen_pad1)) == 4, "physx_PxRigidBody_Pod.structgen_pad1 has unexpected size % instead of 4", size_of(type_of(physx_PxRigidBody_Pod.structgen_pad1)));
    assert(((cast(*void)(*instance.userData)) - cast(*void)(*instance)) == 16, "physx_PxRigidBody_Pod.userData has unexpected offset % instead of 16", ((cast(*void)(*instance.userData)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxRigidBody_Pod.userData)) == 8, "physx_PxRigidBody_Pod.userData has unexpected size % instead of 8", size_of(type_of(physx_PxRigidBody_Pod.userData)));
    assert(size_of(physx_PxRigidBody_Pod) == 24, "physx_PxRigidBody_Pod has size % instead of 24", size_of(physx_PxRigidBody_Pod));
}

physx_PxRigidBodyFlags_Pod :: struct {
    mBits: u8;
}
#run {
    instance: physx_PxRigidBodyFlags_Pod;
    assert(((cast(*void)(*instance.mBits)) - cast(*void)(*instance)) == 0, "physx_PxRigidBodyFlags_Pod.mBits has unexpected offset % instead of 0", ((cast(*void)(*instance.mBits)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxRigidBodyFlags_Pod.mBits)) == 1, "physx_PxRigidBodyFlags_Pod.mBits has unexpected size % instead of 1", size_of(type_of(physx_PxRigidBodyFlags_Pod.mBits)));
    assert(size_of(physx_PxRigidBodyFlags_Pod) == 1, "physx_PxRigidBodyFlags_Pod has size % instead of 1", size_of(physx_PxRigidBodyFlags_Pod));
}

physx_PxFilterFlags_Pod :: struct {
    mBits: u16;
}
#run {
    instance: physx_PxFilterFlags_Pod;
    assert(((cast(*void)(*instance.mBits)) - cast(*void)(*instance)) == 0, "physx_PxFilterFlags_Pod.mBits has unexpected offset % instead of 0", ((cast(*void)(*instance.mBits)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxFilterFlags_Pod.mBits)) == 2, "physx_PxFilterFlags_Pod.mBits has unexpected size % instead of 2", size_of(type_of(physx_PxFilterFlags_Pod.mBits)));
    assert(size_of(physx_PxFilterFlags_Pod) == 2, "physx_PxFilterFlags_Pod has size % instead of 2", size_of(physx_PxFilterFlags_Pod));
}

physx_PxSimulationFilterCallback_Pod :: struct {
    vtable_: *void;
}
#run {
    instance: physx_PxSimulationFilterCallback_Pod;
    assert(((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)) == 0, "physx_PxSimulationFilterCallback_Pod.vtable_ has unexpected offset % instead of 0", ((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSimulationFilterCallback_Pod.vtable_)) == 8, "physx_PxSimulationFilterCallback_Pod.vtable_ has unexpected size % instead of 8", size_of(type_of(physx_PxSimulationFilterCallback_Pod.vtable_)));
    assert(size_of(physx_PxSimulationFilterCallback_Pod) == 8, "physx_PxSimulationFilterCallback_Pod has size % instead of 8", size_of(physx_PxSimulationFilterCallback_Pod));
}

physx_PxPairFlags_Pod :: struct {
    mBits: u16;
}
#run {
    instance: physx_PxPairFlags_Pod;
    assert(((cast(*void)(*instance.mBits)) - cast(*void)(*instance)) == 0, "physx_PxPairFlags_Pod.mBits has unexpected offset % instead of 0", ((cast(*void)(*instance.mBits)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxPairFlags_Pod.mBits)) == 2, "physx_PxPairFlags_Pod.mBits has unexpected size % instead of 2", size_of(type_of(physx_PxPairFlags_Pod.mBits)));
    assert(size_of(physx_PxPairFlags_Pod) == 2, "physx_PxPairFlags_Pod has size % instead of 2", size_of(physx_PxPairFlags_Pod));
}

physx_PxQueryFlags_Pod :: struct {
    mBits: u16;
}
#run {
    instance: physx_PxQueryFlags_Pod;
    assert(((cast(*void)(*instance.mBits)) - cast(*void)(*instance)) == 0, "physx_PxQueryFlags_Pod.mBits has unexpected offset % instead of 0", ((cast(*void)(*instance.mBits)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxQueryFlags_Pod.mBits)) == 2, "physx_PxQueryFlags_Pod.mBits has unexpected size % instead of 2", size_of(type_of(physx_PxQueryFlags_Pod.mBits)));
    assert(size_of(physx_PxQueryFlags_Pod) == 2, "physx_PxQueryFlags_Pod has size % instead of 2", size_of(physx_PxQueryFlags_Pod));
}

physx_PxQueryFilterData_Pod :: struct {
    data:           physx_PxFilterData_Pod;
    flags:          physx_PxQueryFlags_Pod;
    structgen_pad0: [2] u8;
}
#run {
    instance: physx_PxQueryFilterData_Pod;
    assert(((cast(*void)(*instance.data)) - cast(*void)(*instance)) == 0, "physx_PxQueryFilterData_Pod.data has unexpected offset % instead of 0", ((cast(*void)(*instance.data)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxQueryFilterData_Pod.data)) == 16, "physx_PxQueryFilterData_Pod.data has unexpected size % instead of 16", size_of(type_of(physx_PxQueryFilterData_Pod.data)));
    assert(((cast(*void)(*instance.flags)) - cast(*void)(*instance)) == 16, "physx_PxQueryFilterData_Pod.flags has unexpected offset % instead of 16", ((cast(*void)(*instance.flags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxQueryFilterData_Pod.flags)) == 2, "physx_PxQueryFilterData_Pod.flags has unexpected size % instead of 2", size_of(type_of(physx_PxQueryFilterData_Pod.flags)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 18, "physx_PxQueryFilterData_Pod.structgen_pad0 has unexpected offset % instead of 18", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxQueryFilterData_Pod.structgen_pad0)) == 2, "physx_PxQueryFilterData_Pod.structgen_pad0 has unexpected size % instead of 2", size_of(type_of(physx_PxQueryFilterData_Pod.structgen_pad0)));
    assert(size_of(physx_PxQueryFilterData_Pod) == 20, "physx_PxQueryFilterData_Pod has size % instead of 20", size_of(physx_PxQueryFilterData_Pod));
}

physx_PxQueryFilterCallback_Pod :: struct {
    vtable_: *void;
}
#run {
    instance: physx_PxQueryFilterCallback_Pod;
    assert(((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)) == 0, "physx_PxQueryFilterCallback_Pod.vtable_ has unexpected offset % instead of 0", ((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxQueryFilterCallback_Pod.vtable_)) == 8, "physx_PxQueryFilterCallback_Pod.vtable_ has unexpected size % instead of 8", size_of(type_of(physx_PxQueryFilterCallback_Pod.vtable_)));
    assert(size_of(physx_PxQueryFilterCallback_Pod) == 8, "physx_PxQueryFilterCallback_Pod has size % instead of 8", size_of(physx_PxQueryFilterCallback_Pod));
}

physx_PxRaycastQueryResult_Pod :: struct {}
physx_PxSweepQueryResult_Pod :: struct {}
physx_PxOverlapQueryResult_Pod :: struct {}
physx_PxOverlapHit_Pod :: struct {
    actor:          *physx_PxRigidActor_Pod;
    shape:          *physx_PxShape_Pod;
    faceIndex:      u32;
    structgen_pad0: [4] u8;
    padTo16Bytes:   u32;
    structgen_pad1: [4] u8;
}
#run {
    instance: physx_PxOverlapHit_Pod;
    assert(((cast(*void)(*instance.actor)) - cast(*void)(*instance)) == 0, "physx_PxOverlapHit_Pod.actor has unexpected offset % instead of 0", ((cast(*void)(*instance.actor)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxOverlapHit_Pod.actor)) == 8, "physx_PxOverlapHit_Pod.actor has unexpected size % instead of 8", size_of(type_of(physx_PxOverlapHit_Pod.actor)));
    assert(((cast(*void)(*instance.shape)) - cast(*void)(*instance)) == 8, "physx_PxOverlapHit_Pod.shape has unexpected offset % instead of 8", ((cast(*void)(*instance.shape)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxOverlapHit_Pod.shape)) == 8, "physx_PxOverlapHit_Pod.shape has unexpected size % instead of 8", size_of(type_of(physx_PxOverlapHit_Pod.shape)));
    assert(((cast(*void)(*instance.faceIndex)) - cast(*void)(*instance)) == 16, "physx_PxOverlapHit_Pod.faceIndex has unexpected offset % instead of 16", ((cast(*void)(*instance.faceIndex)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxOverlapHit_Pod.faceIndex)) == 4, "physx_PxOverlapHit_Pod.faceIndex has unexpected size % instead of 4", size_of(type_of(physx_PxOverlapHit_Pod.faceIndex)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 20, "physx_PxOverlapHit_Pod.structgen_pad0 has unexpected offset % instead of 20", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxOverlapHit_Pod.structgen_pad0)) == 4, "physx_PxOverlapHit_Pod.structgen_pad0 has unexpected size % instead of 4", size_of(type_of(physx_PxOverlapHit_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.padTo16Bytes)) - cast(*void)(*instance)) == 24, "physx_PxOverlapHit_Pod.padTo16Bytes has unexpected offset % instead of 24", ((cast(*void)(*instance.padTo16Bytes)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxOverlapHit_Pod.padTo16Bytes)) == 4, "physx_PxOverlapHit_Pod.padTo16Bytes has unexpected size % instead of 4", size_of(type_of(physx_PxOverlapHit_Pod.padTo16Bytes)));
    assert(((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)) == 28, "physx_PxOverlapHit_Pod.structgen_pad1 has unexpected offset % instead of 28", ((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxOverlapHit_Pod.structgen_pad1)) == 4, "physx_PxOverlapHit_Pod.structgen_pad1 has unexpected size % instead of 4", size_of(type_of(physx_PxOverlapHit_Pod.structgen_pad1)));
    assert(size_of(physx_PxOverlapHit_Pod) == 32, "physx_PxOverlapHit_Pod has size % instead of 32", size_of(physx_PxOverlapHit_Pod));
}

physx_PxBatchQueryMemory_Pod :: struct {
    userRaycastResultBuffer: *physx_PxRaycastQueryResult_Pod;
    userRaycastTouchBuffer:  *physx_PxRaycastHit_Pod;
    userSweepResultBuffer:   *physx_PxSweepQueryResult_Pod;
    userSweepTouchBuffer:    *physx_PxSweepHit_Pod;
    userOverlapResultBuffer: *physx_PxOverlapQueryResult_Pod;
    userOverlapTouchBuffer:  *physx_PxOverlapHit_Pod;
    raycastTouchBufferSize:  u32;
    sweepTouchBufferSize:    u32;
    overlapTouchBufferSize:  u32;
    raycastResultBufferSize: u32;
    sweepResultBufferSize:   u32;
    overlapResultBufferSize: u32;
}
#run {
    instance: physx_PxBatchQueryMemory_Pod;
    assert(((cast(*void)(*instance.userRaycastResultBuffer)) - cast(*void)(*instance)) == 0, "physx_PxBatchQueryMemory_Pod.userRaycastResultBuffer has unexpected offset % instead of 0", ((cast(*void)(*instance.userRaycastResultBuffer)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBatchQueryMemory_Pod.userRaycastResultBuffer)) == 8, "physx_PxBatchQueryMemory_Pod.userRaycastResultBuffer has unexpected size % instead of 8", size_of(type_of(physx_PxBatchQueryMemory_Pod.userRaycastResultBuffer)));
    assert(((cast(*void)(*instance.userRaycastTouchBuffer)) - cast(*void)(*instance)) == 8, "physx_PxBatchQueryMemory_Pod.userRaycastTouchBuffer has unexpected offset % instead of 8", ((cast(*void)(*instance.userRaycastTouchBuffer)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBatchQueryMemory_Pod.userRaycastTouchBuffer)) == 8, "physx_PxBatchQueryMemory_Pod.userRaycastTouchBuffer has unexpected size % instead of 8", size_of(type_of(physx_PxBatchQueryMemory_Pod.userRaycastTouchBuffer)));
    assert(((cast(*void)(*instance.userSweepResultBuffer)) - cast(*void)(*instance)) == 16, "physx_PxBatchQueryMemory_Pod.userSweepResultBuffer has unexpected offset % instead of 16", ((cast(*void)(*instance.userSweepResultBuffer)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBatchQueryMemory_Pod.userSweepResultBuffer)) == 8, "physx_PxBatchQueryMemory_Pod.userSweepResultBuffer has unexpected size % instead of 8", size_of(type_of(physx_PxBatchQueryMemory_Pod.userSweepResultBuffer)));
    assert(((cast(*void)(*instance.userSweepTouchBuffer)) - cast(*void)(*instance)) == 24, "physx_PxBatchQueryMemory_Pod.userSweepTouchBuffer has unexpected offset % instead of 24", ((cast(*void)(*instance.userSweepTouchBuffer)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBatchQueryMemory_Pod.userSweepTouchBuffer)) == 8, "physx_PxBatchQueryMemory_Pod.userSweepTouchBuffer has unexpected size % instead of 8", size_of(type_of(physx_PxBatchQueryMemory_Pod.userSweepTouchBuffer)));
    assert(((cast(*void)(*instance.userOverlapResultBuffer)) - cast(*void)(*instance)) == 32, "physx_PxBatchQueryMemory_Pod.userOverlapResultBuffer has unexpected offset % instead of 32", ((cast(*void)(*instance.userOverlapResultBuffer)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBatchQueryMemory_Pod.userOverlapResultBuffer)) == 8, "physx_PxBatchQueryMemory_Pod.userOverlapResultBuffer has unexpected size % instead of 8", size_of(type_of(physx_PxBatchQueryMemory_Pod.userOverlapResultBuffer)));
    assert(((cast(*void)(*instance.userOverlapTouchBuffer)) - cast(*void)(*instance)) == 40, "physx_PxBatchQueryMemory_Pod.userOverlapTouchBuffer has unexpected offset % instead of 40", ((cast(*void)(*instance.userOverlapTouchBuffer)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBatchQueryMemory_Pod.userOverlapTouchBuffer)) == 8, "physx_PxBatchQueryMemory_Pod.userOverlapTouchBuffer has unexpected size % instead of 8", size_of(type_of(physx_PxBatchQueryMemory_Pod.userOverlapTouchBuffer)));
    assert(((cast(*void)(*instance.raycastTouchBufferSize)) - cast(*void)(*instance)) == 48, "physx_PxBatchQueryMemory_Pod.raycastTouchBufferSize has unexpected offset % instead of 48", ((cast(*void)(*instance.raycastTouchBufferSize)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBatchQueryMemory_Pod.raycastTouchBufferSize)) == 4, "physx_PxBatchQueryMemory_Pod.raycastTouchBufferSize has unexpected size % instead of 4", size_of(type_of(physx_PxBatchQueryMemory_Pod.raycastTouchBufferSize)));
    assert(((cast(*void)(*instance.sweepTouchBufferSize)) - cast(*void)(*instance)) == 52, "physx_PxBatchQueryMemory_Pod.sweepTouchBufferSize has unexpected offset % instead of 52", ((cast(*void)(*instance.sweepTouchBufferSize)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBatchQueryMemory_Pod.sweepTouchBufferSize)) == 4, "physx_PxBatchQueryMemory_Pod.sweepTouchBufferSize has unexpected size % instead of 4", size_of(type_of(physx_PxBatchQueryMemory_Pod.sweepTouchBufferSize)));
    assert(((cast(*void)(*instance.overlapTouchBufferSize)) - cast(*void)(*instance)) == 56, "physx_PxBatchQueryMemory_Pod.overlapTouchBufferSize has unexpected offset % instead of 56", ((cast(*void)(*instance.overlapTouchBufferSize)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBatchQueryMemory_Pod.overlapTouchBufferSize)) == 4, "physx_PxBatchQueryMemory_Pod.overlapTouchBufferSize has unexpected size % instead of 4", size_of(type_of(physx_PxBatchQueryMemory_Pod.overlapTouchBufferSize)));
    assert(((cast(*void)(*instance.raycastResultBufferSize)) - cast(*void)(*instance)) == 60, "physx_PxBatchQueryMemory_Pod.raycastResultBufferSize has unexpected offset % instead of 60", ((cast(*void)(*instance.raycastResultBufferSize)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBatchQueryMemory_Pod.raycastResultBufferSize)) == 4, "physx_PxBatchQueryMemory_Pod.raycastResultBufferSize has unexpected size % instead of 4", size_of(type_of(physx_PxBatchQueryMemory_Pod.raycastResultBufferSize)));
    assert(((cast(*void)(*instance.sweepResultBufferSize)) - cast(*void)(*instance)) == 64, "physx_PxBatchQueryMemory_Pod.sweepResultBufferSize has unexpected offset % instead of 64", ((cast(*void)(*instance.sweepResultBufferSize)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBatchQueryMemory_Pod.sweepResultBufferSize)) == 4, "physx_PxBatchQueryMemory_Pod.sweepResultBufferSize has unexpected size % instead of 4", size_of(type_of(physx_PxBatchQueryMemory_Pod.sweepResultBufferSize)));
    assert(((cast(*void)(*instance.overlapResultBufferSize)) - cast(*void)(*instance)) == 68, "physx_PxBatchQueryMemory_Pod.overlapResultBufferSize has unexpected offset % instead of 68", ((cast(*void)(*instance.overlapResultBufferSize)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBatchQueryMemory_Pod.overlapResultBufferSize)) == 4, "physx_PxBatchQueryMemory_Pod.overlapResultBufferSize has unexpected size % instead of 4", size_of(type_of(physx_PxBatchQueryMemory_Pod.overlapResultBufferSize)));
    assert(size_of(physx_PxBatchQueryMemory_Pod) == 72, "physx_PxBatchQueryMemory_Pod has size % instead of 72", size_of(physx_PxBatchQueryMemory_Pod));
}

physx_PxBatchQueryDesc_Pod :: struct {
    filterShaderData:     *void;
    filterShaderDataSize: u32;
    structgen_pad0:       [4] u8;
    preFilterShader:      *void;
    postFilterShader:     *void;
    queryMemory:          physx_PxBatchQueryMemory_Pod;
}
#run {
    instance: physx_PxBatchQueryDesc_Pod;
    assert(((cast(*void)(*instance.filterShaderData)) - cast(*void)(*instance)) == 0, "physx_PxBatchQueryDesc_Pod.filterShaderData has unexpected offset % instead of 0", ((cast(*void)(*instance.filterShaderData)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBatchQueryDesc_Pod.filterShaderData)) == 8, "physx_PxBatchQueryDesc_Pod.filterShaderData has unexpected size % instead of 8", size_of(type_of(physx_PxBatchQueryDesc_Pod.filterShaderData)));
    assert(((cast(*void)(*instance.filterShaderDataSize)) - cast(*void)(*instance)) == 8, "physx_PxBatchQueryDesc_Pod.filterShaderDataSize has unexpected offset % instead of 8", ((cast(*void)(*instance.filterShaderDataSize)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBatchQueryDesc_Pod.filterShaderDataSize)) == 4, "physx_PxBatchQueryDesc_Pod.filterShaderDataSize has unexpected size % instead of 4", size_of(type_of(physx_PxBatchQueryDesc_Pod.filterShaderDataSize)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 12, "physx_PxBatchQueryDesc_Pod.structgen_pad0 has unexpected offset % instead of 12", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBatchQueryDesc_Pod.structgen_pad0)) == 4, "physx_PxBatchQueryDesc_Pod.structgen_pad0 has unexpected size % instead of 4", size_of(type_of(physx_PxBatchQueryDesc_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.preFilterShader)) - cast(*void)(*instance)) == 16, "physx_PxBatchQueryDesc_Pod.preFilterShader has unexpected offset % instead of 16", ((cast(*void)(*instance.preFilterShader)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBatchQueryDesc_Pod.preFilterShader)) == 8, "physx_PxBatchQueryDesc_Pod.preFilterShader has unexpected size % instead of 8", size_of(type_of(physx_PxBatchQueryDesc_Pod.preFilterShader)));
    assert(((cast(*void)(*instance.postFilterShader)) - cast(*void)(*instance)) == 24, "physx_PxBatchQueryDesc_Pod.postFilterShader has unexpected offset % instead of 24", ((cast(*void)(*instance.postFilterShader)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBatchQueryDesc_Pod.postFilterShader)) == 8, "physx_PxBatchQueryDesc_Pod.postFilterShader has unexpected size % instead of 8", size_of(type_of(physx_PxBatchQueryDesc_Pod.postFilterShader)));
    assert(((cast(*void)(*instance.queryMemory)) - cast(*void)(*instance)) == 32, "physx_PxBatchQueryDesc_Pod.queryMemory has unexpected offset % instead of 32", ((cast(*void)(*instance.queryMemory)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBatchQueryDesc_Pod.queryMemory)) == 72, "physx_PxBatchQueryDesc_Pod.queryMemory has unexpected size % instead of 72", size_of(type_of(physx_PxBatchQueryDesc_Pod.queryMemory)));
    assert(size_of(physx_PxBatchQueryDesc_Pod) == 104, "physx_PxBatchQueryDesc_Pod has size % instead of 104", size_of(physx_PxBatchQueryDesc_Pod));
}

physx_PxBatchQuery_Pod :: struct {
    vtable_: *void;
}
#run {
    instance: physx_PxBatchQuery_Pod;
    assert(((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)) == 0, "physx_PxBatchQuery_Pod.vtable_ has unexpected offset % instead of 0", ((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBatchQuery_Pod.vtable_)) == 8, "physx_PxBatchQuery_Pod.vtable_ has unexpected size % instead of 8", size_of(type_of(physx_PxBatchQuery_Pod.vtable_)));
    assert(size_of(physx_PxBatchQuery_Pod) == 8, "physx_PxBatchQuery_Pod has size % instead of 8", size_of(physx_PxBatchQuery_Pod));
}

physx_PxQueryCache_Pod :: struct {
    shape:          *physx_PxShape_Pod;
    actor:          *physx_PxRigidActor_Pod;
    faceIndex:      u32;
    structgen_pad0: [4] u8;
}
#run {
    instance: physx_PxQueryCache_Pod;
    assert(((cast(*void)(*instance.shape)) - cast(*void)(*instance)) == 0, "physx_PxQueryCache_Pod.shape has unexpected offset % instead of 0", ((cast(*void)(*instance.shape)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxQueryCache_Pod.shape)) == 8, "physx_PxQueryCache_Pod.shape has unexpected size % instead of 8", size_of(type_of(physx_PxQueryCache_Pod.shape)));
    assert(((cast(*void)(*instance.actor)) - cast(*void)(*instance)) == 8, "physx_PxQueryCache_Pod.actor has unexpected offset % instead of 8", ((cast(*void)(*instance.actor)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxQueryCache_Pod.actor)) == 8, "physx_PxQueryCache_Pod.actor has unexpected size % instead of 8", size_of(type_of(physx_PxQueryCache_Pod.actor)));
    assert(((cast(*void)(*instance.faceIndex)) - cast(*void)(*instance)) == 16, "physx_PxQueryCache_Pod.faceIndex has unexpected offset % instead of 16", ((cast(*void)(*instance.faceIndex)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxQueryCache_Pod.faceIndex)) == 4, "physx_PxQueryCache_Pod.faceIndex has unexpected size % instead of 4", size_of(type_of(physx_PxQueryCache_Pod.faceIndex)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 20, "physx_PxQueryCache_Pod.structgen_pad0 has unexpected offset % instead of 20", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxQueryCache_Pod.structgen_pad0)) == 4, "physx_PxQueryCache_Pod.structgen_pad0 has unexpected size % instead of 4", size_of(type_of(physx_PxQueryCache_Pod.structgen_pad0)));
    assert(size_of(physx_PxQueryCache_Pod) == 24, "physx_PxQueryCache_Pod has size % instead of 24", size_of(physx_PxQueryCache_Pod));
}

physx_PxConstraintFlags_Pod :: struct {
    mBits: u16;
}
#run {
    instance: physx_PxConstraintFlags_Pod;
    assert(((cast(*void)(*instance.mBits)) - cast(*void)(*instance)) == 0, "physx_PxConstraintFlags_Pod.mBits has unexpected offset % instead of 0", ((cast(*void)(*instance.mBits)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxConstraintFlags_Pod.mBits)) == 2, "physx_PxConstraintFlags_Pod.mBits has unexpected size % instead of 2", size_of(type_of(physx_PxConstraintFlags_Pod.mBits)));
    assert(size_of(physx_PxConstraintFlags_Pod) == 2, "physx_PxConstraintFlags_Pod has size % instead of 2", size_of(physx_PxConstraintFlags_Pod));
}

physx_PxConstraintShaderTable_Pod :: struct {
    solverPrep:     *void;
    project:        *void;
    visualize:      *void;
    flag:           u32;
    structgen_pad0: [4] u8;
}
#run {
    instance: physx_PxConstraintShaderTable_Pod;
    assert(((cast(*void)(*instance.solverPrep)) - cast(*void)(*instance)) == 0, "physx_PxConstraintShaderTable_Pod.solverPrep has unexpected offset % instead of 0", ((cast(*void)(*instance.solverPrep)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxConstraintShaderTable_Pod.solverPrep)) == 8, "physx_PxConstraintShaderTable_Pod.solverPrep has unexpected size % instead of 8", size_of(type_of(physx_PxConstraintShaderTable_Pod.solverPrep)));
    assert(((cast(*void)(*instance.project)) - cast(*void)(*instance)) == 8, "physx_PxConstraintShaderTable_Pod.project has unexpected offset % instead of 8", ((cast(*void)(*instance.project)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxConstraintShaderTable_Pod.project)) == 8, "physx_PxConstraintShaderTable_Pod.project has unexpected size % instead of 8", size_of(type_of(physx_PxConstraintShaderTable_Pod.project)));
    assert(((cast(*void)(*instance.visualize)) - cast(*void)(*instance)) == 16, "physx_PxConstraintShaderTable_Pod.visualize has unexpected offset % instead of 16", ((cast(*void)(*instance.visualize)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxConstraintShaderTable_Pod.visualize)) == 8, "physx_PxConstraintShaderTable_Pod.visualize has unexpected size % instead of 8", size_of(type_of(physx_PxConstraintShaderTable_Pod.visualize)));
    assert(((cast(*void)(*instance.flag)) - cast(*void)(*instance)) == 24, "physx_PxConstraintShaderTable_Pod.flag has unexpected offset % instead of 24", ((cast(*void)(*instance.flag)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxConstraintShaderTable_Pod.flag)) == 4, "physx_PxConstraintShaderTable_Pod.flag has unexpected size % instead of 4", size_of(type_of(physx_PxConstraintShaderTable_Pod.flag)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 28, "physx_PxConstraintShaderTable_Pod.structgen_pad0 has unexpected offset % instead of 28", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxConstraintShaderTable_Pod.structgen_pad0)) == 4, "physx_PxConstraintShaderTable_Pod.structgen_pad0 has unexpected size % instead of 4", size_of(type_of(physx_PxConstraintShaderTable_Pod.structgen_pad0)));
    assert(size_of(physx_PxConstraintShaderTable_Pod) == 32, "physx_PxConstraintShaderTable_Pod has size % instead of 32", size_of(physx_PxConstraintShaderTable_Pod));
}

physx_PxMassModificationProps_Pod :: struct {
    mInvMassScale0:    float;
    mInvInertiaScale0: float;
    mInvMassScale1:    float;
    mInvInertiaScale1: float;
}
#run {
    instance: physx_PxMassModificationProps_Pod;
    assert(((cast(*void)(*instance.mInvMassScale0)) - cast(*void)(*instance)) == 0, "physx_PxMassModificationProps_Pod.mInvMassScale0 has unexpected offset % instead of 0", ((cast(*void)(*instance.mInvMassScale0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxMassModificationProps_Pod.mInvMassScale0)) == 4, "physx_PxMassModificationProps_Pod.mInvMassScale0 has unexpected size % instead of 4", size_of(type_of(physx_PxMassModificationProps_Pod.mInvMassScale0)));
    assert(((cast(*void)(*instance.mInvInertiaScale0)) - cast(*void)(*instance)) == 4, "physx_PxMassModificationProps_Pod.mInvInertiaScale0 has unexpected offset % instead of 4", ((cast(*void)(*instance.mInvInertiaScale0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxMassModificationProps_Pod.mInvInertiaScale0)) == 4, "physx_PxMassModificationProps_Pod.mInvInertiaScale0 has unexpected size % instead of 4", size_of(type_of(physx_PxMassModificationProps_Pod.mInvInertiaScale0)));
    assert(((cast(*void)(*instance.mInvMassScale1)) - cast(*void)(*instance)) == 8, "physx_PxMassModificationProps_Pod.mInvMassScale1 has unexpected offset % instead of 8", ((cast(*void)(*instance.mInvMassScale1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxMassModificationProps_Pod.mInvMassScale1)) == 4, "physx_PxMassModificationProps_Pod.mInvMassScale1 has unexpected size % instead of 4", size_of(type_of(physx_PxMassModificationProps_Pod.mInvMassScale1)));
    assert(((cast(*void)(*instance.mInvInertiaScale1)) - cast(*void)(*instance)) == 12, "physx_PxMassModificationProps_Pod.mInvInertiaScale1 has unexpected offset % instead of 12", ((cast(*void)(*instance.mInvInertiaScale1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxMassModificationProps_Pod.mInvInertiaScale1)) == 4, "physx_PxMassModificationProps_Pod.mInvInertiaScale1 has unexpected size % instead of 4", size_of(type_of(physx_PxMassModificationProps_Pod.mInvInertiaScale1)));
    assert(size_of(physx_PxMassModificationProps_Pod) == 16, "physx_PxMassModificationProps_Pod has size % instead of 16", size_of(physx_PxMassModificationProps_Pod));
}

physx_PxContactPatch_Pod :: struct {
    mMassModification: physx_PxMassModificationProps_Pod;
    normal:            physx_PxVec3_Pod;
    restitution:       float;
    dynamicFriction:   float;
    staticFriction:    float;
    startContactIndex: u8;
    nbContacts:        u8;
    materialFlags:     u8;
    internalFlags:     u8;
    materialIndex0:    u16;
    materialIndex1:    u16;
}
#run {
    instance: physx_PxContactPatch_Pod;
    assert(((cast(*void)(*instance.mMassModification)) - cast(*void)(*instance)) == 0, "physx_PxContactPatch_Pod.mMassModification has unexpected offset % instead of 0", ((cast(*void)(*instance.mMassModification)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactPatch_Pod.mMassModification)) == 16, "physx_PxContactPatch_Pod.mMassModification has unexpected size % instead of 16", size_of(type_of(physx_PxContactPatch_Pod.mMassModification)));
    assert(((cast(*void)(*instance.normal)) - cast(*void)(*instance)) == 16, "physx_PxContactPatch_Pod.normal has unexpected offset % instead of 16", ((cast(*void)(*instance.normal)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactPatch_Pod.normal)) == 12, "physx_PxContactPatch_Pod.normal has unexpected size % instead of 12", size_of(type_of(physx_PxContactPatch_Pod.normal)));
    assert(((cast(*void)(*instance.restitution)) - cast(*void)(*instance)) == 28, "physx_PxContactPatch_Pod.restitution has unexpected offset % instead of 28", ((cast(*void)(*instance.restitution)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactPatch_Pod.restitution)) == 4, "physx_PxContactPatch_Pod.restitution has unexpected size % instead of 4", size_of(type_of(physx_PxContactPatch_Pod.restitution)));
    assert(((cast(*void)(*instance.dynamicFriction)) - cast(*void)(*instance)) == 32, "physx_PxContactPatch_Pod.dynamicFriction has unexpected offset % instead of 32", ((cast(*void)(*instance.dynamicFriction)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactPatch_Pod.dynamicFriction)) == 4, "physx_PxContactPatch_Pod.dynamicFriction has unexpected size % instead of 4", size_of(type_of(physx_PxContactPatch_Pod.dynamicFriction)));
    assert(((cast(*void)(*instance.staticFriction)) - cast(*void)(*instance)) == 36, "physx_PxContactPatch_Pod.staticFriction has unexpected offset % instead of 36", ((cast(*void)(*instance.staticFriction)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactPatch_Pod.staticFriction)) == 4, "physx_PxContactPatch_Pod.staticFriction has unexpected size % instead of 4", size_of(type_of(physx_PxContactPatch_Pod.staticFriction)));
    assert(((cast(*void)(*instance.startContactIndex)) - cast(*void)(*instance)) == 40, "physx_PxContactPatch_Pod.startContactIndex has unexpected offset % instead of 40", ((cast(*void)(*instance.startContactIndex)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactPatch_Pod.startContactIndex)) == 1, "physx_PxContactPatch_Pod.startContactIndex has unexpected size % instead of 1", size_of(type_of(physx_PxContactPatch_Pod.startContactIndex)));
    assert(((cast(*void)(*instance.nbContacts)) - cast(*void)(*instance)) == 41, "physx_PxContactPatch_Pod.nbContacts has unexpected offset % instead of 41", ((cast(*void)(*instance.nbContacts)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactPatch_Pod.nbContacts)) == 1, "physx_PxContactPatch_Pod.nbContacts has unexpected size % instead of 1", size_of(type_of(physx_PxContactPatch_Pod.nbContacts)));
    assert(((cast(*void)(*instance.materialFlags)) - cast(*void)(*instance)) == 42, "physx_PxContactPatch_Pod.materialFlags has unexpected offset % instead of 42", ((cast(*void)(*instance.materialFlags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactPatch_Pod.materialFlags)) == 1, "physx_PxContactPatch_Pod.materialFlags has unexpected size % instead of 1", size_of(type_of(physx_PxContactPatch_Pod.materialFlags)));
    assert(((cast(*void)(*instance.internalFlags)) - cast(*void)(*instance)) == 43, "physx_PxContactPatch_Pod.internalFlags has unexpected offset % instead of 43", ((cast(*void)(*instance.internalFlags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactPatch_Pod.internalFlags)) == 1, "physx_PxContactPatch_Pod.internalFlags has unexpected size % instead of 1", size_of(type_of(physx_PxContactPatch_Pod.internalFlags)));
    assert(((cast(*void)(*instance.materialIndex0)) - cast(*void)(*instance)) == 44, "physx_PxContactPatch_Pod.materialIndex0 has unexpected offset % instead of 44", ((cast(*void)(*instance.materialIndex0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactPatch_Pod.materialIndex0)) == 2, "physx_PxContactPatch_Pod.materialIndex0 has unexpected size % instead of 2", size_of(type_of(physx_PxContactPatch_Pod.materialIndex0)));
    assert(((cast(*void)(*instance.materialIndex1)) - cast(*void)(*instance)) == 46, "physx_PxContactPatch_Pod.materialIndex1 has unexpected offset % instead of 46", ((cast(*void)(*instance.materialIndex1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactPatch_Pod.materialIndex1)) == 2, "physx_PxContactPatch_Pod.materialIndex1 has unexpected size % instead of 2", size_of(type_of(physx_PxContactPatch_Pod.materialIndex1)));
    assert(size_of(physx_PxContactPatch_Pod) == 48, "physx_PxContactPatch_Pod has size % instead of 48", size_of(physx_PxContactPatch_Pod));
}

physx_PxContact_Pod :: struct {
    contact:    physx_PxVec3_Pod;
    separation: float;
}
#run {
    instance: physx_PxContact_Pod;
    assert(((cast(*void)(*instance.contact)) - cast(*void)(*instance)) == 0, "physx_PxContact_Pod.contact has unexpected offset % instead of 0", ((cast(*void)(*instance.contact)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContact_Pod.contact)) == 12, "physx_PxContact_Pod.contact has unexpected size % instead of 12", size_of(type_of(physx_PxContact_Pod.contact)));
    assert(((cast(*void)(*instance.separation)) - cast(*void)(*instance)) == 12, "physx_PxContact_Pod.separation has unexpected offset % instead of 12", ((cast(*void)(*instance.separation)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContact_Pod.separation)) == 4, "physx_PxContact_Pod.separation has unexpected size % instead of 4", size_of(type_of(physx_PxContact_Pod.separation)));
    assert(size_of(physx_PxContact_Pod) == 16, "physx_PxContact_Pod has size % instead of 16", size_of(physx_PxContact_Pod));
}

physx_PxContactStreamIterator_Pod :: struct {
    zero:                   physx_PxVec3_Pod;
    structgen_pad0:         [4] u8;
    patch:                  *physx_PxContactPatch_Pod;
    contact:                *physx_PxContact_Pod;
    faceIndice:             *u32;
    totalPatches:           u32;
    totalContacts:          u32;
    nextContactIndex:       u32;
    nextPatchIndex:         u32;
    contactPatchHeaderSize: u32;
    contactPointSize:       u32;
    mStreamFormat:          u32;
    forceNoResponse:        u32;
    pointStepped:           bool;
    structgen_pad1:         [3] u8;
    hasFaceIndices:         u32;
}
#run {
    instance: physx_PxContactStreamIterator_Pod;
    assert(((cast(*void)(*instance.zero)) - cast(*void)(*instance)) == 0, "physx_PxContactStreamIterator_Pod.zero has unexpected offset % instead of 0", ((cast(*void)(*instance.zero)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactStreamIterator_Pod.zero)) == 12, "physx_PxContactStreamIterator_Pod.zero has unexpected size % instead of 12", size_of(type_of(physx_PxContactStreamIterator_Pod.zero)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 12, "physx_PxContactStreamIterator_Pod.structgen_pad0 has unexpected offset % instead of 12", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactStreamIterator_Pod.structgen_pad0)) == 4, "physx_PxContactStreamIterator_Pod.structgen_pad0 has unexpected size % instead of 4", size_of(type_of(physx_PxContactStreamIterator_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.patch)) - cast(*void)(*instance)) == 16, "physx_PxContactStreamIterator_Pod.patch has unexpected offset % instead of 16", ((cast(*void)(*instance.patch)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactStreamIterator_Pod.patch)) == 8, "physx_PxContactStreamIterator_Pod.patch has unexpected size % instead of 8", size_of(type_of(physx_PxContactStreamIterator_Pod.patch)));
    assert(((cast(*void)(*instance.contact)) - cast(*void)(*instance)) == 24, "physx_PxContactStreamIterator_Pod.contact has unexpected offset % instead of 24", ((cast(*void)(*instance.contact)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactStreamIterator_Pod.contact)) == 8, "physx_PxContactStreamIterator_Pod.contact has unexpected size % instead of 8", size_of(type_of(physx_PxContactStreamIterator_Pod.contact)));
    assert(((cast(*void)(*instance.faceIndice)) - cast(*void)(*instance)) == 32, "physx_PxContactStreamIterator_Pod.faceIndice has unexpected offset % instead of 32", ((cast(*void)(*instance.faceIndice)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactStreamIterator_Pod.faceIndice)) == 8, "physx_PxContactStreamIterator_Pod.faceIndice has unexpected size % instead of 8", size_of(type_of(physx_PxContactStreamIterator_Pod.faceIndice)));
    assert(((cast(*void)(*instance.totalPatches)) - cast(*void)(*instance)) == 40, "physx_PxContactStreamIterator_Pod.totalPatches has unexpected offset % instead of 40", ((cast(*void)(*instance.totalPatches)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactStreamIterator_Pod.totalPatches)) == 4, "physx_PxContactStreamIterator_Pod.totalPatches has unexpected size % instead of 4", size_of(type_of(physx_PxContactStreamIterator_Pod.totalPatches)));
    assert(((cast(*void)(*instance.totalContacts)) - cast(*void)(*instance)) == 44, "physx_PxContactStreamIterator_Pod.totalContacts has unexpected offset % instead of 44", ((cast(*void)(*instance.totalContacts)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactStreamIterator_Pod.totalContacts)) == 4, "physx_PxContactStreamIterator_Pod.totalContacts has unexpected size % instead of 4", size_of(type_of(physx_PxContactStreamIterator_Pod.totalContacts)));
    assert(((cast(*void)(*instance.nextContactIndex)) - cast(*void)(*instance)) == 48, "physx_PxContactStreamIterator_Pod.nextContactIndex has unexpected offset % instead of 48", ((cast(*void)(*instance.nextContactIndex)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactStreamIterator_Pod.nextContactIndex)) == 4, "physx_PxContactStreamIterator_Pod.nextContactIndex has unexpected size % instead of 4", size_of(type_of(physx_PxContactStreamIterator_Pod.nextContactIndex)));
    assert(((cast(*void)(*instance.nextPatchIndex)) - cast(*void)(*instance)) == 52, "physx_PxContactStreamIterator_Pod.nextPatchIndex has unexpected offset % instead of 52", ((cast(*void)(*instance.nextPatchIndex)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactStreamIterator_Pod.nextPatchIndex)) == 4, "physx_PxContactStreamIterator_Pod.nextPatchIndex has unexpected size % instead of 4", size_of(type_of(physx_PxContactStreamIterator_Pod.nextPatchIndex)));
    assert(((cast(*void)(*instance.contactPatchHeaderSize)) - cast(*void)(*instance)) == 56, "physx_PxContactStreamIterator_Pod.contactPatchHeaderSize has unexpected offset % instead of 56", ((cast(*void)(*instance.contactPatchHeaderSize)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactStreamIterator_Pod.contactPatchHeaderSize)) == 4, "physx_PxContactStreamIterator_Pod.contactPatchHeaderSize has unexpected size % instead of 4", size_of(type_of(physx_PxContactStreamIterator_Pod.contactPatchHeaderSize)));
    assert(((cast(*void)(*instance.contactPointSize)) - cast(*void)(*instance)) == 60, "physx_PxContactStreamIterator_Pod.contactPointSize has unexpected offset % instead of 60", ((cast(*void)(*instance.contactPointSize)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactStreamIterator_Pod.contactPointSize)) == 4, "physx_PxContactStreamIterator_Pod.contactPointSize has unexpected size % instead of 4", size_of(type_of(physx_PxContactStreamIterator_Pod.contactPointSize)));
    assert(((cast(*void)(*instance.mStreamFormat)) - cast(*void)(*instance)) == 64, "physx_PxContactStreamIterator_Pod.mStreamFormat has unexpected offset % instead of 64", ((cast(*void)(*instance.mStreamFormat)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactStreamIterator_Pod.mStreamFormat)) == 4, "physx_PxContactStreamIterator_Pod.mStreamFormat has unexpected size % instead of 4", size_of(type_of(physx_PxContactStreamIterator_Pod.mStreamFormat)));
    assert(((cast(*void)(*instance.forceNoResponse)) - cast(*void)(*instance)) == 68, "physx_PxContactStreamIterator_Pod.forceNoResponse has unexpected offset % instead of 68", ((cast(*void)(*instance.forceNoResponse)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactStreamIterator_Pod.forceNoResponse)) == 4, "physx_PxContactStreamIterator_Pod.forceNoResponse has unexpected size % instead of 4", size_of(type_of(physx_PxContactStreamIterator_Pod.forceNoResponse)));
    assert(((cast(*void)(*instance.pointStepped)) - cast(*void)(*instance)) == 72, "physx_PxContactStreamIterator_Pod.pointStepped has unexpected offset % instead of 72", ((cast(*void)(*instance.pointStepped)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactStreamIterator_Pod.pointStepped)) == 1, "physx_PxContactStreamIterator_Pod.pointStepped has unexpected size % instead of 1", size_of(type_of(physx_PxContactStreamIterator_Pod.pointStepped)));
    assert(((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)) == 73, "physx_PxContactStreamIterator_Pod.structgen_pad1 has unexpected offset % instead of 73", ((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactStreamIterator_Pod.structgen_pad1)) == 3, "physx_PxContactStreamIterator_Pod.structgen_pad1 has unexpected size % instead of 3", size_of(type_of(physx_PxContactStreamIterator_Pod.structgen_pad1)));
    assert(((cast(*void)(*instance.hasFaceIndices)) - cast(*void)(*instance)) == 76, "physx_PxContactStreamIterator_Pod.hasFaceIndices has unexpected offset % instead of 76", ((cast(*void)(*instance.hasFaceIndices)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactStreamIterator_Pod.hasFaceIndices)) == 4, "physx_PxContactStreamIterator_Pod.hasFaceIndices has unexpected size % instead of 4", size_of(type_of(physx_PxContactStreamIterator_Pod.hasFaceIndices)));
    assert(size_of(physx_PxContactStreamIterator_Pod) == 80, "physx_PxContactStreamIterator_Pod has size % instead of 80", size_of(physx_PxContactStreamIterator_Pod));
}

physx_PxModifiableContact_Pod :: struct {
    contact:         physx_PxVec3_Pod;
    separation:      float;
    targetVelocity:  physx_PxVec3_Pod;
    maxImpulse:      float;
    normal:          physx_PxVec3_Pod;
    restitution:     float;
    materialFlags:   u32;
    materialIndex0:  u16;
    materialIndex1:  u16;
    staticFriction:  float;
    dynamicFriction: float;
}
#run {
    instance: physx_PxModifiableContact_Pod;
    assert(((cast(*void)(*instance.contact)) - cast(*void)(*instance)) == 0, "physx_PxModifiableContact_Pod.contact has unexpected offset % instead of 0", ((cast(*void)(*instance.contact)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxModifiableContact_Pod.contact)) == 12, "physx_PxModifiableContact_Pod.contact has unexpected size % instead of 12", size_of(type_of(physx_PxModifiableContact_Pod.contact)));
    assert(((cast(*void)(*instance.separation)) - cast(*void)(*instance)) == 12, "physx_PxModifiableContact_Pod.separation has unexpected offset % instead of 12", ((cast(*void)(*instance.separation)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxModifiableContact_Pod.separation)) == 4, "physx_PxModifiableContact_Pod.separation has unexpected size % instead of 4", size_of(type_of(physx_PxModifiableContact_Pod.separation)));
    assert(((cast(*void)(*instance.targetVelocity)) - cast(*void)(*instance)) == 16, "physx_PxModifiableContact_Pod.targetVelocity has unexpected offset % instead of 16", ((cast(*void)(*instance.targetVelocity)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxModifiableContact_Pod.targetVelocity)) == 12, "physx_PxModifiableContact_Pod.targetVelocity has unexpected size % instead of 12", size_of(type_of(physx_PxModifiableContact_Pod.targetVelocity)));
    assert(((cast(*void)(*instance.maxImpulse)) - cast(*void)(*instance)) == 28, "physx_PxModifiableContact_Pod.maxImpulse has unexpected offset % instead of 28", ((cast(*void)(*instance.maxImpulse)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxModifiableContact_Pod.maxImpulse)) == 4, "physx_PxModifiableContact_Pod.maxImpulse has unexpected size % instead of 4", size_of(type_of(physx_PxModifiableContact_Pod.maxImpulse)));
    assert(((cast(*void)(*instance.normal)) - cast(*void)(*instance)) == 32, "physx_PxModifiableContact_Pod.normal has unexpected offset % instead of 32", ((cast(*void)(*instance.normal)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxModifiableContact_Pod.normal)) == 12, "physx_PxModifiableContact_Pod.normal has unexpected size % instead of 12", size_of(type_of(physx_PxModifiableContact_Pod.normal)));
    assert(((cast(*void)(*instance.restitution)) - cast(*void)(*instance)) == 44, "physx_PxModifiableContact_Pod.restitution has unexpected offset % instead of 44", ((cast(*void)(*instance.restitution)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxModifiableContact_Pod.restitution)) == 4, "physx_PxModifiableContact_Pod.restitution has unexpected size % instead of 4", size_of(type_of(physx_PxModifiableContact_Pod.restitution)));
    assert(((cast(*void)(*instance.materialFlags)) - cast(*void)(*instance)) == 48, "physx_PxModifiableContact_Pod.materialFlags has unexpected offset % instead of 48", ((cast(*void)(*instance.materialFlags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxModifiableContact_Pod.materialFlags)) == 4, "physx_PxModifiableContact_Pod.materialFlags has unexpected size % instead of 4", size_of(type_of(physx_PxModifiableContact_Pod.materialFlags)));
    assert(((cast(*void)(*instance.materialIndex0)) - cast(*void)(*instance)) == 52, "physx_PxModifiableContact_Pod.materialIndex0 has unexpected offset % instead of 52", ((cast(*void)(*instance.materialIndex0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxModifiableContact_Pod.materialIndex0)) == 2, "physx_PxModifiableContact_Pod.materialIndex0 has unexpected size % instead of 2", size_of(type_of(physx_PxModifiableContact_Pod.materialIndex0)));
    assert(((cast(*void)(*instance.materialIndex1)) - cast(*void)(*instance)) == 54, "physx_PxModifiableContact_Pod.materialIndex1 has unexpected offset % instead of 54", ((cast(*void)(*instance.materialIndex1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxModifiableContact_Pod.materialIndex1)) == 2, "physx_PxModifiableContact_Pod.materialIndex1 has unexpected size % instead of 2", size_of(type_of(physx_PxModifiableContact_Pod.materialIndex1)));
    assert(((cast(*void)(*instance.staticFriction)) - cast(*void)(*instance)) == 56, "physx_PxModifiableContact_Pod.staticFriction has unexpected offset % instead of 56", ((cast(*void)(*instance.staticFriction)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxModifiableContact_Pod.staticFriction)) == 4, "physx_PxModifiableContact_Pod.staticFriction has unexpected size % instead of 4", size_of(type_of(physx_PxModifiableContact_Pod.staticFriction)));
    assert(((cast(*void)(*instance.dynamicFriction)) - cast(*void)(*instance)) == 60, "physx_PxModifiableContact_Pod.dynamicFriction has unexpected offset % instead of 60", ((cast(*void)(*instance.dynamicFriction)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxModifiableContact_Pod.dynamicFriction)) == 4, "physx_PxModifiableContact_Pod.dynamicFriction has unexpected size % instead of 4", size_of(type_of(physx_PxModifiableContact_Pod.dynamicFriction)));
    assert(size_of(physx_PxModifiableContact_Pod) == 64, "physx_PxModifiableContact_Pod has size % instead of 64", size_of(physx_PxModifiableContact_Pod));
}

physx_PxContactSet_Pod :: struct {
    mCount:         u32;
    structgen_pad0: [4] u8;
    mContacts:      *physx_PxModifiableContact_Pod;
}
#run {
    instance: physx_PxContactSet_Pod;
    assert(((cast(*void)(*instance.mCount)) - cast(*void)(*instance)) == 0, "physx_PxContactSet_Pod.mCount has unexpected offset % instead of 0", ((cast(*void)(*instance.mCount)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactSet_Pod.mCount)) == 4, "physx_PxContactSet_Pod.mCount has unexpected size % instead of 4", size_of(type_of(physx_PxContactSet_Pod.mCount)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 4, "physx_PxContactSet_Pod.structgen_pad0 has unexpected offset % instead of 4", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactSet_Pod.structgen_pad0)) == 4, "physx_PxContactSet_Pod.structgen_pad0 has unexpected size % instead of 4", size_of(type_of(physx_PxContactSet_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.mContacts)) - cast(*void)(*instance)) == 8, "physx_PxContactSet_Pod.mContacts has unexpected offset % instead of 8", ((cast(*void)(*instance.mContacts)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactSet_Pod.mContacts)) == 8, "physx_PxContactSet_Pod.mContacts has unexpected size % instead of 8", size_of(type_of(physx_PxContactSet_Pod.mContacts)));
    assert(size_of(physx_PxContactSet_Pod) == 16, "physx_PxContactSet_Pod has size % instead of 16", size_of(physx_PxContactSet_Pod));
}

physx_PxContactModifyCallback_Pod :: struct {
    vtable_: *void;
}
#run {
    instance: physx_PxContactModifyCallback_Pod;
    assert(((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)) == 0, "physx_PxContactModifyCallback_Pod.vtable_ has unexpected offset % instead of 0", ((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactModifyCallback_Pod.vtable_)) == 8, "physx_PxContactModifyCallback_Pod.vtable_ has unexpected size % instead of 8", size_of(type_of(physx_PxContactModifyCallback_Pod.vtable_)));
    assert(size_of(physx_PxContactModifyCallback_Pod) == 8, "physx_PxContactModifyCallback_Pod has size % instead of 8", size_of(physx_PxContactModifyCallback_Pod));
}

physx_PxContactModifyPair_Pod :: struct {
    actor:     [2] *physx_PxRigidActor_Pod;
    shape:     [2] *physx_PxShape_Pod;
    transform: [2] physx_PxTransform_Pod;
    contacts:  physx_PxContactSet_Pod;
}
#run {
    instance: physx_PxContactModifyPair_Pod;
    assert(((cast(*void)(*instance.actor)) - cast(*void)(*instance)) == 0, "physx_PxContactModifyPair_Pod.actor has unexpected offset % instead of 0", ((cast(*void)(*instance.actor)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactModifyPair_Pod.actor)) == 16, "physx_PxContactModifyPair_Pod.actor has unexpected size % instead of 16", size_of(type_of(physx_PxContactModifyPair_Pod.actor)));
    assert(((cast(*void)(*instance.shape)) - cast(*void)(*instance)) == 16, "physx_PxContactModifyPair_Pod.shape has unexpected offset % instead of 16", ((cast(*void)(*instance.shape)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactModifyPair_Pod.shape)) == 16, "physx_PxContactModifyPair_Pod.shape has unexpected size % instead of 16", size_of(type_of(physx_PxContactModifyPair_Pod.shape)));
    assert(((cast(*void)(*instance.transform)) - cast(*void)(*instance)) == 32, "physx_PxContactModifyPair_Pod.transform has unexpected offset % instead of 32", ((cast(*void)(*instance.transform)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactModifyPair_Pod.transform)) == 56, "physx_PxContactModifyPair_Pod.transform has unexpected size % instead of 56", size_of(type_of(physx_PxContactModifyPair_Pod.transform)));
    assert(((cast(*void)(*instance.contacts)) - cast(*void)(*instance)) == 88, "physx_PxContactModifyPair_Pod.contacts has unexpected offset % instead of 88", ((cast(*void)(*instance.contacts)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactModifyPair_Pod.contacts)) == 16, "physx_PxContactModifyPair_Pod.contacts has unexpected size % instead of 16", size_of(type_of(physx_PxContactModifyPair_Pod.contacts)));
    assert(size_of(physx_PxContactModifyPair_Pod) == 104, "physx_PxContactModifyPair_Pod has size % instead of 104", size_of(physx_PxContactModifyPair_Pod));
}

physx_PxCCDContactModifyCallback_Pod :: struct {
    vtable_: *void;
}
#run {
    instance: physx_PxCCDContactModifyCallback_Pod;
    assert(((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)) == 0, "physx_PxCCDContactModifyCallback_Pod.vtable_ has unexpected offset % instead of 0", ((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxCCDContactModifyCallback_Pod.vtable_)) == 8, "physx_PxCCDContactModifyCallback_Pod.vtable_ has unexpected size % instead of 8", size_of(type_of(physx_PxCCDContactModifyCallback_Pod.vtable_)));
    assert(size_of(physx_PxCCDContactModifyCallback_Pod) == 8, "physx_PxCCDContactModifyCallback_Pod has size % instead of 8", size_of(physx_PxCCDContactModifyCallback_Pod));
}

physx_PxDeletionListener_Pod :: struct {
    vtable_: *void;
}
#run {
    instance: physx_PxDeletionListener_Pod;
    assert(((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)) == 0, "physx_PxDeletionListener_Pod.vtable_ has unexpected offset % instead of 0", ((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxDeletionListener_Pod.vtable_)) == 8, "physx_PxDeletionListener_Pod.vtable_ has unexpected size % instead of 8", size_of(type_of(physx_PxDeletionListener_Pod.vtable_)));
    assert(size_of(physx_PxDeletionListener_Pod) == 8, "physx_PxDeletionListener_Pod has size % instead of 8", size_of(physx_PxDeletionListener_Pod));
}

physx_PxDataAccessFlags_Pod :: struct {
    mBits: u8;
}
#run {
    instance: physx_PxDataAccessFlags_Pod;
    assert(((cast(*void)(*instance.mBits)) - cast(*void)(*instance)) == 0, "physx_PxDataAccessFlags_Pod.mBits has unexpected offset % instead of 0", ((cast(*void)(*instance.mBits)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxDataAccessFlags_Pod.mBits)) == 1, "physx_PxDataAccessFlags_Pod.mBits has unexpected size % instead of 1", size_of(type_of(physx_PxDataAccessFlags_Pod.mBits)));
    assert(size_of(physx_PxDataAccessFlags_Pod) == 1, "physx_PxDataAccessFlags_Pod has size % instead of 1", size_of(physx_PxDataAccessFlags_Pod));
}

physx_PxLockedData_Pod :: struct {
    vtable_: *void;
}
#run {
    instance: physx_PxLockedData_Pod;
    assert(((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)) == 0, "physx_PxLockedData_Pod.vtable_ has unexpected offset % instead of 0", ((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxLockedData_Pod.vtable_)) == 8, "physx_PxLockedData_Pod.vtable_ has unexpected size % instead of 8", size_of(type_of(physx_PxLockedData_Pod.vtable_)));
    assert(size_of(physx_PxLockedData_Pod) == 8, "physx_PxLockedData_Pod has size % instead of 8", size_of(physx_PxLockedData_Pod));
}

physx_PxMaterialFlags_Pod :: struct {
    mBits: u16;
}
#run {
    instance: physx_PxMaterialFlags_Pod;
    assert(((cast(*void)(*instance.mBits)) - cast(*void)(*instance)) == 0, "physx_PxMaterialFlags_Pod.mBits has unexpected offset % instead of 0", ((cast(*void)(*instance.mBits)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxMaterialFlags_Pod.mBits)) == 2, "physx_PxMaterialFlags_Pod.mBits has unexpected size % instead of 2", size_of(type_of(physx_PxMaterialFlags_Pod.mBits)));
    assert(size_of(physx_PxMaterialFlags_Pod) == 2, "physx_PxMaterialFlags_Pod has size % instead of 2", size_of(physx_PxMaterialFlags_Pod));
}

physx_PxPhysics_Pod :: struct {
    vtable_: *void;
}
#run {
    instance: physx_PxPhysics_Pod;
    assert(((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)) == 0, "physx_PxPhysics_Pod.vtable_ has unexpected offset % instead of 0", ((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxPhysics_Pod.vtable_)) == 8, "physx_PxPhysics_Pod.vtable_ has unexpected size % instead of 8", size_of(type_of(physx_PxPhysics_Pod.vtable_)));
    assert(size_of(physx_PxPhysics_Pod) == 8, "physx_PxPhysics_Pod has size % instead of 8", size_of(physx_PxPhysics_Pod));
}

physx_PxSimulationEventCallback_Pod :: struct {
    vtable_: *void;
}
#run {
    instance: physx_PxSimulationEventCallback_Pod;
    assert(((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)) == 0, "physx_PxSimulationEventCallback_Pod.vtable_ has unexpected offset % instead of 0", ((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSimulationEventCallback_Pod.vtable_)) == 8, "physx_PxSimulationEventCallback_Pod.vtable_ has unexpected size % instead of 8", size_of(type_of(physx_PxSimulationEventCallback_Pod.vtable_)));
    assert(size_of(physx_PxSimulationEventCallback_Pod) == 8, "physx_PxSimulationEventCallback_Pod has size % instead of 8", size_of(physx_PxSimulationEventCallback_Pod));
}

physx_PxBroadPhaseCallback_Pod :: struct {
    vtable_: *void;
}
#run {
    instance: physx_PxBroadPhaseCallback_Pod;
    assert(((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)) == 0, "physx_PxBroadPhaseCallback_Pod.vtable_ has unexpected offset % instead of 0", ((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBroadPhaseCallback_Pod.vtable_)) == 8, "physx_PxBroadPhaseCallback_Pod.vtable_ has unexpected size % instead of 8", size_of(type_of(physx_PxBroadPhaseCallback_Pod.vtable_)));
    assert(size_of(physx_PxBroadPhaseCallback_Pod) == 8, "physx_PxBroadPhaseCallback_Pod has size % instead of 8", size_of(physx_PxBroadPhaseCallback_Pod));
}

physx_PxSceneLimits_Pod :: struct {
    maxNbActors:             u32;
    maxNbBodies:             u32;
    maxNbStaticShapes:       u32;
    maxNbDynamicShapes:      u32;
    maxNbAggregates:         u32;
    maxNbConstraints:        u32;
    maxNbRegions:            u32;
    maxNbBroadPhaseOverlaps: u32;
}
#run {
    instance: physx_PxSceneLimits_Pod;
    assert(((cast(*void)(*instance.maxNbActors)) - cast(*void)(*instance)) == 0, "physx_PxSceneLimits_Pod.maxNbActors has unexpected offset % instead of 0", ((cast(*void)(*instance.maxNbActors)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneLimits_Pod.maxNbActors)) == 4, "physx_PxSceneLimits_Pod.maxNbActors has unexpected size % instead of 4", size_of(type_of(physx_PxSceneLimits_Pod.maxNbActors)));
    assert(((cast(*void)(*instance.maxNbBodies)) - cast(*void)(*instance)) == 4, "physx_PxSceneLimits_Pod.maxNbBodies has unexpected offset % instead of 4", ((cast(*void)(*instance.maxNbBodies)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneLimits_Pod.maxNbBodies)) == 4, "physx_PxSceneLimits_Pod.maxNbBodies has unexpected size % instead of 4", size_of(type_of(physx_PxSceneLimits_Pod.maxNbBodies)));
    assert(((cast(*void)(*instance.maxNbStaticShapes)) - cast(*void)(*instance)) == 8, "physx_PxSceneLimits_Pod.maxNbStaticShapes has unexpected offset % instead of 8", ((cast(*void)(*instance.maxNbStaticShapes)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneLimits_Pod.maxNbStaticShapes)) == 4, "physx_PxSceneLimits_Pod.maxNbStaticShapes has unexpected size % instead of 4", size_of(type_of(physx_PxSceneLimits_Pod.maxNbStaticShapes)));
    assert(((cast(*void)(*instance.maxNbDynamicShapes)) - cast(*void)(*instance)) == 12, "physx_PxSceneLimits_Pod.maxNbDynamicShapes has unexpected offset % instead of 12", ((cast(*void)(*instance.maxNbDynamicShapes)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneLimits_Pod.maxNbDynamicShapes)) == 4, "physx_PxSceneLimits_Pod.maxNbDynamicShapes has unexpected size % instead of 4", size_of(type_of(physx_PxSceneLimits_Pod.maxNbDynamicShapes)));
    assert(((cast(*void)(*instance.maxNbAggregates)) - cast(*void)(*instance)) == 16, "physx_PxSceneLimits_Pod.maxNbAggregates has unexpected offset % instead of 16", ((cast(*void)(*instance.maxNbAggregates)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneLimits_Pod.maxNbAggregates)) == 4, "physx_PxSceneLimits_Pod.maxNbAggregates has unexpected size % instead of 4", size_of(type_of(physx_PxSceneLimits_Pod.maxNbAggregates)));
    assert(((cast(*void)(*instance.maxNbConstraints)) - cast(*void)(*instance)) == 20, "physx_PxSceneLimits_Pod.maxNbConstraints has unexpected offset % instead of 20", ((cast(*void)(*instance.maxNbConstraints)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneLimits_Pod.maxNbConstraints)) == 4, "physx_PxSceneLimits_Pod.maxNbConstraints has unexpected size % instead of 4", size_of(type_of(physx_PxSceneLimits_Pod.maxNbConstraints)));
    assert(((cast(*void)(*instance.maxNbRegions)) - cast(*void)(*instance)) == 24, "physx_PxSceneLimits_Pod.maxNbRegions has unexpected offset % instead of 24", ((cast(*void)(*instance.maxNbRegions)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneLimits_Pod.maxNbRegions)) == 4, "physx_PxSceneLimits_Pod.maxNbRegions has unexpected size % instead of 4", size_of(type_of(physx_PxSceneLimits_Pod.maxNbRegions)));
    assert(((cast(*void)(*instance.maxNbBroadPhaseOverlaps)) - cast(*void)(*instance)) == 28, "physx_PxSceneLimits_Pod.maxNbBroadPhaseOverlaps has unexpected offset % instead of 28", ((cast(*void)(*instance.maxNbBroadPhaseOverlaps)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneLimits_Pod.maxNbBroadPhaseOverlaps)) == 4, "physx_PxSceneLimits_Pod.maxNbBroadPhaseOverlaps has unexpected size % instead of 4", size_of(type_of(physx_PxSceneLimits_Pod.maxNbBroadPhaseOverlaps)));
    assert(size_of(physx_PxSceneLimits_Pod) == 32, "physx_PxSceneLimits_Pod has size % instead of 32", size_of(physx_PxSceneLimits_Pod));
}

physx_PxSceneFlags_Pod :: struct {
    mBits: u32;
}
#run {
    instance: physx_PxSceneFlags_Pod;
    assert(((cast(*void)(*instance.mBits)) - cast(*void)(*instance)) == 0, "physx_PxSceneFlags_Pod.mBits has unexpected offset % instead of 0", ((cast(*void)(*instance.mBits)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneFlags_Pod.mBits)) == 4, "physx_PxSceneFlags_Pod.mBits has unexpected size % instead of 4", size_of(type_of(physx_PxSceneFlags_Pod.mBits)));
    assert(size_of(physx_PxSceneFlags_Pod) == 4, "physx_PxSceneFlags_Pod has size % instead of 4", size_of(physx_PxSceneFlags_Pod));
}

physx_PxCudaContextManager_Pod :: struct {}
physx_PxgDynamicsMemoryConfig_Pod :: struct {
    constraintBufferCapacity: u32;
    contactBufferCapacity:    u32;
    tempBufferCapacity:       u32;
    contactStreamSize:        u32;
    patchStreamSize:          u32;
    forceStreamCapacity:      u32;
    heapCapacity:             u32;
    foundLostPairsCapacity:   u32;
}
#run {
    instance: physx_PxgDynamicsMemoryConfig_Pod;
    assert(((cast(*void)(*instance.constraintBufferCapacity)) - cast(*void)(*instance)) == 0, "physx_PxgDynamicsMemoryConfig_Pod.constraintBufferCapacity has unexpected offset % instead of 0", ((cast(*void)(*instance.constraintBufferCapacity)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxgDynamicsMemoryConfig_Pod.constraintBufferCapacity)) == 4, "physx_PxgDynamicsMemoryConfig_Pod.constraintBufferCapacity has unexpected size % instead of 4", size_of(type_of(physx_PxgDynamicsMemoryConfig_Pod.constraintBufferCapacity)));
    assert(((cast(*void)(*instance.contactBufferCapacity)) - cast(*void)(*instance)) == 4, "physx_PxgDynamicsMemoryConfig_Pod.contactBufferCapacity has unexpected offset % instead of 4", ((cast(*void)(*instance.contactBufferCapacity)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxgDynamicsMemoryConfig_Pod.contactBufferCapacity)) == 4, "physx_PxgDynamicsMemoryConfig_Pod.contactBufferCapacity has unexpected size % instead of 4", size_of(type_of(physx_PxgDynamicsMemoryConfig_Pod.contactBufferCapacity)));
    assert(((cast(*void)(*instance.tempBufferCapacity)) - cast(*void)(*instance)) == 8, "physx_PxgDynamicsMemoryConfig_Pod.tempBufferCapacity has unexpected offset % instead of 8", ((cast(*void)(*instance.tempBufferCapacity)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxgDynamicsMemoryConfig_Pod.tempBufferCapacity)) == 4, "physx_PxgDynamicsMemoryConfig_Pod.tempBufferCapacity has unexpected size % instead of 4", size_of(type_of(physx_PxgDynamicsMemoryConfig_Pod.tempBufferCapacity)));
    assert(((cast(*void)(*instance.contactStreamSize)) - cast(*void)(*instance)) == 12, "physx_PxgDynamicsMemoryConfig_Pod.contactStreamSize has unexpected offset % instead of 12", ((cast(*void)(*instance.contactStreamSize)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxgDynamicsMemoryConfig_Pod.contactStreamSize)) == 4, "physx_PxgDynamicsMemoryConfig_Pod.contactStreamSize has unexpected size % instead of 4", size_of(type_of(physx_PxgDynamicsMemoryConfig_Pod.contactStreamSize)));
    assert(((cast(*void)(*instance.patchStreamSize)) - cast(*void)(*instance)) == 16, "physx_PxgDynamicsMemoryConfig_Pod.patchStreamSize has unexpected offset % instead of 16", ((cast(*void)(*instance.patchStreamSize)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxgDynamicsMemoryConfig_Pod.patchStreamSize)) == 4, "physx_PxgDynamicsMemoryConfig_Pod.patchStreamSize has unexpected size % instead of 4", size_of(type_of(physx_PxgDynamicsMemoryConfig_Pod.patchStreamSize)));
    assert(((cast(*void)(*instance.forceStreamCapacity)) - cast(*void)(*instance)) == 20, "physx_PxgDynamicsMemoryConfig_Pod.forceStreamCapacity has unexpected offset % instead of 20", ((cast(*void)(*instance.forceStreamCapacity)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxgDynamicsMemoryConfig_Pod.forceStreamCapacity)) == 4, "physx_PxgDynamicsMemoryConfig_Pod.forceStreamCapacity has unexpected size % instead of 4", size_of(type_of(physx_PxgDynamicsMemoryConfig_Pod.forceStreamCapacity)));
    assert(((cast(*void)(*instance.heapCapacity)) - cast(*void)(*instance)) == 24, "physx_PxgDynamicsMemoryConfig_Pod.heapCapacity has unexpected offset % instead of 24", ((cast(*void)(*instance.heapCapacity)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxgDynamicsMemoryConfig_Pod.heapCapacity)) == 4, "physx_PxgDynamicsMemoryConfig_Pod.heapCapacity has unexpected size % instead of 4", size_of(type_of(physx_PxgDynamicsMemoryConfig_Pod.heapCapacity)));
    assert(((cast(*void)(*instance.foundLostPairsCapacity)) - cast(*void)(*instance)) == 28, "physx_PxgDynamicsMemoryConfig_Pod.foundLostPairsCapacity has unexpected offset % instead of 28", ((cast(*void)(*instance.foundLostPairsCapacity)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxgDynamicsMemoryConfig_Pod.foundLostPairsCapacity)) == 4, "physx_PxgDynamicsMemoryConfig_Pod.foundLostPairsCapacity has unexpected size % instead of 4", size_of(type_of(physx_PxgDynamicsMemoryConfig_Pod.foundLostPairsCapacity)));
    assert(size_of(physx_PxgDynamicsMemoryConfig_Pod) == 32, "physx_PxgDynamicsMemoryConfig_Pod has size % instead of 32", size_of(physx_PxgDynamicsMemoryConfig_Pod));
}

physx_PxSceneDesc_Pod :: struct {
    gravity:                       physx_PxVec3_Pod;
    structgen_pad0:                [4] u8;
    simulationEventCallback:       *physx_PxSimulationEventCallback_Pod;
    contactModifyCallback:         *physx_PxContactModifyCallback_Pod;
    ccdContactModifyCallback:      *physx_PxCCDContactModifyCallback_Pod;
    filterShaderData:              *void;
    filterShaderDataSize:          u32;
    structgen_pad1:                [4] u8;
    filterShader:                  *void;
    filterCallback:                *physx_PxSimulationFilterCallback_Pod;
    kineKineFilteringMode:         u32;
    staticKineFilteringMode:       u32;
    broadPhaseType:                u32;
    structgen_pad2:                [4] u8;
    broadPhaseCallback:            *physx_PxBroadPhaseCallback_Pod;
    limits:                        physx_PxSceneLimits_Pod;
    frictionType:                  u32;
    solverType:                    u32;
    bounceThresholdVelocity:       float;
    frictionOffsetThreshold:       float;
    ccdMaxSeparation:              float;
    solverOffsetSlop:              float;
    flags:                         physx_PxSceneFlags_Pod;
    structgen_pad3:                [4] u8;
    cpuDispatcher:                 *physx_PxCpuDispatcher_Pod;
    cudaContextManager:            *physx_PxCudaContextManager_Pod;
    staticStructure:               u32;
    dynamicStructure:              u32;
    dynamicTreeRebuildRateHint:    u32;
    sceneQueryUpdateMode:          u32;
    userData:                      *void;
    solverBatchSize:               u32;
    solverArticulationBatchSize:   u32;
    nbContactDataBlocks:           u32;
    maxNbContactDataBlocks:        u32;
    maxBiasCoefficient:            float;
    contactReportStreamBufferSize: u32;
    ccdMaxPasses:                  u32;
    ccdThreshold:                  float;
    wakeCounterResetValue:         float;
    sanityBounds:                  physx_PxBounds3_Pod;
    gpuDynamicsConfig:             physx_PxgDynamicsMemoryConfig_Pod;
    gpuMaxNumPartitions:           u32;
    gpuComputeVersion:             u32;
    structgen_pad4:                [12] u8;
}
#run {
    instance: physx_PxSceneDesc_Pod;
    assert(((cast(*void)(*instance.gravity)) - cast(*void)(*instance)) == 0, "physx_PxSceneDesc_Pod.gravity has unexpected offset % instead of 0", ((cast(*void)(*instance.gravity)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneDesc_Pod.gravity)) == 12, "physx_PxSceneDesc_Pod.gravity has unexpected size % instead of 12", size_of(type_of(physx_PxSceneDesc_Pod.gravity)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 12, "physx_PxSceneDesc_Pod.structgen_pad0 has unexpected offset % instead of 12", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneDesc_Pod.structgen_pad0)) == 4, "physx_PxSceneDesc_Pod.structgen_pad0 has unexpected size % instead of 4", size_of(type_of(physx_PxSceneDesc_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.simulationEventCallback)) - cast(*void)(*instance)) == 16, "physx_PxSceneDesc_Pod.simulationEventCallback has unexpected offset % instead of 16", ((cast(*void)(*instance.simulationEventCallback)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneDesc_Pod.simulationEventCallback)) == 8, "physx_PxSceneDesc_Pod.simulationEventCallback has unexpected size % instead of 8", size_of(type_of(physx_PxSceneDesc_Pod.simulationEventCallback)));
    assert(((cast(*void)(*instance.contactModifyCallback)) - cast(*void)(*instance)) == 24, "physx_PxSceneDesc_Pod.contactModifyCallback has unexpected offset % instead of 24", ((cast(*void)(*instance.contactModifyCallback)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneDesc_Pod.contactModifyCallback)) == 8, "physx_PxSceneDesc_Pod.contactModifyCallback has unexpected size % instead of 8", size_of(type_of(physx_PxSceneDesc_Pod.contactModifyCallback)));
    assert(((cast(*void)(*instance.ccdContactModifyCallback)) - cast(*void)(*instance)) == 32, "physx_PxSceneDesc_Pod.ccdContactModifyCallback has unexpected offset % instead of 32", ((cast(*void)(*instance.ccdContactModifyCallback)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneDesc_Pod.ccdContactModifyCallback)) == 8, "physx_PxSceneDesc_Pod.ccdContactModifyCallback has unexpected size % instead of 8", size_of(type_of(physx_PxSceneDesc_Pod.ccdContactModifyCallback)));
    assert(((cast(*void)(*instance.filterShaderData)) - cast(*void)(*instance)) == 40, "physx_PxSceneDesc_Pod.filterShaderData has unexpected offset % instead of 40", ((cast(*void)(*instance.filterShaderData)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneDesc_Pod.filterShaderData)) == 8, "physx_PxSceneDesc_Pod.filterShaderData has unexpected size % instead of 8", size_of(type_of(physx_PxSceneDesc_Pod.filterShaderData)));
    assert(((cast(*void)(*instance.filterShaderDataSize)) - cast(*void)(*instance)) == 48, "physx_PxSceneDesc_Pod.filterShaderDataSize has unexpected offset % instead of 48", ((cast(*void)(*instance.filterShaderDataSize)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneDesc_Pod.filterShaderDataSize)) == 4, "physx_PxSceneDesc_Pod.filterShaderDataSize has unexpected size % instead of 4", size_of(type_of(physx_PxSceneDesc_Pod.filterShaderDataSize)));
    assert(((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)) == 52, "physx_PxSceneDesc_Pod.structgen_pad1 has unexpected offset % instead of 52", ((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneDesc_Pod.structgen_pad1)) == 4, "physx_PxSceneDesc_Pod.structgen_pad1 has unexpected size % instead of 4", size_of(type_of(physx_PxSceneDesc_Pod.structgen_pad1)));
    assert(((cast(*void)(*instance.filterShader)) - cast(*void)(*instance)) == 56, "physx_PxSceneDesc_Pod.filterShader has unexpected offset % instead of 56", ((cast(*void)(*instance.filterShader)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneDesc_Pod.filterShader)) == 8, "physx_PxSceneDesc_Pod.filterShader has unexpected size % instead of 8", size_of(type_of(physx_PxSceneDesc_Pod.filterShader)));
    assert(((cast(*void)(*instance.filterCallback)) - cast(*void)(*instance)) == 64, "physx_PxSceneDesc_Pod.filterCallback has unexpected offset % instead of 64", ((cast(*void)(*instance.filterCallback)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneDesc_Pod.filterCallback)) == 8, "physx_PxSceneDesc_Pod.filterCallback has unexpected size % instead of 8", size_of(type_of(physx_PxSceneDesc_Pod.filterCallback)));
    assert(((cast(*void)(*instance.kineKineFilteringMode)) - cast(*void)(*instance)) == 72, "physx_PxSceneDesc_Pod.kineKineFilteringMode has unexpected offset % instead of 72", ((cast(*void)(*instance.kineKineFilteringMode)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneDesc_Pod.kineKineFilteringMode)) == 4, "physx_PxSceneDesc_Pod.kineKineFilteringMode has unexpected size % instead of 4", size_of(type_of(physx_PxSceneDesc_Pod.kineKineFilteringMode)));
    assert(((cast(*void)(*instance.staticKineFilteringMode)) - cast(*void)(*instance)) == 76, "physx_PxSceneDesc_Pod.staticKineFilteringMode has unexpected offset % instead of 76", ((cast(*void)(*instance.staticKineFilteringMode)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneDesc_Pod.staticKineFilteringMode)) == 4, "physx_PxSceneDesc_Pod.staticKineFilteringMode has unexpected size % instead of 4", size_of(type_of(physx_PxSceneDesc_Pod.staticKineFilteringMode)));
    assert(((cast(*void)(*instance.broadPhaseType)) - cast(*void)(*instance)) == 80, "physx_PxSceneDesc_Pod.broadPhaseType has unexpected offset % instead of 80", ((cast(*void)(*instance.broadPhaseType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneDesc_Pod.broadPhaseType)) == 4, "physx_PxSceneDesc_Pod.broadPhaseType has unexpected size % instead of 4", size_of(type_of(physx_PxSceneDesc_Pod.broadPhaseType)));
    assert(((cast(*void)(*instance.structgen_pad2)) - cast(*void)(*instance)) == 84, "physx_PxSceneDesc_Pod.structgen_pad2 has unexpected offset % instead of 84", ((cast(*void)(*instance.structgen_pad2)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneDesc_Pod.structgen_pad2)) == 4, "physx_PxSceneDesc_Pod.structgen_pad2 has unexpected size % instead of 4", size_of(type_of(physx_PxSceneDesc_Pod.structgen_pad2)));
    assert(((cast(*void)(*instance.broadPhaseCallback)) - cast(*void)(*instance)) == 88, "physx_PxSceneDesc_Pod.broadPhaseCallback has unexpected offset % instead of 88", ((cast(*void)(*instance.broadPhaseCallback)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneDesc_Pod.broadPhaseCallback)) == 8, "physx_PxSceneDesc_Pod.broadPhaseCallback has unexpected size % instead of 8", size_of(type_of(physx_PxSceneDesc_Pod.broadPhaseCallback)));
    assert(((cast(*void)(*instance.limits)) - cast(*void)(*instance)) == 96, "physx_PxSceneDesc_Pod.limits has unexpected offset % instead of 96", ((cast(*void)(*instance.limits)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneDesc_Pod.limits)) == 32, "physx_PxSceneDesc_Pod.limits has unexpected size % instead of 32", size_of(type_of(physx_PxSceneDesc_Pod.limits)));
    assert(((cast(*void)(*instance.frictionType)) - cast(*void)(*instance)) == 128, "physx_PxSceneDesc_Pod.frictionType has unexpected offset % instead of 128", ((cast(*void)(*instance.frictionType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneDesc_Pod.frictionType)) == 4, "physx_PxSceneDesc_Pod.frictionType has unexpected size % instead of 4", size_of(type_of(physx_PxSceneDesc_Pod.frictionType)));
    assert(((cast(*void)(*instance.solverType)) - cast(*void)(*instance)) == 132, "physx_PxSceneDesc_Pod.solverType has unexpected offset % instead of 132", ((cast(*void)(*instance.solverType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneDesc_Pod.solverType)) == 4, "physx_PxSceneDesc_Pod.solverType has unexpected size % instead of 4", size_of(type_of(physx_PxSceneDesc_Pod.solverType)));
    assert(((cast(*void)(*instance.bounceThresholdVelocity)) - cast(*void)(*instance)) == 136, "physx_PxSceneDesc_Pod.bounceThresholdVelocity has unexpected offset % instead of 136", ((cast(*void)(*instance.bounceThresholdVelocity)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneDesc_Pod.bounceThresholdVelocity)) == 4, "physx_PxSceneDesc_Pod.bounceThresholdVelocity has unexpected size % instead of 4", size_of(type_of(physx_PxSceneDesc_Pod.bounceThresholdVelocity)));
    assert(((cast(*void)(*instance.frictionOffsetThreshold)) - cast(*void)(*instance)) == 140, "physx_PxSceneDesc_Pod.frictionOffsetThreshold has unexpected offset % instead of 140", ((cast(*void)(*instance.frictionOffsetThreshold)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneDesc_Pod.frictionOffsetThreshold)) == 4, "physx_PxSceneDesc_Pod.frictionOffsetThreshold has unexpected size % instead of 4", size_of(type_of(physx_PxSceneDesc_Pod.frictionOffsetThreshold)));
    assert(((cast(*void)(*instance.ccdMaxSeparation)) - cast(*void)(*instance)) == 144, "physx_PxSceneDesc_Pod.ccdMaxSeparation has unexpected offset % instead of 144", ((cast(*void)(*instance.ccdMaxSeparation)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneDesc_Pod.ccdMaxSeparation)) == 4, "physx_PxSceneDesc_Pod.ccdMaxSeparation has unexpected size % instead of 4", size_of(type_of(physx_PxSceneDesc_Pod.ccdMaxSeparation)));
    assert(((cast(*void)(*instance.solverOffsetSlop)) - cast(*void)(*instance)) == 148, "physx_PxSceneDesc_Pod.solverOffsetSlop has unexpected offset % instead of 148", ((cast(*void)(*instance.solverOffsetSlop)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneDesc_Pod.solverOffsetSlop)) == 4, "physx_PxSceneDesc_Pod.solverOffsetSlop has unexpected size % instead of 4", size_of(type_of(physx_PxSceneDesc_Pod.solverOffsetSlop)));
    assert(((cast(*void)(*instance.flags)) - cast(*void)(*instance)) == 152, "physx_PxSceneDesc_Pod.flags has unexpected offset % instead of 152", ((cast(*void)(*instance.flags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneDesc_Pod.flags)) == 4, "physx_PxSceneDesc_Pod.flags has unexpected size % instead of 4", size_of(type_of(physx_PxSceneDesc_Pod.flags)));
    assert(((cast(*void)(*instance.structgen_pad3)) - cast(*void)(*instance)) == 156, "physx_PxSceneDesc_Pod.structgen_pad3 has unexpected offset % instead of 156", ((cast(*void)(*instance.structgen_pad3)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneDesc_Pod.structgen_pad3)) == 4, "physx_PxSceneDesc_Pod.structgen_pad3 has unexpected size % instead of 4", size_of(type_of(physx_PxSceneDesc_Pod.structgen_pad3)));
    assert(((cast(*void)(*instance.cpuDispatcher)) - cast(*void)(*instance)) == 160, "physx_PxSceneDesc_Pod.cpuDispatcher has unexpected offset % instead of 160", ((cast(*void)(*instance.cpuDispatcher)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneDesc_Pod.cpuDispatcher)) == 8, "physx_PxSceneDesc_Pod.cpuDispatcher has unexpected size % instead of 8", size_of(type_of(physx_PxSceneDesc_Pod.cpuDispatcher)));
    assert(((cast(*void)(*instance.cudaContextManager)) - cast(*void)(*instance)) == 168, "physx_PxSceneDesc_Pod.cudaContextManager has unexpected offset % instead of 168", ((cast(*void)(*instance.cudaContextManager)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneDesc_Pod.cudaContextManager)) == 8, "physx_PxSceneDesc_Pod.cudaContextManager has unexpected size % instead of 8", size_of(type_of(physx_PxSceneDesc_Pod.cudaContextManager)));
    assert(((cast(*void)(*instance.staticStructure)) - cast(*void)(*instance)) == 176, "physx_PxSceneDesc_Pod.staticStructure has unexpected offset % instead of 176", ((cast(*void)(*instance.staticStructure)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneDesc_Pod.staticStructure)) == 4, "physx_PxSceneDesc_Pod.staticStructure has unexpected size % instead of 4", size_of(type_of(physx_PxSceneDesc_Pod.staticStructure)));
    assert(((cast(*void)(*instance.dynamicStructure)) - cast(*void)(*instance)) == 180, "physx_PxSceneDesc_Pod.dynamicStructure has unexpected offset % instead of 180", ((cast(*void)(*instance.dynamicStructure)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneDesc_Pod.dynamicStructure)) == 4, "physx_PxSceneDesc_Pod.dynamicStructure has unexpected size % instead of 4", size_of(type_of(physx_PxSceneDesc_Pod.dynamicStructure)));
    assert(((cast(*void)(*instance.dynamicTreeRebuildRateHint)) - cast(*void)(*instance)) == 184, "physx_PxSceneDesc_Pod.dynamicTreeRebuildRateHint has unexpected offset % instead of 184", ((cast(*void)(*instance.dynamicTreeRebuildRateHint)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneDesc_Pod.dynamicTreeRebuildRateHint)) == 4, "physx_PxSceneDesc_Pod.dynamicTreeRebuildRateHint has unexpected size % instead of 4", size_of(type_of(physx_PxSceneDesc_Pod.dynamicTreeRebuildRateHint)));
    assert(((cast(*void)(*instance.sceneQueryUpdateMode)) - cast(*void)(*instance)) == 188, "physx_PxSceneDesc_Pod.sceneQueryUpdateMode has unexpected offset % instead of 188", ((cast(*void)(*instance.sceneQueryUpdateMode)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneDesc_Pod.sceneQueryUpdateMode)) == 4, "physx_PxSceneDesc_Pod.sceneQueryUpdateMode has unexpected size % instead of 4", size_of(type_of(physx_PxSceneDesc_Pod.sceneQueryUpdateMode)));
    assert(((cast(*void)(*instance.userData)) - cast(*void)(*instance)) == 192, "physx_PxSceneDesc_Pod.userData has unexpected offset % instead of 192", ((cast(*void)(*instance.userData)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneDesc_Pod.userData)) == 8, "physx_PxSceneDesc_Pod.userData has unexpected size % instead of 8", size_of(type_of(physx_PxSceneDesc_Pod.userData)));
    assert(((cast(*void)(*instance.solverBatchSize)) - cast(*void)(*instance)) == 200, "physx_PxSceneDesc_Pod.solverBatchSize has unexpected offset % instead of 200", ((cast(*void)(*instance.solverBatchSize)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneDesc_Pod.solverBatchSize)) == 4, "physx_PxSceneDesc_Pod.solverBatchSize has unexpected size % instead of 4", size_of(type_of(physx_PxSceneDesc_Pod.solverBatchSize)));
    assert(((cast(*void)(*instance.solverArticulationBatchSize)) - cast(*void)(*instance)) == 204, "physx_PxSceneDesc_Pod.solverArticulationBatchSize has unexpected offset % instead of 204", ((cast(*void)(*instance.solverArticulationBatchSize)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneDesc_Pod.solverArticulationBatchSize)) == 4, "physx_PxSceneDesc_Pod.solverArticulationBatchSize has unexpected size % instead of 4", size_of(type_of(physx_PxSceneDesc_Pod.solverArticulationBatchSize)));
    assert(((cast(*void)(*instance.nbContactDataBlocks)) - cast(*void)(*instance)) == 208, "physx_PxSceneDesc_Pod.nbContactDataBlocks has unexpected offset % instead of 208", ((cast(*void)(*instance.nbContactDataBlocks)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneDesc_Pod.nbContactDataBlocks)) == 4, "physx_PxSceneDesc_Pod.nbContactDataBlocks has unexpected size % instead of 4", size_of(type_of(physx_PxSceneDesc_Pod.nbContactDataBlocks)));
    assert(((cast(*void)(*instance.maxNbContactDataBlocks)) - cast(*void)(*instance)) == 212, "physx_PxSceneDesc_Pod.maxNbContactDataBlocks has unexpected offset % instead of 212", ((cast(*void)(*instance.maxNbContactDataBlocks)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneDesc_Pod.maxNbContactDataBlocks)) == 4, "physx_PxSceneDesc_Pod.maxNbContactDataBlocks has unexpected size % instead of 4", size_of(type_of(physx_PxSceneDesc_Pod.maxNbContactDataBlocks)));
    assert(((cast(*void)(*instance.maxBiasCoefficient)) - cast(*void)(*instance)) == 216, "physx_PxSceneDesc_Pod.maxBiasCoefficient has unexpected offset % instead of 216", ((cast(*void)(*instance.maxBiasCoefficient)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneDesc_Pod.maxBiasCoefficient)) == 4, "physx_PxSceneDesc_Pod.maxBiasCoefficient has unexpected size % instead of 4", size_of(type_of(physx_PxSceneDesc_Pod.maxBiasCoefficient)));
    assert(((cast(*void)(*instance.contactReportStreamBufferSize)) - cast(*void)(*instance)) == 220, "physx_PxSceneDesc_Pod.contactReportStreamBufferSize has unexpected offset % instead of 220", ((cast(*void)(*instance.contactReportStreamBufferSize)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneDesc_Pod.contactReportStreamBufferSize)) == 4, "physx_PxSceneDesc_Pod.contactReportStreamBufferSize has unexpected size % instead of 4", size_of(type_of(physx_PxSceneDesc_Pod.contactReportStreamBufferSize)));
    assert(((cast(*void)(*instance.ccdMaxPasses)) - cast(*void)(*instance)) == 224, "physx_PxSceneDesc_Pod.ccdMaxPasses has unexpected offset % instead of 224", ((cast(*void)(*instance.ccdMaxPasses)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneDesc_Pod.ccdMaxPasses)) == 4, "physx_PxSceneDesc_Pod.ccdMaxPasses has unexpected size % instead of 4", size_of(type_of(physx_PxSceneDesc_Pod.ccdMaxPasses)));
    assert(((cast(*void)(*instance.ccdThreshold)) - cast(*void)(*instance)) == 228, "physx_PxSceneDesc_Pod.ccdThreshold has unexpected offset % instead of 228", ((cast(*void)(*instance.ccdThreshold)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneDesc_Pod.ccdThreshold)) == 4, "physx_PxSceneDesc_Pod.ccdThreshold has unexpected size % instead of 4", size_of(type_of(physx_PxSceneDesc_Pod.ccdThreshold)));
    assert(((cast(*void)(*instance.wakeCounterResetValue)) - cast(*void)(*instance)) == 232, "physx_PxSceneDesc_Pod.wakeCounterResetValue has unexpected offset % instead of 232", ((cast(*void)(*instance.wakeCounterResetValue)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneDesc_Pod.wakeCounterResetValue)) == 4, "physx_PxSceneDesc_Pod.wakeCounterResetValue has unexpected size % instead of 4", size_of(type_of(physx_PxSceneDesc_Pod.wakeCounterResetValue)));
    assert(((cast(*void)(*instance.sanityBounds)) - cast(*void)(*instance)) == 236, "physx_PxSceneDesc_Pod.sanityBounds has unexpected offset % instead of 236", ((cast(*void)(*instance.sanityBounds)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneDesc_Pod.sanityBounds)) == 24, "physx_PxSceneDesc_Pod.sanityBounds has unexpected size % instead of 24", size_of(type_of(physx_PxSceneDesc_Pod.sanityBounds)));
    assert(((cast(*void)(*instance.gpuDynamicsConfig)) - cast(*void)(*instance)) == 260, "physx_PxSceneDesc_Pod.gpuDynamicsConfig has unexpected offset % instead of 260", ((cast(*void)(*instance.gpuDynamicsConfig)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneDesc_Pod.gpuDynamicsConfig)) == 32, "physx_PxSceneDesc_Pod.gpuDynamicsConfig has unexpected size % instead of 32", size_of(type_of(physx_PxSceneDesc_Pod.gpuDynamicsConfig)));
    assert(((cast(*void)(*instance.gpuMaxNumPartitions)) - cast(*void)(*instance)) == 292, "physx_PxSceneDesc_Pod.gpuMaxNumPartitions has unexpected offset % instead of 292", ((cast(*void)(*instance.gpuMaxNumPartitions)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneDesc_Pod.gpuMaxNumPartitions)) == 4, "physx_PxSceneDesc_Pod.gpuMaxNumPartitions has unexpected size % instead of 4", size_of(type_of(physx_PxSceneDesc_Pod.gpuMaxNumPartitions)));
    assert(((cast(*void)(*instance.gpuComputeVersion)) - cast(*void)(*instance)) == 296, "physx_PxSceneDesc_Pod.gpuComputeVersion has unexpected offset % instead of 296", ((cast(*void)(*instance.gpuComputeVersion)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneDesc_Pod.gpuComputeVersion)) == 4, "physx_PxSceneDesc_Pod.gpuComputeVersion has unexpected size % instead of 4", size_of(type_of(physx_PxSceneDesc_Pod.gpuComputeVersion)));
    assert(((cast(*void)(*instance.structgen_pad4)) - cast(*void)(*instance)) == 300, "physx_PxSceneDesc_Pod.structgen_pad4 has unexpected offset % instead of 300", ((cast(*void)(*instance.structgen_pad4)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneDesc_Pod.structgen_pad4)) == 12, "physx_PxSceneDesc_Pod.structgen_pad4 has unexpected size % instead of 12", size_of(type_of(physx_PxSceneDesc_Pod.structgen_pad4)));
    assert(size_of(physx_PxSceneDesc_Pod) == 312, "physx_PxSceneDesc_Pod has size % instead of 312", size_of(physx_PxSceneDesc_Pod));
}

physx_PxRigidStatic_Pod :: struct {
    structgen_pad0: [8] u8;
    mConcreteType:  u16;
    mBaseFlags:     physx_PxBaseFlags_Pod;
    structgen_pad1: [4] u8;
    userData:       *void;
}
#run {
    instance: physx_PxRigidStatic_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxRigidStatic_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxRigidStatic_Pod.structgen_pad0)) == 8, "physx_PxRigidStatic_Pod.structgen_pad0 has unexpected size % instead of 8", size_of(type_of(physx_PxRigidStatic_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)) == 8, "physx_PxRigidStatic_Pod.mConcreteType has unexpected offset % instead of 8", ((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxRigidStatic_Pod.mConcreteType)) == 2, "physx_PxRigidStatic_Pod.mConcreteType has unexpected size % instead of 2", size_of(type_of(physx_PxRigidStatic_Pod.mConcreteType)));
    assert(((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)) == 10, "physx_PxRigidStatic_Pod.mBaseFlags has unexpected offset % instead of 10", ((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxRigidStatic_Pod.mBaseFlags)) == 2, "physx_PxRigidStatic_Pod.mBaseFlags has unexpected size % instead of 2", size_of(type_of(physx_PxRigidStatic_Pod.mBaseFlags)));
    assert(((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)) == 12, "physx_PxRigidStatic_Pod.structgen_pad1 has unexpected offset % instead of 12", ((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxRigidStatic_Pod.structgen_pad1)) == 4, "physx_PxRigidStatic_Pod.structgen_pad1 has unexpected size % instead of 4", size_of(type_of(physx_PxRigidStatic_Pod.structgen_pad1)));
    assert(((cast(*void)(*instance.userData)) - cast(*void)(*instance)) == 16, "physx_PxRigidStatic_Pod.userData has unexpected offset % instead of 16", ((cast(*void)(*instance.userData)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxRigidStatic_Pod.userData)) == 8, "physx_PxRigidStatic_Pod.userData has unexpected size % instead of 8", size_of(type_of(physx_PxRigidStatic_Pod.userData)));
    assert(size_of(physx_PxRigidStatic_Pod) == 24, "physx_PxRigidStatic_Pod has size % instead of 24", size_of(physx_PxRigidStatic_Pod));
}

physx_PxRigidDynamic_Pod :: struct {
    structgen_pad0: [8] u8;
    mConcreteType:  u16;
    mBaseFlags:     physx_PxBaseFlags_Pod;
    structgen_pad1: [4] u8;
    userData:       *void;
}
#run {
    instance: physx_PxRigidDynamic_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxRigidDynamic_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxRigidDynamic_Pod.structgen_pad0)) == 8, "physx_PxRigidDynamic_Pod.structgen_pad0 has unexpected size % instead of 8", size_of(type_of(physx_PxRigidDynamic_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)) == 8, "physx_PxRigidDynamic_Pod.mConcreteType has unexpected offset % instead of 8", ((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxRigidDynamic_Pod.mConcreteType)) == 2, "physx_PxRigidDynamic_Pod.mConcreteType has unexpected size % instead of 2", size_of(type_of(physx_PxRigidDynamic_Pod.mConcreteType)));
    assert(((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)) == 10, "physx_PxRigidDynamic_Pod.mBaseFlags has unexpected offset % instead of 10", ((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxRigidDynamic_Pod.mBaseFlags)) == 2, "physx_PxRigidDynamic_Pod.mBaseFlags has unexpected size % instead of 2", size_of(type_of(physx_PxRigidDynamic_Pod.mBaseFlags)));
    assert(((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)) == 12, "physx_PxRigidDynamic_Pod.structgen_pad1 has unexpected offset % instead of 12", ((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxRigidDynamic_Pod.structgen_pad1)) == 4, "physx_PxRigidDynamic_Pod.structgen_pad1 has unexpected size % instead of 4", size_of(type_of(physx_PxRigidDynamic_Pod.structgen_pad1)));
    assert(((cast(*void)(*instance.userData)) - cast(*void)(*instance)) == 16, "physx_PxRigidDynamic_Pod.userData has unexpected offset % instead of 16", ((cast(*void)(*instance.userData)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxRigidDynamic_Pod.userData)) == 8, "physx_PxRigidDynamic_Pod.userData has unexpected size % instead of 8", size_of(type_of(physx_PxRigidDynamic_Pod.userData)));
    assert(size_of(physx_PxRigidDynamic_Pod) == 24, "physx_PxRigidDynamic_Pod has size % instead of 24", size_of(physx_PxRigidDynamic_Pod));
}

physx_PxPruningStructure_Pod :: struct {
    structgen_pad0: [8] u8;
    mConcreteType:  u16;
    mBaseFlags:     physx_PxBaseFlags_Pod;
    structgen_pad1: [4] u8;
}
#run {
    instance: physx_PxPruningStructure_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxPruningStructure_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxPruningStructure_Pod.structgen_pad0)) == 8, "physx_PxPruningStructure_Pod.structgen_pad0 has unexpected size % instead of 8", size_of(type_of(physx_PxPruningStructure_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)) == 8, "physx_PxPruningStructure_Pod.mConcreteType has unexpected offset % instead of 8", ((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxPruningStructure_Pod.mConcreteType)) == 2, "physx_PxPruningStructure_Pod.mConcreteType has unexpected size % instead of 2", size_of(type_of(physx_PxPruningStructure_Pod.mConcreteType)));
    assert(((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)) == 10, "physx_PxPruningStructure_Pod.mBaseFlags has unexpected offset % instead of 10", ((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxPruningStructure_Pod.mBaseFlags)) == 2, "physx_PxPruningStructure_Pod.mBaseFlags has unexpected size % instead of 2", size_of(type_of(physx_PxPruningStructure_Pod.mBaseFlags)));
    assert(((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)) == 12, "physx_PxPruningStructure_Pod.structgen_pad1 has unexpected offset % instead of 12", ((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxPruningStructure_Pod.structgen_pad1)) == 4, "physx_PxPruningStructure_Pod.structgen_pad1 has unexpected size % instead of 4", size_of(type_of(physx_PxPruningStructure_Pod.structgen_pad1)));
    assert(size_of(physx_PxPruningStructure_Pod) == 16, "physx_PxPruningStructure_Pod has size % instead of 16", size_of(physx_PxPruningStructure_Pod));
}

physx_PxDeletionEventFlags_Pod :: struct {
    mBits: u8;
}
#run {
    instance: physx_PxDeletionEventFlags_Pod;
    assert(((cast(*void)(*instance.mBits)) - cast(*void)(*instance)) == 0, "physx_PxDeletionEventFlags_Pod.mBits has unexpected offset % instead of 0", ((cast(*void)(*instance.mBits)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxDeletionEventFlags_Pod.mBits)) == 1, "physx_PxDeletionEventFlags_Pod.mBits has unexpected size % instead of 1", size_of(type_of(physx_PxDeletionEventFlags_Pod.mBits)));
    assert(size_of(physx_PxDeletionEventFlags_Pod) == 1, "physx_PxDeletionEventFlags_Pod has size % instead of 1", size_of(physx_PxDeletionEventFlags_Pod));
}

physx_PxPvd_Pod :: struct {
    vtable_: *void;
}
#run {
    instance: physx_PxPvd_Pod;
    assert(((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)) == 0, "physx_PxPvd_Pod.vtable_ has unexpected offset % instead of 0", ((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxPvd_Pod.vtable_)) == 8, "physx_PxPvd_Pod.vtable_ has unexpected size % instead of 8", size_of(type_of(physx_PxPvd_Pod.vtable_)));
    assert(size_of(physx_PxPvd_Pod) == 8, "physx_PxPvd_Pod has size % instead of 8", size_of(physx_PxPvd_Pod));
}

physx_PxRigidDynamicLockFlags_Pod :: struct {
    mBits: u8;
}
#run {
    instance: physx_PxRigidDynamicLockFlags_Pod;
    assert(((cast(*void)(*instance.mBits)) - cast(*void)(*instance)) == 0, "physx_PxRigidDynamicLockFlags_Pod.mBits has unexpected offset % instead of 0", ((cast(*void)(*instance.mBits)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxRigidDynamicLockFlags_Pod.mBits)) == 1, "physx_PxRigidDynamicLockFlags_Pod.mBits has unexpected size % instead of 1", size_of(type_of(physx_PxRigidDynamicLockFlags_Pod.mBits)));
    assert(size_of(physx_PxRigidDynamicLockFlags_Pod) == 1, "physx_PxRigidDynamicLockFlags_Pod has size % instead of 1", size_of(physx_PxRigidDynamicLockFlags_Pod));
}

physx_PxSimulationStatistics_Pod :: struct {
    nbActiveConstraints:                 u32;
    nbActiveDynamicBodies:               u32;
    nbActiveKinematicBodies:             u32;
    nbStaticBodies:                      u32;
    nbDynamicBodies:                     u32;
    nbKinematicBodies:                   u32;
    nbShapes:                            [7] u32;
    nbAggregates:                        u32;
    nbArticulations:                     u32;
    nbAxisSolverConstraints:             u32;
    compressedContactSize:               u32;
    requiredContactConstraintMemory:     u32;
    peakConstraintMemory:                u32;
    nbDiscreteContactPairsTotal:         u32;
    nbDiscreteContactPairsWithCacheHits: u32;
    nbDiscreteContactPairsWithContacts:  u32;
    nbNewPairs:                          u32;
    nbLostPairs:                         u32;
    nbNewTouches:                        u32;
    nbLostTouches:                       u32;
    nbPartitions:                        u32;
    nbBroadPhaseAdds:                    u32;
    nbBroadPhaseRemoves:                 u32;
    nbDiscreteContactPairs:              [7] [7] u32;
    nbCCDPairs:                          [7] [7] u32;
    nbModifiedContactPairs:              [7] [7] u32;
    nbTriggerPairs:                      [7] [7] u32;
}
#run {
    instance: physx_PxSimulationStatistics_Pod;
    assert(((cast(*void)(*instance.nbActiveConstraints)) - cast(*void)(*instance)) == 0, "physx_PxSimulationStatistics_Pod.nbActiveConstraints has unexpected offset % instead of 0", ((cast(*void)(*instance.nbActiveConstraints)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSimulationStatistics_Pod.nbActiveConstraints)) == 4, "physx_PxSimulationStatistics_Pod.nbActiveConstraints has unexpected size % instead of 4", size_of(type_of(physx_PxSimulationStatistics_Pod.nbActiveConstraints)));
    assert(((cast(*void)(*instance.nbActiveDynamicBodies)) - cast(*void)(*instance)) == 4, "physx_PxSimulationStatistics_Pod.nbActiveDynamicBodies has unexpected offset % instead of 4", ((cast(*void)(*instance.nbActiveDynamicBodies)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSimulationStatistics_Pod.nbActiveDynamicBodies)) == 4, "physx_PxSimulationStatistics_Pod.nbActiveDynamicBodies has unexpected size % instead of 4", size_of(type_of(physx_PxSimulationStatistics_Pod.nbActiveDynamicBodies)));
    assert(((cast(*void)(*instance.nbActiveKinematicBodies)) - cast(*void)(*instance)) == 8, "physx_PxSimulationStatistics_Pod.nbActiveKinematicBodies has unexpected offset % instead of 8", ((cast(*void)(*instance.nbActiveKinematicBodies)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSimulationStatistics_Pod.nbActiveKinematicBodies)) == 4, "physx_PxSimulationStatistics_Pod.nbActiveKinematicBodies has unexpected size % instead of 4", size_of(type_of(physx_PxSimulationStatistics_Pod.nbActiveKinematicBodies)));
    assert(((cast(*void)(*instance.nbStaticBodies)) - cast(*void)(*instance)) == 12, "physx_PxSimulationStatistics_Pod.nbStaticBodies has unexpected offset % instead of 12", ((cast(*void)(*instance.nbStaticBodies)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSimulationStatistics_Pod.nbStaticBodies)) == 4, "physx_PxSimulationStatistics_Pod.nbStaticBodies has unexpected size % instead of 4", size_of(type_of(physx_PxSimulationStatistics_Pod.nbStaticBodies)));
    assert(((cast(*void)(*instance.nbDynamicBodies)) - cast(*void)(*instance)) == 16, "physx_PxSimulationStatistics_Pod.nbDynamicBodies has unexpected offset % instead of 16", ((cast(*void)(*instance.nbDynamicBodies)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSimulationStatistics_Pod.nbDynamicBodies)) == 4, "physx_PxSimulationStatistics_Pod.nbDynamicBodies has unexpected size % instead of 4", size_of(type_of(physx_PxSimulationStatistics_Pod.nbDynamicBodies)));
    assert(((cast(*void)(*instance.nbKinematicBodies)) - cast(*void)(*instance)) == 20, "physx_PxSimulationStatistics_Pod.nbKinematicBodies has unexpected offset % instead of 20", ((cast(*void)(*instance.nbKinematicBodies)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSimulationStatistics_Pod.nbKinematicBodies)) == 4, "physx_PxSimulationStatistics_Pod.nbKinematicBodies has unexpected size % instead of 4", size_of(type_of(physx_PxSimulationStatistics_Pod.nbKinematicBodies)));
    assert(((cast(*void)(*instance.nbShapes)) - cast(*void)(*instance)) == 24, "physx_PxSimulationStatistics_Pod.nbShapes has unexpected offset % instead of 24", ((cast(*void)(*instance.nbShapes)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSimulationStatistics_Pod.nbShapes)) == 28, "physx_PxSimulationStatistics_Pod.nbShapes has unexpected size % instead of 28", size_of(type_of(physx_PxSimulationStatistics_Pod.nbShapes)));
    assert(((cast(*void)(*instance.nbAggregates)) - cast(*void)(*instance)) == 52, "physx_PxSimulationStatistics_Pod.nbAggregates has unexpected offset % instead of 52", ((cast(*void)(*instance.nbAggregates)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSimulationStatistics_Pod.nbAggregates)) == 4, "physx_PxSimulationStatistics_Pod.nbAggregates has unexpected size % instead of 4", size_of(type_of(physx_PxSimulationStatistics_Pod.nbAggregates)));
    assert(((cast(*void)(*instance.nbArticulations)) - cast(*void)(*instance)) == 56, "physx_PxSimulationStatistics_Pod.nbArticulations has unexpected offset % instead of 56", ((cast(*void)(*instance.nbArticulations)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSimulationStatistics_Pod.nbArticulations)) == 4, "physx_PxSimulationStatistics_Pod.nbArticulations has unexpected size % instead of 4", size_of(type_of(physx_PxSimulationStatistics_Pod.nbArticulations)));
    assert(((cast(*void)(*instance.nbAxisSolverConstraints)) - cast(*void)(*instance)) == 60, "physx_PxSimulationStatistics_Pod.nbAxisSolverConstraints has unexpected offset % instead of 60", ((cast(*void)(*instance.nbAxisSolverConstraints)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSimulationStatistics_Pod.nbAxisSolverConstraints)) == 4, "physx_PxSimulationStatistics_Pod.nbAxisSolverConstraints has unexpected size % instead of 4", size_of(type_of(physx_PxSimulationStatistics_Pod.nbAxisSolverConstraints)));
    assert(((cast(*void)(*instance.compressedContactSize)) - cast(*void)(*instance)) == 64, "physx_PxSimulationStatistics_Pod.compressedContactSize has unexpected offset % instead of 64", ((cast(*void)(*instance.compressedContactSize)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSimulationStatistics_Pod.compressedContactSize)) == 4, "physx_PxSimulationStatistics_Pod.compressedContactSize has unexpected size % instead of 4", size_of(type_of(physx_PxSimulationStatistics_Pod.compressedContactSize)));
    assert(((cast(*void)(*instance.requiredContactConstraintMemory)) - cast(*void)(*instance)) == 68, "physx_PxSimulationStatistics_Pod.requiredContactConstraintMemory has unexpected offset % instead of 68", ((cast(*void)(*instance.requiredContactConstraintMemory)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSimulationStatistics_Pod.requiredContactConstraintMemory)) == 4, "physx_PxSimulationStatistics_Pod.requiredContactConstraintMemory has unexpected size % instead of 4", size_of(type_of(physx_PxSimulationStatistics_Pod.requiredContactConstraintMemory)));
    assert(((cast(*void)(*instance.peakConstraintMemory)) - cast(*void)(*instance)) == 72, "physx_PxSimulationStatistics_Pod.peakConstraintMemory has unexpected offset % instead of 72", ((cast(*void)(*instance.peakConstraintMemory)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSimulationStatistics_Pod.peakConstraintMemory)) == 4, "physx_PxSimulationStatistics_Pod.peakConstraintMemory has unexpected size % instead of 4", size_of(type_of(physx_PxSimulationStatistics_Pod.peakConstraintMemory)));
    assert(((cast(*void)(*instance.nbDiscreteContactPairsTotal)) - cast(*void)(*instance)) == 76, "physx_PxSimulationStatistics_Pod.nbDiscreteContactPairsTotal has unexpected offset % instead of 76", ((cast(*void)(*instance.nbDiscreteContactPairsTotal)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSimulationStatistics_Pod.nbDiscreteContactPairsTotal)) == 4, "physx_PxSimulationStatistics_Pod.nbDiscreteContactPairsTotal has unexpected size % instead of 4", size_of(type_of(physx_PxSimulationStatistics_Pod.nbDiscreteContactPairsTotal)));
    assert(((cast(*void)(*instance.nbDiscreteContactPairsWithCacheHits)) - cast(*void)(*instance)) == 80, "physx_PxSimulationStatistics_Pod.nbDiscreteContactPairsWithCacheHits has unexpected offset % instead of 80", ((cast(*void)(*instance.nbDiscreteContactPairsWithCacheHits)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSimulationStatistics_Pod.nbDiscreteContactPairsWithCacheHits)) == 4, "physx_PxSimulationStatistics_Pod.nbDiscreteContactPairsWithCacheHits has unexpected size % instead of 4", size_of(type_of(physx_PxSimulationStatistics_Pod.nbDiscreteContactPairsWithCacheHits)));
    assert(((cast(*void)(*instance.nbDiscreteContactPairsWithContacts)) - cast(*void)(*instance)) == 84, "physx_PxSimulationStatistics_Pod.nbDiscreteContactPairsWithContacts has unexpected offset % instead of 84", ((cast(*void)(*instance.nbDiscreteContactPairsWithContacts)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSimulationStatistics_Pod.nbDiscreteContactPairsWithContacts)) == 4, "physx_PxSimulationStatistics_Pod.nbDiscreteContactPairsWithContacts has unexpected size % instead of 4", size_of(type_of(physx_PxSimulationStatistics_Pod.nbDiscreteContactPairsWithContacts)));
    assert(((cast(*void)(*instance.nbNewPairs)) - cast(*void)(*instance)) == 88, "physx_PxSimulationStatistics_Pod.nbNewPairs has unexpected offset % instead of 88", ((cast(*void)(*instance.nbNewPairs)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSimulationStatistics_Pod.nbNewPairs)) == 4, "physx_PxSimulationStatistics_Pod.nbNewPairs has unexpected size % instead of 4", size_of(type_of(physx_PxSimulationStatistics_Pod.nbNewPairs)));
    assert(((cast(*void)(*instance.nbLostPairs)) - cast(*void)(*instance)) == 92, "physx_PxSimulationStatistics_Pod.nbLostPairs has unexpected offset % instead of 92", ((cast(*void)(*instance.nbLostPairs)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSimulationStatistics_Pod.nbLostPairs)) == 4, "physx_PxSimulationStatistics_Pod.nbLostPairs has unexpected size % instead of 4", size_of(type_of(physx_PxSimulationStatistics_Pod.nbLostPairs)));
    assert(((cast(*void)(*instance.nbNewTouches)) - cast(*void)(*instance)) == 96, "physx_PxSimulationStatistics_Pod.nbNewTouches has unexpected offset % instead of 96", ((cast(*void)(*instance.nbNewTouches)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSimulationStatistics_Pod.nbNewTouches)) == 4, "physx_PxSimulationStatistics_Pod.nbNewTouches has unexpected size % instead of 4", size_of(type_of(physx_PxSimulationStatistics_Pod.nbNewTouches)));
    assert(((cast(*void)(*instance.nbLostTouches)) - cast(*void)(*instance)) == 100, "physx_PxSimulationStatistics_Pod.nbLostTouches has unexpected offset % instead of 100", ((cast(*void)(*instance.nbLostTouches)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSimulationStatistics_Pod.nbLostTouches)) == 4, "physx_PxSimulationStatistics_Pod.nbLostTouches has unexpected size % instead of 4", size_of(type_of(physx_PxSimulationStatistics_Pod.nbLostTouches)));
    assert(((cast(*void)(*instance.nbPartitions)) - cast(*void)(*instance)) == 104, "physx_PxSimulationStatistics_Pod.nbPartitions has unexpected offset % instead of 104", ((cast(*void)(*instance.nbPartitions)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSimulationStatistics_Pod.nbPartitions)) == 4, "physx_PxSimulationStatistics_Pod.nbPartitions has unexpected size % instead of 4", size_of(type_of(physx_PxSimulationStatistics_Pod.nbPartitions)));
    assert(((cast(*void)(*instance.nbBroadPhaseAdds)) - cast(*void)(*instance)) == 108, "physx_PxSimulationStatistics_Pod.nbBroadPhaseAdds has unexpected offset % instead of 108", ((cast(*void)(*instance.nbBroadPhaseAdds)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSimulationStatistics_Pod.nbBroadPhaseAdds)) == 4, "physx_PxSimulationStatistics_Pod.nbBroadPhaseAdds has unexpected size % instead of 4", size_of(type_of(physx_PxSimulationStatistics_Pod.nbBroadPhaseAdds)));
    assert(((cast(*void)(*instance.nbBroadPhaseRemoves)) - cast(*void)(*instance)) == 112, "physx_PxSimulationStatistics_Pod.nbBroadPhaseRemoves has unexpected offset % instead of 112", ((cast(*void)(*instance.nbBroadPhaseRemoves)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSimulationStatistics_Pod.nbBroadPhaseRemoves)) == 4, "physx_PxSimulationStatistics_Pod.nbBroadPhaseRemoves has unexpected size % instead of 4", size_of(type_of(physx_PxSimulationStatistics_Pod.nbBroadPhaseRemoves)));
    assert(((cast(*void)(*instance.nbDiscreteContactPairs)) - cast(*void)(*instance)) == 116, "physx_PxSimulationStatistics_Pod.nbDiscreteContactPairs has unexpected offset % instead of 116", ((cast(*void)(*instance.nbDiscreteContactPairs)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSimulationStatistics_Pod.nbDiscreteContactPairs)) == 196, "physx_PxSimulationStatistics_Pod.nbDiscreteContactPairs has unexpected size % instead of 196", size_of(type_of(physx_PxSimulationStatistics_Pod.nbDiscreteContactPairs)));
    assert(((cast(*void)(*instance.nbCCDPairs)) - cast(*void)(*instance)) == 312, "physx_PxSimulationStatistics_Pod.nbCCDPairs has unexpected offset % instead of 312", ((cast(*void)(*instance.nbCCDPairs)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSimulationStatistics_Pod.nbCCDPairs)) == 196, "physx_PxSimulationStatistics_Pod.nbCCDPairs has unexpected size % instead of 196", size_of(type_of(physx_PxSimulationStatistics_Pod.nbCCDPairs)));
    assert(((cast(*void)(*instance.nbModifiedContactPairs)) - cast(*void)(*instance)) == 508, "physx_PxSimulationStatistics_Pod.nbModifiedContactPairs has unexpected offset % instead of 508", ((cast(*void)(*instance.nbModifiedContactPairs)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSimulationStatistics_Pod.nbModifiedContactPairs)) == 196, "physx_PxSimulationStatistics_Pod.nbModifiedContactPairs has unexpected size % instead of 196", size_of(type_of(physx_PxSimulationStatistics_Pod.nbModifiedContactPairs)));
    assert(((cast(*void)(*instance.nbTriggerPairs)) - cast(*void)(*instance)) == 704, "physx_PxSimulationStatistics_Pod.nbTriggerPairs has unexpected offset % instead of 704", ((cast(*void)(*instance.nbTriggerPairs)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSimulationStatistics_Pod.nbTriggerPairs)) == 196, "physx_PxSimulationStatistics_Pod.nbTriggerPairs has unexpected size % instead of 196", size_of(type_of(physx_PxSimulationStatistics_Pod.nbTriggerPairs)));
    assert(size_of(physx_PxSimulationStatistics_Pod) == 900, "physx_PxSimulationStatistics_Pod has size % instead of 900", size_of(physx_PxSimulationStatistics_Pod));
}

physx_PxPvdSceneClient_Pod :: struct {
    vtable_: *void;
}
#run {
    instance: physx_PxPvdSceneClient_Pod;
    assert(((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)) == 0, "physx_PxPvdSceneClient_Pod.vtable_ has unexpected offset % instead of 0", ((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxPvdSceneClient_Pod.vtable_)) == 8, "physx_PxPvdSceneClient_Pod.vtable_ has unexpected size % instead of 8", size_of(type_of(physx_PxPvdSceneClient_Pod.vtable_)));
    assert(size_of(physx_PxPvdSceneClient_Pod) == 8, "physx_PxPvdSceneClient_Pod has size % instead of 8", size_of(physx_PxPvdSceneClient_Pod));
}

physx_PxPvdSceneFlags_Pod :: struct {
    mBits: u8;
}
#run {
    instance: physx_PxPvdSceneFlags_Pod;
    assert(((cast(*void)(*instance.mBits)) - cast(*void)(*instance)) == 0, "physx_PxPvdSceneFlags_Pod.mBits has unexpected offset % instead of 0", ((cast(*void)(*instance.mBits)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxPvdSceneFlags_Pod.mBits)) == 1, "physx_PxPvdSceneFlags_Pod.mBits has unexpected size % instead of 1", size_of(type_of(physx_PxPvdSceneFlags_Pod.mBits)));
    assert(size_of(physx_PxPvdSceneFlags_Pod) == 1, "physx_PxPvdSceneFlags_Pod has size % instead of 1", size_of(physx_PxPvdSceneFlags_Pod));
}

physx_pvdsdk_PvdDebugPoint_Pod :: struct {}
physx_pvdsdk_PvdDebugLine_Pod :: struct {}
physx_pvdsdk_PvdDebugTriangle_Pod :: struct {}
physx_pvdsdk_PvdDebugText_Pod :: struct {}
physx_pvdsdk_PvdClient_Pod :: struct {}
physx_PxDominanceGroupPair_Pod :: struct {
    dominance0: u8;
    dominance1: u8;
}
#run {
    instance: physx_PxDominanceGroupPair_Pod;
    assert(((cast(*void)(*instance.dominance0)) - cast(*void)(*instance)) == 0, "physx_PxDominanceGroupPair_Pod.dominance0 has unexpected offset % instead of 0", ((cast(*void)(*instance.dominance0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxDominanceGroupPair_Pod.dominance0)) == 1, "physx_PxDominanceGroupPair_Pod.dominance0 has unexpected size % instead of 1", size_of(type_of(physx_PxDominanceGroupPair_Pod.dominance0)));
    assert(((cast(*void)(*instance.dominance1)) - cast(*void)(*instance)) == 1, "physx_PxDominanceGroupPair_Pod.dominance1 has unexpected offset % instead of 1", ((cast(*void)(*instance.dominance1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxDominanceGroupPair_Pod.dominance1)) == 1, "physx_PxDominanceGroupPair_Pod.dominance1 has unexpected size % instead of 1", size_of(type_of(physx_PxDominanceGroupPair_Pod.dominance1)));
    assert(size_of(physx_PxDominanceGroupPair_Pod) == 2, "physx_PxDominanceGroupPair_Pod has size % instead of 2", size_of(physx_PxDominanceGroupPair_Pod));
}

physx_PxActorTypeFlags_Pod :: struct {
    mBits: u16;
}
#run {
    instance: physx_PxActorTypeFlags_Pod;
    assert(((cast(*void)(*instance.mBits)) - cast(*void)(*instance)) == 0, "physx_PxActorTypeFlags_Pod.mBits has unexpected offset % instead of 0", ((cast(*void)(*instance.mBits)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxActorTypeFlags_Pod.mBits)) == 2, "physx_PxActorTypeFlags_Pod.mBits has unexpected size % instead of 2", size_of(type_of(physx_PxActorTypeFlags_Pod.mBits)));
    assert(size_of(physx_PxActorTypeFlags_Pod) == 2, "physx_PxActorTypeFlags_Pod has size % instead of 2", size_of(physx_PxActorTypeFlags_Pod));
}

physx_PxContactPairHeaderFlags_Pod :: struct {
    mBits: u16;
}
#run {
    instance: physx_PxContactPairHeaderFlags_Pod;
    assert(((cast(*void)(*instance.mBits)) - cast(*void)(*instance)) == 0, "physx_PxContactPairHeaderFlags_Pod.mBits has unexpected offset % instead of 0", ((cast(*void)(*instance.mBits)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactPairHeaderFlags_Pod.mBits)) == 2, "physx_PxContactPairHeaderFlags_Pod.mBits has unexpected size % instead of 2", size_of(type_of(physx_PxContactPairHeaderFlags_Pod.mBits)));
    assert(size_of(physx_PxContactPairHeaderFlags_Pod) == 2, "physx_PxContactPairHeaderFlags_Pod has size % instead of 2", size_of(physx_PxContactPairHeaderFlags_Pod));
}

physx_PxContactPairFlags_Pod :: struct {
    mBits: u16;
}
#run {
    instance: physx_PxContactPairFlags_Pod;
    assert(((cast(*void)(*instance.mBits)) - cast(*void)(*instance)) == 0, "physx_PxContactPairFlags_Pod.mBits has unexpected offset % instead of 0", ((cast(*void)(*instance.mBits)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactPairFlags_Pod.mBits)) == 2, "physx_PxContactPairFlags_Pod.mBits has unexpected size % instead of 2", size_of(type_of(physx_PxContactPairFlags_Pod.mBits)));
    assert(size_of(physx_PxContactPairFlags_Pod) == 2, "physx_PxContactPairFlags_Pod has size % instead of 2", size_of(physx_PxContactPairFlags_Pod));
}

physx_PxContactPair_Pod :: struct {
    shapes:             [2] *physx_PxShape_Pod;
    contactPatches:     *u8;
    contactPoints:      *u8;
    contactImpulses:    *float;
    requiredBufferSize: u32;
    contactCount:       u8;
    patchCount:         u8;
    contactStreamSize:  u16;
    flags:              physx_PxContactPairFlags_Pod;
    events:             physx_PxPairFlags_Pod;
    internalData:       [2] u32;
    structgen_pad0:     [4] u8;
}
#run {
    instance: physx_PxContactPair_Pod;
    assert(((cast(*void)(*instance.shapes)) - cast(*void)(*instance)) == 0, "physx_PxContactPair_Pod.shapes has unexpected offset % instead of 0", ((cast(*void)(*instance.shapes)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactPair_Pod.shapes)) == 16, "physx_PxContactPair_Pod.shapes has unexpected size % instead of 16", size_of(type_of(physx_PxContactPair_Pod.shapes)));
    assert(((cast(*void)(*instance.contactPatches)) - cast(*void)(*instance)) == 16, "physx_PxContactPair_Pod.contactPatches has unexpected offset % instead of 16", ((cast(*void)(*instance.contactPatches)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactPair_Pod.contactPatches)) == 8, "physx_PxContactPair_Pod.contactPatches has unexpected size % instead of 8", size_of(type_of(physx_PxContactPair_Pod.contactPatches)));
    assert(((cast(*void)(*instance.contactPoints)) - cast(*void)(*instance)) == 24, "physx_PxContactPair_Pod.contactPoints has unexpected offset % instead of 24", ((cast(*void)(*instance.contactPoints)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactPair_Pod.contactPoints)) == 8, "physx_PxContactPair_Pod.contactPoints has unexpected size % instead of 8", size_of(type_of(physx_PxContactPair_Pod.contactPoints)));
    assert(((cast(*void)(*instance.contactImpulses)) - cast(*void)(*instance)) == 32, "physx_PxContactPair_Pod.contactImpulses has unexpected offset % instead of 32", ((cast(*void)(*instance.contactImpulses)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactPair_Pod.contactImpulses)) == 8, "physx_PxContactPair_Pod.contactImpulses has unexpected size % instead of 8", size_of(type_of(physx_PxContactPair_Pod.contactImpulses)));
    assert(((cast(*void)(*instance.requiredBufferSize)) - cast(*void)(*instance)) == 40, "physx_PxContactPair_Pod.requiredBufferSize has unexpected offset % instead of 40", ((cast(*void)(*instance.requiredBufferSize)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactPair_Pod.requiredBufferSize)) == 4, "physx_PxContactPair_Pod.requiredBufferSize has unexpected size % instead of 4", size_of(type_of(physx_PxContactPair_Pod.requiredBufferSize)));
    assert(((cast(*void)(*instance.contactCount)) - cast(*void)(*instance)) == 44, "physx_PxContactPair_Pod.contactCount has unexpected offset % instead of 44", ((cast(*void)(*instance.contactCount)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactPair_Pod.contactCount)) == 1, "physx_PxContactPair_Pod.contactCount has unexpected size % instead of 1", size_of(type_of(physx_PxContactPair_Pod.contactCount)));
    assert(((cast(*void)(*instance.patchCount)) - cast(*void)(*instance)) == 45, "physx_PxContactPair_Pod.patchCount has unexpected offset % instead of 45", ((cast(*void)(*instance.patchCount)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactPair_Pod.patchCount)) == 1, "physx_PxContactPair_Pod.patchCount has unexpected size % instead of 1", size_of(type_of(physx_PxContactPair_Pod.patchCount)));
    assert(((cast(*void)(*instance.contactStreamSize)) - cast(*void)(*instance)) == 46, "physx_PxContactPair_Pod.contactStreamSize has unexpected offset % instead of 46", ((cast(*void)(*instance.contactStreamSize)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactPair_Pod.contactStreamSize)) == 2, "physx_PxContactPair_Pod.contactStreamSize has unexpected size % instead of 2", size_of(type_of(physx_PxContactPair_Pod.contactStreamSize)));
    assert(((cast(*void)(*instance.flags)) - cast(*void)(*instance)) == 48, "physx_PxContactPair_Pod.flags has unexpected offset % instead of 48", ((cast(*void)(*instance.flags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactPair_Pod.flags)) == 2, "physx_PxContactPair_Pod.flags has unexpected size % instead of 2", size_of(type_of(physx_PxContactPair_Pod.flags)));
    assert(((cast(*void)(*instance.events)) - cast(*void)(*instance)) == 50, "physx_PxContactPair_Pod.events has unexpected offset % instead of 50", ((cast(*void)(*instance.events)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactPair_Pod.events)) == 2, "physx_PxContactPair_Pod.events has unexpected size % instead of 2", size_of(type_of(physx_PxContactPair_Pod.events)));
    assert(((cast(*void)(*instance.internalData)) - cast(*void)(*instance)) == 52, "physx_PxContactPair_Pod.internalData has unexpected offset % instead of 52", ((cast(*void)(*instance.internalData)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactPair_Pod.internalData)) == 8, "physx_PxContactPair_Pod.internalData has unexpected size % instead of 8", size_of(type_of(physx_PxContactPair_Pod.internalData)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 60, "physx_PxContactPair_Pod.structgen_pad0 has unexpected offset % instead of 60", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactPair_Pod.structgen_pad0)) == 4, "physx_PxContactPair_Pod.structgen_pad0 has unexpected size % instead of 4", size_of(type_of(physx_PxContactPair_Pod.structgen_pad0)));
    assert(size_of(physx_PxContactPair_Pod) == 64, "physx_PxContactPair_Pod has size % instead of 64", size_of(physx_PxContactPair_Pod));
}

physx_PxContactPairHeader_Pod :: struct {
    actors:              [2] *physx_PxRigidActor_Pod;
    extraDataStream:     *u8;
    extraDataStreamSize: u16;
    flags:               physx_PxContactPairHeaderFlags_Pod;
    structgen_pad0:      [4] u8;
    pairs:               *physx_PxContactPair_Pod;
    nbPairs:             u32;
    structgen_pad1:      [4] u8;
}
#run {
    instance: physx_PxContactPairHeader_Pod;
    assert(((cast(*void)(*instance.actors)) - cast(*void)(*instance)) == 0, "physx_PxContactPairHeader_Pod.actors has unexpected offset % instead of 0", ((cast(*void)(*instance.actors)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactPairHeader_Pod.actors)) == 16, "physx_PxContactPairHeader_Pod.actors has unexpected size % instead of 16", size_of(type_of(physx_PxContactPairHeader_Pod.actors)));
    assert(((cast(*void)(*instance.extraDataStream)) - cast(*void)(*instance)) == 16, "physx_PxContactPairHeader_Pod.extraDataStream has unexpected offset % instead of 16", ((cast(*void)(*instance.extraDataStream)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactPairHeader_Pod.extraDataStream)) == 8, "physx_PxContactPairHeader_Pod.extraDataStream has unexpected size % instead of 8", size_of(type_of(physx_PxContactPairHeader_Pod.extraDataStream)));
    assert(((cast(*void)(*instance.extraDataStreamSize)) - cast(*void)(*instance)) == 24, "physx_PxContactPairHeader_Pod.extraDataStreamSize has unexpected offset % instead of 24", ((cast(*void)(*instance.extraDataStreamSize)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactPairHeader_Pod.extraDataStreamSize)) == 2, "physx_PxContactPairHeader_Pod.extraDataStreamSize has unexpected size % instead of 2", size_of(type_of(physx_PxContactPairHeader_Pod.extraDataStreamSize)));
    assert(((cast(*void)(*instance.flags)) - cast(*void)(*instance)) == 26, "physx_PxContactPairHeader_Pod.flags has unexpected offset % instead of 26", ((cast(*void)(*instance.flags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactPairHeader_Pod.flags)) == 2, "physx_PxContactPairHeader_Pod.flags has unexpected size % instead of 2", size_of(type_of(physx_PxContactPairHeader_Pod.flags)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 28, "physx_PxContactPairHeader_Pod.structgen_pad0 has unexpected offset % instead of 28", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactPairHeader_Pod.structgen_pad0)) == 4, "physx_PxContactPairHeader_Pod.structgen_pad0 has unexpected size % instead of 4", size_of(type_of(physx_PxContactPairHeader_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.pairs)) - cast(*void)(*instance)) == 32, "physx_PxContactPairHeader_Pod.pairs has unexpected offset % instead of 32", ((cast(*void)(*instance.pairs)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactPairHeader_Pod.pairs)) == 8, "physx_PxContactPairHeader_Pod.pairs has unexpected size % instead of 8", size_of(type_of(physx_PxContactPairHeader_Pod.pairs)));
    assert(((cast(*void)(*instance.nbPairs)) - cast(*void)(*instance)) == 40, "physx_PxContactPairHeader_Pod.nbPairs has unexpected offset % instead of 40", ((cast(*void)(*instance.nbPairs)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactPairHeader_Pod.nbPairs)) == 4, "physx_PxContactPairHeader_Pod.nbPairs has unexpected size % instead of 4", size_of(type_of(physx_PxContactPairHeader_Pod.nbPairs)));
    assert(((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)) == 44, "physx_PxContactPairHeader_Pod.structgen_pad1 has unexpected offset % instead of 44", ((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactPairHeader_Pod.structgen_pad1)) == 4, "physx_PxContactPairHeader_Pod.structgen_pad1 has unexpected size % instead of 4", size_of(type_of(physx_PxContactPairHeader_Pod.structgen_pad1)));
    assert(size_of(physx_PxContactPairHeader_Pod) == 48, "physx_PxContactPairHeader_Pod has size % instead of 48", size_of(physx_PxContactPairHeader_Pod));
}

physx_PxRaycastCallback_Pod :: struct {
    vtable_:      *void;
    block:        physx_PxRaycastHit_Pod;
    hasBlock:     bool;
    touches:      *physx_PxRaycastHit_Pod;
    maxNbTouches: u32;
    nbTouches:    u32;
}
#run {
    instance: physx_PxRaycastCallback_Pod;
    assert(((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)) == 0, "physx_PxRaycastCallback_Pod.vtable_ has unexpected offset % instead of 0", ((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxRaycastCallback_Pod.vtable_)) == 8, "physx_PxRaycastCallback_Pod.vtable_ has unexpected size % instead of 8", size_of(type_of(physx_PxRaycastCallback_Pod.vtable_)));
    assert(((cast(*void)(*instance.block)) - cast(*void)(*instance)) == 8, "physx_PxRaycastCallback_Pod.block has unexpected offset % instead of 8", ((cast(*void)(*instance.block)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxRaycastCallback_Pod.block)) == 64, "physx_PxRaycastCallback_Pod.block has unexpected size % instead of 64", size_of(type_of(physx_PxRaycastCallback_Pod.block)));
    assert(((cast(*void)(*instance.hasBlock)) - cast(*void)(*instance)) == 72, "physx_PxRaycastCallback_Pod.hasBlock has unexpected offset % instead of 72", ((cast(*void)(*instance.hasBlock)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxRaycastCallback_Pod.hasBlock)) == 1, "physx_PxRaycastCallback_Pod.hasBlock has unexpected size % instead of 1", size_of(type_of(physx_PxRaycastCallback_Pod.hasBlock)));
    assert(((cast(*void)(*instance.touches)) - cast(*void)(*instance)) == 80, "physx_PxRaycastCallback_Pod.touches has unexpected offset % instead of 80", ((cast(*void)(*instance.touches)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxRaycastCallback_Pod.touches)) == 8, "physx_PxRaycastCallback_Pod.touches has unexpected size % instead of 8", size_of(type_of(physx_PxRaycastCallback_Pod.touches)));
    assert(((cast(*void)(*instance.maxNbTouches)) - cast(*void)(*instance)) == 88, "physx_PxRaycastCallback_Pod.maxNbTouches has unexpected offset % instead of 88", ((cast(*void)(*instance.maxNbTouches)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxRaycastCallback_Pod.maxNbTouches)) == 4, "physx_PxRaycastCallback_Pod.maxNbTouches has unexpected size % instead of 4", size_of(type_of(physx_PxRaycastCallback_Pod.maxNbTouches)));
    assert(((cast(*void)(*instance.nbTouches)) - cast(*void)(*instance)) == 92, "physx_PxRaycastCallback_Pod.nbTouches has unexpected offset % instead of 92", ((cast(*void)(*instance.nbTouches)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxRaycastCallback_Pod.nbTouches)) == 4, "physx_PxRaycastCallback_Pod.nbTouches has unexpected size % instead of 4", size_of(type_of(physx_PxRaycastCallback_Pod.nbTouches)));
    assert(size_of(physx_PxRaycastCallback_Pod) == 96, "physx_PxRaycastCallback_Pod has size % instead of 96", size_of(physx_PxRaycastCallback_Pod));
}

physx_PxSweepCallback_Pod :: struct {
    vtable_:      *void;
    block:        physx_PxSweepHit_Pod;
    hasBlock:     bool;
    touches:      *physx_PxSweepHit_Pod;
    maxNbTouches: u32;
    nbTouches:    u32;
}
#run {
    instance: physx_PxSweepCallback_Pod;
    assert(((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)) == 0, "physx_PxSweepCallback_Pod.vtable_ has unexpected offset % instead of 0", ((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSweepCallback_Pod.vtable_)) == 8, "physx_PxSweepCallback_Pod.vtable_ has unexpected size % instead of 8", size_of(type_of(physx_PxSweepCallback_Pod.vtable_)));
    assert(((cast(*void)(*instance.block)) - cast(*void)(*instance)) == 8, "physx_PxSweepCallback_Pod.block has unexpected offset % instead of 8", ((cast(*void)(*instance.block)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSweepCallback_Pod.block)) == 64, "physx_PxSweepCallback_Pod.block has unexpected size % instead of 64", size_of(type_of(physx_PxSweepCallback_Pod.block)));
    assert(((cast(*void)(*instance.hasBlock)) - cast(*void)(*instance)) == 72, "physx_PxSweepCallback_Pod.hasBlock has unexpected offset % instead of 72", ((cast(*void)(*instance.hasBlock)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSweepCallback_Pod.hasBlock)) == 1, "physx_PxSweepCallback_Pod.hasBlock has unexpected size % instead of 1", size_of(type_of(physx_PxSweepCallback_Pod.hasBlock)));
    assert(((cast(*void)(*instance.touches)) - cast(*void)(*instance)) == 80, "physx_PxSweepCallback_Pod.touches has unexpected offset % instead of 80", ((cast(*void)(*instance.touches)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSweepCallback_Pod.touches)) == 8, "physx_PxSweepCallback_Pod.touches has unexpected size % instead of 8", size_of(type_of(physx_PxSweepCallback_Pod.touches)));
    assert(((cast(*void)(*instance.maxNbTouches)) - cast(*void)(*instance)) == 88, "physx_PxSweepCallback_Pod.maxNbTouches has unexpected offset % instead of 88", ((cast(*void)(*instance.maxNbTouches)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSweepCallback_Pod.maxNbTouches)) == 4, "physx_PxSweepCallback_Pod.maxNbTouches has unexpected size % instead of 4", size_of(type_of(physx_PxSweepCallback_Pod.maxNbTouches)));
    assert(((cast(*void)(*instance.nbTouches)) - cast(*void)(*instance)) == 92, "physx_PxSweepCallback_Pod.nbTouches has unexpected offset % instead of 92", ((cast(*void)(*instance.nbTouches)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSweepCallback_Pod.nbTouches)) == 4, "physx_PxSweepCallback_Pod.nbTouches has unexpected size % instead of 4", size_of(type_of(physx_PxSweepCallback_Pod.nbTouches)));
    assert(size_of(physx_PxSweepCallback_Pod) == 96, "physx_PxSweepCallback_Pod has size % instead of 96", size_of(physx_PxSweepCallback_Pod));
}

physx_PxOverlapCallback_Pod :: struct {
    vtable_:      *void;
    block:        physx_PxOverlapHit_Pod;
    hasBlock:     bool;
    touches:      *physx_PxOverlapHit_Pod;
    maxNbTouches: u32;
    nbTouches:    u32;
}
#run {
    instance: physx_PxOverlapCallback_Pod;
    assert(((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)) == 0, "physx_PxOverlapCallback_Pod.vtable_ has unexpected offset % instead of 0", ((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxOverlapCallback_Pod.vtable_)) == 8, "physx_PxOverlapCallback_Pod.vtable_ has unexpected size % instead of 8", size_of(type_of(physx_PxOverlapCallback_Pod.vtable_)));
    assert(((cast(*void)(*instance.block)) - cast(*void)(*instance)) == 8, "physx_PxOverlapCallback_Pod.block has unexpected offset % instead of 8", ((cast(*void)(*instance.block)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxOverlapCallback_Pod.block)) == 32, "physx_PxOverlapCallback_Pod.block has unexpected size % instead of 32", size_of(type_of(physx_PxOverlapCallback_Pod.block)));
    assert(((cast(*void)(*instance.hasBlock)) - cast(*void)(*instance)) == 40, "physx_PxOverlapCallback_Pod.hasBlock has unexpected offset % instead of 40", ((cast(*void)(*instance.hasBlock)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxOverlapCallback_Pod.hasBlock)) == 1, "physx_PxOverlapCallback_Pod.hasBlock has unexpected size % instead of 1", size_of(type_of(physx_PxOverlapCallback_Pod.hasBlock)));
    assert(((cast(*void)(*instance.touches)) - cast(*void)(*instance)) == 48, "physx_PxOverlapCallback_Pod.touches has unexpected offset % instead of 48", ((cast(*void)(*instance.touches)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxOverlapCallback_Pod.touches)) == 8, "physx_PxOverlapCallback_Pod.touches has unexpected size % instead of 8", size_of(type_of(physx_PxOverlapCallback_Pod.touches)));
    assert(((cast(*void)(*instance.maxNbTouches)) - cast(*void)(*instance)) == 56, "physx_PxOverlapCallback_Pod.maxNbTouches has unexpected offset % instead of 56", ((cast(*void)(*instance.maxNbTouches)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxOverlapCallback_Pod.maxNbTouches)) == 4, "physx_PxOverlapCallback_Pod.maxNbTouches has unexpected size % instead of 4", size_of(type_of(physx_PxOverlapCallback_Pod.maxNbTouches)));
    assert(((cast(*void)(*instance.nbTouches)) - cast(*void)(*instance)) == 60, "physx_PxOverlapCallback_Pod.nbTouches has unexpected offset % instead of 60", ((cast(*void)(*instance.nbTouches)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxOverlapCallback_Pod.nbTouches)) == 4, "physx_PxOverlapCallback_Pod.nbTouches has unexpected size % instead of 4", size_of(type_of(physx_PxOverlapCallback_Pod.nbTouches)));
    assert(size_of(physx_PxOverlapCallback_Pod) == 64, "physx_PxOverlapCallback_Pod has size % instead of 64", size_of(physx_PxOverlapCallback_Pod));
}

physx_PxBroadPhaseCaps_Pod :: struct {
    maxNbRegions:          u32;
    maxNbObjects:          u32;
    needsPredefinedBounds: bool;
    structgen_pad0:        [3] u8;
}
#run {
    instance: physx_PxBroadPhaseCaps_Pod;
    assert(((cast(*void)(*instance.maxNbRegions)) - cast(*void)(*instance)) == 0, "physx_PxBroadPhaseCaps_Pod.maxNbRegions has unexpected offset % instead of 0", ((cast(*void)(*instance.maxNbRegions)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBroadPhaseCaps_Pod.maxNbRegions)) == 4, "physx_PxBroadPhaseCaps_Pod.maxNbRegions has unexpected size % instead of 4", size_of(type_of(physx_PxBroadPhaseCaps_Pod.maxNbRegions)));
    assert(((cast(*void)(*instance.maxNbObjects)) - cast(*void)(*instance)) == 4, "physx_PxBroadPhaseCaps_Pod.maxNbObjects has unexpected offset % instead of 4", ((cast(*void)(*instance.maxNbObjects)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBroadPhaseCaps_Pod.maxNbObjects)) == 4, "physx_PxBroadPhaseCaps_Pod.maxNbObjects has unexpected size % instead of 4", size_of(type_of(physx_PxBroadPhaseCaps_Pod.maxNbObjects)));
    assert(((cast(*void)(*instance.needsPredefinedBounds)) - cast(*void)(*instance)) == 8, "physx_PxBroadPhaseCaps_Pod.needsPredefinedBounds has unexpected offset % instead of 8", ((cast(*void)(*instance.needsPredefinedBounds)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBroadPhaseCaps_Pod.needsPredefinedBounds)) == 1, "physx_PxBroadPhaseCaps_Pod.needsPredefinedBounds has unexpected size % instead of 1", size_of(type_of(physx_PxBroadPhaseCaps_Pod.needsPredefinedBounds)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 9, "physx_PxBroadPhaseCaps_Pod.structgen_pad0 has unexpected offset % instead of 9", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBroadPhaseCaps_Pod.structgen_pad0)) == 3, "physx_PxBroadPhaseCaps_Pod.structgen_pad0 has unexpected size % instead of 3", size_of(type_of(physx_PxBroadPhaseCaps_Pod.structgen_pad0)));
    assert(size_of(physx_PxBroadPhaseCaps_Pod) == 12, "physx_PxBroadPhaseCaps_Pod has size % instead of 12", size_of(physx_PxBroadPhaseCaps_Pod));
}

physx_PxBroadPhaseRegion_Pod :: struct {
    bounds:   physx_PxBounds3_Pod;
    userData: *void;
}
#run {
    instance: physx_PxBroadPhaseRegion_Pod;
    assert(((cast(*void)(*instance.bounds)) - cast(*void)(*instance)) == 0, "physx_PxBroadPhaseRegion_Pod.bounds has unexpected offset % instead of 0", ((cast(*void)(*instance.bounds)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBroadPhaseRegion_Pod.bounds)) == 24, "physx_PxBroadPhaseRegion_Pod.bounds has unexpected size % instead of 24", size_of(type_of(physx_PxBroadPhaseRegion_Pod.bounds)));
    assert(((cast(*void)(*instance.userData)) - cast(*void)(*instance)) == 24, "physx_PxBroadPhaseRegion_Pod.userData has unexpected offset % instead of 24", ((cast(*void)(*instance.userData)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBroadPhaseRegion_Pod.userData)) == 8, "physx_PxBroadPhaseRegion_Pod.userData has unexpected size % instead of 8", size_of(type_of(physx_PxBroadPhaseRegion_Pod.userData)));
    assert(size_of(physx_PxBroadPhaseRegion_Pod) == 32, "physx_PxBroadPhaseRegion_Pod has size % instead of 32", size_of(physx_PxBroadPhaseRegion_Pod));
}

physx_PxBroadPhaseRegionInfo_Pod :: struct {
    region:           physx_PxBroadPhaseRegion_Pod;
    nbStaticObjects:  u32;
    nbDynamicObjects: u32;
    active:           bool;
    overlap:          bool;
    structgen_pad0:   [6] u8;
}
#run {
    instance: physx_PxBroadPhaseRegionInfo_Pod;
    assert(((cast(*void)(*instance.region)) - cast(*void)(*instance)) == 0, "physx_PxBroadPhaseRegionInfo_Pod.region has unexpected offset % instead of 0", ((cast(*void)(*instance.region)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBroadPhaseRegionInfo_Pod.region)) == 32, "physx_PxBroadPhaseRegionInfo_Pod.region has unexpected size % instead of 32", size_of(type_of(physx_PxBroadPhaseRegionInfo_Pod.region)));
    assert(((cast(*void)(*instance.nbStaticObjects)) - cast(*void)(*instance)) == 32, "physx_PxBroadPhaseRegionInfo_Pod.nbStaticObjects has unexpected offset % instead of 32", ((cast(*void)(*instance.nbStaticObjects)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBroadPhaseRegionInfo_Pod.nbStaticObjects)) == 4, "physx_PxBroadPhaseRegionInfo_Pod.nbStaticObjects has unexpected size % instead of 4", size_of(type_of(physx_PxBroadPhaseRegionInfo_Pod.nbStaticObjects)));
    assert(((cast(*void)(*instance.nbDynamicObjects)) - cast(*void)(*instance)) == 36, "physx_PxBroadPhaseRegionInfo_Pod.nbDynamicObjects has unexpected offset % instead of 36", ((cast(*void)(*instance.nbDynamicObjects)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBroadPhaseRegionInfo_Pod.nbDynamicObjects)) == 4, "physx_PxBroadPhaseRegionInfo_Pod.nbDynamicObjects has unexpected size % instead of 4", size_of(type_of(physx_PxBroadPhaseRegionInfo_Pod.nbDynamicObjects)));
    assert(((cast(*void)(*instance.active)) - cast(*void)(*instance)) == 40, "physx_PxBroadPhaseRegionInfo_Pod.active has unexpected offset % instead of 40", ((cast(*void)(*instance.active)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBroadPhaseRegionInfo_Pod.active)) == 1, "physx_PxBroadPhaseRegionInfo_Pod.active has unexpected size % instead of 1", size_of(type_of(physx_PxBroadPhaseRegionInfo_Pod.active)));
    assert(((cast(*void)(*instance.overlap)) - cast(*void)(*instance)) == 41, "physx_PxBroadPhaseRegionInfo_Pod.overlap has unexpected offset % instead of 41", ((cast(*void)(*instance.overlap)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBroadPhaseRegionInfo_Pod.overlap)) == 1, "physx_PxBroadPhaseRegionInfo_Pod.overlap has unexpected size % instead of 1", size_of(type_of(physx_PxBroadPhaseRegionInfo_Pod.overlap)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 42, "physx_PxBroadPhaseRegionInfo_Pod.structgen_pad0 has unexpected offset % instead of 42", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBroadPhaseRegionInfo_Pod.structgen_pad0)) == 6, "physx_PxBroadPhaseRegionInfo_Pod.structgen_pad0 has unexpected size % instead of 6", size_of(type_of(physx_PxBroadPhaseRegionInfo_Pod.structgen_pad0)));
    assert(size_of(physx_PxBroadPhaseRegionInfo_Pod) == 48, "physx_PxBroadPhaseRegionInfo_Pod has size % instead of 48", size_of(physx_PxBroadPhaseRegionInfo_Pod));
}

physx_PxSceneReadLock_Pod :: struct {
    structgen_pad0: [8] u8;
}
#run {
    instance: physx_PxSceneReadLock_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxSceneReadLock_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneReadLock_Pod.structgen_pad0)) == 8, "physx_PxSceneReadLock_Pod.structgen_pad0 has unexpected size % instead of 8", size_of(type_of(physx_PxSceneReadLock_Pod.structgen_pad0)));
    assert(size_of(physx_PxSceneReadLock_Pod) == 8, "physx_PxSceneReadLock_Pod has size % instead of 8", size_of(physx_PxSceneReadLock_Pod));
}

physx_PxSceneWriteLock_Pod :: struct {
    structgen_pad0: [8] u8;
}
#run {
    instance: physx_PxSceneWriteLock_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxSceneWriteLock_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneWriteLock_Pod.structgen_pad0)) == 8, "physx_PxSceneWriteLock_Pod.structgen_pad0 has unexpected size % instead of 8", size_of(type_of(physx_PxSceneWriteLock_Pod.structgen_pad0)));
    assert(size_of(physx_PxSceneWriteLock_Pod) == 8, "physx_PxSceneWriteLock_Pod has size % instead of 8", size_of(physx_PxSceneWriteLock_Pod));
}

physx_PxContactPairExtraDataItem_Pod :: struct {
    type: u8;
}
#run {
    instance: physx_PxContactPairExtraDataItem_Pod;
    assert(((cast(*void)(*instance.type)) - cast(*void)(*instance)) == 0, "physx_PxContactPairExtraDataItem_Pod.type has unexpected offset % instead of 0", ((cast(*void)(*instance.type)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactPairExtraDataItem_Pod.type)) == 1, "physx_PxContactPairExtraDataItem_Pod.type has unexpected size % instead of 1", size_of(type_of(physx_PxContactPairExtraDataItem_Pod.type)));
    assert(size_of(physx_PxContactPairExtraDataItem_Pod) == 1, "physx_PxContactPairExtraDataItem_Pod has size % instead of 1", size_of(physx_PxContactPairExtraDataItem_Pod));
}

physx_PxContactPairVelocity_Pod :: struct {
    type:            u8;
    structgen_pad0:  [3] u8;
    linearVelocity:  [2] physx_PxVec3_Pod;
    angularVelocity: [2] physx_PxVec3_Pod;
}
#run {
    instance: physx_PxContactPairVelocity_Pod;
    assert(((cast(*void)(*instance.type)) - cast(*void)(*instance)) == 0, "physx_PxContactPairVelocity_Pod.type has unexpected offset % instead of 0", ((cast(*void)(*instance.type)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactPairVelocity_Pod.type)) == 1, "physx_PxContactPairVelocity_Pod.type has unexpected size % instead of 1", size_of(type_of(physx_PxContactPairVelocity_Pod.type)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 1, "physx_PxContactPairVelocity_Pod.structgen_pad0 has unexpected offset % instead of 1", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactPairVelocity_Pod.structgen_pad0)) == 3, "physx_PxContactPairVelocity_Pod.structgen_pad0 has unexpected size % instead of 3", size_of(type_of(physx_PxContactPairVelocity_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.linearVelocity)) - cast(*void)(*instance)) == 4, "physx_PxContactPairVelocity_Pod.linearVelocity has unexpected offset % instead of 4", ((cast(*void)(*instance.linearVelocity)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactPairVelocity_Pod.linearVelocity)) == 24, "physx_PxContactPairVelocity_Pod.linearVelocity has unexpected size % instead of 24", size_of(type_of(physx_PxContactPairVelocity_Pod.linearVelocity)));
    assert(((cast(*void)(*instance.angularVelocity)) - cast(*void)(*instance)) == 28, "physx_PxContactPairVelocity_Pod.angularVelocity has unexpected offset % instead of 28", ((cast(*void)(*instance.angularVelocity)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactPairVelocity_Pod.angularVelocity)) == 24, "physx_PxContactPairVelocity_Pod.angularVelocity has unexpected size % instead of 24", size_of(type_of(physx_PxContactPairVelocity_Pod.angularVelocity)));
    assert(size_of(physx_PxContactPairVelocity_Pod) == 52, "physx_PxContactPairVelocity_Pod has size % instead of 52", size_of(physx_PxContactPairVelocity_Pod));
}

physx_PxContactPairPose_Pod :: struct {
    type:           u8;
    structgen_pad0: [3] u8;
    globalPose:     [2] physx_PxTransform_Pod;
}
#run {
    instance: physx_PxContactPairPose_Pod;
    assert(((cast(*void)(*instance.type)) - cast(*void)(*instance)) == 0, "physx_PxContactPairPose_Pod.type has unexpected offset % instead of 0", ((cast(*void)(*instance.type)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactPairPose_Pod.type)) == 1, "physx_PxContactPairPose_Pod.type has unexpected size % instead of 1", size_of(type_of(physx_PxContactPairPose_Pod.type)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 1, "physx_PxContactPairPose_Pod.structgen_pad0 has unexpected offset % instead of 1", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactPairPose_Pod.structgen_pad0)) == 3, "physx_PxContactPairPose_Pod.structgen_pad0 has unexpected size % instead of 3", size_of(type_of(physx_PxContactPairPose_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.globalPose)) - cast(*void)(*instance)) == 4, "physx_PxContactPairPose_Pod.globalPose has unexpected offset % instead of 4", ((cast(*void)(*instance.globalPose)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactPairPose_Pod.globalPose)) == 56, "physx_PxContactPairPose_Pod.globalPose has unexpected size % instead of 56", size_of(type_of(physx_PxContactPairPose_Pod.globalPose)));
    assert(size_of(physx_PxContactPairPose_Pod) == 60, "physx_PxContactPairPose_Pod has size % instead of 60", size_of(physx_PxContactPairPose_Pod));
}

physx_PxContactPairIndex_Pod :: struct {
    type:           u8;
    structgen_pad0: [1] u8;
    index:          u16;
}
#run {
    instance: physx_PxContactPairIndex_Pod;
    assert(((cast(*void)(*instance.type)) - cast(*void)(*instance)) == 0, "physx_PxContactPairIndex_Pod.type has unexpected offset % instead of 0", ((cast(*void)(*instance.type)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactPairIndex_Pod.type)) == 1, "physx_PxContactPairIndex_Pod.type has unexpected size % instead of 1", size_of(type_of(physx_PxContactPairIndex_Pod.type)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 1, "physx_PxContactPairIndex_Pod.structgen_pad0 has unexpected offset % instead of 1", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactPairIndex_Pod.structgen_pad0)) == 1, "physx_PxContactPairIndex_Pod.structgen_pad0 has unexpected size % instead of 1", size_of(type_of(physx_PxContactPairIndex_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.index)) - cast(*void)(*instance)) == 2, "physx_PxContactPairIndex_Pod.index has unexpected offset % instead of 2", ((cast(*void)(*instance.index)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactPairIndex_Pod.index)) == 2, "physx_PxContactPairIndex_Pod.index has unexpected size % instead of 2", size_of(type_of(physx_PxContactPairIndex_Pod.index)));
    assert(size_of(physx_PxContactPairIndex_Pod) == 4, "physx_PxContactPairIndex_Pod has size % instead of 4", size_of(physx_PxContactPairIndex_Pod));
}

physx_PxContactPairExtraDataIterator_Pod :: struct {
    currPtr:            *u8;
    endPtr:             *u8;
    preSolverVelocity:  *physx_PxContactPairVelocity_Pod;
    postSolverVelocity: *physx_PxContactPairVelocity_Pod;
    eventPose:          *physx_PxContactPairPose_Pod;
    contactPairIndex:   u32;
    structgen_pad0:     [4] u8;
}
#run {
    instance: physx_PxContactPairExtraDataIterator_Pod;
    assert(((cast(*void)(*instance.currPtr)) - cast(*void)(*instance)) == 0, "physx_PxContactPairExtraDataIterator_Pod.currPtr has unexpected offset % instead of 0", ((cast(*void)(*instance.currPtr)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactPairExtraDataIterator_Pod.currPtr)) == 8, "physx_PxContactPairExtraDataIterator_Pod.currPtr has unexpected size % instead of 8", size_of(type_of(physx_PxContactPairExtraDataIterator_Pod.currPtr)));
    assert(((cast(*void)(*instance.endPtr)) - cast(*void)(*instance)) == 8, "physx_PxContactPairExtraDataIterator_Pod.endPtr has unexpected offset % instead of 8", ((cast(*void)(*instance.endPtr)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactPairExtraDataIterator_Pod.endPtr)) == 8, "physx_PxContactPairExtraDataIterator_Pod.endPtr has unexpected size % instead of 8", size_of(type_of(physx_PxContactPairExtraDataIterator_Pod.endPtr)));
    assert(((cast(*void)(*instance.preSolverVelocity)) - cast(*void)(*instance)) == 16, "physx_PxContactPairExtraDataIterator_Pod.preSolverVelocity has unexpected offset % instead of 16", ((cast(*void)(*instance.preSolverVelocity)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactPairExtraDataIterator_Pod.preSolverVelocity)) == 8, "physx_PxContactPairExtraDataIterator_Pod.preSolverVelocity has unexpected size % instead of 8", size_of(type_of(physx_PxContactPairExtraDataIterator_Pod.preSolverVelocity)));
    assert(((cast(*void)(*instance.postSolverVelocity)) - cast(*void)(*instance)) == 24, "physx_PxContactPairExtraDataIterator_Pod.postSolverVelocity has unexpected offset % instead of 24", ((cast(*void)(*instance.postSolverVelocity)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactPairExtraDataIterator_Pod.postSolverVelocity)) == 8, "physx_PxContactPairExtraDataIterator_Pod.postSolverVelocity has unexpected size % instead of 8", size_of(type_of(physx_PxContactPairExtraDataIterator_Pod.postSolverVelocity)));
    assert(((cast(*void)(*instance.eventPose)) - cast(*void)(*instance)) == 32, "physx_PxContactPairExtraDataIterator_Pod.eventPose has unexpected offset % instead of 32", ((cast(*void)(*instance.eventPose)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactPairExtraDataIterator_Pod.eventPose)) == 8, "physx_PxContactPairExtraDataIterator_Pod.eventPose has unexpected size % instead of 8", size_of(type_of(physx_PxContactPairExtraDataIterator_Pod.eventPose)));
    assert(((cast(*void)(*instance.contactPairIndex)) - cast(*void)(*instance)) == 40, "physx_PxContactPairExtraDataIterator_Pod.contactPairIndex has unexpected offset % instead of 40", ((cast(*void)(*instance.contactPairIndex)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactPairExtraDataIterator_Pod.contactPairIndex)) == 4, "physx_PxContactPairExtraDataIterator_Pod.contactPairIndex has unexpected size % instead of 4", size_of(type_of(physx_PxContactPairExtraDataIterator_Pod.contactPairIndex)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 44, "physx_PxContactPairExtraDataIterator_Pod.structgen_pad0 has unexpected offset % instead of 44", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactPairExtraDataIterator_Pod.structgen_pad0)) == 4, "physx_PxContactPairExtraDataIterator_Pod.structgen_pad0 has unexpected size % instead of 4", size_of(type_of(physx_PxContactPairExtraDataIterator_Pod.structgen_pad0)));
    assert(size_of(physx_PxContactPairExtraDataIterator_Pod) == 48, "physx_PxContactPairExtraDataIterator_Pod has size % instead of 48", size_of(physx_PxContactPairExtraDataIterator_Pod));
}

physx_PxContactPairPoint_Pod :: struct {
    position:           physx_PxVec3_Pod;
    separation:         float;
    normal:             physx_PxVec3_Pod;
    internalFaceIndex0: u32;
    impulse:            physx_PxVec3_Pod;
    internalFaceIndex1: u32;
}
#run {
    instance: physx_PxContactPairPoint_Pod;
    assert(((cast(*void)(*instance.position)) - cast(*void)(*instance)) == 0, "physx_PxContactPairPoint_Pod.position has unexpected offset % instead of 0", ((cast(*void)(*instance.position)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactPairPoint_Pod.position)) == 12, "physx_PxContactPairPoint_Pod.position has unexpected size % instead of 12", size_of(type_of(physx_PxContactPairPoint_Pod.position)));
    assert(((cast(*void)(*instance.separation)) - cast(*void)(*instance)) == 12, "physx_PxContactPairPoint_Pod.separation has unexpected offset % instead of 12", ((cast(*void)(*instance.separation)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactPairPoint_Pod.separation)) == 4, "physx_PxContactPairPoint_Pod.separation has unexpected size % instead of 4", size_of(type_of(physx_PxContactPairPoint_Pod.separation)));
    assert(((cast(*void)(*instance.normal)) - cast(*void)(*instance)) == 16, "physx_PxContactPairPoint_Pod.normal has unexpected offset % instead of 16", ((cast(*void)(*instance.normal)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactPairPoint_Pod.normal)) == 12, "physx_PxContactPairPoint_Pod.normal has unexpected size % instead of 12", size_of(type_of(physx_PxContactPairPoint_Pod.normal)));
    assert(((cast(*void)(*instance.internalFaceIndex0)) - cast(*void)(*instance)) == 28, "physx_PxContactPairPoint_Pod.internalFaceIndex0 has unexpected offset % instead of 28", ((cast(*void)(*instance.internalFaceIndex0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactPairPoint_Pod.internalFaceIndex0)) == 4, "physx_PxContactPairPoint_Pod.internalFaceIndex0 has unexpected size % instead of 4", size_of(type_of(physx_PxContactPairPoint_Pod.internalFaceIndex0)));
    assert(((cast(*void)(*instance.impulse)) - cast(*void)(*instance)) == 32, "physx_PxContactPairPoint_Pod.impulse has unexpected offset % instead of 32", ((cast(*void)(*instance.impulse)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactPairPoint_Pod.impulse)) == 12, "physx_PxContactPairPoint_Pod.impulse has unexpected size % instead of 12", size_of(type_of(physx_PxContactPairPoint_Pod.impulse)));
    assert(((cast(*void)(*instance.internalFaceIndex1)) - cast(*void)(*instance)) == 44, "physx_PxContactPairPoint_Pod.internalFaceIndex1 has unexpected offset % instead of 44", ((cast(*void)(*instance.internalFaceIndex1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactPairPoint_Pod.internalFaceIndex1)) == 4, "physx_PxContactPairPoint_Pod.internalFaceIndex1 has unexpected size % instead of 4", size_of(type_of(physx_PxContactPairPoint_Pod.internalFaceIndex1)));
    assert(size_of(physx_PxContactPairPoint_Pod) == 48, "physx_PxContactPairPoint_Pod has size % instead of 48", size_of(physx_PxContactPairPoint_Pod));
}

physx_PxTriggerPairFlags_Pod :: struct {
    mBits: u8;
}
#run {
    instance: physx_PxTriggerPairFlags_Pod;
    assert(((cast(*void)(*instance.mBits)) - cast(*void)(*instance)) == 0, "physx_PxTriggerPairFlags_Pod.mBits has unexpected offset % instead of 0", ((cast(*void)(*instance.mBits)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxTriggerPairFlags_Pod.mBits)) == 1, "physx_PxTriggerPairFlags_Pod.mBits has unexpected size % instead of 1", size_of(type_of(physx_PxTriggerPairFlags_Pod.mBits)));
    assert(size_of(physx_PxTriggerPairFlags_Pod) == 1, "physx_PxTriggerPairFlags_Pod has size % instead of 1", size_of(physx_PxTriggerPairFlags_Pod));
}

physx_PxTriggerPair_Pod :: struct {
    triggerShape:   *physx_PxShape_Pod;
    triggerActor:   *physx_PxRigidActor_Pod;
    otherShape:     *physx_PxShape_Pod;
    otherActor:     *physx_PxRigidActor_Pod;
    status:         u32;
    flags:          physx_PxTriggerPairFlags_Pod;
    structgen_pad0: [3] u8;
}
#run {
    instance: physx_PxTriggerPair_Pod;
    assert(((cast(*void)(*instance.triggerShape)) - cast(*void)(*instance)) == 0, "physx_PxTriggerPair_Pod.triggerShape has unexpected offset % instead of 0", ((cast(*void)(*instance.triggerShape)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxTriggerPair_Pod.triggerShape)) == 8, "physx_PxTriggerPair_Pod.triggerShape has unexpected size % instead of 8", size_of(type_of(physx_PxTriggerPair_Pod.triggerShape)));
    assert(((cast(*void)(*instance.triggerActor)) - cast(*void)(*instance)) == 8, "physx_PxTriggerPair_Pod.triggerActor has unexpected offset % instead of 8", ((cast(*void)(*instance.triggerActor)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxTriggerPair_Pod.triggerActor)) == 8, "physx_PxTriggerPair_Pod.triggerActor has unexpected size % instead of 8", size_of(type_of(physx_PxTriggerPair_Pod.triggerActor)));
    assert(((cast(*void)(*instance.otherShape)) - cast(*void)(*instance)) == 16, "physx_PxTriggerPair_Pod.otherShape has unexpected offset % instead of 16", ((cast(*void)(*instance.otherShape)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxTriggerPair_Pod.otherShape)) == 8, "physx_PxTriggerPair_Pod.otherShape has unexpected size % instead of 8", size_of(type_of(physx_PxTriggerPair_Pod.otherShape)));
    assert(((cast(*void)(*instance.otherActor)) - cast(*void)(*instance)) == 24, "physx_PxTriggerPair_Pod.otherActor has unexpected offset % instead of 24", ((cast(*void)(*instance.otherActor)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxTriggerPair_Pod.otherActor)) == 8, "physx_PxTriggerPair_Pod.otherActor has unexpected size % instead of 8", size_of(type_of(physx_PxTriggerPair_Pod.otherActor)));
    assert(((cast(*void)(*instance.status)) - cast(*void)(*instance)) == 32, "physx_PxTriggerPair_Pod.status has unexpected offset % instead of 32", ((cast(*void)(*instance.status)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxTriggerPair_Pod.status)) == 4, "physx_PxTriggerPair_Pod.status has unexpected size % instead of 4", size_of(type_of(physx_PxTriggerPair_Pod.status)));
    assert(((cast(*void)(*instance.flags)) - cast(*void)(*instance)) == 36, "physx_PxTriggerPair_Pod.flags has unexpected offset % instead of 36", ((cast(*void)(*instance.flags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxTriggerPair_Pod.flags)) == 1, "physx_PxTriggerPair_Pod.flags has unexpected size % instead of 1", size_of(type_of(physx_PxTriggerPair_Pod.flags)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 37, "physx_PxTriggerPair_Pod.structgen_pad0 has unexpected offset % instead of 37", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxTriggerPair_Pod.structgen_pad0)) == 3, "physx_PxTriggerPair_Pod.structgen_pad0 has unexpected size % instead of 3", size_of(type_of(physx_PxTriggerPair_Pod.structgen_pad0)));
    assert(size_of(physx_PxTriggerPair_Pod) == 40, "physx_PxTriggerPair_Pod has size % instead of 40", size_of(physx_PxTriggerPair_Pod));
}

physx_PxConstraintInfo_Pod :: struct {
    constraint:        *physx_PxConstraint_Pod;
    externalReference: *void;
    type:              u32;
    structgen_pad0:    [4] u8;
}
#run {
    instance: physx_PxConstraintInfo_Pod;
    assert(((cast(*void)(*instance.constraint)) - cast(*void)(*instance)) == 0, "physx_PxConstraintInfo_Pod.constraint has unexpected offset % instead of 0", ((cast(*void)(*instance.constraint)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxConstraintInfo_Pod.constraint)) == 8, "physx_PxConstraintInfo_Pod.constraint has unexpected size % instead of 8", size_of(type_of(physx_PxConstraintInfo_Pod.constraint)));
    assert(((cast(*void)(*instance.externalReference)) - cast(*void)(*instance)) == 8, "physx_PxConstraintInfo_Pod.externalReference has unexpected offset % instead of 8", ((cast(*void)(*instance.externalReference)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxConstraintInfo_Pod.externalReference)) == 8, "physx_PxConstraintInfo_Pod.externalReference has unexpected size % instead of 8", size_of(type_of(physx_PxConstraintInfo_Pod.externalReference)));
    assert(((cast(*void)(*instance.type)) - cast(*void)(*instance)) == 16, "physx_PxConstraintInfo_Pod.type has unexpected offset % instead of 16", ((cast(*void)(*instance.type)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxConstraintInfo_Pod.type)) == 4, "physx_PxConstraintInfo_Pod.type has unexpected size % instead of 4", size_of(type_of(physx_PxConstraintInfo_Pod.type)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 20, "physx_PxConstraintInfo_Pod.structgen_pad0 has unexpected offset % instead of 20", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxConstraintInfo_Pod.structgen_pad0)) == 4, "physx_PxConstraintInfo_Pod.structgen_pad0 has unexpected size % instead of 4", size_of(type_of(physx_PxConstraintInfo_Pod.structgen_pad0)));
    assert(size_of(physx_PxConstraintInfo_Pod) == 24, "physx_PxConstraintInfo_Pod has size % instead of 24", size_of(physx_PxConstraintInfo_Pod));
}

physx_PxExtendedVec3_Pod :: struct {
    x: float64;
    y: float64;
    z: float64;
}
#run {
    instance: physx_PxExtendedVec3_Pod;
    assert(((cast(*void)(*instance.x)) - cast(*void)(*instance)) == 0, "physx_PxExtendedVec3_Pod.x has unexpected offset % instead of 0", ((cast(*void)(*instance.x)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxExtendedVec3_Pod.x)) == 8, "physx_PxExtendedVec3_Pod.x has unexpected size % instead of 8", size_of(type_of(physx_PxExtendedVec3_Pod.x)));
    assert(((cast(*void)(*instance.y)) - cast(*void)(*instance)) == 8, "physx_PxExtendedVec3_Pod.y has unexpected offset % instead of 8", ((cast(*void)(*instance.y)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxExtendedVec3_Pod.y)) == 8, "physx_PxExtendedVec3_Pod.y has unexpected size % instead of 8", size_of(type_of(physx_PxExtendedVec3_Pod.y)));
    assert(((cast(*void)(*instance.z)) - cast(*void)(*instance)) == 16, "physx_PxExtendedVec3_Pod.z has unexpected offset % instead of 16", ((cast(*void)(*instance.z)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxExtendedVec3_Pod.z)) == 8, "physx_PxExtendedVec3_Pod.z has unexpected size % instead of 8", size_of(type_of(physx_PxExtendedVec3_Pod.z)));
    assert(size_of(physx_PxExtendedVec3_Pod) == 24, "physx_PxExtendedVec3_Pod has size % instead of 24", size_of(physx_PxExtendedVec3_Pod));
}

physx_PxObstacle_Pod :: struct {
    mType:          s32;
    structgen_pad0: [4] u8;
    mUserData:      *void;
    mPos:           physx_PxExtendedVec3_Pod;
    mRot:           physx_PxQuat_Pod;
}
#run {
    instance: physx_PxObstacle_Pod;
    assert(((cast(*void)(*instance.mType)) - cast(*void)(*instance)) == 0, "physx_PxObstacle_Pod.mType has unexpected offset % instead of 0", ((cast(*void)(*instance.mType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxObstacle_Pod.mType)) == 4, "physx_PxObstacle_Pod.mType has unexpected size % instead of 4", size_of(type_of(physx_PxObstacle_Pod.mType)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 4, "physx_PxObstacle_Pod.structgen_pad0 has unexpected offset % instead of 4", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxObstacle_Pod.structgen_pad0)) == 4, "physx_PxObstacle_Pod.structgen_pad0 has unexpected size % instead of 4", size_of(type_of(physx_PxObstacle_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.mUserData)) - cast(*void)(*instance)) == 8, "physx_PxObstacle_Pod.mUserData has unexpected offset % instead of 8", ((cast(*void)(*instance.mUserData)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxObstacle_Pod.mUserData)) == 8, "physx_PxObstacle_Pod.mUserData has unexpected size % instead of 8", size_of(type_of(physx_PxObstacle_Pod.mUserData)));
    assert(((cast(*void)(*instance.mPos)) - cast(*void)(*instance)) == 16, "physx_PxObstacle_Pod.mPos has unexpected offset % instead of 16", ((cast(*void)(*instance.mPos)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxObstacle_Pod.mPos)) == 24, "physx_PxObstacle_Pod.mPos has unexpected size % instead of 24", size_of(type_of(physx_PxObstacle_Pod.mPos)));
    assert(((cast(*void)(*instance.mRot)) - cast(*void)(*instance)) == 40, "physx_PxObstacle_Pod.mRot has unexpected offset % instead of 40", ((cast(*void)(*instance.mRot)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxObstacle_Pod.mRot)) == 16, "physx_PxObstacle_Pod.mRot has unexpected size % instead of 16", size_of(type_of(physx_PxObstacle_Pod.mRot)));
    assert(size_of(physx_PxObstacle_Pod) == 56, "physx_PxObstacle_Pod has size % instead of 56", size_of(physx_PxObstacle_Pod));
}

physx_PxBoxObstacle_Pod :: struct {
    mType:          s32;
    structgen_pad0: [4] u8;
    mUserData:      *void;
    mPos:           physx_PxExtendedVec3_Pod;
    mRot:           physx_PxQuat_Pod;
    mHalfExtents:   physx_PxVec3_Pod;
    structgen_pad1: [4] u8;
}
#run {
    instance: physx_PxBoxObstacle_Pod;
    assert(((cast(*void)(*instance.mType)) - cast(*void)(*instance)) == 0, "physx_PxBoxObstacle_Pod.mType has unexpected offset % instead of 0", ((cast(*void)(*instance.mType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBoxObstacle_Pod.mType)) == 4, "physx_PxBoxObstacle_Pod.mType has unexpected size % instead of 4", size_of(type_of(physx_PxBoxObstacle_Pod.mType)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 4, "physx_PxBoxObstacle_Pod.structgen_pad0 has unexpected offset % instead of 4", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBoxObstacle_Pod.structgen_pad0)) == 4, "physx_PxBoxObstacle_Pod.structgen_pad0 has unexpected size % instead of 4", size_of(type_of(physx_PxBoxObstacle_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.mUserData)) - cast(*void)(*instance)) == 8, "physx_PxBoxObstacle_Pod.mUserData has unexpected offset % instead of 8", ((cast(*void)(*instance.mUserData)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBoxObstacle_Pod.mUserData)) == 8, "physx_PxBoxObstacle_Pod.mUserData has unexpected size % instead of 8", size_of(type_of(physx_PxBoxObstacle_Pod.mUserData)));
    assert(((cast(*void)(*instance.mPos)) - cast(*void)(*instance)) == 16, "physx_PxBoxObstacle_Pod.mPos has unexpected offset % instead of 16", ((cast(*void)(*instance.mPos)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBoxObstacle_Pod.mPos)) == 24, "physx_PxBoxObstacle_Pod.mPos has unexpected size % instead of 24", size_of(type_of(physx_PxBoxObstacle_Pod.mPos)));
    assert(((cast(*void)(*instance.mRot)) - cast(*void)(*instance)) == 40, "physx_PxBoxObstacle_Pod.mRot has unexpected offset % instead of 40", ((cast(*void)(*instance.mRot)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBoxObstacle_Pod.mRot)) == 16, "physx_PxBoxObstacle_Pod.mRot has unexpected size % instead of 16", size_of(type_of(physx_PxBoxObstacle_Pod.mRot)));
    assert(((cast(*void)(*instance.mHalfExtents)) - cast(*void)(*instance)) == 56, "physx_PxBoxObstacle_Pod.mHalfExtents has unexpected offset % instead of 56", ((cast(*void)(*instance.mHalfExtents)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBoxObstacle_Pod.mHalfExtents)) == 12, "physx_PxBoxObstacle_Pod.mHalfExtents has unexpected size % instead of 12", size_of(type_of(physx_PxBoxObstacle_Pod.mHalfExtents)));
    assert(((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)) == 68, "physx_PxBoxObstacle_Pod.structgen_pad1 has unexpected offset % instead of 68", ((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBoxObstacle_Pod.structgen_pad1)) == 4, "physx_PxBoxObstacle_Pod.structgen_pad1 has unexpected size % instead of 4", size_of(type_of(physx_PxBoxObstacle_Pod.structgen_pad1)));
    assert(size_of(physx_PxBoxObstacle_Pod) == 72, "physx_PxBoxObstacle_Pod has size % instead of 72", size_of(physx_PxBoxObstacle_Pod));
}

physx_PxCapsuleObstacle_Pod :: struct {
    mType:          s32;
    structgen_pad0: [4] u8;
    mUserData:      *void;
    mPos:           physx_PxExtendedVec3_Pod;
    mRot:           physx_PxQuat_Pod;
    mHalfHeight:    float;
    mRadius:        float;
}
#run {
    instance: physx_PxCapsuleObstacle_Pod;
    assert(((cast(*void)(*instance.mType)) - cast(*void)(*instance)) == 0, "physx_PxCapsuleObstacle_Pod.mType has unexpected offset % instead of 0", ((cast(*void)(*instance.mType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxCapsuleObstacle_Pod.mType)) == 4, "physx_PxCapsuleObstacle_Pod.mType has unexpected size % instead of 4", size_of(type_of(physx_PxCapsuleObstacle_Pod.mType)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 4, "physx_PxCapsuleObstacle_Pod.structgen_pad0 has unexpected offset % instead of 4", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxCapsuleObstacle_Pod.structgen_pad0)) == 4, "physx_PxCapsuleObstacle_Pod.structgen_pad0 has unexpected size % instead of 4", size_of(type_of(physx_PxCapsuleObstacle_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.mUserData)) - cast(*void)(*instance)) == 8, "physx_PxCapsuleObstacle_Pod.mUserData has unexpected offset % instead of 8", ((cast(*void)(*instance.mUserData)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxCapsuleObstacle_Pod.mUserData)) == 8, "physx_PxCapsuleObstacle_Pod.mUserData has unexpected size % instead of 8", size_of(type_of(physx_PxCapsuleObstacle_Pod.mUserData)));
    assert(((cast(*void)(*instance.mPos)) - cast(*void)(*instance)) == 16, "physx_PxCapsuleObstacle_Pod.mPos has unexpected offset % instead of 16", ((cast(*void)(*instance.mPos)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxCapsuleObstacle_Pod.mPos)) == 24, "physx_PxCapsuleObstacle_Pod.mPos has unexpected size % instead of 24", size_of(type_of(physx_PxCapsuleObstacle_Pod.mPos)));
    assert(((cast(*void)(*instance.mRot)) - cast(*void)(*instance)) == 40, "physx_PxCapsuleObstacle_Pod.mRot has unexpected offset % instead of 40", ((cast(*void)(*instance.mRot)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxCapsuleObstacle_Pod.mRot)) == 16, "physx_PxCapsuleObstacle_Pod.mRot has unexpected size % instead of 16", size_of(type_of(physx_PxCapsuleObstacle_Pod.mRot)));
    assert(((cast(*void)(*instance.mHalfHeight)) - cast(*void)(*instance)) == 56, "physx_PxCapsuleObstacle_Pod.mHalfHeight has unexpected offset % instead of 56", ((cast(*void)(*instance.mHalfHeight)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxCapsuleObstacle_Pod.mHalfHeight)) == 4, "physx_PxCapsuleObstacle_Pod.mHalfHeight has unexpected size % instead of 4", size_of(type_of(physx_PxCapsuleObstacle_Pod.mHalfHeight)));
    assert(((cast(*void)(*instance.mRadius)) - cast(*void)(*instance)) == 60, "physx_PxCapsuleObstacle_Pod.mRadius has unexpected offset % instead of 60", ((cast(*void)(*instance.mRadius)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxCapsuleObstacle_Pod.mRadius)) == 4, "physx_PxCapsuleObstacle_Pod.mRadius has unexpected size % instead of 4", size_of(type_of(physx_PxCapsuleObstacle_Pod.mRadius)));
    assert(size_of(physx_PxCapsuleObstacle_Pod) == 64, "physx_PxCapsuleObstacle_Pod has size % instead of 64", size_of(physx_PxCapsuleObstacle_Pod));
}

physx_PxObstacleContext_Pod :: struct {
    vtable_: *void;
}
#run {
    instance: physx_PxObstacleContext_Pod;
    assert(((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)) == 0, "physx_PxObstacleContext_Pod.vtable_ has unexpected offset % instead of 0", ((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxObstacleContext_Pod.vtable_)) == 8, "physx_PxObstacleContext_Pod.vtable_ has unexpected size % instead of 8", size_of(type_of(physx_PxObstacleContext_Pod.vtable_)));
    assert(size_of(physx_PxObstacleContext_Pod) == 8, "physx_PxObstacleContext_Pod has size % instead of 8", size_of(physx_PxObstacleContext_Pod));
}

physx_PxControllerManager_Pod :: struct {
    vtable_: *void;
}
#run {
    instance: physx_PxControllerManager_Pod;
    assert(((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)) == 0, "physx_PxControllerManager_Pod.vtable_ has unexpected offset % instead of 0", ((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerManager_Pod.vtable_)) == 8, "physx_PxControllerManager_Pod.vtable_ has unexpected size % instead of 8", size_of(type_of(physx_PxControllerManager_Pod.vtable_)));
    assert(size_of(physx_PxControllerManager_Pod) == 8, "physx_PxControllerManager_Pod has size % instead of 8", size_of(physx_PxControllerManager_Pod));
}

physx_PxUserControllerHitReport_Pod :: struct {
    vtable_: *void;
}
#run {
    instance: physx_PxUserControllerHitReport_Pod;
    assert(((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)) == 0, "physx_PxUserControllerHitReport_Pod.vtable_ has unexpected offset % instead of 0", ((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxUserControllerHitReport_Pod.vtable_)) == 8, "physx_PxUserControllerHitReport_Pod.vtable_ has unexpected size % instead of 8", size_of(type_of(physx_PxUserControllerHitReport_Pod.vtable_)));
    assert(size_of(physx_PxUserControllerHitReport_Pod) == 8, "physx_PxUserControllerHitReport_Pod has size % instead of 8", size_of(physx_PxUserControllerHitReport_Pod));
}

physx_PxController_Pod :: struct {
    vtable_: *void;
}
#run {
    instance: physx_PxController_Pod;
    assert(((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)) == 0, "physx_PxController_Pod.vtable_ has unexpected offset % instead of 0", ((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxController_Pod.vtable_)) == 8, "physx_PxController_Pod.vtable_ has unexpected size % instead of 8", size_of(type_of(physx_PxController_Pod.vtable_)));
    assert(size_of(physx_PxController_Pod) == 8, "physx_PxController_Pod has size % instead of 8", size_of(physx_PxController_Pod));
}

physx_PxControllerShapeHit_Pod :: struct {
    controller:     *physx_PxController_Pod;
    worldPos:       physx_PxExtendedVec3_Pod;
    worldNormal:    physx_PxVec3_Pod;
    dir:            physx_PxVec3_Pod;
    length:         float;
    structgen_pad0: [4] u8;
    shape:          *physx_PxShape_Pod;
    actor:          *physx_PxRigidActor_Pod;
    triangleIndex:  u32;
    structgen_pad1: [4] u8;
}
#run {
    instance: physx_PxControllerShapeHit_Pod;
    assert(((cast(*void)(*instance.controller)) - cast(*void)(*instance)) == 0, "physx_PxControllerShapeHit_Pod.controller has unexpected offset % instead of 0", ((cast(*void)(*instance.controller)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerShapeHit_Pod.controller)) == 8, "physx_PxControllerShapeHit_Pod.controller has unexpected size % instead of 8", size_of(type_of(physx_PxControllerShapeHit_Pod.controller)));
    assert(((cast(*void)(*instance.worldPos)) - cast(*void)(*instance)) == 8, "physx_PxControllerShapeHit_Pod.worldPos has unexpected offset % instead of 8", ((cast(*void)(*instance.worldPos)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerShapeHit_Pod.worldPos)) == 24, "physx_PxControllerShapeHit_Pod.worldPos has unexpected size % instead of 24", size_of(type_of(physx_PxControllerShapeHit_Pod.worldPos)));
    assert(((cast(*void)(*instance.worldNormal)) - cast(*void)(*instance)) == 32, "physx_PxControllerShapeHit_Pod.worldNormal has unexpected offset % instead of 32", ((cast(*void)(*instance.worldNormal)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerShapeHit_Pod.worldNormal)) == 12, "physx_PxControllerShapeHit_Pod.worldNormal has unexpected size % instead of 12", size_of(type_of(physx_PxControllerShapeHit_Pod.worldNormal)));
    assert(((cast(*void)(*instance.dir)) - cast(*void)(*instance)) == 44, "physx_PxControllerShapeHit_Pod.dir has unexpected offset % instead of 44", ((cast(*void)(*instance.dir)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerShapeHit_Pod.dir)) == 12, "physx_PxControllerShapeHit_Pod.dir has unexpected size % instead of 12", size_of(type_of(physx_PxControllerShapeHit_Pod.dir)));
    assert(((cast(*void)(*instance.length)) - cast(*void)(*instance)) == 56, "physx_PxControllerShapeHit_Pod.length has unexpected offset % instead of 56", ((cast(*void)(*instance.length)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerShapeHit_Pod.length)) == 4, "physx_PxControllerShapeHit_Pod.length has unexpected size % instead of 4", size_of(type_of(physx_PxControllerShapeHit_Pod.length)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 60, "physx_PxControllerShapeHit_Pod.structgen_pad0 has unexpected offset % instead of 60", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerShapeHit_Pod.structgen_pad0)) == 4, "physx_PxControllerShapeHit_Pod.structgen_pad0 has unexpected size % instead of 4", size_of(type_of(physx_PxControllerShapeHit_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.shape)) - cast(*void)(*instance)) == 64, "physx_PxControllerShapeHit_Pod.shape has unexpected offset % instead of 64", ((cast(*void)(*instance.shape)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerShapeHit_Pod.shape)) == 8, "physx_PxControllerShapeHit_Pod.shape has unexpected size % instead of 8", size_of(type_of(physx_PxControllerShapeHit_Pod.shape)));
    assert(((cast(*void)(*instance.actor)) - cast(*void)(*instance)) == 72, "physx_PxControllerShapeHit_Pod.actor has unexpected offset % instead of 72", ((cast(*void)(*instance.actor)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerShapeHit_Pod.actor)) == 8, "physx_PxControllerShapeHit_Pod.actor has unexpected size % instead of 8", size_of(type_of(physx_PxControllerShapeHit_Pod.actor)));
    assert(((cast(*void)(*instance.triangleIndex)) - cast(*void)(*instance)) == 80, "physx_PxControllerShapeHit_Pod.triangleIndex has unexpected offset % instead of 80", ((cast(*void)(*instance.triangleIndex)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerShapeHit_Pod.triangleIndex)) == 4, "physx_PxControllerShapeHit_Pod.triangleIndex has unexpected size % instead of 4", size_of(type_of(physx_PxControllerShapeHit_Pod.triangleIndex)));
    assert(((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)) == 84, "physx_PxControllerShapeHit_Pod.structgen_pad1 has unexpected offset % instead of 84", ((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerShapeHit_Pod.structgen_pad1)) == 4, "physx_PxControllerShapeHit_Pod.structgen_pad1 has unexpected size % instead of 4", size_of(type_of(physx_PxControllerShapeHit_Pod.structgen_pad1)));
    assert(size_of(physx_PxControllerShapeHit_Pod) == 88, "physx_PxControllerShapeHit_Pod has size % instead of 88", size_of(physx_PxControllerShapeHit_Pod));
}

physx_PxControllersHit_Pod :: struct {
    controller:     *physx_PxController_Pod;
    worldPos:       physx_PxExtendedVec3_Pod;
    worldNormal:    physx_PxVec3_Pod;
    dir:            physx_PxVec3_Pod;
    length:         float;
    structgen_pad0: [4] u8;
    other:          *physx_PxController_Pod;
}
#run {
    instance: physx_PxControllersHit_Pod;
    assert(((cast(*void)(*instance.controller)) - cast(*void)(*instance)) == 0, "physx_PxControllersHit_Pod.controller has unexpected offset % instead of 0", ((cast(*void)(*instance.controller)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllersHit_Pod.controller)) == 8, "physx_PxControllersHit_Pod.controller has unexpected size % instead of 8", size_of(type_of(physx_PxControllersHit_Pod.controller)));
    assert(((cast(*void)(*instance.worldPos)) - cast(*void)(*instance)) == 8, "physx_PxControllersHit_Pod.worldPos has unexpected offset % instead of 8", ((cast(*void)(*instance.worldPos)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllersHit_Pod.worldPos)) == 24, "physx_PxControllersHit_Pod.worldPos has unexpected size % instead of 24", size_of(type_of(physx_PxControllersHit_Pod.worldPos)));
    assert(((cast(*void)(*instance.worldNormal)) - cast(*void)(*instance)) == 32, "physx_PxControllersHit_Pod.worldNormal has unexpected offset % instead of 32", ((cast(*void)(*instance.worldNormal)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllersHit_Pod.worldNormal)) == 12, "physx_PxControllersHit_Pod.worldNormal has unexpected size % instead of 12", size_of(type_of(physx_PxControllersHit_Pod.worldNormal)));
    assert(((cast(*void)(*instance.dir)) - cast(*void)(*instance)) == 44, "physx_PxControllersHit_Pod.dir has unexpected offset % instead of 44", ((cast(*void)(*instance.dir)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllersHit_Pod.dir)) == 12, "physx_PxControllersHit_Pod.dir has unexpected size % instead of 12", size_of(type_of(physx_PxControllersHit_Pod.dir)));
    assert(((cast(*void)(*instance.length)) - cast(*void)(*instance)) == 56, "physx_PxControllersHit_Pod.length has unexpected offset % instead of 56", ((cast(*void)(*instance.length)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllersHit_Pod.length)) == 4, "physx_PxControllersHit_Pod.length has unexpected size % instead of 4", size_of(type_of(physx_PxControllersHit_Pod.length)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 60, "physx_PxControllersHit_Pod.structgen_pad0 has unexpected offset % instead of 60", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllersHit_Pod.structgen_pad0)) == 4, "physx_PxControllersHit_Pod.structgen_pad0 has unexpected size % instead of 4", size_of(type_of(physx_PxControllersHit_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.other)) - cast(*void)(*instance)) == 64, "physx_PxControllersHit_Pod.other has unexpected offset % instead of 64", ((cast(*void)(*instance.other)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllersHit_Pod.other)) == 8, "physx_PxControllersHit_Pod.other has unexpected size % instead of 8", size_of(type_of(physx_PxControllersHit_Pod.other)));
    assert(size_of(physx_PxControllersHit_Pod) == 72, "physx_PxControllersHit_Pod has size % instead of 72", size_of(physx_PxControllersHit_Pod));
}

physx_PxControllerObstacleHit_Pod :: struct {
    controller:     *physx_PxController_Pod;
    worldPos:       physx_PxExtendedVec3_Pod;
    worldNormal:    physx_PxVec3_Pod;
    dir:            physx_PxVec3_Pod;
    length:         float;
    structgen_pad0: [4] u8;
    userData:       *void;
}
#run {
    instance: physx_PxControllerObstacleHit_Pod;
    assert(((cast(*void)(*instance.controller)) - cast(*void)(*instance)) == 0, "physx_PxControllerObstacleHit_Pod.controller has unexpected offset % instead of 0", ((cast(*void)(*instance.controller)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerObstacleHit_Pod.controller)) == 8, "physx_PxControllerObstacleHit_Pod.controller has unexpected size % instead of 8", size_of(type_of(physx_PxControllerObstacleHit_Pod.controller)));
    assert(((cast(*void)(*instance.worldPos)) - cast(*void)(*instance)) == 8, "physx_PxControllerObstacleHit_Pod.worldPos has unexpected offset % instead of 8", ((cast(*void)(*instance.worldPos)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerObstacleHit_Pod.worldPos)) == 24, "physx_PxControllerObstacleHit_Pod.worldPos has unexpected size % instead of 24", size_of(type_of(physx_PxControllerObstacleHit_Pod.worldPos)));
    assert(((cast(*void)(*instance.worldNormal)) - cast(*void)(*instance)) == 32, "physx_PxControllerObstacleHit_Pod.worldNormal has unexpected offset % instead of 32", ((cast(*void)(*instance.worldNormal)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerObstacleHit_Pod.worldNormal)) == 12, "physx_PxControllerObstacleHit_Pod.worldNormal has unexpected size % instead of 12", size_of(type_of(physx_PxControllerObstacleHit_Pod.worldNormal)));
    assert(((cast(*void)(*instance.dir)) - cast(*void)(*instance)) == 44, "physx_PxControllerObstacleHit_Pod.dir has unexpected offset % instead of 44", ((cast(*void)(*instance.dir)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerObstacleHit_Pod.dir)) == 12, "physx_PxControllerObstacleHit_Pod.dir has unexpected size % instead of 12", size_of(type_of(physx_PxControllerObstacleHit_Pod.dir)));
    assert(((cast(*void)(*instance.length)) - cast(*void)(*instance)) == 56, "physx_PxControllerObstacleHit_Pod.length has unexpected offset % instead of 56", ((cast(*void)(*instance.length)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerObstacleHit_Pod.length)) == 4, "physx_PxControllerObstacleHit_Pod.length has unexpected size % instead of 4", size_of(type_of(physx_PxControllerObstacleHit_Pod.length)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 60, "physx_PxControllerObstacleHit_Pod.structgen_pad0 has unexpected offset % instead of 60", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerObstacleHit_Pod.structgen_pad0)) == 4, "physx_PxControllerObstacleHit_Pod.structgen_pad0 has unexpected size % instead of 4", size_of(type_of(physx_PxControllerObstacleHit_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.userData)) - cast(*void)(*instance)) == 64, "physx_PxControllerObstacleHit_Pod.userData has unexpected offset % instead of 64", ((cast(*void)(*instance.userData)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerObstacleHit_Pod.userData)) == 8, "physx_PxControllerObstacleHit_Pod.userData has unexpected size % instead of 8", size_of(type_of(physx_PxControllerObstacleHit_Pod.userData)));
    assert(size_of(physx_PxControllerObstacleHit_Pod) == 72, "physx_PxControllerObstacleHit_Pod has size % instead of 72", size_of(physx_PxControllerObstacleHit_Pod));
}

physx_PxControllerFilterCallback_Pod :: struct {
    vtable_: *void;
}
#run {
    instance: physx_PxControllerFilterCallback_Pod;
    assert(((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)) == 0, "physx_PxControllerFilterCallback_Pod.vtable_ has unexpected offset % instead of 0", ((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerFilterCallback_Pod.vtable_)) == 8, "physx_PxControllerFilterCallback_Pod.vtable_ has unexpected size % instead of 8", size_of(type_of(physx_PxControllerFilterCallback_Pod.vtable_)));
    assert(size_of(physx_PxControllerFilterCallback_Pod) == 8, "physx_PxControllerFilterCallback_Pod has size % instead of 8", size_of(physx_PxControllerFilterCallback_Pod));
}

physx_PxControllerFilters_Pod :: struct {
    mFilterData:        *physx_PxFilterData_Pod;
    mFilterCallback:    *physx_PxQueryFilterCallback_Pod;
    mFilterFlags:       physx_PxQueryFlags_Pod;
    structgen_pad0:     [6] u8;
    mCCTFilterCallback: *physx_PxControllerFilterCallback_Pod;
}
#run {
    instance: physx_PxControllerFilters_Pod;
    assert(((cast(*void)(*instance.mFilterData)) - cast(*void)(*instance)) == 0, "physx_PxControllerFilters_Pod.mFilterData has unexpected offset % instead of 0", ((cast(*void)(*instance.mFilterData)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerFilters_Pod.mFilterData)) == 8, "physx_PxControllerFilters_Pod.mFilterData has unexpected size % instead of 8", size_of(type_of(physx_PxControllerFilters_Pod.mFilterData)));
    assert(((cast(*void)(*instance.mFilterCallback)) - cast(*void)(*instance)) == 8, "physx_PxControllerFilters_Pod.mFilterCallback has unexpected offset % instead of 8", ((cast(*void)(*instance.mFilterCallback)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerFilters_Pod.mFilterCallback)) == 8, "physx_PxControllerFilters_Pod.mFilterCallback has unexpected size % instead of 8", size_of(type_of(physx_PxControllerFilters_Pod.mFilterCallback)));
    assert(((cast(*void)(*instance.mFilterFlags)) - cast(*void)(*instance)) == 16, "physx_PxControllerFilters_Pod.mFilterFlags has unexpected offset % instead of 16", ((cast(*void)(*instance.mFilterFlags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerFilters_Pod.mFilterFlags)) == 2, "physx_PxControllerFilters_Pod.mFilterFlags has unexpected size % instead of 2", size_of(type_of(physx_PxControllerFilters_Pod.mFilterFlags)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 18, "physx_PxControllerFilters_Pod.structgen_pad0 has unexpected offset % instead of 18", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerFilters_Pod.structgen_pad0)) == 6, "physx_PxControllerFilters_Pod.structgen_pad0 has unexpected size % instead of 6", size_of(type_of(physx_PxControllerFilters_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.mCCTFilterCallback)) - cast(*void)(*instance)) == 24, "physx_PxControllerFilters_Pod.mCCTFilterCallback has unexpected offset % instead of 24", ((cast(*void)(*instance.mCCTFilterCallback)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerFilters_Pod.mCCTFilterCallback)) == 8, "physx_PxControllerFilters_Pod.mCCTFilterCallback has unexpected size % instead of 8", size_of(type_of(physx_PxControllerFilters_Pod.mCCTFilterCallback)));
    assert(size_of(physx_PxControllerFilters_Pod) == 32, "physx_PxControllerFilters_Pod has size % instead of 32", size_of(physx_PxControllerFilters_Pod));
}

physx_PxControllerBehaviorCallback_Pod :: struct {
    vtable_: *void;
}
#run {
    instance: physx_PxControllerBehaviorCallback_Pod;
    assert(((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)) == 0, "physx_PxControllerBehaviorCallback_Pod.vtable_ has unexpected offset % instead of 0", ((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerBehaviorCallback_Pod.vtable_)) == 8, "physx_PxControllerBehaviorCallback_Pod.vtable_ has unexpected size % instead of 8", size_of(type_of(physx_PxControllerBehaviorCallback_Pod.vtable_)));
    assert(size_of(physx_PxControllerBehaviorCallback_Pod) == 8, "physx_PxControllerBehaviorCallback_Pod has size % instead of 8", size_of(physx_PxControllerBehaviorCallback_Pod));
}

physx_PxControllerDesc_Pod :: struct {
    structgen_pad0:           [8] u8;
    position:                 physx_PxExtendedVec3_Pod;
    upDirection:              physx_PxVec3_Pod;
    slopeLimit:               float;
    invisibleWallHeight:      float;
    maxJumpHeight:            float;
    contactOffset:            float;
    stepOffset:               float;
    density:                  float;
    scaleCoeff:               float;
    volumeGrowth:             float;
    structgen_pad1:           [4] u8;
    reportCallback:           *physx_PxUserControllerHitReport_Pod;
    behaviorCallback:         *physx_PxControllerBehaviorCallback_Pod;
    nonWalkableMode:          u32;
    structgen_pad2:           [4] u8;
    material:                 *physx_PxMaterial_Pod;
    registerDeletionListener: bool;
    structgen_pad3:           [7] u8;
    userData:                 *void;
    mType:                    u32;
    structgen_pad4:           [4] u8;
}
#run {
    instance: physx_PxControllerDesc_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxControllerDesc_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerDesc_Pod.structgen_pad0)) == 8, "physx_PxControllerDesc_Pod.structgen_pad0 has unexpected size % instead of 8", size_of(type_of(physx_PxControllerDesc_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.position)) - cast(*void)(*instance)) == 8, "physx_PxControllerDesc_Pod.position has unexpected offset % instead of 8", ((cast(*void)(*instance.position)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerDesc_Pod.position)) == 24, "physx_PxControllerDesc_Pod.position has unexpected size % instead of 24", size_of(type_of(physx_PxControllerDesc_Pod.position)));
    assert(((cast(*void)(*instance.upDirection)) - cast(*void)(*instance)) == 32, "physx_PxControllerDesc_Pod.upDirection has unexpected offset % instead of 32", ((cast(*void)(*instance.upDirection)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerDesc_Pod.upDirection)) == 12, "physx_PxControllerDesc_Pod.upDirection has unexpected size % instead of 12", size_of(type_of(physx_PxControllerDesc_Pod.upDirection)));
    assert(((cast(*void)(*instance.slopeLimit)) - cast(*void)(*instance)) == 44, "physx_PxControllerDesc_Pod.slopeLimit has unexpected offset % instead of 44", ((cast(*void)(*instance.slopeLimit)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerDesc_Pod.slopeLimit)) == 4, "physx_PxControllerDesc_Pod.slopeLimit has unexpected size % instead of 4", size_of(type_of(physx_PxControllerDesc_Pod.slopeLimit)));
    assert(((cast(*void)(*instance.invisibleWallHeight)) - cast(*void)(*instance)) == 48, "physx_PxControllerDesc_Pod.invisibleWallHeight has unexpected offset % instead of 48", ((cast(*void)(*instance.invisibleWallHeight)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerDesc_Pod.invisibleWallHeight)) == 4, "physx_PxControllerDesc_Pod.invisibleWallHeight has unexpected size % instead of 4", size_of(type_of(physx_PxControllerDesc_Pod.invisibleWallHeight)));
    assert(((cast(*void)(*instance.maxJumpHeight)) - cast(*void)(*instance)) == 52, "physx_PxControllerDesc_Pod.maxJumpHeight has unexpected offset % instead of 52", ((cast(*void)(*instance.maxJumpHeight)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerDesc_Pod.maxJumpHeight)) == 4, "physx_PxControllerDesc_Pod.maxJumpHeight has unexpected size % instead of 4", size_of(type_of(physx_PxControllerDesc_Pod.maxJumpHeight)));
    assert(((cast(*void)(*instance.contactOffset)) - cast(*void)(*instance)) == 56, "physx_PxControllerDesc_Pod.contactOffset has unexpected offset % instead of 56", ((cast(*void)(*instance.contactOffset)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerDesc_Pod.contactOffset)) == 4, "physx_PxControllerDesc_Pod.contactOffset has unexpected size % instead of 4", size_of(type_of(physx_PxControllerDesc_Pod.contactOffset)));
    assert(((cast(*void)(*instance.stepOffset)) - cast(*void)(*instance)) == 60, "physx_PxControllerDesc_Pod.stepOffset has unexpected offset % instead of 60", ((cast(*void)(*instance.stepOffset)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerDesc_Pod.stepOffset)) == 4, "physx_PxControllerDesc_Pod.stepOffset has unexpected size % instead of 4", size_of(type_of(physx_PxControllerDesc_Pod.stepOffset)));
    assert(((cast(*void)(*instance.density)) - cast(*void)(*instance)) == 64, "physx_PxControllerDesc_Pod.density has unexpected offset % instead of 64", ((cast(*void)(*instance.density)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerDesc_Pod.density)) == 4, "physx_PxControllerDesc_Pod.density has unexpected size % instead of 4", size_of(type_of(physx_PxControllerDesc_Pod.density)));
    assert(((cast(*void)(*instance.scaleCoeff)) - cast(*void)(*instance)) == 68, "physx_PxControllerDesc_Pod.scaleCoeff has unexpected offset % instead of 68", ((cast(*void)(*instance.scaleCoeff)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerDesc_Pod.scaleCoeff)) == 4, "physx_PxControllerDesc_Pod.scaleCoeff has unexpected size % instead of 4", size_of(type_of(physx_PxControllerDesc_Pod.scaleCoeff)));
    assert(((cast(*void)(*instance.volumeGrowth)) - cast(*void)(*instance)) == 72, "physx_PxControllerDesc_Pod.volumeGrowth has unexpected offset % instead of 72", ((cast(*void)(*instance.volumeGrowth)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerDesc_Pod.volumeGrowth)) == 4, "physx_PxControllerDesc_Pod.volumeGrowth has unexpected size % instead of 4", size_of(type_of(physx_PxControllerDesc_Pod.volumeGrowth)));
    assert(((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)) == 76, "physx_PxControllerDesc_Pod.structgen_pad1 has unexpected offset % instead of 76", ((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerDesc_Pod.structgen_pad1)) == 4, "physx_PxControllerDesc_Pod.structgen_pad1 has unexpected size % instead of 4", size_of(type_of(physx_PxControllerDesc_Pod.structgen_pad1)));
    assert(((cast(*void)(*instance.reportCallback)) - cast(*void)(*instance)) == 80, "physx_PxControllerDesc_Pod.reportCallback has unexpected offset % instead of 80", ((cast(*void)(*instance.reportCallback)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerDesc_Pod.reportCallback)) == 8, "physx_PxControllerDesc_Pod.reportCallback has unexpected size % instead of 8", size_of(type_of(physx_PxControllerDesc_Pod.reportCallback)));
    assert(((cast(*void)(*instance.behaviorCallback)) - cast(*void)(*instance)) == 88, "physx_PxControllerDesc_Pod.behaviorCallback has unexpected offset % instead of 88", ((cast(*void)(*instance.behaviorCallback)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerDesc_Pod.behaviorCallback)) == 8, "physx_PxControllerDesc_Pod.behaviorCallback has unexpected size % instead of 8", size_of(type_of(physx_PxControllerDesc_Pod.behaviorCallback)));
    assert(((cast(*void)(*instance.nonWalkableMode)) - cast(*void)(*instance)) == 96, "physx_PxControllerDesc_Pod.nonWalkableMode has unexpected offset % instead of 96", ((cast(*void)(*instance.nonWalkableMode)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerDesc_Pod.nonWalkableMode)) == 4, "physx_PxControllerDesc_Pod.nonWalkableMode has unexpected size % instead of 4", size_of(type_of(physx_PxControllerDesc_Pod.nonWalkableMode)));
    assert(((cast(*void)(*instance.structgen_pad2)) - cast(*void)(*instance)) == 100, "physx_PxControllerDesc_Pod.structgen_pad2 has unexpected offset % instead of 100", ((cast(*void)(*instance.structgen_pad2)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerDesc_Pod.structgen_pad2)) == 4, "physx_PxControllerDesc_Pod.structgen_pad2 has unexpected size % instead of 4", size_of(type_of(physx_PxControllerDesc_Pod.structgen_pad2)));
    assert(((cast(*void)(*instance.material)) - cast(*void)(*instance)) == 104, "physx_PxControllerDesc_Pod.material has unexpected offset % instead of 104", ((cast(*void)(*instance.material)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerDesc_Pod.material)) == 8, "physx_PxControllerDesc_Pod.material has unexpected size % instead of 8", size_of(type_of(physx_PxControllerDesc_Pod.material)));
    assert(((cast(*void)(*instance.registerDeletionListener)) - cast(*void)(*instance)) == 112, "physx_PxControllerDesc_Pod.registerDeletionListener has unexpected offset % instead of 112", ((cast(*void)(*instance.registerDeletionListener)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerDesc_Pod.registerDeletionListener)) == 1, "physx_PxControllerDesc_Pod.registerDeletionListener has unexpected size % instead of 1", size_of(type_of(physx_PxControllerDesc_Pod.registerDeletionListener)));
    assert(((cast(*void)(*instance.structgen_pad3)) - cast(*void)(*instance)) == 113, "physx_PxControllerDesc_Pod.structgen_pad3 has unexpected offset % instead of 113", ((cast(*void)(*instance.structgen_pad3)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerDesc_Pod.structgen_pad3)) == 7, "physx_PxControllerDesc_Pod.structgen_pad3 has unexpected size % instead of 7", size_of(type_of(physx_PxControllerDesc_Pod.structgen_pad3)));
    assert(((cast(*void)(*instance.userData)) - cast(*void)(*instance)) == 120, "physx_PxControllerDesc_Pod.userData has unexpected offset % instead of 120", ((cast(*void)(*instance.userData)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerDesc_Pod.userData)) == 8, "physx_PxControllerDesc_Pod.userData has unexpected size % instead of 8", size_of(type_of(physx_PxControllerDesc_Pod.userData)));
    assert(((cast(*void)(*instance.mType)) - cast(*void)(*instance)) == 128, "physx_PxControllerDesc_Pod.mType has unexpected offset % instead of 128", ((cast(*void)(*instance.mType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerDesc_Pod.mType)) == 4, "physx_PxControllerDesc_Pod.mType has unexpected size % instead of 4", size_of(type_of(physx_PxControllerDesc_Pod.mType)));
    assert(((cast(*void)(*instance.structgen_pad4)) - cast(*void)(*instance)) == 132, "physx_PxControllerDesc_Pod.structgen_pad4 has unexpected offset % instead of 132", ((cast(*void)(*instance.structgen_pad4)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerDesc_Pod.structgen_pad4)) == 4, "physx_PxControllerDesc_Pod.structgen_pad4 has unexpected size % instead of 4", size_of(type_of(physx_PxControllerDesc_Pod.structgen_pad4)));
    assert(size_of(physx_PxControllerDesc_Pod) == 136, "physx_PxControllerDesc_Pod has size % instead of 136", size_of(physx_PxControllerDesc_Pod));
}

physx_PxControllerCollisionFlags_Pod :: struct {
    mBits: u8;
}
#run {
    instance: physx_PxControllerCollisionFlags_Pod;
    assert(((cast(*void)(*instance.mBits)) - cast(*void)(*instance)) == 0, "physx_PxControllerCollisionFlags_Pod.mBits has unexpected offset % instead of 0", ((cast(*void)(*instance.mBits)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerCollisionFlags_Pod.mBits)) == 1, "physx_PxControllerCollisionFlags_Pod.mBits has unexpected size % instead of 1", size_of(type_of(physx_PxControllerCollisionFlags_Pod.mBits)));
    assert(size_of(physx_PxControllerCollisionFlags_Pod) == 1, "physx_PxControllerCollisionFlags_Pod has size % instead of 1", size_of(physx_PxControllerCollisionFlags_Pod));
}

physx_PxControllerState_Pod :: struct {
    deltaXP:               physx_PxVec3_Pod;
    structgen_pad0:        [4] u8;
    touchedShape:          *physx_PxShape_Pod;
    touchedActor:          *physx_PxRigidActor_Pod;
    touchedObstacleHandle: u32;
    collisionFlags:        u32;
    standOnAnotherCCT:     bool;
    standOnObstacle:       bool;
    isMovingUp:            bool;
    structgen_pad1:        [5] u8;
}
#run {
    instance: physx_PxControllerState_Pod;
    assert(((cast(*void)(*instance.deltaXP)) - cast(*void)(*instance)) == 0, "physx_PxControllerState_Pod.deltaXP has unexpected offset % instead of 0", ((cast(*void)(*instance.deltaXP)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerState_Pod.deltaXP)) == 12, "physx_PxControllerState_Pod.deltaXP has unexpected size % instead of 12", size_of(type_of(physx_PxControllerState_Pod.deltaXP)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 12, "physx_PxControllerState_Pod.structgen_pad0 has unexpected offset % instead of 12", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerState_Pod.structgen_pad0)) == 4, "physx_PxControllerState_Pod.structgen_pad0 has unexpected size % instead of 4", size_of(type_of(physx_PxControllerState_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.touchedShape)) - cast(*void)(*instance)) == 16, "physx_PxControllerState_Pod.touchedShape has unexpected offset % instead of 16", ((cast(*void)(*instance.touchedShape)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerState_Pod.touchedShape)) == 8, "physx_PxControllerState_Pod.touchedShape has unexpected size % instead of 8", size_of(type_of(physx_PxControllerState_Pod.touchedShape)));
    assert(((cast(*void)(*instance.touchedActor)) - cast(*void)(*instance)) == 24, "physx_PxControllerState_Pod.touchedActor has unexpected offset % instead of 24", ((cast(*void)(*instance.touchedActor)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerState_Pod.touchedActor)) == 8, "physx_PxControllerState_Pod.touchedActor has unexpected size % instead of 8", size_of(type_of(physx_PxControllerState_Pod.touchedActor)));
    assert(((cast(*void)(*instance.touchedObstacleHandle)) - cast(*void)(*instance)) == 32, "physx_PxControllerState_Pod.touchedObstacleHandle has unexpected offset % instead of 32", ((cast(*void)(*instance.touchedObstacleHandle)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerState_Pod.touchedObstacleHandle)) == 4, "physx_PxControllerState_Pod.touchedObstacleHandle has unexpected size % instead of 4", size_of(type_of(physx_PxControllerState_Pod.touchedObstacleHandle)));
    assert(((cast(*void)(*instance.collisionFlags)) - cast(*void)(*instance)) == 36, "physx_PxControllerState_Pod.collisionFlags has unexpected offset % instead of 36", ((cast(*void)(*instance.collisionFlags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerState_Pod.collisionFlags)) == 4, "physx_PxControllerState_Pod.collisionFlags has unexpected size % instead of 4", size_of(type_of(physx_PxControllerState_Pod.collisionFlags)));
    assert(((cast(*void)(*instance.standOnAnotherCCT)) - cast(*void)(*instance)) == 40, "physx_PxControllerState_Pod.standOnAnotherCCT has unexpected offset % instead of 40", ((cast(*void)(*instance.standOnAnotherCCT)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerState_Pod.standOnAnotherCCT)) == 1, "physx_PxControllerState_Pod.standOnAnotherCCT has unexpected size % instead of 1", size_of(type_of(physx_PxControllerState_Pod.standOnAnotherCCT)));
    assert(((cast(*void)(*instance.standOnObstacle)) - cast(*void)(*instance)) == 41, "physx_PxControllerState_Pod.standOnObstacle has unexpected offset % instead of 41", ((cast(*void)(*instance.standOnObstacle)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerState_Pod.standOnObstacle)) == 1, "physx_PxControllerState_Pod.standOnObstacle has unexpected size % instead of 1", size_of(type_of(physx_PxControllerState_Pod.standOnObstacle)));
    assert(((cast(*void)(*instance.isMovingUp)) - cast(*void)(*instance)) == 42, "physx_PxControllerState_Pod.isMovingUp has unexpected offset % instead of 42", ((cast(*void)(*instance.isMovingUp)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerState_Pod.isMovingUp)) == 1, "physx_PxControllerState_Pod.isMovingUp has unexpected size % instead of 1", size_of(type_of(physx_PxControllerState_Pod.isMovingUp)));
    assert(((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)) == 43, "physx_PxControllerState_Pod.structgen_pad1 has unexpected offset % instead of 43", ((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerState_Pod.structgen_pad1)) == 5, "physx_PxControllerState_Pod.structgen_pad1 has unexpected size % instead of 5", size_of(type_of(physx_PxControllerState_Pod.structgen_pad1)));
    assert(size_of(physx_PxControllerState_Pod) == 48, "physx_PxControllerState_Pod has size % instead of 48", size_of(physx_PxControllerState_Pod));
}

physx_PxControllerStats_Pod :: struct {
    nbIterations:     u16;
    nbFullUpdates:    u16;
    nbPartialUpdates: u16;
    nbTessellation:   u16;
}
#run {
    instance: physx_PxControllerStats_Pod;
    assert(((cast(*void)(*instance.nbIterations)) - cast(*void)(*instance)) == 0, "physx_PxControllerStats_Pod.nbIterations has unexpected offset % instead of 0", ((cast(*void)(*instance.nbIterations)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerStats_Pod.nbIterations)) == 2, "physx_PxControllerStats_Pod.nbIterations has unexpected size % instead of 2", size_of(type_of(physx_PxControllerStats_Pod.nbIterations)));
    assert(((cast(*void)(*instance.nbFullUpdates)) - cast(*void)(*instance)) == 2, "physx_PxControllerStats_Pod.nbFullUpdates has unexpected offset % instead of 2", ((cast(*void)(*instance.nbFullUpdates)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerStats_Pod.nbFullUpdates)) == 2, "physx_PxControllerStats_Pod.nbFullUpdates has unexpected size % instead of 2", size_of(type_of(physx_PxControllerStats_Pod.nbFullUpdates)));
    assert(((cast(*void)(*instance.nbPartialUpdates)) - cast(*void)(*instance)) == 4, "physx_PxControllerStats_Pod.nbPartialUpdates has unexpected offset % instead of 4", ((cast(*void)(*instance.nbPartialUpdates)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerStats_Pod.nbPartialUpdates)) == 2, "physx_PxControllerStats_Pod.nbPartialUpdates has unexpected size % instead of 2", size_of(type_of(physx_PxControllerStats_Pod.nbPartialUpdates)));
    assert(((cast(*void)(*instance.nbTessellation)) - cast(*void)(*instance)) == 6, "physx_PxControllerStats_Pod.nbTessellation has unexpected offset % instead of 6", ((cast(*void)(*instance.nbTessellation)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerStats_Pod.nbTessellation)) == 2, "physx_PxControllerStats_Pod.nbTessellation has unexpected size % instead of 2", size_of(type_of(physx_PxControllerStats_Pod.nbTessellation)));
    assert(size_of(physx_PxControllerStats_Pod) == 8, "physx_PxControllerStats_Pod has size % instead of 8", size_of(physx_PxControllerStats_Pod));
}

physx_PxBoxControllerDesc_Pod :: struct {
    structgen_pad0:           [8] u8;
    position:                 physx_PxExtendedVec3_Pod;
    upDirection:              physx_PxVec3_Pod;
    slopeLimit:               float;
    invisibleWallHeight:      float;
    maxJumpHeight:            float;
    contactOffset:            float;
    stepOffset:               float;
    density:                  float;
    scaleCoeff:               float;
    volumeGrowth:             float;
    structgen_pad1:           [4] u8;
    reportCallback:           *physx_PxUserControllerHitReport_Pod;
    behaviorCallback:         *physx_PxControllerBehaviorCallback_Pod;
    nonWalkableMode:          u32;
    structgen_pad2:           [4] u8;
    material:                 *physx_PxMaterial_Pod;
    registerDeletionListener: bool;
    structgen_pad3:           [7] u8;
    userData:                 *void;
    mType:                    u32;
    structgen_pad4:           [4] u8;
    halfHeight:               float;
    halfSideExtent:           float;
    halfForwardExtent:        float;
    structgen_pad5:           [4] u8;
}
#run {
    instance: physx_PxBoxControllerDesc_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxBoxControllerDesc_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBoxControllerDesc_Pod.structgen_pad0)) == 8, "physx_PxBoxControllerDesc_Pod.structgen_pad0 has unexpected size % instead of 8", size_of(type_of(physx_PxBoxControllerDesc_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.position)) - cast(*void)(*instance)) == 8, "physx_PxBoxControllerDesc_Pod.position has unexpected offset % instead of 8", ((cast(*void)(*instance.position)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBoxControllerDesc_Pod.position)) == 24, "physx_PxBoxControllerDesc_Pod.position has unexpected size % instead of 24", size_of(type_of(physx_PxBoxControllerDesc_Pod.position)));
    assert(((cast(*void)(*instance.upDirection)) - cast(*void)(*instance)) == 32, "physx_PxBoxControllerDesc_Pod.upDirection has unexpected offset % instead of 32", ((cast(*void)(*instance.upDirection)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBoxControllerDesc_Pod.upDirection)) == 12, "physx_PxBoxControllerDesc_Pod.upDirection has unexpected size % instead of 12", size_of(type_of(physx_PxBoxControllerDesc_Pod.upDirection)));
    assert(((cast(*void)(*instance.slopeLimit)) - cast(*void)(*instance)) == 44, "physx_PxBoxControllerDesc_Pod.slopeLimit has unexpected offset % instead of 44", ((cast(*void)(*instance.slopeLimit)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBoxControllerDesc_Pod.slopeLimit)) == 4, "physx_PxBoxControllerDesc_Pod.slopeLimit has unexpected size % instead of 4", size_of(type_of(physx_PxBoxControllerDesc_Pod.slopeLimit)));
    assert(((cast(*void)(*instance.invisibleWallHeight)) - cast(*void)(*instance)) == 48, "physx_PxBoxControllerDesc_Pod.invisibleWallHeight has unexpected offset % instead of 48", ((cast(*void)(*instance.invisibleWallHeight)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBoxControllerDesc_Pod.invisibleWallHeight)) == 4, "physx_PxBoxControllerDesc_Pod.invisibleWallHeight has unexpected size % instead of 4", size_of(type_of(physx_PxBoxControllerDesc_Pod.invisibleWallHeight)));
    assert(((cast(*void)(*instance.maxJumpHeight)) - cast(*void)(*instance)) == 52, "physx_PxBoxControllerDesc_Pod.maxJumpHeight has unexpected offset % instead of 52", ((cast(*void)(*instance.maxJumpHeight)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBoxControllerDesc_Pod.maxJumpHeight)) == 4, "physx_PxBoxControllerDesc_Pod.maxJumpHeight has unexpected size % instead of 4", size_of(type_of(physx_PxBoxControllerDesc_Pod.maxJumpHeight)));
    assert(((cast(*void)(*instance.contactOffset)) - cast(*void)(*instance)) == 56, "physx_PxBoxControllerDesc_Pod.contactOffset has unexpected offset % instead of 56", ((cast(*void)(*instance.contactOffset)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBoxControllerDesc_Pod.contactOffset)) == 4, "physx_PxBoxControllerDesc_Pod.contactOffset has unexpected size % instead of 4", size_of(type_of(physx_PxBoxControllerDesc_Pod.contactOffset)));
    assert(((cast(*void)(*instance.stepOffset)) - cast(*void)(*instance)) == 60, "physx_PxBoxControllerDesc_Pod.stepOffset has unexpected offset % instead of 60", ((cast(*void)(*instance.stepOffset)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBoxControllerDesc_Pod.stepOffset)) == 4, "physx_PxBoxControllerDesc_Pod.stepOffset has unexpected size % instead of 4", size_of(type_of(physx_PxBoxControllerDesc_Pod.stepOffset)));
    assert(((cast(*void)(*instance.density)) - cast(*void)(*instance)) == 64, "physx_PxBoxControllerDesc_Pod.density has unexpected offset % instead of 64", ((cast(*void)(*instance.density)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBoxControllerDesc_Pod.density)) == 4, "physx_PxBoxControllerDesc_Pod.density has unexpected size % instead of 4", size_of(type_of(physx_PxBoxControllerDesc_Pod.density)));
    assert(((cast(*void)(*instance.scaleCoeff)) - cast(*void)(*instance)) == 68, "physx_PxBoxControllerDesc_Pod.scaleCoeff has unexpected offset % instead of 68", ((cast(*void)(*instance.scaleCoeff)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBoxControllerDesc_Pod.scaleCoeff)) == 4, "physx_PxBoxControllerDesc_Pod.scaleCoeff has unexpected size % instead of 4", size_of(type_of(physx_PxBoxControllerDesc_Pod.scaleCoeff)));
    assert(((cast(*void)(*instance.volumeGrowth)) - cast(*void)(*instance)) == 72, "physx_PxBoxControllerDesc_Pod.volumeGrowth has unexpected offset % instead of 72", ((cast(*void)(*instance.volumeGrowth)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBoxControllerDesc_Pod.volumeGrowth)) == 4, "physx_PxBoxControllerDesc_Pod.volumeGrowth has unexpected size % instead of 4", size_of(type_of(physx_PxBoxControllerDesc_Pod.volumeGrowth)));
    assert(((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)) == 76, "physx_PxBoxControllerDesc_Pod.structgen_pad1 has unexpected offset % instead of 76", ((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBoxControllerDesc_Pod.structgen_pad1)) == 4, "physx_PxBoxControllerDesc_Pod.structgen_pad1 has unexpected size % instead of 4", size_of(type_of(physx_PxBoxControllerDesc_Pod.structgen_pad1)));
    assert(((cast(*void)(*instance.reportCallback)) - cast(*void)(*instance)) == 80, "physx_PxBoxControllerDesc_Pod.reportCallback has unexpected offset % instead of 80", ((cast(*void)(*instance.reportCallback)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBoxControllerDesc_Pod.reportCallback)) == 8, "physx_PxBoxControllerDesc_Pod.reportCallback has unexpected size % instead of 8", size_of(type_of(physx_PxBoxControllerDesc_Pod.reportCallback)));
    assert(((cast(*void)(*instance.behaviorCallback)) - cast(*void)(*instance)) == 88, "physx_PxBoxControllerDesc_Pod.behaviorCallback has unexpected offset % instead of 88", ((cast(*void)(*instance.behaviorCallback)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBoxControllerDesc_Pod.behaviorCallback)) == 8, "physx_PxBoxControllerDesc_Pod.behaviorCallback has unexpected size % instead of 8", size_of(type_of(physx_PxBoxControllerDesc_Pod.behaviorCallback)));
    assert(((cast(*void)(*instance.nonWalkableMode)) - cast(*void)(*instance)) == 96, "physx_PxBoxControllerDesc_Pod.nonWalkableMode has unexpected offset % instead of 96", ((cast(*void)(*instance.nonWalkableMode)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBoxControllerDesc_Pod.nonWalkableMode)) == 4, "physx_PxBoxControllerDesc_Pod.nonWalkableMode has unexpected size % instead of 4", size_of(type_of(physx_PxBoxControllerDesc_Pod.nonWalkableMode)));
    assert(((cast(*void)(*instance.structgen_pad2)) - cast(*void)(*instance)) == 100, "physx_PxBoxControllerDesc_Pod.structgen_pad2 has unexpected offset % instead of 100", ((cast(*void)(*instance.structgen_pad2)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBoxControllerDesc_Pod.structgen_pad2)) == 4, "physx_PxBoxControllerDesc_Pod.structgen_pad2 has unexpected size % instead of 4", size_of(type_of(physx_PxBoxControllerDesc_Pod.structgen_pad2)));
    assert(((cast(*void)(*instance.material)) - cast(*void)(*instance)) == 104, "physx_PxBoxControllerDesc_Pod.material has unexpected offset % instead of 104", ((cast(*void)(*instance.material)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBoxControllerDesc_Pod.material)) == 8, "physx_PxBoxControllerDesc_Pod.material has unexpected size % instead of 8", size_of(type_of(physx_PxBoxControllerDesc_Pod.material)));
    assert(((cast(*void)(*instance.registerDeletionListener)) - cast(*void)(*instance)) == 112, "physx_PxBoxControllerDesc_Pod.registerDeletionListener has unexpected offset % instead of 112", ((cast(*void)(*instance.registerDeletionListener)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBoxControllerDesc_Pod.registerDeletionListener)) == 1, "physx_PxBoxControllerDesc_Pod.registerDeletionListener has unexpected size % instead of 1", size_of(type_of(physx_PxBoxControllerDesc_Pod.registerDeletionListener)));
    assert(((cast(*void)(*instance.structgen_pad3)) - cast(*void)(*instance)) == 113, "physx_PxBoxControllerDesc_Pod.structgen_pad3 has unexpected offset % instead of 113", ((cast(*void)(*instance.structgen_pad3)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBoxControllerDesc_Pod.structgen_pad3)) == 7, "physx_PxBoxControllerDesc_Pod.structgen_pad3 has unexpected size % instead of 7", size_of(type_of(physx_PxBoxControllerDesc_Pod.structgen_pad3)));
    assert(((cast(*void)(*instance.userData)) - cast(*void)(*instance)) == 120, "physx_PxBoxControllerDesc_Pod.userData has unexpected offset % instead of 120", ((cast(*void)(*instance.userData)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBoxControllerDesc_Pod.userData)) == 8, "physx_PxBoxControllerDesc_Pod.userData has unexpected size % instead of 8", size_of(type_of(physx_PxBoxControllerDesc_Pod.userData)));
    assert(((cast(*void)(*instance.mType)) - cast(*void)(*instance)) == 128, "physx_PxBoxControllerDesc_Pod.mType has unexpected offset % instead of 128", ((cast(*void)(*instance.mType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBoxControllerDesc_Pod.mType)) == 4, "physx_PxBoxControllerDesc_Pod.mType has unexpected size % instead of 4", size_of(type_of(physx_PxBoxControllerDesc_Pod.mType)));
    assert(((cast(*void)(*instance.structgen_pad4)) - cast(*void)(*instance)) == 132, "physx_PxBoxControllerDesc_Pod.structgen_pad4 has unexpected offset % instead of 132", ((cast(*void)(*instance.structgen_pad4)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBoxControllerDesc_Pod.structgen_pad4)) == 4, "physx_PxBoxControllerDesc_Pod.structgen_pad4 has unexpected size % instead of 4", size_of(type_of(physx_PxBoxControllerDesc_Pod.structgen_pad4)));
    assert(((cast(*void)(*instance.halfHeight)) - cast(*void)(*instance)) == 136, "physx_PxBoxControllerDesc_Pod.halfHeight has unexpected offset % instead of 136", ((cast(*void)(*instance.halfHeight)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBoxControllerDesc_Pod.halfHeight)) == 4, "physx_PxBoxControllerDesc_Pod.halfHeight has unexpected size % instead of 4", size_of(type_of(physx_PxBoxControllerDesc_Pod.halfHeight)));
    assert(((cast(*void)(*instance.halfSideExtent)) - cast(*void)(*instance)) == 140, "physx_PxBoxControllerDesc_Pod.halfSideExtent has unexpected offset % instead of 140", ((cast(*void)(*instance.halfSideExtent)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBoxControllerDesc_Pod.halfSideExtent)) == 4, "physx_PxBoxControllerDesc_Pod.halfSideExtent has unexpected size % instead of 4", size_of(type_of(physx_PxBoxControllerDesc_Pod.halfSideExtent)));
    assert(((cast(*void)(*instance.halfForwardExtent)) - cast(*void)(*instance)) == 144, "physx_PxBoxControllerDesc_Pod.halfForwardExtent has unexpected offset % instead of 144", ((cast(*void)(*instance.halfForwardExtent)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBoxControllerDesc_Pod.halfForwardExtent)) == 4, "physx_PxBoxControllerDesc_Pod.halfForwardExtent has unexpected size % instead of 4", size_of(type_of(physx_PxBoxControllerDesc_Pod.halfForwardExtent)));
    assert(((cast(*void)(*instance.structgen_pad5)) - cast(*void)(*instance)) == 148, "physx_PxBoxControllerDesc_Pod.structgen_pad5 has unexpected offset % instead of 148", ((cast(*void)(*instance.structgen_pad5)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBoxControllerDesc_Pod.structgen_pad5)) == 4, "physx_PxBoxControllerDesc_Pod.structgen_pad5 has unexpected size % instead of 4", size_of(type_of(physx_PxBoxControllerDesc_Pod.structgen_pad5)));
    assert(size_of(physx_PxBoxControllerDesc_Pod) == 152, "physx_PxBoxControllerDesc_Pod has size % instead of 152", size_of(physx_PxBoxControllerDesc_Pod));
}

physx_PxBoxController_Pod :: struct {
    vtable_: *void;
}
#run {
    instance: physx_PxBoxController_Pod;
    assert(((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)) == 0, "physx_PxBoxController_Pod.vtable_ has unexpected offset % instead of 0", ((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBoxController_Pod.vtable_)) == 8, "physx_PxBoxController_Pod.vtable_ has unexpected size % instead of 8", size_of(type_of(physx_PxBoxController_Pod.vtable_)));
    assert(size_of(physx_PxBoxController_Pod) == 8, "physx_PxBoxController_Pod has size % instead of 8", size_of(physx_PxBoxController_Pod));
}

physx_PxCapsuleControllerDesc_Pod :: struct {
    structgen_pad0:           [8] u8;
    position:                 physx_PxExtendedVec3_Pod;
    upDirection:              physx_PxVec3_Pod;
    slopeLimit:               float;
    invisibleWallHeight:      float;
    maxJumpHeight:            float;
    contactOffset:            float;
    stepOffset:               float;
    density:                  float;
    scaleCoeff:               float;
    volumeGrowth:             float;
    structgen_pad1:           [4] u8;
    reportCallback:           *physx_PxUserControllerHitReport_Pod;
    behaviorCallback:         *physx_PxControllerBehaviorCallback_Pod;
    nonWalkableMode:          u32;
    structgen_pad2:           [4] u8;
    material:                 *physx_PxMaterial_Pod;
    registerDeletionListener: bool;
    structgen_pad3:           [7] u8;
    userData:                 *void;
    mType:                    u32;
    structgen_pad4:           [4] u8;
    radius:                   float;
    height:                   float;
    climbingMode:             u32;
    structgen_pad5:           [4] u8;
}
#run {
    instance: physx_PxCapsuleControllerDesc_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxCapsuleControllerDesc_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxCapsuleControllerDesc_Pod.structgen_pad0)) == 8, "physx_PxCapsuleControllerDesc_Pod.structgen_pad0 has unexpected size % instead of 8", size_of(type_of(physx_PxCapsuleControllerDesc_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.position)) - cast(*void)(*instance)) == 8, "physx_PxCapsuleControllerDesc_Pod.position has unexpected offset % instead of 8", ((cast(*void)(*instance.position)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxCapsuleControllerDesc_Pod.position)) == 24, "physx_PxCapsuleControllerDesc_Pod.position has unexpected size % instead of 24", size_of(type_of(physx_PxCapsuleControllerDesc_Pod.position)));
    assert(((cast(*void)(*instance.upDirection)) - cast(*void)(*instance)) == 32, "physx_PxCapsuleControllerDesc_Pod.upDirection has unexpected offset % instead of 32", ((cast(*void)(*instance.upDirection)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxCapsuleControllerDesc_Pod.upDirection)) == 12, "physx_PxCapsuleControllerDesc_Pod.upDirection has unexpected size % instead of 12", size_of(type_of(physx_PxCapsuleControllerDesc_Pod.upDirection)));
    assert(((cast(*void)(*instance.slopeLimit)) - cast(*void)(*instance)) == 44, "physx_PxCapsuleControllerDesc_Pod.slopeLimit has unexpected offset % instead of 44", ((cast(*void)(*instance.slopeLimit)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxCapsuleControllerDesc_Pod.slopeLimit)) == 4, "physx_PxCapsuleControllerDesc_Pod.slopeLimit has unexpected size % instead of 4", size_of(type_of(physx_PxCapsuleControllerDesc_Pod.slopeLimit)));
    assert(((cast(*void)(*instance.invisibleWallHeight)) - cast(*void)(*instance)) == 48, "physx_PxCapsuleControllerDesc_Pod.invisibleWallHeight has unexpected offset % instead of 48", ((cast(*void)(*instance.invisibleWallHeight)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxCapsuleControllerDesc_Pod.invisibleWallHeight)) == 4, "physx_PxCapsuleControllerDesc_Pod.invisibleWallHeight has unexpected size % instead of 4", size_of(type_of(physx_PxCapsuleControllerDesc_Pod.invisibleWallHeight)));
    assert(((cast(*void)(*instance.maxJumpHeight)) - cast(*void)(*instance)) == 52, "physx_PxCapsuleControllerDesc_Pod.maxJumpHeight has unexpected offset % instead of 52", ((cast(*void)(*instance.maxJumpHeight)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxCapsuleControllerDesc_Pod.maxJumpHeight)) == 4, "physx_PxCapsuleControllerDesc_Pod.maxJumpHeight has unexpected size % instead of 4", size_of(type_of(physx_PxCapsuleControllerDesc_Pod.maxJumpHeight)));
    assert(((cast(*void)(*instance.contactOffset)) - cast(*void)(*instance)) == 56, "physx_PxCapsuleControllerDesc_Pod.contactOffset has unexpected offset % instead of 56", ((cast(*void)(*instance.contactOffset)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxCapsuleControllerDesc_Pod.contactOffset)) == 4, "physx_PxCapsuleControllerDesc_Pod.contactOffset has unexpected size % instead of 4", size_of(type_of(physx_PxCapsuleControllerDesc_Pod.contactOffset)));
    assert(((cast(*void)(*instance.stepOffset)) - cast(*void)(*instance)) == 60, "physx_PxCapsuleControllerDesc_Pod.stepOffset has unexpected offset % instead of 60", ((cast(*void)(*instance.stepOffset)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxCapsuleControllerDesc_Pod.stepOffset)) == 4, "physx_PxCapsuleControllerDesc_Pod.stepOffset has unexpected size % instead of 4", size_of(type_of(physx_PxCapsuleControllerDesc_Pod.stepOffset)));
    assert(((cast(*void)(*instance.density)) - cast(*void)(*instance)) == 64, "physx_PxCapsuleControllerDesc_Pod.density has unexpected offset % instead of 64", ((cast(*void)(*instance.density)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxCapsuleControllerDesc_Pod.density)) == 4, "physx_PxCapsuleControllerDesc_Pod.density has unexpected size % instead of 4", size_of(type_of(physx_PxCapsuleControllerDesc_Pod.density)));
    assert(((cast(*void)(*instance.scaleCoeff)) - cast(*void)(*instance)) == 68, "physx_PxCapsuleControllerDesc_Pod.scaleCoeff has unexpected offset % instead of 68", ((cast(*void)(*instance.scaleCoeff)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxCapsuleControllerDesc_Pod.scaleCoeff)) == 4, "physx_PxCapsuleControllerDesc_Pod.scaleCoeff has unexpected size % instead of 4", size_of(type_of(physx_PxCapsuleControllerDesc_Pod.scaleCoeff)));
    assert(((cast(*void)(*instance.volumeGrowth)) - cast(*void)(*instance)) == 72, "physx_PxCapsuleControllerDesc_Pod.volumeGrowth has unexpected offset % instead of 72", ((cast(*void)(*instance.volumeGrowth)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxCapsuleControllerDesc_Pod.volumeGrowth)) == 4, "physx_PxCapsuleControllerDesc_Pod.volumeGrowth has unexpected size % instead of 4", size_of(type_of(physx_PxCapsuleControllerDesc_Pod.volumeGrowth)));
    assert(((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)) == 76, "physx_PxCapsuleControllerDesc_Pod.structgen_pad1 has unexpected offset % instead of 76", ((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxCapsuleControllerDesc_Pod.structgen_pad1)) == 4, "physx_PxCapsuleControllerDesc_Pod.structgen_pad1 has unexpected size % instead of 4", size_of(type_of(physx_PxCapsuleControllerDesc_Pod.structgen_pad1)));
    assert(((cast(*void)(*instance.reportCallback)) - cast(*void)(*instance)) == 80, "physx_PxCapsuleControllerDesc_Pod.reportCallback has unexpected offset % instead of 80", ((cast(*void)(*instance.reportCallback)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxCapsuleControllerDesc_Pod.reportCallback)) == 8, "physx_PxCapsuleControllerDesc_Pod.reportCallback has unexpected size % instead of 8", size_of(type_of(physx_PxCapsuleControllerDesc_Pod.reportCallback)));
    assert(((cast(*void)(*instance.behaviorCallback)) - cast(*void)(*instance)) == 88, "physx_PxCapsuleControllerDesc_Pod.behaviorCallback has unexpected offset % instead of 88", ((cast(*void)(*instance.behaviorCallback)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxCapsuleControllerDesc_Pod.behaviorCallback)) == 8, "physx_PxCapsuleControllerDesc_Pod.behaviorCallback has unexpected size % instead of 8", size_of(type_of(physx_PxCapsuleControllerDesc_Pod.behaviorCallback)));
    assert(((cast(*void)(*instance.nonWalkableMode)) - cast(*void)(*instance)) == 96, "physx_PxCapsuleControllerDesc_Pod.nonWalkableMode has unexpected offset % instead of 96", ((cast(*void)(*instance.nonWalkableMode)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxCapsuleControllerDesc_Pod.nonWalkableMode)) == 4, "physx_PxCapsuleControllerDesc_Pod.nonWalkableMode has unexpected size % instead of 4", size_of(type_of(physx_PxCapsuleControllerDesc_Pod.nonWalkableMode)));
    assert(((cast(*void)(*instance.structgen_pad2)) - cast(*void)(*instance)) == 100, "physx_PxCapsuleControllerDesc_Pod.structgen_pad2 has unexpected offset % instead of 100", ((cast(*void)(*instance.structgen_pad2)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxCapsuleControllerDesc_Pod.structgen_pad2)) == 4, "physx_PxCapsuleControllerDesc_Pod.structgen_pad2 has unexpected size % instead of 4", size_of(type_of(physx_PxCapsuleControllerDesc_Pod.structgen_pad2)));
    assert(((cast(*void)(*instance.material)) - cast(*void)(*instance)) == 104, "physx_PxCapsuleControllerDesc_Pod.material has unexpected offset % instead of 104", ((cast(*void)(*instance.material)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxCapsuleControllerDesc_Pod.material)) == 8, "physx_PxCapsuleControllerDesc_Pod.material has unexpected size % instead of 8", size_of(type_of(physx_PxCapsuleControllerDesc_Pod.material)));
    assert(((cast(*void)(*instance.registerDeletionListener)) - cast(*void)(*instance)) == 112, "physx_PxCapsuleControllerDesc_Pod.registerDeletionListener has unexpected offset % instead of 112", ((cast(*void)(*instance.registerDeletionListener)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxCapsuleControllerDesc_Pod.registerDeletionListener)) == 1, "physx_PxCapsuleControllerDesc_Pod.registerDeletionListener has unexpected size % instead of 1", size_of(type_of(physx_PxCapsuleControllerDesc_Pod.registerDeletionListener)));
    assert(((cast(*void)(*instance.structgen_pad3)) - cast(*void)(*instance)) == 113, "physx_PxCapsuleControllerDesc_Pod.structgen_pad3 has unexpected offset % instead of 113", ((cast(*void)(*instance.structgen_pad3)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxCapsuleControllerDesc_Pod.structgen_pad3)) == 7, "physx_PxCapsuleControllerDesc_Pod.structgen_pad3 has unexpected size % instead of 7", size_of(type_of(physx_PxCapsuleControllerDesc_Pod.structgen_pad3)));
    assert(((cast(*void)(*instance.userData)) - cast(*void)(*instance)) == 120, "physx_PxCapsuleControllerDesc_Pod.userData has unexpected offset % instead of 120", ((cast(*void)(*instance.userData)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxCapsuleControllerDesc_Pod.userData)) == 8, "physx_PxCapsuleControllerDesc_Pod.userData has unexpected size % instead of 8", size_of(type_of(physx_PxCapsuleControllerDesc_Pod.userData)));
    assert(((cast(*void)(*instance.mType)) - cast(*void)(*instance)) == 128, "physx_PxCapsuleControllerDesc_Pod.mType has unexpected offset % instead of 128", ((cast(*void)(*instance.mType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxCapsuleControllerDesc_Pod.mType)) == 4, "physx_PxCapsuleControllerDesc_Pod.mType has unexpected size % instead of 4", size_of(type_of(physx_PxCapsuleControllerDesc_Pod.mType)));
    assert(((cast(*void)(*instance.structgen_pad4)) - cast(*void)(*instance)) == 132, "physx_PxCapsuleControllerDesc_Pod.structgen_pad4 has unexpected offset % instead of 132", ((cast(*void)(*instance.structgen_pad4)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxCapsuleControllerDesc_Pod.structgen_pad4)) == 4, "physx_PxCapsuleControllerDesc_Pod.structgen_pad4 has unexpected size % instead of 4", size_of(type_of(physx_PxCapsuleControllerDesc_Pod.structgen_pad4)));
    assert(((cast(*void)(*instance.radius)) - cast(*void)(*instance)) == 136, "physx_PxCapsuleControllerDesc_Pod.radius has unexpected offset % instead of 136", ((cast(*void)(*instance.radius)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxCapsuleControllerDesc_Pod.radius)) == 4, "physx_PxCapsuleControllerDesc_Pod.radius has unexpected size % instead of 4", size_of(type_of(physx_PxCapsuleControllerDesc_Pod.radius)));
    assert(((cast(*void)(*instance.height)) - cast(*void)(*instance)) == 140, "physx_PxCapsuleControllerDesc_Pod.height has unexpected offset % instead of 140", ((cast(*void)(*instance.height)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxCapsuleControllerDesc_Pod.height)) == 4, "physx_PxCapsuleControllerDesc_Pod.height has unexpected size % instead of 4", size_of(type_of(physx_PxCapsuleControllerDesc_Pod.height)));
    assert(((cast(*void)(*instance.climbingMode)) - cast(*void)(*instance)) == 144, "physx_PxCapsuleControllerDesc_Pod.climbingMode has unexpected offset % instead of 144", ((cast(*void)(*instance.climbingMode)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxCapsuleControllerDesc_Pod.climbingMode)) == 4, "physx_PxCapsuleControllerDesc_Pod.climbingMode has unexpected size % instead of 4", size_of(type_of(physx_PxCapsuleControllerDesc_Pod.climbingMode)));
    assert(((cast(*void)(*instance.structgen_pad5)) - cast(*void)(*instance)) == 148, "physx_PxCapsuleControllerDesc_Pod.structgen_pad5 has unexpected offset % instead of 148", ((cast(*void)(*instance.structgen_pad5)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxCapsuleControllerDesc_Pod.structgen_pad5)) == 4, "physx_PxCapsuleControllerDesc_Pod.structgen_pad5 has unexpected size % instead of 4", size_of(type_of(physx_PxCapsuleControllerDesc_Pod.structgen_pad5)));
    assert(size_of(physx_PxCapsuleControllerDesc_Pod) == 152, "physx_PxCapsuleControllerDesc_Pod has size % instead of 152", size_of(physx_PxCapsuleControllerDesc_Pod));
}

physx_PxCapsuleController_Pod :: struct {
    vtable_: *void;
}
#run {
    instance: physx_PxCapsuleController_Pod;
    assert(((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)) == 0, "physx_PxCapsuleController_Pod.vtable_ has unexpected offset % instead of 0", ((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxCapsuleController_Pod.vtable_)) == 8, "physx_PxCapsuleController_Pod.vtable_ has unexpected size % instead of 8", size_of(type_of(physx_PxCapsuleController_Pod.vtable_)));
    assert(size_of(physx_PxCapsuleController_Pod) == 8, "physx_PxCapsuleController_Pod has size % instead of 8", size_of(physx_PxCapsuleController_Pod));
}

physx_PxControllerBehaviorFlags_Pod :: struct {
    mBits: u8;
}
#run {
    instance: physx_PxControllerBehaviorFlags_Pod;
    assert(((cast(*void)(*instance.mBits)) - cast(*void)(*instance)) == 0, "physx_PxControllerBehaviorFlags_Pod.mBits has unexpected offset % instead of 0", ((cast(*void)(*instance.mBits)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerBehaviorFlags_Pod.mBits)) == 1, "physx_PxControllerBehaviorFlags_Pod.mBits has unexpected size % instead of 1", size_of(type_of(physx_PxControllerBehaviorFlags_Pod.mBits)));
    assert(size_of(physx_PxControllerBehaviorFlags_Pod) == 1, "physx_PxControllerBehaviorFlags_Pod has size % instead of 1", size_of(physx_PxControllerBehaviorFlags_Pod));
}

physx_PxControllerDebugRenderFlags_Pod :: struct {
    mBits: u32;
}
#run {
    instance: physx_PxControllerDebugRenderFlags_Pod;
    assert(((cast(*void)(*instance.mBits)) - cast(*void)(*instance)) == 0, "physx_PxControllerDebugRenderFlags_Pod.mBits has unexpected offset % instead of 0", ((cast(*void)(*instance.mBits)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxControllerDebugRenderFlags_Pod.mBits)) == 4, "physx_PxControllerDebugRenderFlags_Pod.mBits has unexpected size % instead of 4", size_of(type_of(physx_PxControllerDebugRenderFlags_Pod.mBits)));
    assert(size_of(physx_PxControllerDebugRenderFlags_Pod) == 4, "physx_PxControllerDebugRenderFlags_Pod has size % instead of 4", size_of(physx_PxControllerDebugRenderFlags_Pod));
}

physx_PxConvexFlags_Pod :: struct {
    mBits: u16;
}
#run {
    instance: physx_PxConvexFlags_Pod;
    assert(((cast(*void)(*instance.mBits)) - cast(*void)(*instance)) == 0, "physx_PxConvexFlags_Pod.mBits has unexpected offset % instead of 0", ((cast(*void)(*instance.mBits)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxConvexFlags_Pod.mBits)) == 2, "physx_PxConvexFlags_Pod.mBits has unexpected size % instead of 2", size_of(type_of(physx_PxConvexFlags_Pod.mBits)));
    assert(size_of(physx_PxConvexFlags_Pod) == 2, "physx_PxConvexFlags_Pod has size % instead of 2", size_of(physx_PxConvexFlags_Pod));
}

physx_PxConvexMeshDesc_Pod :: struct {
    points:         physx_PxBoundedData_Pod;
    polygons:       physx_PxBoundedData_Pod;
    indices:        physx_PxBoundedData_Pod;
    flags:          physx_PxConvexFlags_Pod;
    vertexLimit:    u16;
    quantizedCount: u16;
    structgen_pad0: [2] u8;
}
#run {
    instance: physx_PxConvexMeshDesc_Pod;
    assert(((cast(*void)(*instance.points)) - cast(*void)(*instance)) == 0, "physx_PxConvexMeshDesc_Pod.points has unexpected offset % instead of 0", ((cast(*void)(*instance.points)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxConvexMeshDesc_Pod.points)) == 24, "physx_PxConvexMeshDesc_Pod.points has unexpected size % instead of 24", size_of(type_of(physx_PxConvexMeshDesc_Pod.points)));
    assert(((cast(*void)(*instance.polygons)) - cast(*void)(*instance)) == 24, "physx_PxConvexMeshDesc_Pod.polygons has unexpected offset % instead of 24", ((cast(*void)(*instance.polygons)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxConvexMeshDesc_Pod.polygons)) == 24, "physx_PxConvexMeshDesc_Pod.polygons has unexpected size % instead of 24", size_of(type_of(physx_PxConvexMeshDesc_Pod.polygons)));
    assert(((cast(*void)(*instance.indices)) - cast(*void)(*instance)) == 48, "physx_PxConvexMeshDesc_Pod.indices has unexpected offset % instead of 48", ((cast(*void)(*instance.indices)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxConvexMeshDesc_Pod.indices)) == 24, "physx_PxConvexMeshDesc_Pod.indices has unexpected size % instead of 24", size_of(type_of(physx_PxConvexMeshDesc_Pod.indices)));
    assert(((cast(*void)(*instance.flags)) - cast(*void)(*instance)) == 72, "physx_PxConvexMeshDesc_Pod.flags has unexpected offset % instead of 72", ((cast(*void)(*instance.flags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxConvexMeshDesc_Pod.flags)) == 2, "physx_PxConvexMeshDesc_Pod.flags has unexpected size % instead of 2", size_of(type_of(physx_PxConvexMeshDesc_Pod.flags)));
    assert(((cast(*void)(*instance.vertexLimit)) - cast(*void)(*instance)) == 74, "physx_PxConvexMeshDesc_Pod.vertexLimit has unexpected offset % instead of 74", ((cast(*void)(*instance.vertexLimit)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxConvexMeshDesc_Pod.vertexLimit)) == 2, "physx_PxConvexMeshDesc_Pod.vertexLimit has unexpected size % instead of 2", size_of(type_of(physx_PxConvexMeshDesc_Pod.vertexLimit)));
    assert(((cast(*void)(*instance.quantizedCount)) - cast(*void)(*instance)) == 76, "physx_PxConvexMeshDesc_Pod.quantizedCount has unexpected offset % instead of 76", ((cast(*void)(*instance.quantizedCount)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxConvexMeshDesc_Pod.quantizedCount)) == 2, "physx_PxConvexMeshDesc_Pod.quantizedCount has unexpected size % instead of 2", size_of(type_of(physx_PxConvexMeshDesc_Pod.quantizedCount)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 78, "physx_PxConvexMeshDesc_Pod.structgen_pad0 has unexpected offset % instead of 78", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxConvexMeshDesc_Pod.structgen_pad0)) == 2, "physx_PxConvexMeshDesc_Pod.structgen_pad0 has unexpected size % instead of 2", size_of(type_of(physx_PxConvexMeshDesc_Pod.structgen_pad0)));
    assert(size_of(physx_PxConvexMeshDesc_Pod) == 80, "physx_PxConvexMeshDesc_Pod has size % instead of 80", size_of(physx_PxConvexMeshDesc_Pod));
}

PxTypedStridedData_physx_PxMaterialTableIndex__Pod :: struct {
    stride: u32;
    data:   *u16;
}
#run {
    instance: PxTypedStridedData_physx_PxMaterialTableIndex__Pod;
    assert(((cast(*void)(*instance.stride)) - cast(*void)(*instance)) == 0, "PxTypedStridedData_physx_PxMaterialTableIndex__Pod.stride has unexpected offset % instead of 0", ((cast(*void)(*instance.stride)) - cast(*void)(*instance)));
    assert(size_of(type_of(PxTypedStridedData_physx_PxMaterialTableIndex__Pod.stride)) == 4, "PxTypedStridedData_physx_PxMaterialTableIndex__Pod.stride has unexpected size % instead of 4", size_of(type_of(PxTypedStridedData_physx_PxMaterialTableIndex__Pod.stride)));
    assert(((cast(*void)(*instance.data)) - cast(*void)(*instance)) == 8, "PxTypedStridedData_physx_PxMaterialTableIndex__Pod.data has unexpected offset % instead of 8", ((cast(*void)(*instance.data)) - cast(*void)(*instance)));
    assert(size_of(type_of(PxTypedStridedData_physx_PxMaterialTableIndex__Pod.data)) == 8, "PxTypedStridedData_physx_PxMaterialTableIndex__Pod.data has unexpected size % instead of 8", size_of(type_of(PxTypedStridedData_physx_PxMaterialTableIndex__Pod.data)));
    assert(size_of(PxTypedStridedData_physx_PxMaterialTableIndex__Pod) == 16, "PxTypedStridedData_physx_PxMaterialTableIndex__Pod has size % instead of 16", size_of(PxTypedStridedData_physx_PxMaterialTableIndex__Pod));
}

physx_PxTriangleMeshDesc_Pod :: struct {
    points:          physx_PxBoundedData_Pod;
    triangles:       physx_PxBoundedData_Pod;
    flags:           physx_PxMeshFlags_Pod;
    structgen_pad0:  [6] u8;
    materialIndices: PxTypedStridedData_physx_PxMaterialTableIndex__Pod;
}
#run {
    instance: physx_PxTriangleMeshDesc_Pod;
    assert(((cast(*void)(*instance.points)) - cast(*void)(*instance)) == 0, "physx_PxTriangleMeshDesc_Pod.points has unexpected offset % instead of 0", ((cast(*void)(*instance.points)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxTriangleMeshDesc_Pod.points)) == 24, "physx_PxTriangleMeshDesc_Pod.points has unexpected size % instead of 24", size_of(type_of(physx_PxTriangleMeshDesc_Pod.points)));
    assert(((cast(*void)(*instance.triangles)) - cast(*void)(*instance)) == 24, "physx_PxTriangleMeshDesc_Pod.triangles has unexpected offset % instead of 24", ((cast(*void)(*instance.triangles)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxTriangleMeshDesc_Pod.triangles)) == 24, "physx_PxTriangleMeshDesc_Pod.triangles has unexpected size % instead of 24", size_of(type_of(physx_PxTriangleMeshDesc_Pod.triangles)));
    assert(((cast(*void)(*instance.flags)) - cast(*void)(*instance)) == 48, "physx_PxTriangleMeshDesc_Pod.flags has unexpected offset % instead of 48", ((cast(*void)(*instance.flags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxTriangleMeshDesc_Pod.flags)) == 2, "physx_PxTriangleMeshDesc_Pod.flags has unexpected size % instead of 2", size_of(type_of(physx_PxTriangleMeshDesc_Pod.flags)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 50, "physx_PxTriangleMeshDesc_Pod.structgen_pad0 has unexpected offset % instead of 50", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxTriangleMeshDesc_Pod.structgen_pad0)) == 6, "physx_PxTriangleMeshDesc_Pod.structgen_pad0 has unexpected size % instead of 6", size_of(type_of(physx_PxTriangleMeshDesc_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.materialIndices)) - cast(*void)(*instance)) == 56, "physx_PxTriangleMeshDesc_Pod.materialIndices has unexpected offset % instead of 56", ((cast(*void)(*instance.materialIndices)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxTriangleMeshDesc_Pod.materialIndices)) == 16, "physx_PxTriangleMeshDesc_Pod.materialIndices has unexpected size % instead of 16", size_of(type_of(physx_PxTriangleMeshDesc_Pod.materialIndices)));
    assert(size_of(physx_PxTriangleMeshDesc_Pod) == 72, "physx_PxTriangleMeshDesc_Pod has size % instead of 72", size_of(physx_PxTriangleMeshDesc_Pod));
}

physx_PxBVH33MidphaseDesc_Pod :: struct {
    meshSizePerformanceTradeOff: float;
    meshCookingHint:             u32;
}
#run {
    instance: physx_PxBVH33MidphaseDesc_Pod;
    assert(((cast(*void)(*instance.meshSizePerformanceTradeOff)) - cast(*void)(*instance)) == 0, "physx_PxBVH33MidphaseDesc_Pod.meshSizePerformanceTradeOff has unexpected offset % instead of 0", ((cast(*void)(*instance.meshSizePerformanceTradeOff)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBVH33MidphaseDesc_Pod.meshSizePerformanceTradeOff)) == 4, "physx_PxBVH33MidphaseDesc_Pod.meshSizePerformanceTradeOff has unexpected size % instead of 4", size_of(type_of(physx_PxBVH33MidphaseDesc_Pod.meshSizePerformanceTradeOff)));
    assert(((cast(*void)(*instance.meshCookingHint)) - cast(*void)(*instance)) == 4, "physx_PxBVH33MidphaseDesc_Pod.meshCookingHint has unexpected offset % instead of 4", ((cast(*void)(*instance.meshCookingHint)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBVH33MidphaseDesc_Pod.meshCookingHint)) == 4, "physx_PxBVH33MidphaseDesc_Pod.meshCookingHint has unexpected size % instead of 4", size_of(type_of(physx_PxBVH33MidphaseDesc_Pod.meshCookingHint)));
    assert(size_of(physx_PxBVH33MidphaseDesc_Pod) == 8, "physx_PxBVH33MidphaseDesc_Pod has size % instead of 8", size_of(physx_PxBVH33MidphaseDesc_Pod));
}

physx_PxBVH34MidphaseDesc_Pod :: struct {
    numPrimsPerLeaf: u32;
}
#run {
    instance: physx_PxBVH34MidphaseDesc_Pod;
    assert(((cast(*void)(*instance.numPrimsPerLeaf)) - cast(*void)(*instance)) == 0, "physx_PxBVH34MidphaseDesc_Pod.numPrimsPerLeaf has unexpected offset % instead of 0", ((cast(*void)(*instance.numPrimsPerLeaf)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBVH34MidphaseDesc_Pod.numPrimsPerLeaf)) == 4, "physx_PxBVH34MidphaseDesc_Pod.numPrimsPerLeaf has unexpected size % instead of 4", size_of(type_of(physx_PxBVH34MidphaseDesc_Pod.numPrimsPerLeaf)));
    assert(size_of(physx_PxBVH34MidphaseDesc_Pod) == 4, "physx_PxBVH34MidphaseDesc_Pod has size % instead of 4", size_of(physx_PxBVH34MidphaseDesc_Pod));
}

Anonymous217_Pod :: struct {
    mBVH33Desc: physx_PxBVH33MidphaseDesc_Pod;
    mBVH34Desc: physx_PxBVH34MidphaseDesc_Pod;
}
#run {
    instance: Anonymous217_Pod;
    assert(((cast(*void)(*instance.mBVH33Desc)) - cast(*void)(*instance)) == 0, "Anonymous217_Pod.mBVH33Desc has unexpected offset % instead of 0", ((cast(*void)(*instance.mBVH33Desc)) - cast(*void)(*instance)));
    assert(size_of(type_of(Anonymous217_Pod.mBVH33Desc)) == 8, "Anonymous217_Pod.mBVH33Desc has unexpected size % instead of 8", size_of(type_of(Anonymous217_Pod.mBVH33Desc)));
    assert(((cast(*void)(*instance.mBVH34Desc)) - cast(*void)(*instance)) == 8, "Anonymous217_Pod.mBVH34Desc has unexpected offset % instead of 8", ((cast(*void)(*instance.mBVH34Desc)) - cast(*void)(*instance)));
    assert(size_of(type_of(Anonymous217_Pod.mBVH34Desc)) == 4, "Anonymous217_Pod.mBVH34Desc has unexpected size % instead of 4", size_of(type_of(Anonymous217_Pod.mBVH34Desc)));
    assert(size_of(Anonymous217_Pod) == 12, "Anonymous217_Pod has size % instead of 12", size_of(Anonymous217_Pod));
}

physx_PxMidphaseDesc_Pod :: struct {
    structgen_pad0: [8] u8;
    mType:          u32;
}
#run {
    instance: physx_PxMidphaseDesc_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxMidphaseDesc_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxMidphaseDesc_Pod.structgen_pad0)) == 8, "physx_PxMidphaseDesc_Pod.structgen_pad0 has unexpected size % instead of 8", size_of(type_of(physx_PxMidphaseDesc_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.mType)) - cast(*void)(*instance)) == 8, "physx_PxMidphaseDesc_Pod.mType has unexpected offset % instead of 8", ((cast(*void)(*instance.mType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxMidphaseDesc_Pod.mType)) == 4, "physx_PxMidphaseDesc_Pod.mType has unexpected size % instead of 4", size_of(type_of(physx_PxMidphaseDesc_Pod.mType)));
    assert(size_of(physx_PxMidphaseDesc_Pod) == 12, "physx_PxMidphaseDesc_Pod has size % instead of 12", size_of(physx_PxMidphaseDesc_Pod));
}

physx_PxBVHStructureDesc_Pod :: struct {
    bounds: physx_PxBoundedData_Pod;
}
#run {
    instance: physx_PxBVHStructureDesc_Pod;
    assert(((cast(*void)(*instance.bounds)) - cast(*void)(*instance)) == 0, "physx_PxBVHStructureDesc_Pod.bounds has unexpected offset % instead of 0", ((cast(*void)(*instance.bounds)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBVHStructureDesc_Pod.bounds)) == 24, "physx_PxBVHStructureDesc_Pod.bounds has unexpected size % instead of 24", size_of(type_of(physx_PxBVHStructureDesc_Pod.bounds)));
    assert(size_of(physx_PxBVHStructureDesc_Pod) == 24, "physx_PxBVHStructureDesc_Pod has size % instead of 24", size_of(physx_PxBVHStructureDesc_Pod));
}

physx_PxMeshPreprocessingFlags_Pod :: struct {
    mBits: u32;
}
#run {
    instance: physx_PxMeshPreprocessingFlags_Pod;
    assert(((cast(*void)(*instance.mBits)) - cast(*void)(*instance)) == 0, "physx_PxMeshPreprocessingFlags_Pod.mBits has unexpected offset % instead of 0", ((cast(*void)(*instance.mBits)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxMeshPreprocessingFlags_Pod.mBits)) == 4, "physx_PxMeshPreprocessingFlags_Pod.mBits has unexpected size % instead of 4", size_of(type_of(physx_PxMeshPreprocessingFlags_Pod.mBits)));
    assert(size_of(physx_PxMeshPreprocessingFlags_Pod) == 4, "physx_PxMeshPreprocessingFlags_Pod has size % instead of 4", size_of(physx_PxMeshPreprocessingFlags_Pod));
}

physx_PxCookingParams_Pod :: struct {
    areaTestEpsilon:                float;
    planeTolerance:                 float;
    convexMeshCookingType:          u32;
    suppressTriangleMeshRemapTable: bool;
    buildTriangleAdjacencies:       bool;
    buildGPUData:                   bool;
    structgen_pad0:                 [1] u8;
    scale:                          physx_PxTolerancesScale_Pod;
    meshPreprocessParams:           physx_PxMeshPreprocessingFlags_Pod;
    meshWeldTolerance:              float;
    midphaseDesc:                   physx_PxMidphaseDesc_Pod;
    gaussMapLimit:                  u32;
}
#run {
    instance: physx_PxCookingParams_Pod;
    assert(((cast(*void)(*instance.areaTestEpsilon)) - cast(*void)(*instance)) == 0, "physx_PxCookingParams_Pod.areaTestEpsilon has unexpected offset % instead of 0", ((cast(*void)(*instance.areaTestEpsilon)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxCookingParams_Pod.areaTestEpsilon)) == 4, "physx_PxCookingParams_Pod.areaTestEpsilon has unexpected size % instead of 4", size_of(type_of(physx_PxCookingParams_Pod.areaTestEpsilon)));
    assert(((cast(*void)(*instance.planeTolerance)) - cast(*void)(*instance)) == 4, "physx_PxCookingParams_Pod.planeTolerance has unexpected offset % instead of 4", ((cast(*void)(*instance.planeTolerance)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxCookingParams_Pod.planeTolerance)) == 4, "physx_PxCookingParams_Pod.planeTolerance has unexpected size % instead of 4", size_of(type_of(physx_PxCookingParams_Pod.planeTolerance)));
    assert(((cast(*void)(*instance.convexMeshCookingType)) - cast(*void)(*instance)) == 8, "physx_PxCookingParams_Pod.convexMeshCookingType has unexpected offset % instead of 8", ((cast(*void)(*instance.convexMeshCookingType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxCookingParams_Pod.convexMeshCookingType)) == 4, "physx_PxCookingParams_Pod.convexMeshCookingType has unexpected size % instead of 4", size_of(type_of(physx_PxCookingParams_Pod.convexMeshCookingType)));
    assert(((cast(*void)(*instance.suppressTriangleMeshRemapTable)) - cast(*void)(*instance)) == 12, "physx_PxCookingParams_Pod.suppressTriangleMeshRemapTable has unexpected offset % instead of 12", ((cast(*void)(*instance.suppressTriangleMeshRemapTable)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxCookingParams_Pod.suppressTriangleMeshRemapTable)) == 1, "physx_PxCookingParams_Pod.suppressTriangleMeshRemapTable has unexpected size % instead of 1", size_of(type_of(physx_PxCookingParams_Pod.suppressTriangleMeshRemapTable)));
    assert(((cast(*void)(*instance.buildTriangleAdjacencies)) - cast(*void)(*instance)) == 13, "physx_PxCookingParams_Pod.buildTriangleAdjacencies has unexpected offset % instead of 13", ((cast(*void)(*instance.buildTriangleAdjacencies)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxCookingParams_Pod.buildTriangleAdjacencies)) == 1, "physx_PxCookingParams_Pod.buildTriangleAdjacencies has unexpected size % instead of 1", size_of(type_of(physx_PxCookingParams_Pod.buildTriangleAdjacencies)));
    assert(((cast(*void)(*instance.buildGPUData)) - cast(*void)(*instance)) == 14, "physx_PxCookingParams_Pod.buildGPUData has unexpected offset % instead of 14", ((cast(*void)(*instance.buildGPUData)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxCookingParams_Pod.buildGPUData)) == 1, "physx_PxCookingParams_Pod.buildGPUData has unexpected size % instead of 1", size_of(type_of(physx_PxCookingParams_Pod.buildGPUData)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 15, "physx_PxCookingParams_Pod.structgen_pad0 has unexpected offset % instead of 15", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxCookingParams_Pod.structgen_pad0)) == 1, "physx_PxCookingParams_Pod.structgen_pad0 has unexpected size % instead of 1", size_of(type_of(physx_PxCookingParams_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.scale)) - cast(*void)(*instance)) == 16, "physx_PxCookingParams_Pod.scale has unexpected offset % instead of 16", ((cast(*void)(*instance.scale)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxCookingParams_Pod.scale)) == 8, "physx_PxCookingParams_Pod.scale has unexpected size % instead of 8", size_of(type_of(physx_PxCookingParams_Pod.scale)));
    assert(((cast(*void)(*instance.meshPreprocessParams)) - cast(*void)(*instance)) == 24, "physx_PxCookingParams_Pod.meshPreprocessParams has unexpected offset % instead of 24", ((cast(*void)(*instance.meshPreprocessParams)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxCookingParams_Pod.meshPreprocessParams)) == 4, "physx_PxCookingParams_Pod.meshPreprocessParams has unexpected size % instead of 4", size_of(type_of(physx_PxCookingParams_Pod.meshPreprocessParams)));
    assert(((cast(*void)(*instance.meshWeldTolerance)) - cast(*void)(*instance)) == 28, "physx_PxCookingParams_Pod.meshWeldTolerance has unexpected offset % instead of 28", ((cast(*void)(*instance.meshWeldTolerance)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxCookingParams_Pod.meshWeldTolerance)) == 4, "physx_PxCookingParams_Pod.meshWeldTolerance has unexpected size % instead of 4", size_of(type_of(physx_PxCookingParams_Pod.meshWeldTolerance)));
    assert(((cast(*void)(*instance.midphaseDesc)) - cast(*void)(*instance)) == 32, "physx_PxCookingParams_Pod.midphaseDesc has unexpected offset % instead of 32", ((cast(*void)(*instance.midphaseDesc)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxCookingParams_Pod.midphaseDesc)) == 12, "physx_PxCookingParams_Pod.midphaseDesc has unexpected size % instead of 12", size_of(type_of(physx_PxCookingParams_Pod.midphaseDesc)));
    assert(((cast(*void)(*instance.gaussMapLimit)) - cast(*void)(*instance)) == 44, "physx_PxCookingParams_Pod.gaussMapLimit has unexpected offset % instead of 44", ((cast(*void)(*instance.gaussMapLimit)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxCookingParams_Pod.gaussMapLimit)) == 4, "physx_PxCookingParams_Pod.gaussMapLimit has unexpected size % instead of 4", size_of(type_of(physx_PxCookingParams_Pod.gaussMapLimit)));
    assert(size_of(physx_PxCookingParams_Pod) == 48, "physx_PxCookingParams_Pod has size % instead of 48", size_of(physx_PxCookingParams_Pod));
}

physx_PxCooking_Pod :: struct {
    vtable_: *void;
}
#run {
    instance: physx_PxCooking_Pod;
    assert(((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)) == 0, "physx_PxCooking_Pod.vtable_ has unexpected offset % instead of 0", ((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxCooking_Pod.vtable_)) == 8, "physx_PxCooking_Pod.vtable_ has unexpected size % instead of 8", size_of(type_of(physx_PxCooking_Pod.vtable_)));
    assert(size_of(physx_PxCooking_Pod) == 8, "physx_PxCooking_Pod has size % instead of 8", size_of(physx_PxCooking_Pod));
}

physx_PxDefaultMemoryOutputStream_Pod :: struct {
    structgen_pad0: [32] u8;
}
#run {
    instance: physx_PxDefaultMemoryOutputStream_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxDefaultMemoryOutputStream_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxDefaultMemoryOutputStream_Pod.structgen_pad0)) == 32, "physx_PxDefaultMemoryOutputStream_Pod.structgen_pad0 has unexpected size % instead of 32", size_of(type_of(physx_PxDefaultMemoryOutputStream_Pod.structgen_pad0)));
    assert(size_of(physx_PxDefaultMemoryOutputStream_Pod) == 32, "physx_PxDefaultMemoryOutputStream_Pod has size % instead of 32", size_of(physx_PxDefaultMemoryOutputStream_Pod));
}

physx_PxDefaultMemoryInputData_Pod :: struct {
    structgen_pad0: [32] u8;
}
#run {
    instance: physx_PxDefaultMemoryInputData_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxDefaultMemoryInputData_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxDefaultMemoryInputData_Pod.structgen_pad0)) == 32, "physx_PxDefaultMemoryInputData_Pod.structgen_pad0 has unexpected size % instead of 32", size_of(type_of(physx_PxDefaultMemoryInputData_Pod.structgen_pad0)));
    assert(size_of(physx_PxDefaultMemoryInputData_Pod) == 32, "physx_PxDefaultMemoryInputData_Pod has size % instead of 32", size_of(physx_PxDefaultMemoryInputData_Pod));
}

physx_PxDefaultFileOutputStream_Pod :: struct {
    structgen_pad0: [16] u8;
}
#run {
    instance: physx_PxDefaultFileOutputStream_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxDefaultFileOutputStream_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxDefaultFileOutputStream_Pod.structgen_pad0)) == 16, "physx_PxDefaultFileOutputStream_Pod.structgen_pad0 has unexpected size % instead of 16", size_of(type_of(physx_PxDefaultFileOutputStream_Pod.structgen_pad0)));
    assert(size_of(physx_PxDefaultFileOutputStream_Pod) == 16, "physx_PxDefaultFileOutputStream_Pod has size % instead of 16", size_of(physx_PxDefaultFileOutputStream_Pod));
}

physx_PxDefaultFileInputData_Pod :: struct {
    structgen_pad0: [24] u8;
}
#run {
    instance: physx_PxDefaultFileInputData_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxDefaultFileInputData_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxDefaultFileInputData_Pod.structgen_pad0)) == 24, "physx_PxDefaultFileInputData_Pod.structgen_pad0 has unexpected size % instead of 24", size_of(type_of(physx_PxDefaultFileInputData_Pod.structgen_pad0)));
    assert(size_of(physx_PxDefaultFileInputData_Pod) == 24, "physx_PxDefaultFileInputData_Pod has size % instead of 24", size_of(physx_PxDefaultFileInputData_Pod));
}

physx_PxSpring_Pod :: struct {
    stiffness: float;
    damping:   float;
}
#run {
    instance: physx_PxSpring_Pod;
    assert(((cast(*void)(*instance.stiffness)) - cast(*void)(*instance)) == 0, "physx_PxSpring_Pod.stiffness has unexpected offset % instead of 0", ((cast(*void)(*instance.stiffness)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSpring_Pod.stiffness)) == 4, "physx_PxSpring_Pod.stiffness has unexpected size % instead of 4", size_of(type_of(physx_PxSpring_Pod.stiffness)));
    assert(((cast(*void)(*instance.damping)) - cast(*void)(*instance)) == 4, "physx_PxSpring_Pod.damping has unexpected offset % instead of 4", ((cast(*void)(*instance.damping)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSpring_Pod.damping)) == 4, "physx_PxSpring_Pod.damping has unexpected size % instead of 4", size_of(type_of(physx_PxSpring_Pod.damping)));
    assert(size_of(physx_PxSpring_Pod) == 8, "physx_PxSpring_Pod has size % instead of 8", size_of(physx_PxSpring_Pod));
}

physx_PxDistanceJoint_Pod :: struct {
    structgen_pad0: [8] u8;
    mConcreteType:  u16;
    mBaseFlags:     physx_PxBaseFlags_Pod;
    structgen_pad1: [4] u8;
    userData:       *void;
}
#run {
    instance: physx_PxDistanceJoint_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxDistanceJoint_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxDistanceJoint_Pod.structgen_pad0)) == 8, "physx_PxDistanceJoint_Pod.structgen_pad0 has unexpected size % instead of 8", size_of(type_of(physx_PxDistanceJoint_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)) == 8, "physx_PxDistanceJoint_Pod.mConcreteType has unexpected offset % instead of 8", ((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxDistanceJoint_Pod.mConcreteType)) == 2, "physx_PxDistanceJoint_Pod.mConcreteType has unexpected size % instead of 2", size_of(type_of(physx_PxDistanceJoint_Pod.mConcreteType)));
    assert(((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)) == 10, "physx_PxDistanceJoint_Pod.mBaseFlags has unexpected offset % instead of 10", ((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxDistanceJoint_Pod.mBaseFlags)) == 2, "physx_PxDistanceJoint_Pod.mBaseFlags has unexpected size % instead of 2", size_of(type_of(physx_PxDistanceJoint_Pod.mBaseFlags)));
    assert(((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)) == 12, "physx_PxDistanceJoint_Pod.structgen_pad1 has unexpected offset % instead of 12", ((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxDistanceJoint_Pod.structgen_pad1)) == 4, "physx_PxDistanceJoint_Pod.structgen_pad1 has unexpected size % instead of 4", size_of(type_of(physx_PxDistanceJoint_Pod.structgen_pad1)));
    assert(((cast(*void)(*instance.userData)) - cast(*void)(*instance)) == 16, "physx_PxDistanceJoint_Pod.userData has unexpected offset % instead of 16", ((cast(*void)(*instance.userData)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxDistanceJoint_Pod.userData)) == 8, "physx_PxDistanceJoint_Pod.userData has unexpected size % instead of 8", size_of(type_of(physx_PxDistanceJoint_Pod.userData)));
    assert(size_of(physx_PxDistanceJoint_Pod) == 24, "physx_PxDistanceJoint_Pod has size % instead of 24", size_of(physx_PxDistanceJoint_Pod));
}

physx_PxDistanceJointFlags_Pod :: struct {
    mBits: u16;
}
#run {
    instance: physx_PxDistanceJointFlags_Pod;
    assert(((cast(*void)(*instance.mBits)) - cast(*void)(*instance)) == 0, "physx_PxDistanceJointFlags_Pod.mBits has unexpected offset % instead of 0", ((cast(*void)(*instance.mBits)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxDistanceJointFlags_Pod.mBits)) == 2, "physx_PxDistanceJointFlags_Pod.mBits has unexpected size % instead of 2", size_of(type_of(physx_PxDistanceJointFlags_Pod.mBits)));
    assert(size_of(physx_PxDistanceJointFlags_Pod) == 2, "physx_PxDistanceJointFlags_Pod has size % instead of 2", size_of(physx_PxDistanceJointFlags_Pod));
}

physx_PxDefaultAllocator_Pod :: struct {
    vtable_: *void;
}
#run {
    instance: physx_PxDefaultAllocator_Pod;
    assert(((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)) == 0, "physx_PxDefaultAllocator_Pod.vtable_ has unexpected offset % instead of 0", ((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxDefaultAllocator_Pod.vtable_)) == 8, "physx_PxDefaultAllocator_Pod.vtable_ has unexpected size % instead of 8", size_of(type_of(physx_PxDefaultAllocator_Pod.vtable_)));
    assert(size_of(physx_PxDefaultAllocator_Pod) == 8, "physx_PxDefaultAllocator_Pod has size % instead of 8", size_of(physx_PxDefaultAllocator_Pod));
}

physx_PxContactJoint_Pod :: struct {
    structgen_pad0: [8] u8;
    mConcreteType:  u16;
    mBaseFlags:     physx_PxBaseFlags_Pod;
    structgen_pad1: [4] u8;
    userData:       *void;
}
#run {
    instance: physx_PxContactJoint_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxContactJoint_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactJoint_Pod.structgen_pad0)) == 8, "physx_PxContactJoint_Pod.structgen_pad0 has unexpected size % instead of 8", size_of(type_of(physx_PxContactJoint_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)) == 8, "physx_PxContactJoint_Pod.mConcreteType has unexpected offset % instead of 8", ((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactJoint_Pod.mConcreteType)) == 2, "physx_PxContactJoint_Pod.mConcreteType has unexpected size % instead of 2", size_of(type_of(physx_PxContactJoint_Pod.mConcreteType)));
    assert(((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)) == 10, "physx_PxContactJoint_Pod.mBaseFlags has unexpected offset % instead of 10", ((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactJoint_Pod.mBaseFlags)) == 2, "physx_PxContactJoint_Pod.mBaseFlags has unexpected size % instead of 2", size_of(type_of(physx_PxContactJoint_Pod.mBaseFlags)));
    assert(((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)) == 12, "physx_PxContactJoint_Pod.structgen_pad1 has unexpected offset % instead of 12", ((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactJoint_Pod.structgen_pad1)) == 4, "physx_PxContactJoint_Pod.structgen_pad1 has unexpected size % instead of 4", size_of(type_of(physx_PxContactJoint_Pod.structgen_pad1)));
    assert(((cast(*void)(*instance.userData)) - cast(*void)(*instance)) == 16, "physx_PxContactJoint_Pod.userData has unexpected offset % instead of 16", ((cast(*void)(*instance.userData)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxContactJoint_Pod.userData)) == 8, "physx_PxContactJoint_Pod.userData has unexpected size % instead of 8", size_of(type_of(physx_PxContactJoint_Pod.userData)));
    assert(size_of(physx_PxContactJoint_Pod) == 24, "physx_PxContactJoint_Pod has size % instead of 24", size_of(physx_PxContactJoint_Pod));
}

physx_PxJacobianRow_Pod :: struct {
    linear0:  physx_PxVec3_Pod;
    linear1:  physx_PxVec3_Pod;
    angular0: physx_PxVec3_Pod;
    angular1: physx_PxVec3_Pod;
}
#run {
    instance: physx_PxJacobianRow_Pod;
    assert(((cast(*void)(*instance.linear0)) - cast(*void)(*instance)) == 0, "physx_PxJacobianRow_Pod.linear0 has unexpected offset % instead of 0", ((cast(*void)(*instance.linear0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxJacobianRow_Pod.linear0)) == 12, "physx_PxJacobianRow_Pod.linear0 has unexpected size % instead of 12", size_of(type_of(physx_PxJacobianRow_Pod.linear0)));
    assert(((cast(*void)(*instance.linear1)) - cast(*void)(*instance)) == 12, "physx_PxJacobianRow_Pod.linear1 has unexpected offset % instead of 12", ((cast(*void)(*instance.linear1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxJacobianRow_Pod.linear1)) == 12, "physx_PxJacobianRow_Pod.linear1 has unexpected size % instead of 12", size_of(type_of(physx_PxJacobianRow_Pod.linear1)));
    assert(((cast(*void)(*instance.angular0)) - cast(*void)(*instance)) == 24, "physx_PxJacobianRow_Pod.angular0 has unexpected offset % instead of 24", ((cast(*void)(*instance.angular0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxJacobianRow_Pod.angular0)) == 12, "physx_PxJacobianRow_Pod.angular0 has unexpected size % instead of 12", size_of(type_of(physx_PxJacobianRow_Pod.angular0)));
    assert(((cast(*void)(*instance.angular1)) - cast(*void)(*instance)) == 36, "physx_PxJacobianRow_Pod.angular1 has unexpected offset % instead of 36", ((cast(*void)(*instance.angular1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxJacobianRow_Pod.angular1)) == 12, "physx_PxJacobianRow_Pod.angular1 has unexpected size % instead of 12", size_of(type_of(physx_PxJacobianRow_Pod.angular1)));
    assert(size_of(physx_PxJacobianRow_Pod) == 48, "physx_PxJacobianRow_Pod has size % instead of 48", size_of(physx_PxJacobianRow_Pod));
}

physx_PxFixedJoint_Pod :: struct {
    structgen_pad0: [8] u8;
    mConcreteType:  u16;
    mBaseFlags:     physx_PxBaseFlags_Pod;
    structgen_pad1: [4] u8;
    userData:       *void;
}
#run {
    instance: physx_PxFixedJoint_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxFixedJoint_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxFixedJoint_Pod.structgen_pad0)) == 8, "physx_PxFixedJoint_Pod.structgen_pad0 has unexpected size % instead of 8", size_of(type_of(physx_PxFixedJoint_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)) == 8, "physx_PxFixedJoint_Pod.mConcreteType has unexpected offset % instead of 8", ((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxFixedJoint_Pod.mConcreteType)) == 2, "physx_PxFixedJoint_Pod.mConcreteType has unexpected size % instead of 2", size_of(type_of(physx_PxFixedJoint_Pod.mConcreteType)));
    assert(((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)) == 10, "physx_PxFixedJoint_Pod.mBaseFlags has unexpected offset % instead of 10", ((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxFixedJoint_Pod.mBaseFlags)) == 2, "physx_PxFixedJoint_Pod.mBaseFlags has unexpected size % instead of 2", size_of(type_of(physx_PxFixedJoint_Pod.mBaseFlags)));
    assert(((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)) == 12, "physx_PxFixedJoint_Pod.structgen_pad1 has unexpected offset % instead of 12", ((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxFixedJoint_Pod.structgen_pad1)) == 4, "physx_PxFixedJoint_Pod.structgen_pad1 has unexpected size % instead of 4", size_of(type_of(physx_PxFixedJoint_Pod.structgen_pad1)));
    assert(((cast(*void)(*instance.userData)) - cast(*void)(*instance)) == 16, "physx_PxFixedJoint_Pod.userData has unexpected offset % instead of 16", ((cast(*void)(*instance.userData)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxFixedJoint_Pod.userData)) == 8, "physx_PxFixedJoint_Pod.userData has unexpected size % instead of 8", size_of(type_of(physx_PxFixedJoint_Pod.userData)));
    assert(size_of(physx_PxFixedJoint_Pod) == 24, "physx_PxFixedJoint_Pod has size % instead of 24", size_of(physx_PxFixedJoint_Pod));
}

physx_PxJointLimitParameters_Pod :: struct {
    restitution:     float;
    bounceThreshold: float;
    stiffness:       float;
    damping:         float;
    contactDistance: float;
}
#run {
    instance: physx_PxJointLimitParameters_Pod;
    assert(((cast(*void)(*instance.restitution)) - cast(*void)(*instance)) == 0, "physx_PxJointLimitParameters_Pod.restitution has unexpected offset % instead of 0", ((cast(*void)(*instance.restitution)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxJointLimitParameters_Pod.restitution)) == 4, "physx_PxJointLimitParameters_Pod.restitution has unexpected size % instead of 4", size_of(type_of(physx_PxJointLimitParameters_Pod.restitution)));
    assert(((cast(*void)(*instance.bounceThreshold)) - cast(*void)(*instance)) == 4, "physx_PxJointLimitParameters_Pod.bounceThreshold has unexpected offset % instead of 4", ((cast(*void)(*instance.bounceThreshold)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxJointLimitParameters_Pod.bounceThreshold)) == 4, "physx_PxJointLimitParameters_Pod.bounceThreshold has unexpected size % instead of 4", size_of(type_of(physx_PxJointLimitParameters_Pod.bounceThreshold)));
    assert(((cast(*void)(*instance.stiffness)) - cast(*void)(*instance)) == 8, "physx_PxJointLimitParameters_Pod.stiffness has unexpected offset % instead of 8", ((cast(*void)(*instance.stiffness)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxJointLimitParameters_Pod.stiffness)) == 4, "physx_PxJointLimitParameters_Pod.stiffness has unexpected size % instead of 4", size_of(type_of(physx_PxJointLimitParameters_Pod.stiffness)));
    assert(((cast(*void)(*instance.damping)) - cast(*void)(*instance)) == 12, "physx_PxJointLimitParameters_Pod.damping has unexpected offset % instead of 12", ((cast(*void)(*instance.damping)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxJointLimitParameters_Pod.damping)) == 4, "physx_PxJointLimitParameters_Pod.damping has unexpected size % instead of 4", size_of(type_of(physx_PxJointLimitParameters_Pod.damping)));
    assert(((cast(*void)(*instance.contactDistance)) - cast(*void)(*instance)) == 16, "physx_PxJointLimitParameters_Pod.contactDistance has unexpected offset % instead of 16", ((cast(*void)(*instance.contactDistance)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxJointLimitParameters_Pod.contactDistance)) == 4, "physx_PxJointLimitParameters_Pod.contactDistance has unexpected size % instead of 4", size_of(type_of(physx_PxJointLimitParameters_Pod.contactDistance)));
    assert(size_of(physx_PxJointLimitParameters_Pod) == 20, "physx_PxJointLimitParameters_Pod has size % instead of 20", size_of(physx_PxJointLimitParameters_Pod));
}

physx_PxJointLinearLimit_Pod :: struct {
    restitution:     float;
    bounceThreshold: float;
    stiffness:       float;
    damping:         float;
    contactDistance: float;
    value:           float;
}
#run {
    instance: physx_PxJointLinearLimit_Pod;
    assert(((cast(*void)(*instance.restitution)) - cast(*void)(*instance)) == 0, "physx_PxJointLinearLimit_Pod.restitution has unexpected offset % instead of 0", ((cast(*void)(*instance.restitution)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxJointLinearLimit_Pod.restitution)) == 4, "physx_PxJointLinearLimit_Pod.restitution has unexpected size % instead of 4", size_of(type_of(physx_PxJointLinearLimit_Pod.restitution)));
    assert(((cast(*void)(*instance.bounceThreshold)) - cast(*void)(*instance)) == 4, "physx_PxJointLinearLimit_Pod.bounceThreshold has unexpected offset % instead of 4", ((cast(*void)(*instance.bounceThreshold)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxJointLinearLimit_Pod.bounceThreshold)) == 4, "physx_PxJointLinearLimit_Pod.bounceThreshold has unexpected size % instead of 4", size_of(type_of(physx_PxJointLinearLimit_Pod.bounceThreshold)));
    assert(((cast(*void)(*instance.stiffness)) - cast(*void)(*instance)) == 8, "physx_PxJointLinearLimit_Pod.stiffness has unexpected offset % instead of 8", ((cast(*void)(*instance.stiffness)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxJointLinearLimit_Pod.stiffness)) == 4, "physx_PxJointLinearLimit_Pod.stiffness has unexpected size % instead of 4", size_of(type_of(physx_PxJointLinearLimit_Pod.stiffness)));
    assert(((cast(*void)(*instance.damping)) - cast(*void)(*instance)) == 12, "physx_PxJointLinearLimit_Pod.damping has unexpected offset % instead of 12", ((cast(*void)(*instance.damping)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxJointLinearLimit_Pod.damping)) == 4, "physx_PxJointLinearLimit_Pod.damping has unexpected size % instead of 4", size_of(type_of(physx_PxJointLinearLimit_Pod.damping)));
    assert(((cast(*void)(*instance.contactDistance)) - cast(*void)(*instance)) == 16, "physx_PxJointLinearLimit_Pod.contactDistance has unexpected offset % instead of 16", ((cast(*void)(*instance.contactDistance)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxJointLinearLimit_Pod.contactDistance)) == 4, "physx_PxJointLinearLimit_Pod.contactDistance has unexpected size % instead of 4", size_of(type_of(physx_PxJointLinearLimit_Pod.contactDistance)));
    assert(((cast(*void)(*instance.value)) - cast(*void)(*instance)) == 20, "physx_PxJointLinearLimit_Pod.value has unexpected offset % instead of 20", ((cast(*void)(*instance.value)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxJointLinearLimit_Pod.value)) == 4, "physx_PxJointLinearLimit_Pod.value has unexpected size % instead of 4", size_of(type_of(physx_PxJointLinearLimit_Pod.value)));
    assert(size_of(physx_PxJointLinearLimit_Pod) == 24, "physx_PxJointLinearLimit_Pod has size % instead of 24", size_of(physx_PxJointLinearLimit_Pod));
}

physx_PxJointLinearLimitPair_Pod :: struct {
    restitution:     float;
    bounceThreshold: float;
    stiffness:       float;
    damping:         float;
    contactDistance: float;
    upper:           float;
    lower:           float;
}
#run {
    instance: physx_PxJointLinearLimitPair_Pod;
    assert(((cast(*void)(*instance.restitution)) - cast(*void)(*instance)) == 0, "physx_PxJointLinearLimitPair_Pod.restitution has unexpected offset % instead of 0", ((cast(*void)(*instance.restitution)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxJointLinearLimitPair_Pod.restitution)) == 4, "physx_PxJointLinearLimitPair_Pod.restitution has unexpected size % instead of 4", size_of(type_of(physx_PxJointLinearLimitPair_Pod.restitution)));
    assert(((cast(*void)(*instance.bounceThreshold)) - cast(*void)(*instance)) == 4, "physx_PxJointLinearLimitPair_Pod.bounceThreshold has unexpected offset % instead of 4", ((cast(*void)(*instance.bounceThreshold)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxJointLinearLimitPair_Pod.bounceThreshold)) == 4, "physx_PxJointLinearLimitPair_Pod.bounceThreshold has unexpected size % instead of 4", size_of(type_of(physx_PxJointLinearLimitPair_Pod.bounceThreshold)));
    assert(((cast(*void)(*instance.stiffness)) - cast(*void)(*instance)) == 8, "physx_PxJointLinearLimitPair_Pod.stiffness has unexpected offset % instead of 8", ((cast(*void)(*instance.stiffness)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxJointLinearLimitPair_Pod.stiffness)) == 4, "physx_PxJointLinearLimitPair_Pod.stiffness has unexpected size % instead of 4", size_of(type_of(physx_PxJointLinearLimitPair_Pod.stiffness)));
    assert(((cast(*void)(*instance.damping)) - cast(*void)(*instance)) == 12, "physx_PxJointLinearLimitPair_Pod.damping has unexpected offset % instead of 12", ((cast(*void)(*instance.damping)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxJointLinearLimitPair_Pod.damping)) == 4, "physx_PxJointLinearLimitPair_Pod.damping has unexpected size % instead of 4", size_of(type_of(physx_PxJointLinearLimitPair_Pod.damping)));
    assert(((cast(*void)(*instance.contactDistance)) - cast(*void)(*instance)) == 16, "physx_PxJointLinearLimitPair_Pod.contactDistance has unexpected offset % instead of 16", ((cast(*void)(*instance.contactDistance)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxJointLinearLimitPair_Pod.contactDistance)) == 4, "physx_PxJointLinearLimitPair_Pod.contactDistance has unexpected size % instead of 4", size_of(type_of(physx_PxJointLinearLimitPair_Pod.contactDistance)));
    assert(((cast(*void)(*instance.upper)) - cast(*void)(*instance)) == 20, "physx_PxJointLinearLimitPair_Pod.upper has unexpected offset % instead of 20", ((cast(*void)(*instance.upper)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxJointLinearLimitPair_Pod.upper)) == 4, "physx_PxJointLinearLimitPair_Pod.upper has unexpected size % instead of 4", size_of(type_of(physx_PxJointLinearLimitPair_Pod.upper)));
    assert(((cast(*void)(*instance.lower)) - cast(*void)(*instance)) == 24, "physx_PxJointLinearLimitPair_Pod.lower has unexpected offset % instead of 24", ((cast(*void)(*instance.lower)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxJointLinearLimitPair_Pod.lower)) == 4, "physx_PxJointLinearLimitPair_Pod.lower has unexpected size % instead of 4", size_of(type_of(physx_PxJointLinearLimitPair_Pod.lower)));
    assert(size_of(physx_PxJointLinearLimitPair_Pod) == 28, "physx_PxJointLinearLimitPair_Pod has size % instead of 28", size_of(physx_PxJointLinearLimitPair_Pod));
}

physx_PxJointAngularLimitPair_Pod :: struct {
    restitution:     float;
    bounceThreshold: float;
    stiffness:       float;
    damping:         float;
    contactDistance: float;
    upper:           float;
    lower:           float;
}
#run {
    instance: physx_PxJointAngularLimitPair_Pod;
    assert(((cast(*void)(*instance.restitution)) - cast(*void)(*instance)) == 0, "physx_PxJointAngularLimitPair_Pod.restitution has unexpected offset % instead of 0", ((cast(*void)(*instance.restitution)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxJointAngularLimitPair_Pod.restitution)) == 4, "physx_PxJointAngularLimitPair_Pod.restitution has unexpected size % instead of 4", size_of(type_of(physx_PxJointAngularLimitPair_Pod.restitution)));
    assert(((cast(*void)(*instance.bounceThreshold)) - cast(*void)(*instance)) == 4, "physx_PxJointAngularLimitPair_Pod.bounceThreshold has unexpected offset % instead of 4", ((cast(*void)(*instance.bounceThreshold)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxJointAngularLimitPair_Pod.bounceThreshold)) == 4, "physx_PxJointAngularLimitPair_Pod.bounceThreshold has unexpected size % instead of 4", size_of(type_of(physx_PxJointAngularLimitPair_Pod.bounceThreshold)));
    assert(((cast(*void)(*instance.stiffness)) - cast(*void)(*instance)) == 8, "physx_PxJointAngularLimitPair_Pod.stiffness has unexpected offset % instead of 8", ((cast(*void)(*instance.stiffness)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxJointAngularLimitPair_Pod.stiffness)) == 4, "physx_PxJointAngularLimitPair_Pod.stiffness has unexpected size % instead of 4", size_of(type_of(physx_PxJointAngularLimitPair_Pod.stiffness)));
    assert(((cast(*void)(*instance.damping)) - cast(*void)(*instance)) == 12, "physx_PxJointAngularLimitPair_Pod.damping has unexpected offset % instead of 12", ((cast(*void)(*instance.damping)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxJointAngularLimitPair_Pod.damping)) == 4, "physx_PxJointAngularLimitPair_Pod.damping has unexpected size % instead of 4", size_of(type_of(physx_PxJointAngularLimitPair_Pod.damping)));
    assert(((cast(*void)(*instance.contactDistance)) - cast(*void)(*instance)) == 16, "physx_PxJointAngularLimitPair_Pod.contactDistance has unexpected offset % instead of 16", ((cast(*void)(*instance.contactDistance)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxJointAngularLimitPair_Pod.contactDistance)) == 4, "physx_PxJointAngularLimitPair_Pod.contactDistance has unexpected size % instead of 4", size_of(type_of(physx_PxJointAngularLimitPair_Pod.contactDistance)));
    assert(((cast(*void)(*instance.upper)) - cast(*void)(*instance)) == 20, "physx_PxJointAngularLimitPair_Pod.upper has unexpected offset % instead of 20", ((cast(*void)(*instance.upper)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxJointAngularLimitPair_Pod.upper)) == 4, "physx_PxJointAngularLimitPair_Pod.upper has unexpected size % instead of 4", size_of(type_of(physx_PxJointAngularLimitPair_Pod.upper)));
    assert(((cast(*void)(*instance.lower)) - cast(*void)(*instance)) == 24, "physx_PxJointAngularLimitPair_Pod.lower has unexpected offset % instead of 24", ((cast(*void)(*instance.lower)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxJointAngularLimitPair_Pod.lower)) == 4, "physx_PxJointAngularLimitPair_Pod.lower has unexpected size % instead of 4", size_of(type_of(physx_PxJointAngularLimitPair_Pod.lower)));
    assert(size_of(physx_PxJointAngularLimitPair_Pod) == 28, "physx_PxJointAngularLimitPair_Pod has size % instead of 28", size_of(physx_PxJointAngularLimitPair_Pod));
}

physx_PxJointLimitCone_Pod :: struct {
    restitution:     float;
    bounceThreshold: float;
    stiffness:       float;
    damping:         float;
    contactDistance: float;
    yAngle:          float;
    zAngle:          float;
}
#run {
    instance: physx_PxJointLimitCone_Pod;
    assert(((cast(*void)(*instance.restitution)) - cast(*void)(*instance)) == 0, "physx_PxJointLimitCone_Pod.restitution has unexpected offset % instead of 0", ((cast(*void)(*instance.restitution)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxJointLimitCone_Pod.restitution)) == 4, "physx_PxJointLimitCone_Pod.restitution has unexpected size % instead of 4", size_of(type_of(physx_PxJointLimitCone_Pod.restitution)));
    assert(((cast(*void)(*instance.bounceThreshold)) - cast(*void)(*instance)) == 4, "physx_PxJointLimitCone_Pod.bounceThreshold has unexpected offset % instead of 4", ((cast(*void)(*instance.bounceThreshold)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxJointLimitCone_Pod.bounceThreshold)) == 4, "physx_PxJointLimitCone_Pod.bounceThreshold has unexpected size % instead of 4", size_of(type_of(physx_PxJointLimitCone_Pod.bounceThreshold)));
    assert(((cast(*void)(*instance.stiffness)) - cast(*void)(*instance)) == 8, "physx_PxJointLimitCone_Pod.stiffness has unexpected offset % instead of 8", ((cast(*void)(*instance.stiffness)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxJointLimitCone_Pod.stiffness)) == 4, "physx_PxJointLimitCone_Pod.stiffness has unexpected size % instead of 4", size_of(type_of(physx_PxJointLimitCone_Pod.stiffness)));
    assert(((cast(*void)(*instance.damping)) - cast(*void)(*instance)) == 12, "physx_PxJointLimitCone_Pod.damping has unexpected offset % instead of 12", ((cast(*void)(*instance.damping)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxJointLimitCone_Pod.damping)) == 4, "physx_PxJointLimitCone_Pod.damping has unexpected size % instead of 4", size_of(type_of(physx_PxJointLimitCone_Pod.damping)));
    assert(((cast(*void)(*instance.contactDistance)) - cast(*void)(*instance)) == 16, "physx_PxJointLimitCone_Pod.contactDistance has unexpected offset % instead of 16", ((cast(*void)(*instance.contactDistance)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxJointLimitCone_Pod.contactDistance)) == 4, "physx_PxJointLimitCone_Pod.contactDistance has unexpected size % instead of 4", size_of(type_of(physx_PxJointLimitCone_Pod.contactDistance)));
    assert(((cast(*void)(*instance.yAngle)) - cast(*void)(*instance)) == 20, "physx_PxJointLimitCone_Pod.yAngle has unexpected offset % instead of 20", ((cast(*void)(*instance.yAngle)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxJointLimitCone_Pod.yAngle)) == 4, "physx_PxJointLimitCone_Pod.yAngle has unexpected size % instead of 4", size_of(type_of(physx_PxJointLimitCone_Pod.yAngle)));
    assert(((cast(*void)(*instance.zAngle)) - cast(*void)(*instance)) == 24, "physx_PxJointLimitCone_Pod.zAngle has unexpected offset % instead of 24", ((cast(*void)(*instance.zAngle)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxJointLimitCone_Pod.zAngle)) == 4, "physx_PxJointLimitCone_Pod.zAngle has unexpected size % instead of 4", size_of(type_of(physx_PxJointLimitCone_Pod.zAngle)));
    assert(size_of(physx_PxJointLimitCone_Pod) == 28, "physx_PxJointLimitCone_Pod has size % instead of 28", size_of(physx_PxJointLimitCone_Pod));
}

physx_PxJointLimitPyramid_Pod :: struct {
    restitution:     float;
    bounceThreshold: float;
    stiffness:       float;
    damping:         float;
    contactDistance: float;
    yAngleMin:       float;
    yAngleMax:       float;
    zAngleMin:       float;
    zAngleMax:       float;
}
#run {
    instance: physx_PxJointLimitPyramid_Pod;
    assert(((cast(*void)(*instance.restitution)) - cast(*void)(*instance)) == 0, "physx_PxJointLimitPyramid_Pod.restitution has unexpected offset % instead of 0", ((cast(*void)(*instance.restitution)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxJointLimitPyramid_Pod.restitution)) == 4, "physx_PxJointLimitPyramid_Pod.restitution has unexpected size % instead of 4", size_of(type_of(physx_PxJointLimitPyramid_Pod.restitution)));
    assert(((cast(*void)(*instance.bounceThreshold)) - cast(*void)(*instance)) == 4, "physx_PxJointLimitPyramid_Pod.bounceThreshold has unexpected offset % instead of 4", ((cast(*void)(*instance.bounceThreshold)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxJointLimitPyramid_Pod.bounceThreshold)) == 4, "physx_PxJointLimitPyramid_Pod.bounceThreshold has unexpected size % instead of 4", size_of(type_of(physx_PxJointLimitPyramid_Pod.bounceThreshold)));
    assert(((cast(*void)(*instance.stiffness)) - cast(*void)(*instance)) == 8, "physx_PxJointLimitPyramid_Pod.stiffness has unexpected offset % instead of 8", ((cast(*void)(*instance.stiffness)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxJointLimitPyramid_Pod.stiffness)) == 4, "physx_PxJointLimitPyramid_Pod.stiffness has unexpected size % instead of 4", size_of(type_of(physx_PxJointLimitPyramid_Pod.stiffness)));
    assert(((cast(*void)(*instance.damping)) - cast(*void)(*instance)) == 12, "physx_PxJointLimitPyramid_Pod.damping has unexpected offset % instead of 12", ((cast(*void)(*instance.damping)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxJointLimitPyramid_Pod.damping)) == 4, "physx_PxJointLimitPyramid_Pod.damping has unexpected size % instead of 4", size_of(type_of(physx_PxJointLimitPyramid_Pod.damping)));
    assert(((cast(*void)(*instance.contactDistance)) - cast(*void)(*instance)) == 16, "physx_PxJointLimitPyramid_Pod.contactDistance has unexpected offset % instead of 16", ((cast(*void)(*instance.contactDistance)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxJointLimitPyramid_Pod.contactDistance)) == 4, "physx_PxJointLimitPyramid_Pod.contactDistance has unexpected size % instead of 4", size_of(type_of(physx_PxJointLimitPyramid_Pod.contactDistance)));
    assert(((cast(*void)(*instance.yAngleMin)) - cast(*void)(*instance)) == 20, "physx_PxJointLimitPyramid_Pod.yAngleMin has unexpected offset % instead of 20", ((cast(*void)(*instance.yAngleMin)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxJointLimitPyramid_Pod.yAngleMin)) == 4, "physx_PxJointLimitPyramid_Pod.yAngleMin has unexpected size % instead of 4", size_of(type_of(physx_PxJointLimitPyramid_Pod.yAngleMin)));
    assert(((cast(*void)(*instance.yAngleMax)) - cast(*void)(*instance)) == 24, "physx_PxJointLimitPyramid_Pod.yAngleMax has unexpected offset % instead of 24", ((cast(*void)(*instance.yAngleMax)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxJointLimitPyramid_Pod.yAngleMax)) == 4, "physx_PxJointLimitPyramid_Pod.yAngleMax has unexpected size % instead of 4", size_of(type_of(physx_PxJointLimitPyramid_Pod.yAngleMax)));
    assert(((cast(*void)(*instance.zAngleMin)) - cast(*void)(*instance)) == 28, "physx_PxJointLimitPyramid_Pod.zAngleMin has unexpected offset % instead of 28", ((cast(*void)(*instance.zAngleMin)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxJointLimitPyramid_Pod.zAngleMin)) == 4, "physx_PxJointLimitPyramid_Pod.zAngleMin has unexpected size % instead of 4", size_of(type_of(physx_PxJointLimitPyramid_Pod.zAngleMin)));
    assert(((cast(*void)(*instance.zAngleMax)) - cast(*void)(*instance)) == 32, "physx_PxJointLimitPyramid_Pod.zAngleMax has unexpected offset % instead of 32", ((cast(*void)(*instance.zAngleMax)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxJointLimitPyramid_Pod.zAngleMax)) == 4, "physx_PxJointLimitPyramid_Pod.zAngleMax has unexpected size % instead of 4", size_of(type_of(physx_PxJointLimitPyramid_Pod.zAngleMax)));
    assert(size_of(physx_PxJointLimitPyramid_Pod) == 36, "physx_PxJointLimitPyramid_Pod has size % instead of 36", size_of(physx_PxJointLimitPyramid_Pod));
}

physx_PxPrismaticJoint_Pod :: struct {
    structgen_pad0: [8] u8;
    mConcreteType:  u16;
    mBaseFlags:     physx_PxBaseFlags_Pod;
    structgen_pad1: [4] u8;
    userData:       *void;
}
#run {
    instance: physx_PxPrismaticJoint_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxPrismaticJoint_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxPrismaticJoint_Pod.structgen_pad0)) == 8, "physx_PxPrismaticJoint_Pod.structgen_pad0 has unexpected size % instead of 8", size_of(type_of(physx_PxPrismaticJoint_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)) == 8, "physx_PxPrismaticJoint_Pod.mConcreteType has unexpected offset % instead of 8", ((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxPrismaticJoint_Pod.mConcreteType)) == 2, "physx_PxPrismaticJoint_Pod.mConcreteType has unexpected size % instead of 2", size_of(type_of(physx_PxPrismaticJoint_Pod.mConcreteType)));
    assert(((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)) == 10, "physx_PxPrismaticJoint_Pod.mBaseFlags has unexpected offset % instead of 10", ((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxPrismaticJoint_Pod.mBaseFlags)) == 2, "physx_PxPrismaticJoint_Pod.mBaseFlags has unexpected size % instead of 2", size_of(type_of(physx_PxPrismaticJoint_Pod.mBaseFlags)));
    assert(((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)) == 12, "physx_PxPrismaticJoint_Pod.structgen_pad1 has unexpected offset % instead of 12", ((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxPrismaticJoint_Pod.structgen_pad1)) == 4, "physx_PxPrismaticJoint_Pod.structgen_pad1 has unexpected size % instead of 4", size_of(type_of(physx_PxPrismaticJoint_Pod.structgen_pad1)));
    assert(((cast(*void)(*instance.userData)) - cast(*void)(*instance)) == 16, "physx_PxPrismaticJoint_Pod.userData has unexpected offset % instead of 16", ((cast(*void)(*instance.userData)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxPrismaticJoint_Pod.userData)) == 8, "physx_PxPrismaticJoint_Pod.userData has unexpected size % instead of 8", size_of(type_of(physx_PxPrismaticJoint_Pod.userData)));
    assert(size_of(physx_PxPrismaticJoint_Pod) == 24, "physx_PxPrismaticJoint_Pod has size % instead of 24", size_of(physx_PxPrismaticJoint_Pod));
}

physx_PxPrismaticJointFlags_Pod :: struct {
    mBits: u16;
}
#run {
    instance: physx_PxPrismaticJointFlags_Pod;
    assert(((cast(*void)(*instance.mBits)) - cast(*void)(*instance)) == 0, "physx_PxPrismaticJointFlags_Pod.mBits has unexpected offset % instead of 0", ((cast(*void)(*instance.mBits)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxPrismaticJointFlags_Pod.mBits)) == 2, "physx_PxPrismaticJointFlags_Pod.mBits has unexpected size % instead of 2", size_of(type_of(physx_PxPrismaticJointFlags_Pod.mBits)));
    assert(size_of(physx_PxPrismaticJointFlags_Pod) == 2, "physx_PxPrismaticJointFlags_Pod has size % instead of 2", size_of(physx_PxPrismaticJointFlags_Pod));
}

physx_PxRevoluteJoint_Pod :: struct {
    structgen_pad0: [8] u8;
    mConcreteType:  u16;
    mBaseFlags:     physx_PxBaseFlags_Pod;
    structgen_pad1: [4] u8;
    userData:       *void;
}
#run {
    instance: physx_PxRevoluteJoint_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxRevoluteJoint_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxRevoluteJoint_Pod.structgen_pad0)) == 8, "physx_PxRevoluteJoint_Pod.structgen_pad0 has unexpected size % instead of 8", size_of(type_of(physx_PxRevoluteJoint_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)) == 8, "physx_PxRevoluteJoint_Pod.mConcreteType has unexpected offset % instead of 8", ((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxRevoluteJoint_Pod.mConcreteType)) == 2, "physx_PxRevoluteJoint_Pod.mConcreteType has unexpected size % instead of 2", size_of(type_of(physx_PxRevoluteJoint_Pod.mConcreteType)));
    assert(((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)) == 10, "physx_PxRevoluteJoint_Pod.mBaseFlags has unexpected offset % instead of 10", ((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxRevoluteJoint_Pod.mBaseFlags)) == 2, "physx_PxRevoluteJoint_Pod.mBaseFlags has unexpected size % instead of 2", size_of(type_of(physx_PxRevoluteJoint_Pod.mBaseFlags)));
    assert(((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)) == 12, "physx_PxRevoluteJoint_Pod.structgen_pad1 has unexpected offset % instead of 12", ((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxRevoluteJoint_Pod.structgen_pad1)) == 4, "physx_PxRevoluteJoint_Pod.structgen_pad1 has unexpected size % instead of 4", size_of(type_of(physx_PxRevoluteJoint_Pod.structgen_pad1)));
    assert(((cast(*void)(*instance.userData)) - cast(*void)(*instance)) == 16, "physx_PxRevoluteJoint_Pod.userData has unexpected offset % instead of 16", ((cast(*void)(*instance.userData)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxRevoluteJoint_Pod.userData)) == 8, "physx_PxRevoluteJoint_Pod.userData has unexpected size % instead of 8", size_of(type_of(physx_PxRevoluteJoint_Pod.userData)));
    assert(size_of(physx_PxRevoluteJoint_Pod) == 24, "physx_PxRevoluteJoint_Pod has size % instead of 24", size_of(physx_PxRevoluteJoint_Pod));
}

physx_PxRevoluteJointFlags_Pod :: struct {
    mBits: u16;
}
#run {
    instance: physx_PxRevoluteJointFlags_Pod;
    assert(((cast(*void)(*instance.mBits)) - cast(*void)(*instance)) == 0, "physx_PxRevoluteJointFlags_Pod.mBits has unexpected offset % instead of 0", ((cast(*void)(*instance.mBits)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxRevoluteJointFlags_Pod.mBits)) == 2, "physx_PxRevoluteJointFlags_Pod.mBits has unexpected size % instead of 2", size_of(type_of(physx_PxRevoluteJointFlags_Pod.mBits)));
    assert(size_of(physx_PxRevoluteJointFlags_Pod) == 2, "physx_PxRevoluteJointFlags_Pod has size % instead of 2", size_of(physx_PxRevoluteJointFlags_Pod));
}

physx_PxSphericalJoint_Pod :: struct {
    structgen_pad0: [8] u8;
    mConcreteType:  u16;
    mBaseFlags:     physx_PxBaseFlags_Pod;
    structgen_pad1: [4] u8;
    userData:       *void;
}
#run {
    instance: physx_PxSphericalJoint_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxSphericalJoint_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSphericalJoint_Pod.structgen_pad0)) == 8, "physx_PxSphericalJoint_Pod.structgen_pad0 has unexpected size % instead of 8", size_of(type_of(physx_PxSphericalJoint_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)) == 8, "physx_PxSphericalJoint_Pod.mConcreteType has unexpected offset % instead of 8", ((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSphericalJoint_Pod.mConcreteType)) == 2, "physx_PxSphericalJoint_Pod.mConcreteType has unexpected size % instead of 2", size_of(type_of(physx_PxSphericalJoint_Pod.mConcreteType)));
    assert(((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)) == 10, "physx_PxSphericalJoint_Pod.mBaseFlags has unexpected offset % instead of 10", ((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSphericalJoint_Pod.mBaseFlags)) == 2, "physx_PxSphericalJoint_Pod.mBaseFlags has unexpected size % instead of 2", size_of(type_of(physx_PxSphericalJoint_Pod.mBaseFlags)));
    assert(((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)) == 12, "physx_PxSphericalJoint_Pod.structgen_pad1 has unexpected offset % instead of 12", ((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSphericalJoint_Pod.structgen_pad1)) == 4, "physx_PxSphericalJoint_Pod.structgen_pad1 has unexpected size % instead of 4", size_of(type_of(physx_PxSphericalJoint_Pod.structgen_pad1)));
    assert(((cast(*void)(*instance.userData)) - cast(*void)(*instance)) == 16, "physx_PxSphericalJoint_Pod.userData has unexpected offset % instead of 16", ((cast(*void)(*instance.userData)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSphericalJoint_Pod.userData)) == 8, "physx_PxSphericalJoint_Pod.userData has unexpected size % instead of 8", size_of(type_of(physx_PxSphericalJoint_Pod.userData)));
    assert(size_of(physx_PxSphericalJoint_Pod) == 24, "physx_PxSphericalJoint_Pod has size % instead of 24", size_of(physx_PxSphericalJoint_Pod));
}

physx_PxSphericalJointFlags_Pod :: struct {
    mBits: u16;
}
#run {
    instance: physx_PxSphericalJointFlags_Pod;
    assert(((cast(*void)(*instance.mBits)) - cast(*void)(*instance)) == 0, "physx_PxSphericalJointFlags_Pod.mBits has unexpected offset % instead of 0", ((cast(*void)(*instance.mBits)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSphericalJointFlags_Pod.mBits)) == 2, "physx_PxSphericalJointFlags_Pod.mBits has unexpected size % instead of 2", size_of(type_of(physx_PxSphericalJointFlags_Pod.mBits)));
    assert(size_of(physx_PxSphericalJointFlags_Pod) == 2, "physx_PxSphericalJointFlags_Pod has size % instead of 2", size_of(physx_PxSphericalJointFlags_Pod));
}

physx_PxD6Joint_Pod :: struct {
    structgen_pad0: [8] u8;
    mConcreteType:  u16;
    mBaseFlags:     physx_PxBaseFlags_Pod;
    structgen_pad1: [4] u8;
    userData:       *void;
}
#run {
    instance: physx_PxD6Joint_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxD6Joint_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxD6Joint_Pod.structgen_pad0)) == 8, "physx_PxD6Joint_Pod.structgen_pad0 has unexpected size % instead of 8", size_of(type_of(physx_PxD6Joint_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)) == 8, "physx_PxD6Joint_Pod.mConcreteType has unexpected offset % instead of 8", ((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxD6Joint_Pod.mConcreteType)) == 2, "physx_PxD6Joint_Pod.mConcreteType has unexpected size % instead of 2", size_of(type_of(physx_PxD6Joint_Pod.mConcreteType)));
    assert(((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)) == 10, "physx_PxD6Joint_Pod.mBaseFlags has unexpected offset % instead of 10", ((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxD6Joint_Pod.mBaseFlags)) == 2, "physx_PxD6Joint_Pod.mBaseFlags has unexpected size % instead of 2", size_of(type_of(physx_PxD6Joint_Pod.mBaseFlags)));
    assert(((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)) == 12, "physx_PxD6Joint_Pod.structgen_pad1 has unexpected offset % instead of 12", ((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxD6Joint_Pod.structgen_pad1)) == 4, "physx_PxD6Joint_Pod.structgen_pad1 has unexpected size % instead of 4", size_of(type_of(physx_PxD6Joint_Pod.structgen_pad1)));
    assert(((cast(*void)(*instance.userData)) - cast(*void)(*instance)) == 16, "physx_PxD6Joint_Pod.userData has unexpected offset % instead of 16", ((cast(*void)(*instance.userData)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxD6Joint_Pod.userData)) == 8, "physx_PxD6Joint_Pod.userData has unexpected size % instead of 8", size_of(type_of(physx_PxD6Joint_Pod.userData)));
    assert(size_of(physx_PxD6Joint_Pod) == 24, "physx_PxD6Joint_Pod has size % instead of 24", size_of(physx_PxD6Joint_Pod));
}

physx_PxD6JointDriveFlags_Pod :: struct {
    mBits: u32;
}
#run {
    instance: physx_PxD6JointDriveFlags_Pod;
    assert(((cast(*void)(*instance.mBits)) - cast(*void)(*instance)) == 0, "physx_PxD6JointDriveFlags_Pod.mBits has unexpected offset % instead of 0", ((cast(*void)(*instance.mBits)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxD6JointDriveFlags_Pod.mBits)) == 4, "physx_PxD6JointDriveFlags_Pod.mBits has unexpected size % instead of 4", size_of(type_of(physx_PxD6JointDriveFlags_Pod.mBits)));
    assert(size_of(physx_PxD6JointDriveFlags_Pod) == 4, "physx_PxD6JointDriveFlags_Pod has size % instead of 4", size_of(physx_PxD6JointDriveFlags_Pod));
}

physx_PxD6JointDrive_Pod :: struct {
    stiffness:  float;
    damping:    float;
    forceLimit: float;
    flags:      physx_PxD6JointDriveFlags_Pod;
}
#run {
    instance: physx_PxD6JointDrive_Pod;
    assert(((cast(*void)(*instance.stiffness)) - cast(*void)(*instance)) == 0, "physx_PxD6JointDrive_Pod.stiffness has unexpected offset % instead of 0", ((cast(*void)(*instance.stiffness)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxD6JointDrive_Pod.stiffness)) == 4, "physx_PxD6JointDrive_Pod.stiffness has unexpected size % instead of 4", size_of(type_of(physx_PxD6JointDrive_Pod.stiffness)));
    assert(((cast(*void)(*instance.damping)) - cast(*void)(*instance)) == 4, "physx_PxD6JointDrive_Pod.damping has unexpected offset % instead of 4", ((cast(*void)(*instance.damping)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxD6JointDrive_Pod.damping)) == 4, "physx_PxD6JointDrive_Pod.damping has unexpected size % instead of 4", size_of(type_of(physx_PxD6JointDrive_Pod.damping)));
    assert(((cast(*void)(*instance.forceLimit)) - cast(*void)(*instance)) == 8, "physx_PxD6JointDrive_Pod.forceLimit has unexpected offset % instead of 8", ((cast(*void)(*instance.forceLimit)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxD6JointDrive_Pod.forceLimit)) == 4, "physx_PxD6JointDrive_Pod.forceLimit has unexpected size % instead of 4", size_of(type_of(physx_PxD6JointDrive_Pod.forceLimit)));
    assert(((cast(*void)(*instance.flags)) - cast(*void)(*instance)) == 12, "physx_PxD6JointDrive_Pod.flags has unexpected offset % instead of 12", ((cast(*void)(*instance.flags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxD6JointDrive_Pod.flags)) == 4, "physx_PxD6JointDrive_Pod.flags has unexpected size % instead of 4", size_of(type_of(physx_PxD6JointDrive_Pod.flags)));
    assert(size_of(physx_PxD6JointDrive_Pod) == 16, "physx_PxD6JointDrive_Pod has size % instead of 16", size_of(physx_PxD6JointDrive_Pod));
}

physx_PxGroupsMask_Pod :: struct {
    bits0: u16;
    bits1: u16;
    bits2: u16;
    bits3: u16;
}
#run {
    instance: physx_PxGroupsMask_Pod;
    assert(((cast(*void)(*instance.bits0)) - cast(*void)(*instance)) == 0, "physx_PxGroupsMask_Pod.bits0 has unexpected offset % instead of 0", ((cast(*void)(*instance.bits0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxGroupsMask_Pod.bits0)) == 2, "physx_PxGroupsMask_Pod.bits0 has unexpected size % instead of 2", size_of(type_of(physx_PxGroupsMask_Pod.bits0)));
    assert(((cast(*void)(*instance.bits1)) - cast(*void)(*instance)) == 2, "physx_PxGroupsMask_Pod.bits1 has unexpected offset % instead of 2", ((cast(*void)(*instance.bits1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxGroupsMask_Pod.bits1)) == 2, "physx_PxGroupsMask_Pod.bits1 has unexpected size % instead of 2", size_of(type_of(physx_PxGroupsMask_Pod.bits1)));
    assert(((cast(*void)(*instance.bits2)) - cast(*void)(*instance)) == 4, "physx_PxGroupsMask_Pod.bits2 has unexpected offset % instead of 4", ((cast(*void)(*instance.bits2)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxGroupsMask_Pod.bits2)) == 2, "physx_PxGroupsMask_Pod.bits2 has unexpected size % instead of 2", size_of(type_of(physx_PxGroupsMask_Pod.bits2)));
    assert(((cast(*void)(*instance.bits3)) - cast(*void)(*instance)) == 6, "physx_PxGroupsMask_Pod.bits3 has unexpected offset % instead of 6", ((cast(*void)(*instance.bits3)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxGroupsMask_Pod.bits3)) == 2, "physx_PxGroupsMask_Pod.bits3 has unexpected size % instead of 2", size_of(type_of(physx_PxGroupsMask_Pod.bits3)));
    assert(size_of(physx_PxGroupsMask_Pod) == 8, "physx_PxGroupsMask_Pod has size % instead of 8", size_of(physx_PxGroupsMask_Pod));
}

physx_PxDefaultErrorCallback_Pod :: struct {
    vtable_: *void;
}
#run {
    instance: physx_PxDefaultErrorCallback_Pod;
    assert(((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)) == 0, "physx_PxDefaultErrorCallback_Pod.vtable_ has unexpected offset % instead of 0", ((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxDefaultErrorCallback_Pod.vtable_)) == 8, "physx_PxDefaultErrorCallback_Pod.vtable_ has unexpected size % instead of 8", size_of(type_of(physx_PxDefaultErrorCallback_Pod.vtable_)));
    assert(size_of(physx_PxDefaultErrorCallback_Pod) == 8, "physx_PxDefaultErrorCallback_Pod has size % instead of 8", size_of(physx_PxDefaultErrorCallback_Pod));
}

physx_PxMassProperties_Pod :: struct {
    inertiaTensor: physx_PxMat33_Pod;
    centerOfMass:  physx_PxVec3_Pod;
    mass:          float;
}
#run {
    instance: physx_PxMassProperties_Pod;
    assert(((cast(*void)(*instance.inertiaTensor)) - cast(*void)(*instance)) == 0, "physx_PxMassProperties_Pod.inertiaTensor has unexpected offset % instead of 0", ((cast(*void)(*instance.inertiaTensor)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxMassProperties_Pod.inertiaTensor)) == 36, "physx_PxMassProperties_Pod.inertiaTensor has unexpected size % instead of 36", size_of(type_of(physx_PxMassProperties_Pod.inertiaTensor)));
    assert(((cast(*void)(*instance.centerOfMass)) - cast(*void)(*instance)) == 36, "physx_PxMassProperties_Pod.centerOfMass has unexpected offset % instead of 36", ((cast(*void)(*instance.centerOfMass)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxMassProperties_Pod.centerOfMass)) == 12, "physx_PxMassProperties_Pod.centerOfMass has unexpected size % instead of 12", size_of(type_of(physx_PxMassProperties_Pod.centerOfMass)));
    assert(((cast(*void)(*instance.mass)) - cast(*void)(*instance)) == 48, "physx_PxMassProperties_Pod.mass has unexpected offset % instead of 48", ((cast(*void)(*instance.mass)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxMassProperties_Pod.mass)) == 4, "physx_PxMassProperties_Pod.mass has unexpected size % instead of 4", size_of(type_of(physx_PxMassProperties_Pod.mass)));
    assert(size_of(physx_PxMassProperties_Pod) == 52, "physx_PxMassProperties_Pod has size % instead of 52", size_of(physx_PxMassProperties_Pod));
}

physx_PxMeshOverlapUtil_Pod :: struct {
    structgen_pad0: [1040] u8;
}
#run {
    instance: physx_PxMeshOverlapUtil_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxMeshOverlapUtil_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxMeshOverlapUtil_Pod.structgen_pad0)) == 1040, "physx_PxMeshOverlapUtil_Pod.structgen_pad0 has unexpected size % instead of 1040", size_of(type_of(physx_PxMeshOverlapUtil_Pod.structgen_pad0)));
    assert(size_of(physx_PxMeshOverlapUtil_Pod) == 1040, "physx_PxMeshOverlapUtil_Pod has size % instead of 1040", size_of(physx_PxMeshOverlapUtil_Pod));
}

physx_PxSerialization_PxXmlMiscParameter_Pod :: struct {
    upVector: physx_PxVec3_Pod;
    scale:    physx_PxTolerancesScale_Pod;
}
#run {
    instance: physx_PxSerialization_PxXmlMiscParameter_Pod;
    assert(((cast(*void)(*instance.upVector)) - cast(*void)(*instance)) == 0, "physx_PxSerialization_PxXmlMiscParameter_Pod.upVector has unexpected offset % instead of 0", ((cast(*void)(*instance.upVector)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSerialization_PxXmlMiscParameter_Pod.upVector)) == 12, "physx_PxSerialization_PxXmlMiscParameter_Pod.upVector has unexpected size % instead of 12", size_of(type_of(physx_PxSerialization_PxXmlMiscParameter_Pod.upVector)));
    assert(((cast(*void)(*instance.scale)) - cast(*void)(*instance)) == 12, "physx_PxSerialization_PxXmlMiscParameter_Pod.scale has unexpected offset % instead of 12", ((cast(*void)(*instance.scale)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSerialization_PxXmlMiscParameter_Pod.scale)) == 8, "physx_PxSerialization_PxXmlMiscParameter_Pod.scale has unexpected size % instead of 8", size_of(type_of(physx_PxSerialization_PxXmlMiscParameter_Pod.scale)));
    assert(size_of(physx_PxSerialization_PxXmlMiscParameter_Pod) == 20, "physx_PxSerialization_PxXmlMiscParameter_Pod has size % instead of 20", size_of(physx_PxSerialization_PxXmlMiscParameter_Pod));
}

physx_PxBinaryConverter_Pod :: struct {
    vtable_: *void;
}
#run {
    instance: physx_PxBinaryConverter_Pod;
    assert(((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)) == 0, "physx_PxBinaryConverter_Pod.vtable_ has unexpected offset % instead of 0", ((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxBinaryConverter_Pod.vtable_)) == 8, "physx_PxBinaryConverter_Pod.vtable_ has unexpected size % instead of 8", size_of(type_of(physx_PxBinaryConverter_Pod.vtable_)));
    assert(size_of(physx_PxBinaryConverter_Pod) == 8, "physx_PxBinaryConverter_Pod has size % instead of 8", size_of(physx_PxBinaryConverter_Pod));
}

physx_PxDefaultCpuDispatcher_Pod :: struct {
    vtable_: *void;
}
#run {
    instance: physx_PxDefaultCpuDispatcher_Pod;
    assert(((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)) == 0, "physx_PxDefaultCpuDispatcher_Pod.vtable_ has unexpected offset % instead of 0", ((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxDefaultCpuDispatcher_Pod.vtable_)) == 8, "physx_PxDefaultCpuDispatcher_Pod.vtable_ has unexpected size % instead of 8", size_of(type_of(physx_PxDefaultCpuDispatcher_Pod.vtable_)));
    assert(size_of(physx_PxDefaultCpuDispatcher_Pod) == 8, "physx_PxDefaultCpuDispatcher_Pod has size % instead of 8", size_of(physx_PxDefaultCpuDispatcher_Pod));
}

physx_PxSceneQueryHit_Pod :: struct {
    actor:          *physx_PxRigidActor_Pod;
    shape:          *physx_PxShape_Pod;
    faceIndex:      u32;
    structgen_pad0: [4] u8;
}
#run {
    instance: physx_PxSceneQueryHit_Pod;
    assert(((cast(*void)(*instance.actor)) - cast(*void)(*instance)) == 0, "physx_PxSceneQueryHit_Pod.actor has unexpected offset % instead of 0", ((cast(*void)(*instance.actor)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneQueryHit_Pod.actor)) == 8, "physx_PxSceneQueryHit_Pod.actor has unexpected size % instead of 8", size_of(type_of(physx_PxSceneQueryHit_Pod.actor)));
    assert(((cast(*void)(*instance.shape)) - cast(*void)(*instance)) == 8, "physx_PxSceneQueryHit_Pod.shape has unexpected offset % instead of 8", ((cast(*void)(*instance.shape)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneQueryHit_Pod.shape)) == 8, "physx_PxSceneQueryHit_Pod.shape has unexpected size % instead of 8", size_of(type_of(physx_PxSceneQueryHit_Pod.shape)));
    assert(((cast(*void)(*instance.faceIndex)) - cast(*void)(*instance)) == 16, "physx_PxSceneQueryHit_Pod.faceIndex has unexpected offset % instead of 16", ((cast(*void)(*instance.faceIndex)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneQueryHit_Pod.faceIndex)) == 4, "physx_PxSceneQueryHit_Pod.faceIndex has unexpected size % instead of 4", size_of(type_of(physx_PxSceneQueryHit_Pod.faceIndex)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 20, "physx_PxSceneQueryHit_Pod.structgen_pad0 has unexpected offset % instead of 20", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneQueryHit_Pod.structgen_pad0)) == 4, "physx_PxSceneQueryHit_Pod.structgen_pad0 has unexpected size % instead of 4", size_of(type_of(physx_PxSceneQueryHit_Pod.structgen_pad0)));
    assert(size_of(physx_PxSceneQueryHit_Pod) == 24, "physx_PxSceneQueryHit_Pod has size % instead of 24", size_of(physx_PxSceneQueryHit_Pod));
}

physx_PxSceneQueryFilterData_Pod :: struct {
    data:           physx_PxFilterData_Pod;
    flags:          physx_PxQueryFlags_Pod;
    structgen_pad0: [2] u8;
}
#run {
    instance: physx_PxSceneQueryFilterData_Pod;
    assert(((cast(*void)(*instance.data)) - cast(*void)(*instance)) == 0, "physx_PxSceneQueryFilterData_Pod.data has unexpected offset % instead of 0", ((cast(*void)(*instance.data)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneQueryFilterData_Pod.data)) == 16, "physx_PxSceneQueryFilterData_Pod.data has unexpected size % instead of 16", size_of(type_of(physx_PxSceneQueryFilterData_Pod.data)));
    assert(((cast(*void)(*instance.flags)) - cast(*void)(*instance)) == 16, "physx_PxSceneQueryFilterData_Pod.flags has unexpected offset % instead of 16", ((cast(*void)(*instance.flags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneQueryFilterData_Pod.flags)) == 2, "physx_PxSceneQueryFilterData_Pod.flags has unexpected size % instead of 2", size_of(type_of(physx_PxSceneQueryFilterData_Pod.flags)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 18, "physx_PxSceneQueryFilterData_Pod.structgen_pad0 has unexpected offset % instead of 18", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneQueryFilterData_Pod.structgen_pad0)) == 2, "physx_PxSceneQueryFilterData_Pod.structgen_pad0 has unexpected size % instead of 2", size_of(type_of(physx_PxSceneQueryFilterData_Pod.structgen_pad0)));
    assert(size_of(physx_PxSceneQueryFilterData_Pod) == 20, "physx_PxSceneQueryFilterData_Pod has size % instead of 20", size_of(physx_PxSceneQueryFilterData_Pod));
}

physx_PxSceneQueryFilterCallback_Pod :: struct {
    vtable_: *void;
}
#run {
    instance: physx_PxSceneQueryFilterCallback_Pod;
    assert(((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)) == 0, "physx_PxSceneQueryFilterCallback_Pod.vtable_ has unexpected offset % instead of 0", ((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneQueryFilterCallback_Pod.vtable_)) == 8, "physx_PxSceneQueryFilterCallback_Pod.vtable_ has unexpected size % instead of 8", size_of(type_of(physx_PxSceneQueryFilterCallback_Pod.vtable_)));
    assert(size_of(physx_PxSceneQueryFilterCallback_Pod) == 8, "physx_PxSceneQueryFilterCallback_Pod has size % instead of 8", size_of(physx_PxSceneQueryFilterCallback_Pod));
}

physx_PxSceneQueryCache_Pod :: struct {
    shape:          *physx_PxShape_Pod;
    actor:          *physx_PxRigidActor_Pod;
    faceIndex:      u32;
    structgen_pad0: [4] u8;
}
#run {
    instance: physx_PxSceneQueryCache_Pod;
    assert(((cast(*void)(*instance.shape)) - cast(*void)(*instance)) == 0, "physx_PxSceneQueryCache_Pod.shape has unexpected offset % instead of 0", ((cast(*void)(*instance.shape)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneQueryCache_Pod.shape)) == 8, "physx_PxSceneQueryCache_Pod.shape has unexpected size % instead of 8", size_of(type_of(physx_PxSceneQueryCache_Pod.shape)));
    assert(((cast(*void)(*instance.actor)) - cast(*void)(*instance)) == 8, "physx_PxSceneQueryCache_Pod.actor has unexpected offset % instead of 8", ((cast(*void)(*instance.actor)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneQueryCache_Pod.actor)) == 8, "physx_PxSceneQueryCache_Pod.actor has unexpected size % instead of 8", size_of(type_of(physx_PxSceneQueryCache_Pod.actor)));
    assert(((cast(*void)(*instance.faceIndex)) - cast(*void)(*instance)) == 16, "physx_PxSceneQueryCache_Pod.faceIndex has unexpected offset % instead of 16", ((cast(*void)(*instance.faceIndex)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneQueryCache_Pod.faceIndex)) == 4, "physx_PxSceneQueryCache_Pod.faceIndex has unexpected size % instead of 4", size_of(type_of(physx_PxSceneQueryCache_Pod.faceIndex)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 20, "physx_PxSceneQueryCache_Pod.structgen_pad0 has unexpected offset % instead of 20", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneQueryCache_Pod.structgen_pad0)) == 4, "physx_PxSceneQueryCache_Pod.structgen_pad0 has unexpected size % instead of 4", size_of(type_of(physx_PxSceneQueryCache_Pod.structgen_pad0)));
    assert(size_of(physx_PxSceneQueryCache_Pod) == 24, "physx_PxSceneQueryCache_Pod has size % instead of 24", size_of(physx_PxSceneQueryCache_Pod));
}

physx_PxSceneQueryFlags_Pod :: struct {
    mBits: u16;
}
#run {
    instance: physx_PxSceneQueryFlags_Pod;
    assert(((cast(*void)(*instance.mBits)) - cast(*void)(*instance)) == 0, "physx_PxSceneQueryFlags_Pod.mBits has unexpected offset % instead of 0", ((cast(*void)(*instance.mBits)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxSceneQueryFlags_Pod.mBits)) == 2, "physx_PxSceneQueryFlags_Pod.mBits has unexpected size % instead of 2", size_of(type_of(physx_PxSceneQueryFlags_Pod.mBits)));
    assert(size_of(physx_PxSceneQueryFlags_Pod) == 2, "physx_PxSceneQueryFlags_Pod has size % instead of 2", size_of(physx_PxSceneQueryFlags_Pod));
}

physx_PxRepXObject_Pod :: struct {
    typeName:     *u8;
    serializable: *void;
    id:           u64;
}
#run {
    instance: physx_PxRepXObject_Pod;
    assert(((cast(*void)(*instance.typeName)) - cast(*void)(*instance)) == 0, "physx_PxRepXObject_Pod.typeName has unexpected offset % instead of 0", ((cast(*void)(*instance.typeName)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxRepXObject_Pod.typeName)) == 8, "physx_PxRepXObject_Pod.typeName has unexpected size % instead of 8", size_of(type_of(physx_PxRepXObject_Pod.typeName)));
    assert(((cast(*void)(*instance.serializable)) - cast(*void)(*instance)) == 8, "physx_PxRepXObject_Pod.serializable has unexpected offset % instead of 8", ((cast(*void)(*instance.serializable)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxRepXObject_Pod.serializable)) == 8, "physx_PxRepXObject_Pod.serializable has unexpected size % instead of 8", size_of(type_of(physx_PxRepXObject_Pod.serializable)));
    assert(((cast(*void)(*instance.id)) - cast(*void)(*instance)) == 16, "physx_PxRepXObject_Pod.id has unexpected offset % instead of 16", ((cast(*void)(*instance.id)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxRepXObject_Pod.id)) == 8, "physx_PxRepXObject_Pod.id has unexpected size % instead of 8", size_of(type_of(physx_PxRepXObject_Pod.id)));
    assert(size_of(physx_PxRepXObject_Pod) == 24, "physx_PxRepXObject_Pod has size % instead of 24", size_of(physx_PxRepXObject_Pod));
}

physx_PxRepXInstantiationArgs_Pod :: struct {
    structgen_pad0: [8] u8;
    cooker:         *physx_PxCooking_Pod;
    stringTable:    *physx_PxStringTable_Pod;
}
#run {
    instance: physx_PxRepXInstantiationArgs_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxRepXInstantiationArgs_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxRepXInstantiationArgs_Pod.structgen_pad0)) == 8, "physx_PxRepXInstantiationArgs_Pod.structgen_pad0 has unexpected size % instead of 8", size_of(type_of(physx_PxRepXInstantiationArgs_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.cooker)) - cast(*void)(*instance)) == 8, "physx_PxRepXInstantiationArgs_Pod.cooker has unexpected offset % instead of 8", ((cast(*void)(*instance.cooker)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxRepXInstantiationArgs_Pod.cooker)) == 8, "physx_PxRepXInstantiationArgs_Pod.cooker has unexpected size % instead of 8", size_of(type_of(physx_PxRepXInstantiationArgs_Pod.cooker)));
    assert(((cast(*void)(*instance.stringTable)) - cast(*void)(*instance)) == 16, "physx_PxRepXInstantiationArgs_Pod.stringTable has unexpected offset % instead of 16", ((cast(*void)(*instance.stringTable)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxRepXInstantiationArgs_Pod.stringTable)) == 8, "physx_PxRepXInstantiationArgs_Pod.stringTable has unexpected size % instead of 8", size_of(type_of(physx_PxRepXInstantiationArgs_Pod.stringTable)));
    assert(size_of(physx_PxRepXInstantiationArgs_Pod) == 24, "physx_PxRepXInstantiationArgs_Pod has size % instead of 24", size_of(physx_PxRepXInstantiationArgs_Pod));
}

physx_XmlWriter_Pod :: struct {}
physx_MemoryBuffer_Pod :: struct {}
physx_XmlReader_Pod :: struct {}
physx_XmlMemoryAllocator_Pod :: struct {}
physx_PxVehicleChassisData_Pod :: struct {
    mMOI:           physx_PxVec3_Pod;
    mMass:          float;
    mCMOffset:      physx_PxVec3_Pod;
    structgen_pad0: [4] u8;
}
#run {
    instance: physx_PxVehicleChassisData_Pod;
    assert(((cast(*void)(*instance.mMOI)) - cast(*void)(*instance)) == 0, "physx_PxVehicleChassisData_Pod.mMOI has unexpected offset % instead of 0", ((cast(*void)(*instance.mMOI)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleChassisData_Pod.mMOI)) == 12, "physx_PxVehicleChassisData_Pod.mMOI has unexpected size % instead of 12", size_of(type_of(physx_PxVehicleChassisData_Pod.mMOI)));
    assert(((cast(*void)(*instance.mMass)) - cast(*void)(*instance)) == 12, "physx_PxVehicleChassisData_Pod.mMass has unexpected offset % instead of 12", ((cast(*void)(*instance.mMass)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleChassisData_Pod.mMass)) == 4, "physx_PxVehicleChassisData_Pod.mMass has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleChassisData_Pod.mMass)));
    assert(((cast(*void)(*instance.mCMOffset)) - cast(*void)(*instance)) == 16, "physx_PxVehicleChassisData_Pod.mCMOffset has unexpected offset % instead of 16", ((cast(*void)(*instance.mCMOffset)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleChassisData_Pod.mCMOffset)) == 12, "physx_PxVehicleChassisData_Pod.mCMOffset has unexpected size % instead of 12", size_of(type_of(physx_PxVehicleChassisData_Pod.mCMOffset)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 28, "physx_PxVehicleChassisData_Pod.structgen_pad0 has unexpected offset % instead of 28", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleChassisData_Pod.structgen_pad0)) == 4, "physx_PxVehicleChassisData_Pod.structgen_pad0 has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleChassisData_Pod.structgen_pad0)));
    assert(size_of(physx_PxVehicleChassisData_Pod) == 32, "physx_PxVehicleChassisData_Pod has size % instead of 32", size_of(physx_PxVehicleChassisData_Pod));
}

PxFixedSizeLookupTable_eMAX_NB_ENGINE_TORQUE_CURVE_ENTRIES__Pod :: struct {
    mDataPairs:   [16] float;
    mNbDataPairs: u32;
    mPad:         [3] u32;
}
#run {
    instance: PxFixedSizeLookupTable_eMAX_NB_ENGINE_TORQUE_CURVE_ENTRIES__Pod;
    assert(((cast(*void)(*instance.mDataPairs)) - cast(*void)(*instance)) == 0, "PxFixedSizeLookupTable_eMAX_NB_ENGINE_TORQUE_CURVE_ENTRIES__Pod.mDataPairs has unexpected offset % instead of 0", ((cast(*void)(*instance.mDataPairs)) - cast(*void)(*instance)));
    assert(size_of(type_of(PxFixedSizeLookupTable_eMAX_NB_ENGINE_TORQUE_CURVE_ENTRIES__Pod.mDataPairs)) == 64, "PxFixedSizeLookupTable_eMAX_NB_ENGINE_TORQUE_CURVE_ENTRIES__Pod.mDataPairs has unexpected size % instead of 64", size_of(type_of(PxFixedSizeLookupTable_eMAX_NB_ENGINE_TORQUE_CURVE_ENTRIES__Pod.mDataPairs)));
    assert(((cast(*void)(*instance.mNbDataPairs)) - cast(*void)(*instance)) == 64, "PxFixedSizeLookupTable_eMAX_NB_ENGINE_TORQUE_CURVE_ENTRIES__Pod.mNbDataPairs has unexpected offset % instead of 64", ((cast(*void)(*instance.mNbDataPairs)) - cast(*void)(*instance)));
    assert(size_of(type_of(PxFixedSizeLookupTable_eMAX_NB_ENGINE_TORQUE_CURVE_ENTRIES__Pod.mNbDataPairs)) == 4, "PxFixedSizeLookupTable_eMAX_NB_ENGINE_TORQUE_CURVE_ENTRIES__Pod.mNbDataPairs has unexpected size % instead of 4", size_of(type_of(PxFixedSizeLookupTable_eMAX_NB_ENGINE_TORQUE_CURVE_ENTRIES__Pod.mNbDataPairs)));
    assert(((cast(*void)(*instance.mPad)) - cast(*void)(*instance)) == 68, "PxFixedSizeLookupTable_eMAX_NB_ENGINE_TORQUE_CURVE_ENTRIES__Pod.mPad has unexpected offset % instead of 68", ((cast(*void)(*instance.mPad)) - cast(*void)(*instance)));
    assert(size_of(type_of(PxFixedSizeLookupTable_eMAX_NB_ENGINE_TORQUE_CURVE_ENTRIES__Pod.mPad)) == 12, "PxFixedSizeLookupTable_eMAX_NB_ENGINE_TORQUE_CURVE_ENTRIES__Pod.mPad has unexpected size % instead of 12", size_of(type_of(PxFixedSizeLookupTable_eMAX_NB_ENGINE_TORQUE_CURVE_ENTRIES__Pod.mPad)));
    assert(size_of(PxFixedSizeLookupTable_eMAX_NB_ENGINE_TORQUE_CURVE_ENTRIES__Pod) == 80, "PxFixedSizeLookupTable_eMAX_NB_ENGINE_TORQUE_CURVE_ENTRIES__Pod has size % instead of 80", size_of(PxFixedSizeLookupTable_eMAX_NB_ENGINE_TORQUE_CURVE_ENTRIES__Pod));
}

physx_PxVehicleEngineData_Pod :: struct {
    mTorqueCurve:                             PxFixedSizeLookupTable_eMAX_NB_ENGINE_TORQUE_CURVE_ENTRIES__Pod;
    mMOI:                                     float;
    mPeakTorque:                              float;
    mMaxOmega:                                float;
    mDampingRateFullThrottle:                 float;
    mDampingRateZeroThrottleClutchEngaged:    float;
    mDampingRateZeroThrottleClutchDisengaged: float;
    structgen_pad0:                           [8] u8;
}
#run {
    instance: physx_PxVehicleEngineData_Pod;
    assert(((cast(*void)(*instance.mTorqueCurve)) - cast(*void)(*instance)) == 0, "physx_PxVehicleEngineData_Pod.mTorqueCurve has unexpected offset % instead of 0", ((cast(*void)(*instance.mTorqueCurve)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleEngineData_Pod.mTorqueCurve)) == 80, "physx_PxVehicleEngineData_Pod.mTorqueCurve has unexpected size % instead of 80", size_of(type_of(physx_PxVehicleEngineData_Pod.mTorqueCurve)));
    assert(((cast(*void)(*instance.mMOI)) - cast(*void)(*instance)) == 80, "physx_PxVehicleEngineData_Pod.mMOI has unexpected offset % instead of 80", ((cast(*void)(*instance.mMOI)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleEngineData_Pod.mMOI)) == 4, "physx_PxVehicleEngineData_Pod.mMOI has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleEngineData_Pod.mMOI)));
    assert(((cast(*void)(*instance.mPeakTorque)) - cast(*void)(*instance)) == 84, "physx_PxVehicleEngineData_Pod.mPeakTorque has unexpected offset % instead of 84", ((cast(*void)(*instance.mPeakTorque)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleEngineData_Pod.mPeakTorque)) == 4, "physx_PxVehicleEngineData_Pod.mPeakTorque has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleEngineData_Pod.mPeakTorque)));
    assert(((cast(*void)(*instance.mMaxOmega)) - cast(*void)(*instance)) == 88, "physx_PxVehicleEngineData_Pod.mMaxOmega has unexpected offset % instead of 88", ((cast(*void)(*instance.mMaxOmega)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleEngineData_Pod.mMaxOmega)) == 4, "physx_PxVehicleEngineData_Pod.mMaxOmega has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleEngineData_Pod.mMaxOmega)));
    assert(((cast(*void)(*instance.mDampingRateFullThrottle)) - cast(*void)(*instance)) == 92, "physx_PxVehicleEngineData_Pod.mDampingRateFullThrottle has unexpected offset % instead of 92", ((cast(*void)(*instance.mDampingRateFullThrottle)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleEngineData_Pod.mDampingRateFullThrottle)) == 4, "physx_PxVehicleEngineData_Pod.mDampingRateFullThrottle has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleEngineData_Pod.mDampingRateFullThrottle)));
    assert(((cast(*void)(*instance.mDampingRateZeroThrottleClutchEngaged)) - cast(*void)(*instance)) == 96, "physx_PxVehicleEngineData_Pod.mDampingRateZeroThrottleClutchEngaged has unexpected offset % instead of 96", ((cast(*void)(*instance.mDampingRateZeroThrottleClutchEngaged)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleEngineData_Pod.mDampingRateZeroThrottleClutchEngaged)) == 4, "physx_PxVehicleEngineData_Pod.mDampingRateZeroThrottleClutchEngaged has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleEngineData_Pod.mDampingRateZeroThrottleClutchEngaged)));
    assert(((cast(*void)(*instance.mDampingRateZeroThrottleClutchDisengaged)) - cast(*void)(*instance)) == 100, "physx_PxVehicleEngineData_Pod.mDampingRateZeroThrottleClutchDisengaged has unexpected offset % instead of 100", ((cast(*void)(*instance.mDampingRateZeroThrottleClutchDisengaged)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleEngineData_Pod.mDampingRateZeroThrottleClutchDisengaged)) == 4, "physx_PxVehicleEngineData_Pod.mDampingRateZeroThrottleClutchDisengaged has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleEngineData_Pod.mDampingRateZeroThrottleClutchDisengaged)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 104, "physx_PxVehicleEngineData_Pod.structgen_pad0 has unexpected offset % instead of 104", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleEngineData_Pod.structgen_pad0)) == 8, "physx_PxVehicleEngineData_Pod.structgen_pad0 has unexpected size % instead of 8", size_of(type_of(physx_PxVehicleEngineData_Pod.structgen_pad0)));
    assert(size_of(physx_PxVehicleEngineData_Pod) == 112, "physx_PxVehicleEngineData_Pod has size % instead of 112", size_of(physx_PxVehicleEngineData_Pod));
}

physx_PxVehicleGearsData_Pod :: struct {
    mRatios:        [32] float;
    mFinalRatio:    float;
    mNbRatios:      u32;
    mSwitchTime:    float;
    structgen_pad0: [4] u8;
}
#run {
    instance: physx_PxVehicleGearsData_Pod;
    assert(((cast(*void)(*instance.mRatios)) - cast(*void)(*instance)) == 0, "physx_PxVehicleGearsData_Pod.mRatios has unexpected offset % instead of 0", ((cast(*void)(*instance.mRatios)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleGearsData_Pod.mRatios)) == 128, "physx_PxVehicleGearsData_Pod.mRatios has unexpected size % instead of 128", size_of(type_of(physx_PxVehicleGearsData_Pod.mRatios)));
    assert(((cast(*void)(*instance.mFinalRatio)) - cast(*void)(*instance)) == 128, "physx_PxVehicleGearsData_Pod.mFinalRatio has unexpected offset % instead of 128", ((cast(*void)(*instance.mFinalRatio)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleGearsData_Pod.mFinalRatio)) == 4, "physx_PxVehicleGearsData_Pod.mFinalRatio has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleGearsData_Pod.mFinalRatio)));
    assert(((cast(*void)(*instance.mNbRatios)) - cast(*void)(*instance)) == 132, "physx_PxVehicleGearsData_Pod.mNbRatios has unexpected offset % instead of 132", ((cast(*void)(*instance.mNbRatios)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleGearsData_Pod.mNbRatios)) == 4, "physx_PxVehicleGearsData_Pod.mNbRatios has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleGearsData_Pod.mNbRatios)));
    assert(((cast(*void)(*instance.mSwitchTime)) - cast(*void)(*instance)) == 136, "physx_PxVehicleGearsData_Pod.mSwitchTime has unexpected offset % instead of 136", ((cast(*void)(*instance.mSwitchTime)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleGearsData_Pod.mSwitchTime)) == 4, "physx_PxVehicleGearsData_Pod.mSwitchTime has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleGearsData_Pod.mSwitchTime)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 140, "physx_PxVehicleGearsData_Pod.structgen_pad0 has unexpected offset % instead of 140", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleGearsData_Pod.structgen_pad0)) == 4, "physx_PxVehicleGearsData_Pod.structgen_pad0 has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleGearsData_Pod.structgen_pad0)));
    assert(size_of(physx_PxVehicleGearsData_Pod) == 144, "physx_PxVehicleGearsData_Pod has size % instead of 144", size_of(physx_PxVehicleGearsData_Pod));
}

physx_PxVehicleAutoBoxData_Pod :: struct {
    mUpRatios:   [32] float;
    mDownRatios: [32] float;
}
#run {
    instance: physx_PxVehicleAutoBoxData_Pod;
    assert(((cast(*void)(*instance.mUpRatios)) - cast(*void)(*instance)) == 0, "physx_PxVehicleAutoBoxData_Pod.mUpRatios has unexpected offset % instead of 0", ((cast(*void)(*instance.mUpRatios)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleAutoBoxData_Pod.mUpRatios)) == 128, "physx_PxVehicleAutoBoxData_Pod.mUpRatios has unexpected size % instead of 128", size_of(type_of(physx_PxVehicleAutoBoxData_Pod.mUpRatios)));
    assert(((cast(*void)(*instance.mDownRatios)) - cast(*void)(*instance)) == 128, "physx_PxVehicleAutoBoxData_Pod.mDownRatios has unexpected offset % instead of 128", ((cast(*void)(*instance.mDownRatios)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleAutoBoxData_Pod.mDownRatios)) == 128, "physx_PxVehicleAutoBoxData_Pod.mDownRatios has unexpected size % instead of 128", size_of(type_of(physx_PxVehicleAutoBoxData_Pod.mDownRatios)));
    assert(size_of(physx_PxVehicleAutoBoxData_Pod) == 256, "physx_PxVehicleAutoBoxData_Pod has size % instead of 256", size_of(physx_PxVehicleAutoBoxData_Pod));
}

physx_PxVehicleDifferential4WData_Pod :: struct {
    mFrontRearSplit:      float;
    mFrontLeftRightSplit: float;
    mRearLeftRightSplit:  float;
    mCentreBias:          float;
    mFrontBias:           float;
    mRearBias:            float;
    mType:                u32;
    structgen_pad0:       [4] u8;
}
#run {
    instance: physx_PxVehicleDifferential4WData_Pod;
    assert(((cast(*void)(*instance.mFrontRearSplit)) - cast(*void)(*instance)) == 0, "physx_PxVehicleDifferential4WData_Pod.mFrontRearSplit has unexpected offset % instead of 0", ((cast(*void)(*instance.mFrontRearSplit)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDifferential4WData_Pod.mFrontRearSplit)) == 4, "physx_PxVehicleDifferential4WData_Pod.mFrontRearSplit has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleDifferential4WData_Pod.mFrontRearSplit)));
    assert(((cast(*void)(*instance.mFrontLeftRightSplit)) - cast(*void)(*instance)) == 4, "physx_PxVehicleDifferential4WData_Pod.mFrontLeftRightSplit has unexpected offset % instead of 4", ((cast(*void)(*instance.mFrontLeftRightSplit)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDifferential4WData_Pod.mFrontLeftRightSplit)) == 4, "physx_PxVehicleDifferential4WData_Pod.mFrontLeftRightSplit has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleDifferential4WData_Pod.mFrontLeftRightSplit)));
    assert(((cast(*void)(*instance.mRearLeftRightSplit)) - cast(*void)(*instance)) == 8, "physx_PxVehicleDifferential4WData_Pod.mRearLeftRightSplit has unexpected offset % instead of 8", ((cast(*void)(*instance.mRearLeftRightSplit)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDifferential4WData_Pod.mRearLeftRightSplit)) == 4, "physx_PxVehicleDifferential4WData_Pod.mRearLeftRightSplit has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleDifferential4WData_Pod.mRearLeftRightSplit)));
    assert(((cast(*void)(*instance.mCentreBias)) - cast(*void)(*instance)) == 12, "physx_PxVehicleDifferential4WData_Pod.mCentreBias has unexpected offset % instead of 12", ((cast(*void)(*instance.mCentreBias)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDifferential4WData_Pod.mCentreBias)) == 4, "physx_PxVehicleDifferential4WData_Pod.mCentreBias has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleDifferential4WData_Pod.mCentreBias)));
    assert(((cast(*void)(*instance.mFrontBias)) - cast(*void)(*instance)) == 16, "physx_PxVehicleDifferential4WData_Pod.mFrontBias has unexpected offset % instead of 16", ((cast(*void)(*instance.mFrontBias)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDifferential4WData_Pod.mFrontBias)) == 4, "physx_PxVehicleDifferential4WData_Pod.mFrontBias has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleDifferential4WData_Pod.mFrontBias)));
    assert(((cast(*void)(*instance.mRearBias)) - cast(*void)(*instance)) == 20, "physx_PxVehicleDifferential4WData_Pod.mRearBias has unexpected offset % instead of 20", ((cast(*void)(*instance.mRearBias)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDifferential4WData_Pod.mRearBias)) == 4, "physx_PxVehicleDifferential4WData_Pod.mRearBias has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleDifferential4WData_Pod.mRearBias)));
    assert(((cast(*void)(*instance.mType)) - cast(*void)(*instance)) == 24, "physx_PxVehicleDifferential4WData_Pod.mType has unexpected offset % instead of 24", ((cast(*void)(*instance.mType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDifferential4WData_Pod.mType)) == 4, "physx_PxVehicleDifferential4WData_Pod.mType has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleDifferential4WData_Pod.mType)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 28, "physx_PxVehicleDifferential4WData_Pod.structgen_pad0 has unexpected offset % instead of 28", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDifferential4WData_Pod.structgen_pad0)) == 4, "physx_PxVehicleDifferential4WData_Pod.structgen_pad0 has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleDifferential4WData_Pod.structgen_pad0)));
    assert(size_of(physx_PxVehicleDifferential4WData_Pod) == 32, "physx_PxVehicleDifferential4WData_Pod has size % instead of 32", size_of(physx_PxVehicleDifferential4WData_Pod));
}

physx_PxVehicleDifferentialNWData_Pod :: struct {
    structgen_pad0: [16] u8;
}
#run {
    instance: physx_PxVehicleDifferentialNWData_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxVehicleDifferentialNWData_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDifferentialNWData_Pod.structgen_pad0)) == 16, "physx_PxVehicleDifferentialNWData_Pod.structgen_pad0 has unexpected size % instead of 16", size_of(type_of(physx_PxVehicleDifferentialNWData_Pod.structgen_pad0)));
    assert(size_of(physx_PxVehicleDifferentialNWData_Pod) == 16, "physx_PxVehicleDifferentialNWData_Pod has size % instead of 16", size_of(physx_PxVehicleDifferentialNWData_Pod));
}

physx_PxVehicleAckermannGeometryData_Pod :: struct {
    mAccuracy:       float;
    mFrontWidth:     float;
    mRearWidth:      float;
    mAxleSeparation: float;
}
#run {
    instance: physx_PxVehicleAckermannGeometryData_Pod;
    assert(((cast(*void)(*instance.mAccuracy)) - cast(*void)(*instance)) == 0, "physx_PxVehicleAckermannGeometryData_Pod.mAccuracy has unexpected offset % instead of 0", ((cast(*void)(*instance.mAccuracy)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleAckermannGeometryData_Pod.mAccuracy)) == 4, "physx_PxVehicleAckermannGeometryData_Pod.mAccuracy has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleAckermannGeometryData_Pod.mAccuracy)));
    assert(((cast(*void)(*instance.mFrontWidth)) - cast(*void)(*instance)) == 4, "physx_PxVehicleAckermannGeometryData_Pod.mFrontWidth has unexpected offset % instead of 4", ((cast(*void)(*instance.mFrontWidth)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleAckermannGeometryData_Pod.mFrontWidth)) == 4, "physx_PxVehicleAckermannGeometryData_Pod.mFrontWidth has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleAckermannGeometryData_Pod.mFrontWidth)));
    assert(((cast(*void)(*instance.mRearWidth)) - cast(*void)(*instance)) == 8, "physx_PxVehicleAckermannGeometryData_Pod.mRearWidth has unexpected offset % instead of 8", ((cast(*void)(*instance.mRearWidth)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleAckermannGeometryData_Pod.mRearWidth)) == 4, "physx_PxVehicleAckermannGeometryData_Pod.mRearWidth has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleAckermannGeometryData_Pod.mRearWidth)));
    assert(((cast(*void)(*instance.mAxleSeparation)) - cast(*void)(*instance)) == 12, "physx_PxVehicleAckermannGeometryData_Pod.mAxleSeparation has unexpected offset % instead of 12", ((cast(*void)(*instance.mAxleSeparation)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleAckermannGeometryData_Pod.mAxleSeparation)) == 4, "physx_PxVehicleAckermannGeometryData_Pod.mAxleSeparation has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleAckermannGeometryData_Pod.mAxleSeparation)));
    assert(size_of(physx_PxVehicleAckermannGeometryData_Pod) == 16, "physx_PxVehicleAckermannGeometryData_Pod has size % instead of 16", size_of(physx_PxVehicleAckermannGeometryData_Pod));
}

physx_PxVehicleClutchData_Pod :: struct {
    mStrength:           float;
    mAccuracyMode:       u32;
    mEstimateIterations: u32;
    structgen_pad0:      [4] u8;
}
#run {
    instance: physx_PxVehicleClutchData_Pod;
    assert(((cast(*void)(*instance.mStrength)) - cast(*void)(*instance)) == 0, "physx_PxVehicleClutchData_Pod.mStrength has unexpected offset % instead of 0", ((cast(*void)(*instance.mStrength)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleClutchData_Pod.mStrength)) == 4, "physx_PxVehicleClutchData_Pod.mStrength has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleClutchData_Pod.mStrength)));
    assert(((cast(*void)(*instance.mAccuracyMode)) - cast(*void)(*instance)) == 4, "physx_PxVehicleClutchData_Pod.mAccuracyMode has unexpected offset % instead of 4", ((cast(*void)(*instance.mAccuracyMode)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleClutchData_Pod.mAccuracyMode)) == 4, "physx_PxVehicleClutchData_Pod.mAccuracyMode has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleClutchData_Pod.mAccuracyMode)));
    assert(((cast(*void)(*instance.mEstimateIterations)) - cast(*void)(*instance)) == 8, "physx_PxVehicleClutchData_Pod.mEstimateIterations has unexpected offset % instead of 8", ((cast(*void)(*instance.mEstimateIterations)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleClutchData_Pod.mEstimateIterations)) == 4, "physx_PxVehicleClutchData_Pod.mEstimateIterations has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleClutchData_Pod.mEstimateIterations)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 12, "physx_PxVehicleClutchData_Pod.structgen_pad0 has unexpected offset % instead of 12", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleClutchData_Pod.structgen_pad0)) == 4, "physx_PxVehicleClutchData_Pod.structgen_pad0 has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleClutchData_Pod.structgen_pad0)));
    assert(size_of(physx_PxVehicleClutchData_Pod) == 16, "physx_PxVehicleClutchData_Pod has size % instead of 16", size_of(physx_PxVehicleClutchData_Pod));
}

physx_PxVehicleTireLoadFilterData_Pod :: struct {
    mMinNormalisedLoad:         float;
    mMinFilteredNormalisedLoad: float;
    mMaxNormalisedLoad:         float;
    mMaxFilteredNormalisedLoad: float;
    structgen_pad0:             [16] u8;
}
#run {
    instance: physx_PxVehicleTireLoadFilterData_Pod;
    assert(((cast(*void)(*instance.mMinNormalisedLoad)) - cast(*void)(*instance)) == 0, "physx_PxVehicleTireLoadFilterData_Pod.mMinNormalisedLoad has unexpected offset % instead of 0", ((cast(*void)(*instance.mMinNormalisedLoad)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleTireLoadFilterData_Pod.mMinNormalisedLoad)) == 4, "physx_PxVehicleTireLoadFilterData_Pod.mMinNormalisedLoad has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleTireLoadFilterData_Pod.mMinNormalisedLoad)));
    assert(((cast(*void)(*instance.mMinFilteredNormalisedLoad)) - cast(*void)(*instance)) == 4, "physx_PxVehicleTireLoadFilterData_Pod.mMinFilteredNormalisedLoad has unexpected offset % instead of 4", ((cast(*void)(*instance.mMinFilteredNormalisedLoad)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleTireLoadFilterData_Pod.mMinFilteredNormalisedLoad)) == 4, "physx_PxVehicleTireLoadFilterData_Pod.mMinFilteredNormalisedLoad has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleTireLoadFilterData_Pod.mMinFilteredNormalisedLoad)));
    assert(((cast(*void)(*instance.mMaxNormalisedLoad)) - cast(*void)(*instance)) == 8, "physx_PxVehicleTireLoadFilterData_Pod.mMaxNormalisedLoad has unexpected offset % instead of 8", ((cast(*void)(*instance.mMaxNormalisedLoad)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleTireLoadFilterData_Pod.mMaxNormalisedLoad)) == 4, "physx_PxVehicleTireLoadFilterData_Pod.mMaxNormalisedLoad has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleTireLoadFilterData_Pod.mMaxNormalisedLoad)));
    assert(((cast(*void)(*instance.mMaxFilteredNormalisedLoad)) - cast(*void)(*instance)) == 12, "physx_PxVehicleTireLoadFilterData_Pod.mMaxFilteredNormalisedLoad has unexpected offset % instead of 12", ((cast(*void)(*instance.mMaxFilteredNormalisedLoad)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleTireLoadFilterData_Pod.mMaxFilteredNormalisedLoad)) == 4, "physx_PxVehicleTireLoadFilterData_Pod.mMaxFilteredNormalisedLoad has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleTireLoadFilterData_Pod.mMaxFilteredNormalisedLoad)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 16, "physx_PxVehicleTireLoadFilterData_Pod.structgen_pad0 has unexpected offset % instead of 16", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleTireLoadFilterData_Pod.structgen_pad0)) == 16, "physx_PxVehicleTireLoadFilterData_Pod.structgen_pad0 has unexpected size % instead of 16", size_of(type_of(physx_PxVehicleTireLoadFilterData_Pod.structgen_pad0)));
    assert(size_of(physx_PxVehicleTireLoadFilterData_Pod) == 32, "physx_PxVehicleTireLoadFilterData_Pod has size % instead of 32", size_of(physx_PxVehicleTireLoadFilterData_Pod));
}

physx_PxVehicleWheelData_Pod :: struct {
    mRadius:             float;
    mWidth:              float;
    mMass:               float;
    mMOI:                float;
    mDampingRate:        float;
    mMaxBrakeTorque:     float;
    mMaxHandBrakeTorque: float;
    mMaxSteer:           float;
    mToeAngle:           float;
    structgen_pad0:      [12] u8;
}
#run {
    instance: physx_PxVehicleWheelData_Pod;
    assert(((cast(*void)(*instance.mRadius)) - cast(*void)(*instance)) == 0, "physx_PxVehicleWheelData_Pod.mRadius has unexpected offset % instead of 0", ((cast(*void)(*instance.mRadius)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleWheelData_Pod.mRadius)) == 4, "physx_PxVehicleWheelData_Pod.mRadius has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleWheelData_Pod.mRadius)));
    assert(((cast(*void)(*instance.mWidth)) - cast(*void)(*instance)) == 4, "physx_PxVehicleWheelData_Pod.mWidth has unexpected offset % instead of 4", ((cast(*void)(*instance.mWidth)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleWheelData_Pod.mWidth)) == 4, "physx_PxVehicleWheelData_Pod.mWidth has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleWheelData_Pod.mWidth)));
    assert(((cast(*void)(*instance.mMass)) - cast(*void)(*instance)) == 8, "physx_PxVehicleWheelData_Pod.mMass has unexpected offset % instead of 8", ((cast(*void)(*instance.mMass)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleWheelData_Pod.mMass)) == 4, "physx_PxVehicleWheelData_Pod.mMass has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleWheelData_Pod.mMass)));
    assert(((cast(*void)(*instance.mMOI)) - cast(*void)(*instance)) == 12, "physx_PxVehicleWheelData_Pod.mMOI has unexpected offset % instead of 12", ((cast(*void)(*instance.mMOI)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleWheelData_Pod.mMOI)) == 4, "physx_PxVehicleWheelData_Pod.mMOI has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleWheelData_Pod.mMOI)));
    assert(((cast(*void)(*instance.mDampingRate)) - cast(*void)(*instance)) == 16, "physx_PxVehicleWheelData_Pod.mDampingRate has unexpected offset % instead of 16", ((cast(*void)(*instance.mDampingRate)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleWheelData_Pod.mDampingRate)) == 4, "physx_PxVehicleWheelData_Pod.mDampingRate has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleWheelData_Pod.mDampingRate)));
    assert(((cast(*void)(*instance.mMaxBrakeTorque)) - cast(*void)(*instance)) == 20, "physx_PxVehicleWheelData_Pod.mMaxBrakeTorque has unexpected offset % instead of 20", ((cast(*void)(*instance.mMaxBrakeTorque)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleWheelData_Pod.mMaxBrakeTorque)) == 4, "physx_PxVehicleWheelData_Pod.mMaxBrakeTorque has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleWheelData_Pod.mMaxBrakeTorque)));
    assert(((cast(*void)(*instance.mMaxHandBrakeTorque)) - cast(*void)(*instance)) == 24, "physx_PxVehicleWheelData_Pod.mMaxHandBrakeTorque has unexpected offset % instead of 24", ((cast(*void)(*instance.mMaxHandBrakeTorque)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleWheelData_Pod.mMaxHandBrakeTorque)) == 4, "physx_PxVehicleWheelData_Pod.mMaxHandBrakeTorque has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleWheelData_Pod.mMaxHandBrakeTorque)));
    assert(((cast(*void)(*instance.mMaxSteer)) - cast(*void)(*instance)) == 28, "physx_PxVehicleWheelData_Pod.mMaxSteer has unexpected offset % instead of 28", ((cast(*void)(*instance.mMaxSteer)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleWheelData_Pod.mMaxSteer)) == 4, "physx_PxVehicleWheelData_Pod.mMaxSteer has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleWheelData_Pod.mMaxSteer)));
    assert(((cast(*void)(*instance.mToeAngle)) - cast(*void)(*instance)) == 32, "physx_PxVehicleWheelData_Pod.mToeAngle has unexpected offset % instead of 32", ((cast(*void)(*instance.mToeAngle)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleWheelData_Pod.mToeAngle)) == 4, "physx_PxVehicleWheelData_Pod.mToeAngle has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleWheelData_Pod.mToeAngle)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 36, "physx_PxVehicleWheelData_Pod.structgen_pad0 has unexpected offset % instead of 36", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleWheelData_Pod.structgen_pad0)) == 12, "physx_PxVehicleWheelData_Pod.structgen_pad0 has unexpected size % instead of 12", size_of(type_of(physx_PxVehicleWheelData_Pod.structgen_pad0)));
    assert(size_of(physx_PxVehicleWheelData_Pod) == 48, "physx_PxVehicleWheelData_Pod has size % instead of 48", size_of(physx_PxVehicleWheelData_Pod));
}

physx_PxVehicleSuspensionData_Pod :: struct {
    mSpringStrength:         float;
    mSpringDamperRate:       float;
    mMaxCompression:         float;
    mMaxDroop:               float;
    mSprungMass:             float;
    mCamberAtRest:           float;
    mCamberAtMaxCompression: float;
    mCamberAtMaxDroop:       float;
    structgen_pad0:          [16] u8;
}
#run {
    instance: physx_PxVehicleSuspensionData_Pod;
    assert(((cast(*void)(*instance.mSpringStrength)) - cast(*void)(*instance)) == 0, "physx_PxVehicleSuspensionData_Pod.mSpringStrength has unexpected offset % instead of 0", ((cast(*void)(*instance.mSpringStrength)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleSuspensionData_Pod.mSpringStrength)) == 4, "physx_PxVehicleSuspensionData_Pod.mSpringStrength has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleSuspensionData_Pod.mSpringStrength)));
    assert(((cast(*void)(*instance.mSpringDamperRate)) - cast(*void)(*instance)) == 4, "physx_PxVehicleSuspensionData_Pod.mSpringDamperRate has unexpected offset % instead of 4", ((cast(*void)(*instance.mSpringDamperRate)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleSuspensionData_Pod.mSpringDamperRate)) == 4, "physx_PxVehicleSuspensionData_Pod.mSpringDamperRate has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleSuspensionData_Pod.mSpringDamperRate)));
    assert(((cast(*void)(*instance.mMaxCompression)) - cast(*void)(*instance)) == 8, "physx_PxVehicleSuspensionData_Pod.mMaxCompression has unexpected offset % instead of 8", ((cast(*void)(*instance.mMaxCompression)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleSuspensionData_Pod.mMaxCompression)) == 4, "physx_PxVehicleSuspensionData_Pod.mMaxCompression has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleSuspensionData_Pod.mMaxCompression)));
    assert(((cast(*void)(*instance.mMaxDroop)) - cast(*void)(*instance)) == 12, "physx_PxVehicleSuspensionData_Pod.mMaxDroop has unexpected offset % instead of 12", ((cast(*void)(*instance.mMaxDroop)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleSuspensionData_Pod.mMaxDroop)) == 4, "physx_PxVehicleSuspensionData_Pod.mMaxDroop has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleSuspensionData_Pod.mMaxDroop)));
    assert(((cast(*void)(*instance.mSprungMass)) - cast(*void)(*instance)) == 16, "physx_PxVehicleSuspensionData_Pod.mSprungMass has unexpected offset % instead of 16", ((cast(*void)(*instance.mSprungMass)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleSuspensionData_Pod.mSprungMass)) == 4, "physx_PxVehicleSuspensionData_Pod.mSprungMass has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleSuspensionData_Pod.mSprungMass)));
    assert(((cast(*void)(*instance.mCamberAtRest)) - cast(*void)(*instance)) == 20, "physx_PxVehicleSuspensionData_Pod.mCamberAtRest has unexpected offset % instead of 20", ((cast(*void)(*instance.mCamberAtRest)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleSuspensionData_Pod.mCamberAtRest)) == 4, "physx_PxVehicleSuspensionData_Pod.mCamberAtRest has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleSuspensionData_Pod.mCamberAtRest)));
    assert(((cast(*void)(*instance.mCamberAtMaxCompression)) - cast(*void)(*instance)) == 24, "physx_PxVehicleSuspensionData_Pod.mCamberAtMaxCompression has unexpected offset % instead of 24", ((cast(*void)(*instance.mCamberAtMaxCompression)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleSuspensionData_Pod.mCamberAtMaxCompression)) == 4, "physx_PxVehicleSuspensionData_Pod.mCamberAtMaxCompression has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleSuspensionData_Pod.mCamberAtMaxCompression)));
    assert(((cast(*void)(*instance.mCamberAtMaxDroop)) - cast(*void)(*instance)) == 28, "physx_PxVehicleSuspensionData_Pod.mCamberAtMaxDroop has unexpected offset % instead of 28", ((cast(*void)(*instance.mCamberAtMaxDroop)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleSuspensionData_Pod.mCamberAtMaxDroop)) == 4, "physx_PxVehicleSuspensionData_Pod.mCamberAtMaxDroop has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleSuspensionData_Pod.mCamberAtMaxDroop)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 32, "physx_PxVehicleSuspensionData_Pod.structgen_pad0 has unexpected offset % instead of 32", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleSuspensionData_Pod.structgen_pad0)) == 16, "physx_PxVehicleSuspensionData_Pod.structgen_pad0 has unexpected size % instead of 16", size_of(type_of(physx_PxVehicleSuspensionData_Pod.structgen_pad0)));
    assert(size_of(physx_PxVehicleSuspensionData_Pod) == 48, "physx_PxVehicleSuspensionData_Pod has size % instead of 48", size_of(physx_PxVehicleSuspensionData_Pod));
}

physx_PxVehicleAntiRollBarData_Pod :: struct {
    mWheel0:        u32;
    mWheel1:        u32;
    mStiffness:     float;
    structgen_pad0: [4] u8;
}
#run {
    instance: physx_PxVehicleAntiRollBarData_Pod;
    assert(((cast(*void)(*instance.mWheel0)) - cast(*void)(*instance)) == 0, "physx_PxVehicleAntiRollBarData_Pod.mWheel0 has unexpected offset % instead of 0", ((cast(*void)(*instance.mWheel0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleAntiRollBarData_Pod.mWheel0)) == 4, "physx_PxVehicleAntiRollBarData_Pod.mWheel0 has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleAntiRollBarData_Pod.mWheel0)));
    assert(((cast(*void)(*instance.mWheel1)) - cast(*void)(*instance)) == 4, "physx_PxVehicleAntiRollBarData_Pod.mWheel1 has unexpected offset % instead of 4", ((cast(*void)(*instance.mWheel1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleAntiRollBarData_Pod.mWheel1)) == 4, "physx_PxVehicleAntiRollBarData_Pod.mWheel1 has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleAntiRollBarData_Pod.mWheel1)));
    assert(((cast(*void)(*instance.mStiffness)) - cast(*void)(*instance)) == 8, "physx_PxVehicleAntiRollBarData_Pod.mStiffness has unexpected offset % instead of 8", ((cast(*void)(*instance.mStiffness)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleAntiRollBarData_Pod.mStiffness)) == 4, "physx_PxVehicleAntiRollBarData_Pod.mStiffness has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleAntiRollBarData_Pod.mStiffness)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 12, "physx_PxVehicleAntiRollBarData_Pod.structgen_pad0 has unexpected offset % instead of 12", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleAntiRollBarData_Pod.structgen_pad0)) == 4, "physx_PxVehicleAntiRollBarData_Pod.structgen_pad0 has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleAntiRollBarData_Pod.structgen_pad0)));
    assert(size_of(physx_PxVehicleAntiRollBarData_Pod) == 16, "physx_PxVehicleAntiRollBarData_Pod has size % instead of 16", size_of(physx_PxVehicleAntiRollBarData_Pod));
}

physx_PxVehicleTireData_Pod :: struct {
    mLatStiffX:                           float;
    mLatStiffY:                           float;
    mLongitudinalStiffnessPerUnitGravity: float;
    mCamberStiffnessPerUnitGravity:       float;
    mFrictionVsSlipGraph:                 [3] [2] float;
    mType:                                u32;
    structgen_pad0:                       [20] u8;
}
#run {
    instance: physx_PxVehicleTireData_Pod;
    assert(((cast(*void)(*instance.mLatStiffX)) - cast(*void)(*instance)) == 0, "physx_PxVehicleTireData_Pod.mLatStiffX has unexpected offset % instead of 0", ((cast(*void)(*instance.mLatStiffX)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleTireData_Pod.mLatStiffX)) == 4, "physx_PxVehicleTireData_Pod.mLatStiffX has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleTireData_Pod.mLatStiffX)));
    assert(((cast(*void)(*instance.mLatStiffY)) - cast(*void)(*instance)) == 4, "physx_PxVehicleTireData_Pod.mLatStiffY has unexpected offset % instead of 4", ((cast(*void)(*instance.mLatStiffY)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleTireData_Pod.mLatStiffY)) == 4, "physx_PxVehicleTireData_Pod.mLatStiffY has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleTireData_Pod.mLatStiffY)));
    assert(((cast(*void)(*instance.mLongitudinalStiffnessPerUnitGravity)) - cast(*void)(*instance)) == 8, "physx_PxVehicleTireData_Pod.mLongitudinalStiffnessPerUnitGravity has unexpected offset % instead of 8", ((cast(*void)(*instance.mLongitudinalStiffnessPerUnitGravity)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleTireData_Pod.mLongitudinalStiffnessPerUnitGravity)) == 4, "physx_PxVehicleTireData_Pod.mLongitudinalStiffnessPerUnitGravity has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleTireData_Pod.mLongitudinalStiffnessPerUnitGravity)));
    assert(((cast(*void)(*instance.mCamberStiffnessPerUnitGravity)) - cast(*void)(*instance)) == 12, "physx_PxVehicleTireData_Pod.mCamberStiffnessPerUnitGravity has unexpected offset % instead of 12", ((cast(*void)(*instance.mCamberStiffnessPerUnitGravity)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleTireData_Pod.mCamberStiffnessPerUnitGravity)) == 4, "physx_PxVehicleTireData_Pod.mCamberStiffnessPerUnitGravity has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleTireData_Pod.mCamberStiffnessPerUnitGravity)));
    assert(((cast(*void)(*instance.mFrictionVsSlipGraph)) - cast(*void)(*instance)) == 16, "physx_PxVehicleTireData_Pod.mFrictionVsSlipGraph has unexpected offset % instead of 16", ((cast(*void)(*instance.mFrictionVsSlipGraph)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleTireData_Pod.mFrictionVsSlipGraph)) == 24, "physx_PxVehicleTireData_Pod.mFrictionVsSlipGraph has unexpected size % instead of 24", size_of(type_of(physx_PxVehicleTireData_Pod.mFrictionVsSlipGraph)));
    assert(((cast(*void)(*instance.mType)) - cast(*void)(*instance)) == 40, "physx_PxVehicleTireData_Pod.mType has unexpected offset % instead of 40", ((cast(*void)(*instance.mType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleTireData_Pod.mType)) == 4, "physx_PxVehicleTireData_Pod.mType has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleTireData_Pod.mType)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 44, "physx_PxVehicleTireData_Pod.structgen_pad0 has unexpected offset % instead of 44", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleTireData_Pod.structgen_pad0)) == 20, "physx_PxVehicleTireData_Pod.structgen_pad0 has unexpected size % instead of 20", size_of(type_of(physx_PxVehicleTireData_Pod.structgen_pad0)));
    assert(size_of(physx_PxVehicleTireData_Pod) == 64, "physx_PxVehicleTireData_Pod has size % instead of 64", size_of(physx_PxVehicleTireData_Pod));
}

physx_PxVehicleWheels4SimData_Pod :: struct {}
physx_PxVehicleWheelsSimData_Pod :: struct {
    structgen_pad0: [96] u8;
}
#run {
    instance: physx_PxVehicleWheelsSimData_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxVehicleWheelsSimData_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleWheelsSimData_Pod.structgen_pad0)) == 96, "physx_PxVehicleWheelsSimData_Pod.structgen_pad0 has unexpected size % instead of 96", size_of(type_of(physx_PxVehicleWheelsSimData_Pod.structgen_pad0)));
    assert(size_of(physx_PxVehicleWheelsSimData_Pod) == 96, "physx_PxVehicleWheelsSimData_Pod has size % instead of 96", size_of(physx_PxVehicleWheelsSimData_Pod));
}

physx_PxVehicleWheelsSimFlags_Pod :: struct {
    mBits: u32;
}
#run {
    instance: physx_PxVehicleWheelsSimFlags_Pod;
    assert(((cast(*void)(*instance.mBits)) - cast(*void)(*instance)) == 0, "physx_PxVehicleWheelsSimFlags_Pod.mBits has unexpected offset % instead of 0", ((cast(*void)(*instance.mBits)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleWheelsSimFlags_Pod.mBits)) == 4, "physx_PxVehicleWheelsSimFlags_Pod.mBits has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleWheelsSimFlags_Pod.mBits)));
    assert(size_of(physx_PxVehicleWheelsSimFlags_Pod) == 4, "physx_PxVehicleWheelsSimFlags_Pod has size % instead of 4", size_of(physx_PxVehicleWheelsSimFlags_Pod));
}

physx_PxVehicleWheels4DynData_Pod :: struct {}
physx_PxVehicleTireForceCalculator_Pod :: struct {}
physx_PxVehicleWheelsDynData_Pod :: struct {
    structgen_pad0: [48] u8;
}
#run {
    instance: physx_PxVehicleWheelsDynData_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxVehicleWheelsDynData_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleWheelsDynData_Pod.structgen_pad0)) == 48, "physx_PxVehicleWheelsDynData_Pod.structgen_pad0 has unexpected size % instead of 48", size_of(type_of(physx_PxVehicleWheelsDynData_Pod.structgen_pad0)));
    assert(size_of(physx_PxVehicleWheelsDynData_Pod) == 48, "physx_PxVehicleWheelsDynData_Pod has size % instead of 48", size_of(physx_PxVehicleWheelsDynData_Pod));
}

physx_PxVehicleWheels_Pod :: struct {
    structgen_pad0: [8] u8;
    mConcreteType:  u16;
    mBaseFlags:     physx_PxBaseFlags_Pod;
    structgen_pad1: [4] u8;
    mWheelsSimData: physx_PxVehicleWheelsSimData_Pod;
    mWheelsDynData: physx_PxVehicleWheelsDynData_Pod;
    mActor:         *physx_PxRigidDynamic_Pod;
    structgen_pad2: [5] u8;
    mType:          u8;
    mPad0:          [14] u8;
    structgen_pad3: [4] u8;
}
#run {
    instance: physx_PxVehicleWheels_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxVehicleWheels_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleWheels_Pod.structgen_pad0)) == 8, "physx_PxVehicleWheels_Pod.structgen_pad0 has unexpected size % instead of 8", size_of(type_of(physx_PxVehicleWheels_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)) == 8, "physx_PxVehicleWheels_Pod.mConcreteType has unexpected offset % instead of 8", ((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleWheels_Pod.mConcreteType)) == 2, "physx_PxVehicleWheels_Pod.mConcreteType has unexpected size % instead of 2", size_of(type_of(physx_PxVehicleWheels_Pod.mConcreteType)));
    assert(((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)) == 10, "physx_PxVehicleWheels_Pod.mBaseFlags has unexpected offset % instead of 10", ((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleWheels_Pod.mBaseFlags)) == 2, "physx_PxVehicleWheels_Pod.mBaseFlags has unexpected size % instead of 2", size_of(type_of(physx_PxVehicleWheels_Pod.mBaseFlags)));
    assert(((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)) == 12, "physx_PxVehicleWheels_Pod.structgen_pad1 has unexpected offset % instead of 12", ((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleWheels_Pod.structgen_pad1)) == 4, "physx_PxVehicleWheels_Pod.structgen_pad1 has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleWheels_Pod.structgen_pad1)));
    assert(((cast(*void)(*instance.mWheelsSimData)) - cast(*void)(*instance)) == 16, "physx_PxVehicleWheels_Pod.mWheelsSimData has unexpected offset % instead of 16", ((cast(*void)(*instance.mWheelsSimData)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleWheels_Pod.mWheelsSimData)) == 96, "physx_PxVehicleWheels_Pod.mWheelsSimData has unexpected size % instead of 96", size_of(type_of(physx_PxVehicleWheels_Pod.mWheelsSimData)));
    assert(((cast(*void)(*instance.mWheelsDynData)) - cast(*void)(*instance)) == 112, "physx_PxVehicleWheels_Pod.mWheelsDynData has unexpected offset % instead of 112", ((cast(*void)(*instance.mWheelsDynData)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleWheels_Pod.mWheelsDynData)) == 48, "physx_PxVehicleWheels_Pod.mWheelsDynData has unexpected size % instead of 48", size_of(type_of(physx_PxVehicleWheels_Pod.mWheelsDynData)));
    assert(((cast(*void)(*instance.mActor)) - cast(*void)(*instance)) == 160, "physx_PxVehicleWheels_Pod.mActor has unexpected offset % instead of 160", ((cast(*void)(*instance.mActor)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleWheels_Pod.mActor)) == 8, "physx_PxVehicleWheels_Pod.mActor has unexpected size % instead of 8", size_of(type_of(physx_PxVehicleWheels_Pod.mActor)));
    assert(((cast(*void)(*instance.structgen_pad2)) - cast(*void)(*instance)) == 168, "physx_PxVehicleWheels_Pod.structgen_pad2 has unexpected offset % instead of 168", ((cast(*void)(*instance.structgen_pad2)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleWheels_Pod.structgen_pad2)) == 5, "physx_PxVehicleWheels_Pod.structgen_pad2 has unexpected size % instead of 5", size_of(type_of(physx_PxVehicleWheels_Pod.structgen_pad2)));
    assert(((cast(*void)(*instance.mType)) - cast(*void)(*instance)) == 173, "physx_PxVehicleWheels_Pod.mType has unexpected offset % instead of 173", ((cast(*void)(*instance.mType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleWheels_Pod.mType)) == 1, "physx_PxVehicleWheels_Pod.mType has unexpected size % instead of 1", size_of(type_of(physx_PxVehicleWheels_Pod.mType)));
    assert(((cast(*void)(*instance.mPad0)) - cast(*void)(*instance)) == 174, "physx_PxVehicleWheels_Pod.mPad0 has unexpected offset % instead of 174", ((cast(*void)(*instance.mPad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleWheels_Pod.mPad0)) == 14, "physx_PxVehicleWheels_Pod.mPad0 has unexpected size % instead of 14", size_of(type_of(physx_PxVehicleWheels_Pod.mPad0)));
    assert(((cast(*void)(*instance.structgen_pad3)) - cast(*void)(*instance)) == 188, "physx_PxVehicleWheels_Pod.structgen_pad3 has unexpected offset % instead of 188", ((cast(*void)(*instance.structgen_pad3)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleWheels_Pod.structgen_pad3)) == 4, "physx_PxVehicleWheels_Pod.structgen_pad3 has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleWheels_Pod.structgen_pad3)));
    assert(size_of(physx_PxVehicleWheels_Pod) == 192, "physx_PxVehicleWheels_Pod has size % instead of 192", size_of(physx_PxVehicleWheels_Pod));
}

physx_PxVehicleDriveSimData_Pod :: struct {
    mEngine:  physx_PxVehicleEngineData_Pod;
    mGears:   physx_PxVehicleGearsData_Pod;
    mClutch:  physx_PxVehicleClutchData_Pod;
    mAutoBox: physx_PxVehicleAutoBoxData_Pod;
}
#run {
    instance: physx_PxVehicleDriveSimData_Pod;
    assert(((cast(*void)(*instance.mEngine)) - cast(*void)(*instance)) == 0, "physx_PxVehicleDriveSimData_Pod.mEngine has unexpected offset % instead of 0", ((cast(*void)(*instance.mEngine)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDriveSimData_Pod.mEngine)) == 112, "physx_PxVehicleDriveSimData_Pod.mEngine has unexpected size % instead of 112", size_of(type_of(physx_PxVehicleDriveSimData_Pod.mEngine)));
    assert(((cast(*void)(*instance.mGears)) - cast(*void)(*instance)) == 112, "physx_PxVehicleDriveSimData_Pod.mGears has unexpected offset % instead of 112", ((cast(*void)(*instance.mGears)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDriveSimData_Pod.mGears)) == 144, "physx_PxVehicleDriveSimData_Pod.mGears has unexpected size % instead of 144", size_of(type_of(physx_PxVehicleDriveSimData_Pod.mGears)));
    assert(((cast(*void)(*instance.mClutch)) - cast(*void)(*instance)) == 256, "physx_PxVehicleDriveSimData_Pod.mClutch has unexpected offset % instead of 256", ((cast(*void)(*instance.mClutch)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDriveSimData_Pod.mClutch)) == 16, "physx_PxVehicleDriveSimData_Pod.mClutch has unexpected size % instead of 16", size_of(type_of(physx_PxVehicleDriveSimData_Pod.mClutch)));
    assert(((cast(*void)(*instance.mAutoBox)) - cast(*void)(*instance)) == 272, "physx_PxVehicleDriveSimData_Pod.mAutoBox has unexpected offset % instead of 272", ((cast(*void)(*instance.mAutoBox)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDriveSimData_Pod.mAutoBox)) == 256, "physx_PxVehicleDriveSimData_Pod.mAutoBox has unexpected size % instead of 256", size_of(type_of(physx_PxVehicleDriveSimData_Pod.mAutoBox)));
    assert(size_of(physx_PxVehicleDriveSimData_Pod) == 528, "physx_PxVehicleDriveSimData_Pod has size % instead of 528", size_of(physx_PxVehicleDriveSimData_Pod));
}

physx_PxVehicleDriveDynData_Pod :: struct {
    mControlAnalogVals: [16] float;
    mUseAutoGears:      bool;
    mGearUpPressed:     bool;
    mGearDownPressed:   bool;
    structgen_pad0:     [1] u8;
    mCurrentGear:       u32;
    mTargetGear:        u32;
    mEnginespeed:       float;
    mGearSwitchTime:    float;
    mAutoBoxSwitchTime: float;
    structgen_pad1:     [8] u8;
}
#run {
    instance: physx_PxVehicleDriveDynData_Pod;
    assert(((cast(*void)(*instance.mControlAnalogVals)) - cast(*void)(*instance)) == 0, "physx_PxVehicleDriveDynData_Pod.mControlAnalogVals has unexpected offset % instead of 0", ((cast(*void)(*instance.mControlAnalogVals)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDriveDynData_Pod.mControlAnalogVals)) == 64, "physx_PxVehicleDriveDynData_Pod.mControlAnalogVals has unexpected size % instead of 64", size_of(type_of(physx_PxVehicleDriveDynData_Pod.mControlAnalogVals)));
    assert(((cast(*void)(*instance.mUseAutoGears)) - cast(*void)(*instance)) == 64, "physx_PxVehicleDriveDynData_Pod.mUseAutoGears has unexpected offset % instead of 64", ((cast(*void)(*instance.mUseAutoGears)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDriveDynData_Pod.mUseAutoGears)) == 1, "physx_PxVehicleDriveDynData_Pod.mUseAutoGears has unexpected size % instead of 1", size_of(type_of(physx_PxVehicleDriveDynData_Pod.mUseAutoGears)));
    assert(((cast(*void)(*instance.mGearUpPressed)) - cast(*void)(*instance)) == 65, "physx_PxVehicleDriveDynData_Pod.mGearUpPressed has unexpected offset % instead of 65", ((cast(*void)(*instance.mGearUpPressed)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDriveDynData_Pod.mGearUpPressed)) == 1, "physx_PxVehicleDriveDynData_Pod.mGearUpPressed has unexpected size % instead of 1", size_of(type_of(physx_PxVehicleDriveDynData_Pod.mGearUpPressed)));
    assert(((cast(*void)(*instance.mGearDownPressed)) - cast(*void)(*instance)) == 66, "physx_PxVehicleDriveDynData_Pod.mGearDownPressed has unexpected offset % instead of 66", ((cast(*void)(*instance.mGearDownPressed)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDriveDynData_Pod.mGearDownPressed)) == 1, "physx_PxVehicleDriveDynData_Pod.mGearDownPressed has unexpected size % instead of 1", size_of(type_of(physx_PxVehicleDriveDynData_Pod.mGearDownPressed)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 67, "physx_PxVehicleDriveDynData_Pod.structgen_pad0 has unexpected offset % instead of 67", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDriveDynData_Pod.structgen_pad0)) == 1, "physx_PxVehicleDriveDynData_Pod.structgen_pad0 has unexpected size % instead of 1", size_of(type_of(physx_PxVehicleDriveDynData_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.mCurrentGear)) - cast(*void)(*instance)) == 68, "physx_PxVehicleDriveDynData_Pod.mCurrentGear has unexpected offset % instead of 68", ((cast(*void)(*instance.mCurrentGear)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDriveDynData_Pod.mCurrentGear)) == 4, "physx_PxVehicleDriveDynData_Pod.mCurrentGear has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleDriveDynData_Pod.mCurrentGear)));
    assert(((cast(*void)(*instance.mTargetGear)) - cast(*void)(*instance)) == 72, "physx_PxVehicleDriveDynData_Pod.mTargetGear has unexpected offset % instead of 72", ((cast(*void)(*instance.mTargetGear)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDriveDynData_Pod.mTargetGear)) == 4, "physx_PxVehicleDriveDynData_Pod.mTargetGear has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleDriveDynData_Pod.mTargetGear)));
    assert(((cast(*void)(*instance.mEnginespeed)) - cast(*void)(*instance)) == 76, "physx_PxVehicleDriveDynData_Pod.mEnginespeed has unexpected offset % instead of 76", ((cast(*void)(*instance.mEnginespeed)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDriveDynData_Pod.mEnginespeed)) == 4, "physx_PxVehicleDriveDynData_Pod.mEnginespeed has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleDriveDynData_Pod.mEnginespeed)));
    assert(((cast(*void)(*instance.mGearSwitchTime)) - cast(*void)(*instance)) == 80, "physx_PxVehicleDriveDynData_Pod.mGearSwitchTime has unexpected offset % instead of 80", ((cast(*void)(*instance.mGearSwitchTime)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDriveDynData_Pod.mGearSwitchTime)) == 4, "physx_PxVehicleDriveDynData_Pod.mGearSwitchTime has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleDriveDynData_Pod.mGearSwitchTime)));
    assert(((cast(*void)(*instance.mAutoBoxSwitchTime)) - cast(*void)(*instance)) == 84, "physx_PxVehicleDriveDynData_Pod.mAutoBoxSwitchTime has unexpected offset % instead of 84", ((cast(*void)(*instance.mAutoBoxSwitchTime)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDriveDynData_Pod.mAutoBoxSwitchTime)) == 4, "physx_PxVehicleDriveDynData_Pod.mAutoBoxSwitchTime has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleDriveDynData_Pod.mAutoBoxSwitchTime)));
    assert(((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)) == 88, "physx_PxVehicleDriveDynData_Pod.structgen_pad1 has unexpected offset % instead of 88", ((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDriveDynData_Pod.structgen_pad1)) == 8, "physx_PxVehicleDriveDynData_Pod.structgen_pad1 has unexpected size % instead of 8", size_of(type_of(physx_PxVehicleDriveDynData_Pod.structgen_pad1)));
    assert(size_of(physx_PxVehicleDriveDynData_Pod) == 96, "physx_PxVehicleDriveDynData_Pod has size % instead of 96", size_of(physx_PxVehicleDriveDynData_Pod));
}

physx_PxVehicleDrive_Pod :: struct {
    structgen_pad0: [8] u8;
    mConcreteType:  u16;
    mBaseFlags:     physx_PxBaseFlags_Pod;
    structgen_pad1: [4] u8;
    mWheelsSimData: physx_PxVehicleWheelsSimData_Pod;
    mWheelsDynData: physx_PxVehicleWheelsDynData_Pod;
    mActor:         *physx_PxRigidDynamic_Pod;
    structgen_pad2: [5] u8;
    mType:          u8;
    mPad0:          [14] u8;
    structgen_pad3: [4] u8;
    mDriveDynData:  physx_PxVehicleDriveDynData_Pod;
}
#run {
    instance: physx_PxVehicleDrive_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxVehicleDrive_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDrive_Pod.structgen_pad0)) == 8, "physx_PxVehicleDrive_Pod.structgen_pad0 has unexpected size % instead of 8", size_of(type_of(physx_PxVehicleDrive_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)) == 8, "physx_PxVehicleDrive_Pod.mConcreteType has unexpected offset % instead of 8", ((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDrive_Pod.mConcreteType)) == 2, "physx_PxVehicleDrive_Pod.mConcreteType has unexpected size % instead of 2", size_of(type_of(physx_PxVehicleDrive_Pod.mConcreteType)));
    assert(((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)) == 10, "physx_PxVehicleDrive_Pod.mBaseFlags has unexpected offset % instead of 10", ((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDrive_Pod.mBaseFlags)) == 2, "physx_PxVehicleDrive_Pod.mBaseFlags has unexpected size % instead of 2", size_of(type_of(physx_PxVehicleDrive_Pod.mBaseFlags)));
    assert(((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)) == 12, "physx_PxVehicleDrive_Pod.structgen_pad1 has unexpected offset % instead of 12", ((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDrive_Pod.structgen_pad1)) == 4, "physx_PxVehicleDrive_Pod.structgen_pad1 has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleDrive_Pod.structgen_pad1)));
    assert(((cast(*void)(*instance.mWheelsSimData)) - cast(*void)(*instance)) == 16, "physx_PxVehicleDrive_Pod.mWheelsSimData has unexpected offset % instead of 16", ((cast(*void)(*instance.mWheelsSimData)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDrive_Pod.mWheelsSimData)) == 96, "physx_PxVehicleDrive_Pod.mWheelsSimData has unexpected size % instead of 96", size_of(type_of(physx_PxVehicleDrive_Pod.mWheelsSimData)));
    assert(((cast(*void)(*instance.mWheelsDynData)) - cast(*void)(*instance)) == 112, "physx_PxVehicleDrive_Pod.mWheelsDynData has unexpected offset % instead of 112", ((cast(*void)(*instance.mWheelsDynData)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDrive_Pod.mWheelsDynData)) == 48, "physx_PxVehicleDrive_Pod.mWheelsDynData has unexpected size % instead of 48", size_of(type_of(physx_PxVehicleDrive_Pod.mWheelsDynData)));
    assert(((cast(*void)(*instance.mActor)) - cast(*void)(*instance)) == 160, "physx_PxVehicleDrive_Pod.mActor has unexpected offset % instead of 160", ((cast(*void)(*instance.mActor)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDrive_Pod.mActor)) == 8, "physx_PxVehicleDrive_Pod.mActor has unexpected size % instead of 8", size_of(type_of(physx_PxVehicleDrive_Pod.mActor)));
    assert(((cast(*void)(*instance.structgen_pad2)) - cast(*void)(*instance)) == 168, "physx_PxVehicleDrive_Pod.structgen_pad2 has unexpected offset % instead of 168", ((cast(*void)(*instance.structgen_pad2)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDrive_Pod.structgen_pad2)) == 5, "physx_PxVehicleDrive_Pod.structgen_pad2 has unexpected size % instead of 5", size_of(type_of(physx_PxVehicleDrive_Pod.structgen_pad2)));
    assert(((cast(*void)(*instance.mType)) - cast(*void)(*instance)) == 173, "physx_PxVehicleDrive_Pod.mType has unexpected offset % instead of 173", ((cast(*void)(*instance.mType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDrive_Pod.mType)) == 1, "physx_PxVehicleDrive_Pod.mType has unexpected size % instead of 1", size_of(type_of(physx_PxVehicleDrive_Pod.mType)));
    assert(((cast(*void)(*instance.mPad0)) - cast(*void)(*instance)) == 174, "physx_PxVehicleDrive_Pod.mPad0 has unexpected offset % instead of 174", ((cast(*void)(*instance.mPad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDrive_Pod.mPad0)) == 14, "physx_PxVehicleDrive_Pod.mPad0 has unexpected size % instead of 14", size_of(type_of(physx_PxVehicleDrive_Pod.mPad0)));
    assert(((cast(*void)(*instance.structgen_pad3)) - cast(*void)(*instance)) == 188, "physx_PxVehicleDrive_Pod.structgen_pad3 has unexpected offset % instead of 188", ((cast(*void)(*instance.structgen_pad3)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDrive_Pod.structgen_pad3)) == 4, "physx_PxVehicleDrive_Pod.structgen_pad3 has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleDrive_Pod.structgen_pad3)));
    assert(((cast(*void)(*instance.mDriveDynData)) - cast(*void)(*instance)) == 192, "physx_PxVehicleDrive_Pod.mDriveDynData has unexpected offset % instead of 192", ((cast(*void)(*instance.mDriveDynData)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDrive_Pod.mDriveDynData)) == 96, "physx_PxVehicleDrive_Pod.mDriveDynData has unexpected size % instead of 96", size_of(type_of(physx_PxVehicleDrive_Pod.mDriveDynData)));
    assert(size_of(physx_PxVehicleDrive_Pod) == 288, "physx_PxVehicleDrive_Pod has size % instead of 288", size_of(physx_PxVehicleDrive_Pod));
}

physx_PxVehicleDriveSimData4W_Pod :: struct {
    mEngine:        physx_PxVehicleEngineData_Pod;
    mGears:         physx_PxVehicleGearsData_Pod;
    mClutch:        physx_PxVehicleClutchData_Pod;
    mAutoBox:       physx_PxVehicleAutoBoxData_Pod;
    structgen_pad0: [48] u8;
}
#run {
    instance: physx_PxVehicleDriveSimData4W_Pod;
    assert(((cast(*void)(*instance.mEngine)) - cast(*void)(*instance)) == 0, "physx_PxVehicleDriveSimData4W_Pod.mEngine has unexpected offset % instead of 0", ((cast(*void)(*instance.mEngine)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDriveSimData4W_Pod.mEngine)) == 112, "physx_PxVehicleDriveSimData4W_Pod.mEngine has unexpected size % instead of 112", size_of(type_of(physx_PxVehicleDriveSimData4W_Pod.mEngine)));
    assert(((cast(*void)(*instance.mGears)) - cast(*void)(*instance)) == 112, "physx_PxVehicleDriveSimData4W_Pod.mGears has unexpected offset % instead of 112", ((cast(*void)(*instance.mGears)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDriveSimData4W_Pod.mGears)) == 144, "physx_PxVehicleDriveSimData4W_Pod.mGears has unexpected size % instead of 144", size_of(type_of(physx_PxVehicleDriveSimData4W_Pod.mGears)));
    assert(((cast(*void)(*instance.mClutch)) - cast(*void)(*instance)) == 256, "physx_PxVehicleDriveSimData4W_Pod.mClutch has unexpected offset % instead of 256", ((cast(*void)(*instance.mClutch)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDriveSimData4W_Pod.mClutch)) == 16, "physx_PxVehicleDriveSimData4W_Pod.mClutch has unexpected size % instead of 16", size_of(type_of(physx_PxVehicleDriveSimData4W_Pod.mClutch)));
    assert(((cast(*void)(*instance.mAutoBox)) - cast(*void)(*instance)) == 272, "physx_PxVehicleDriveSimData4W_Pod.mAutoBox has unexpected offset % instead of 272", ((cast(*void)(*instance.mAutoBox)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDriveSimData4W_Pod.mAutoBox)) == 256, "physx_PxVehicleDriveSimData4W_Pod.mAutoBox has unexpected size % instead of 256", size_of(type_of(physx_PxVehicleDriveSimData4W_Pod.mAutoBox)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 528, "physx_PxVehicleDriveSimData4W_Pod.structgen_pad0 has unexpected offset % instead of 528", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDriveSimData4W_Pod.structgen_pad0)) == 48, "physx_PxVehicleDriveSimData4W_Pod.structgen_pad0 has unexpected size % instead of 48", size_of(type_of(physx_PxVehicleDriveSimData4W_Pod.structgen_pad0)));
    assert(size_of(physx_PxVehicleDriveSimData4W_Pod) == 576, "physx_PxVehicleDriveSimData4W_Pod has size % instead of 576", size_of(physx_PxVehicleDriveSimData4W_Pod));
}

physx_PxVehicleDrive4W_Pod :: struct {
    structgen_pad0: [8] u8;
    mConcreteType:  u16;
    mBaseFlags:     physx_PxBaseFlags_Pod;
    structgen_pad1: [4] u8;
    mWheelsSimData: physx_PxVehicleWheelsSimData_Pod;
    mWheelsDynData: physx_PxVehicleWheelsDynData_Pod;
    mActor:         *physx_PxRigidDynamic_Pod;
    structgen_pad2: [5] u8;
    mType:          u8;
    mPad0:          [14] u8;
    structgen_pad3: [4] u8;
    mDriveDynData:  physx_PxVehicleDriveDynData_Pod;
    mDriveSimData:  physx_PxVehicleDriveSimData4W_Pod;
}
#run {
    instance: physx_PxVehicleDrive4W_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxVehicleDrive4W_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDrive4W_Pod.structgen_pad0)) == 8, "physx_PxVehicleDrive4W_Pod.structgen_pad0 has unexpected size % instead of 8", size_of(type_of(physx_PxVehicleDrive4W_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)) == 8, "physx_PxVehicleDrive4W_Pod.mConcreteType has unexpected offset % instead of 8", ((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDrive4W_Pod.mConcreteType)) == 2, "physx_PxVehicleDrive4W_Pod.mConcreteType has unexpected size % instead of 2", size_of(type_of(physx_PxVehicleDrive4W_Pod.mConcreteType)));
    assert(((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)) == 10, "physx_PxVehicleDrive4W_Pod.mBaseFlags has unexpected offset % instead of 10", ((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDrive4W_Pod.mBaseFlags)) == 2, "physx_PxVehicleDrive4W_Pod.mBaseFlags has unexpected size % instead of 2", size_of(type_of(physx_PxVehicleDrive4W_Pod.mBaseFlags)));
    assert(((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)) == 12, "physx_PxVehicleDrive4W_Pod.structgen_pad1 has unexpected offset % instead of 12", ((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDrive4W_Pod.structgen_pad1)) == 4, "physx_PxVehicleDrive4W_Pod.structgen_pad1 has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleDrive4W_Pod.structgen_pad1)));
    assert(((cast(*void)(*instance.mWheelsSimData)) - cast(*void)(*instance)) == 16, "physx_PxVehicleDrive4W_Pod.mWheelsSimData has unexpected offset % instead of 16", ((cast(*void)(*instance.mWheelsSimData)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDrive4W_Pod.mWheelsSimData)) == 96, "physx_PxVehicleDrive4W_Pod.mWheelsSimData has unexpected size % instead of 96", size_of(type_of(physx_PxVehicleDrive4W_Pod.mWheelsSimData)));
    assert(((cast(*void)(*instance.mWheelsDynData)) - cast(*void)(*instance)) == 112, "physx_PxVehicleDrive4W_Pod.mWheelsDynData has unexpected offset % instead of 112", ((cast(*void)(*instance.mWheelsDynData)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDrive4W_Pod.mWheelsDynData)) == 48, "physx_PxVehicleDrive4W_Pod.mWheelsDynData has unexpected size % instead of 48", size_of(type_of(physx_PxVehicleDrive4W_Pod.mWheelsDynData)));
    assert(((cast(*void)(*instance.mActor)) - cast(*void)(*instance)) == 160, "physx_PxVehicleDrive4W_Pod.mActor has unexpected offset % instead of 160", ((cast(*void)(*instance.mActor)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDrive4W_Pod.mActor)) == 8, "physx_PxVehicleDrive4W_Pod.mActor has unexpected size % instead of 8", size_of(type_of(physx_PxVehicleDrive4W_Pod.mActor)));
    assert(((cast(*void)(*instance.structgen_pad2)) - cast(*void)(*instance)) == 168, "physx_PxVehicleDrive4W_Pod.structgen_pad2 has unexpected offset % instead of 168", ((cast(*void)(*instance.structgen_pad2)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDrive4W_Pod.structgen_pad2)) == 5, "physx_PxVehicleDrive4W_Pod.structgen_pad2 has unexpected size % instead of 5", size_of(type_of(physx_PxVehicleDrive4W_Pod.structgen_pad2)));
    assert(((cast(*void)(*instance.mType)) - cast(*void)(*instance)) == 173, "physx_PxVehicleDrive4W_Pod.mType has unexpected offset % instead of 173", ((cast(*void)(*instance.mType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDrive4W_Pod.mType)) == 1, "physx_PxVehicleDrive4W_Pod.mType has unexpected size % instead of 1", size_of(type_of(physx_PxVehicleDrive4W_Pod.mType)));
    assert(((cast(*void)(*instance.mPad0)) - cast(*void)(*instance)) == 174, "physx_PxVehicleDrive4W_Pod.mPad0 has unexpected offset % instead of 174", ((cast(*void)(*instance.mPad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDrive4W_Pod.mPad0)) == 14, "physx_PxVehicleDrive4W_Pod.mPad0 has unexpected size % instead of 14", size_of(type_of(physx_PxVehicleDrive4W_Pod.mPad0)));
    assert(((cast(*void)(*instance.structgen_pad3)) - cast(*void)(*instance)) == 188, "physx_PxVehicleDrive4W_Pod.structgen_pad3 has unexpected offset % instead of 188", ((cast(*void)(*instance.structgen_pad3)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDrive4W_Pod.structgen_pad3)) == 4, "physx_PxVehicleDrive4W_Pod.structgen_pad3 has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleDrive4W_Pod.structgen_pad3)));
    assert(((cast(*void)(*instance.mDriveDynData)) - cast(*void)(*instance)) == 192, "physx_PxVehicleDrive4W_Pod.mDriveDynData has unexpected offset % instead of 192", ((cast(*void)(*instance.mDriveDynData)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDrive4W_Pod.mDriveDynData)) == 96, "physx_PxVehicleDrive4W_Pod.mDriveDynData has unexpected size % instead of 96", size_of(type_of(physx_PxVehicleDrive4W_Pod.mDriveDynData)));
    assert(((cast(*void)(*instance.mDriveSimData)) - cast(*void)(*instance)) == 288, "physx_PxVehicleDrive4W_Pod.mDriveSimData has unexpected offset % instead of 288", ((cast(*void)(*instance.mDriveSimData)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDrive4W_Pod.mDriveSimData)) == 576, "physx_PxVehicleDrive4W_Pod.mDriveSimData has unexpected size % instead of 576", size_of(type_of(physx_PxVehicleDrive4W_Pod.mDriveSimData)));
    assert(size_of(physx_PxVehicleDrive4W_Pod) == 864, "physx_PxVehicleDrive4W_Pod has size % instead of 864", size_of(physx_PxVehicleDrive4W_Pod));
}

physx_PxVehicleDriveTank_Pod :: struct {
    structgen_pad0: [8] u8;
    mConcreteType:  u16;
    mBaseFlags:     physx_PxBaseFlags_Pod;
    structgen_pad1: [4] u8;
    mWheelsSimData: physx_PxVehicleWheelsSimData_Pod;
    mWheelsDynData: physx_PxVehicleWheelsDynData_Pod;
    mActor:         *physx_PxRigidDynamic_Pod;
    structgen_pad2: [5] u8;
    mType:          u8;
    mPad0:          [14] u8;
    structgen_pad3: [4] u8;
    mDriveDynData:  physx_PxVehicleDriveDynData_Pod;
    mDriveSimData:  physx_PxVehicleDriveSimData_Pod;
    structgen_pad4: [16] u8;
}
#run {
    instance: physx_PxVehicleDriveTank_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxVehicleDriveTank_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDriveTank_Pod.structgen_pad0)) == 8, "physx_PxVehicleDriveTank_Pod.structgen_pad0 has unexpected size % instead of 8", size_of(type_of(physx_PxVehicleDriveTank_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)) == 8, "physx_PxVehicleDriveTank_Pod.mConcreteType has unexpected offset % instead of 8", ((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDriveTank_Pod.mConcreteType)) == 2, "physx_PxVehicleDriveTank_Pod.mConcreteType has unexpected size % instead of 2", size_of(type_of(physx_PxVehicleDriveTank_Pod.mConcreteType)));
    assert(((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)) == 10, "physx_PxVehicleDriveTank_Pod.mBaseFlags has unexpected offset % instead of 10", ((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDriveTank_Pod.mBaseFlags)) == 2, "physx_PxVehicleDriveTank_Pod.mBaseFlags has unexpected size % instead of 2", size_of(type_of(physx_PxVehicleDriveTank_Pod.mBaseFlags)));
    assert(((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)) == 12, "physx_PxVehicleDriveTank_Pod.structgen_pad1 has unexpected offset % instead of 12", ((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDriveTank_Pod.structgen_pad1)) == 4, "physx_PxVehicleDriveTank_Pod.structgen_pad1 has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleDriveTank_Pod.structgen_pad1)));
    assert(((cast(*void)(*instance.mWheelsSimData)) - cast(*void)(*instance)) == 16, "physx_PxVehicleDriveTank_Pod.mWheelsSimData has unexpected offset % instead of 16", ((cast(*void)(*instance.mWheelsSimData)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDriveTank_Pod.mWheelsSimData)) == 96, "physx_PxVehicleDriveTank_Pod.mWheelsSimData has unexpected size % instead of 96", size_of(type_of(physx_PxVehicleDriveTank_Pod.mWheelsSimData)));
    assert(((cast(*void)(*instance.mWheelsDynData)) - cast(*void)(*instance)) == 112, "physx_PxVehicleDriveTank_Pod.mWheelsDynData has unexpected offset % instead of 112", ((cast(*void)(*instance.mWheelsDynData)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDriveTank_Pod.mWheelsDynData)) == 48, "physx_PxVehicleDriveTank_Pod.mWheelsDynData has unexpected size % instead of 48", size_of(type_of(physx_PxVehicleDriveTank_Pod.mWheelsDynData)));
    assert(((cast(*void)(*instance.mActor)) - cast(*void)(*instance)) == 160, "physx_PxVehicleDriveTank_Pod.mActor has unexpected offset % instead of 160", ((cast(*void)(*instance.mActor)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDriveTank_Pod.mActor)) == 8, "physx_PxVehicleDriveTank_Pod.mActor has unexpected size % instead of 8", size_of(type_of(physx_PxVehicleDriveTank_Pod.mActor)));
    assert(((cast(*void)(*instance.structgen_pad2)) - cast(*void)(*instance)) == 168, "physx_PxVehicleDriveTank_Pod.structgen_pad2 has unexpected offset % instead of 168", ((cast(*void)(*instance.structgen_pad2)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDriveTank_Pod.structgen_pad2)) == 5, "physx_PxVehicleDriveTank_Pod.structgen_pad2 has unexpected size % instead of 5", size_of(type_of(physx_PxVehicleDriveTank_Pod.structgen_pad2)));
    assert(((cast(*void)(*instance.mType)) - cast(*void)(*instance)) == 173, "physx_PxVehicleDriveTank_Pod.mType has unexpected offset % instead of 173", ((cast(*void)(*instance.mType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDriveTank_Pod.mType)) == 1, "physx_PxVehicleDriveTank_Pod.mType has unexpected size % instead of 1", size_of(type_of(physx_PxVehicleDriveTank_Pod.mType)));
    assert(((cast(*void)(*instance.mPad0)) - cast(*void)(*instance)) == 174, "physx_PxVehicleDriveTank_Pod.mPad0 has unexpected offset % instead of 174", ((cast(*void)(*instance.mPad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDriveTank_Pod.mPad0)) == 14, "physx_PxVehicleDriveTank_Pod.mPad0 has unexpected size % instead of 14", size_of(type_of(physx_PxVehicleDriveTank_Pod.mPad0)));
    assert(((cast(*void)(*instance.structgen_pad3)) - cast(*void)(*instance)) == 188, "physx_PxVehicleDriveTank_Pod.structgen_pad3 has unexpected offset % instead of 188", ((cast(*void)(*instance.structgen_pad3)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDriveTank_Pod.structgen_pad3)) == 4, "physx_PxVehicleDriveTank_Pod.structgen_pad3 has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleDriveTank_Pod.structgen_pad3)));
    assert(((cast(*void)(*instance.mDriveDynData)) - cast(*void)(*instance)) == 192, "physx_PxVehicleDriveTank_Pod.mDriveDynData has unexpected offset % instead of 192", ((cast(*void)(*instance.mDriveDynData)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDriveTank_Pod.mDriveDynData)) == 96, "physx_PxVehicleDriveTank_Pod.mDriveDynData has unexpected size % instead of 96", size_of(type_of(physx_PxVehicleDriveTank_Pod.mDriveDynData)));
    assert(((cast(*void)(*instance.mDriveSimData)) - cast(*void)(*instance)) == 288, "physx_PxVehicleDriveTank_Pod.mDriveSimData has unexpected offset % instead of 288", ((cast(*void)(*instance.mDriveSimData)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDriveTank_Pod.mDriveSimData)) == 528, "physx_PxVehicleDriveTank_Pod.mDriveSimData has unexpected size % instead of 528", size_of(type_of(physx_PxVehicleDriveTank_Pod.mDriveSimData)));
    assert(((cast(*void)(*instance.structgen_pad4)) - cast(*void)(*instance)) == 816, "physx_PxVehicleDriveTank_Pod.structgen_pad4 has unexpected offset % instead of 816", ((cast(*void)(*instance.structgen_pad4)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDriveTank_Pod.structgen_pad4)) == 16, "physx_PxVehicleDriveTank_Pod.structgen_pad4 has unexpected size % instead of 16", size_of(type_of(physx_PxVehicleDriveTank_Pod.structgen_pad4)));
    assert(size_of(physx_PxVehicleDriveTank_Pod) == 832, "physx_PxVehicleDriveTank_Pod has size % instead of 832", size_of(physx_PxVehicleDriveTank_Pod));
}

physx_PxVehicleDrivableSurfaceType_Pod :: struct {
    mType: u32;
}
#run {
    instance: physx_PxVehicleDrivableSurfaceType_Pod;
    assert(((cast(*void)(*instance.mType)) - cast(*void)(*instance)) == 0, "physx_PxVehicleDrivableSurfaceType_Pod.mType has unexpected offset % instead of 0", ((cast(*void)(*instance.mType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDrivableSurfaceType_Pod.mType)) == 4, "physx_PxVehicleDrivableSurfaceType_Pod.mType has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleDrivableSurfaceType_Pod.mType)));
    assert(size_of(physx_PxVehicleDrivableSurfaceType_Pod) == 4, "physx_PxVehicleDrivableSurfaceType_Pod has size % instead of 4", size_of(physx_PxVehicleDrivableSurfaceType_Pod));
}

physx_PxVehicleDrivableSurfaceToTireFrictionPairs_Pod :: struct {
    structgen_pad0: [48] u8;
}
#run {
    instance: physx_PxVehicleDrivableSurfaceToTireFrictionPairs_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxVehicleDrivableSurfaceToTireFrictionPairs_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDrivableSurfaceToTireFrictionPairs_Pod.structgen_pad0)) == 48, "physx_PxVehicleDrivableSurfaceToTireFrictionPairs_Pod.structgen_pad0 has unexpected size % instead of 48", size_of(type_of(physx_PxVehicleDrivableSurfaceToTireFrictionPairs_Pod.structgen_pad0)));
    assert(size_of(physx_PxVehicleDrivableSurfaceToTireFrictionPairs_Pod) == 48, "physx_PxVehicleDrivableSurfaceToTireFrictionPairs_Pod has size % instead of 48", size_of(physx_PxVehicleDrivableSurfaceToTireFrictionPairs_Pod));
}

physx_PxWheelQueryResult_Pod :: struct {
    suspLineStart:       physx_PxVec3_Pod;
    suspLineDir:         physx_PxVec3_Pod;
    suspLineLength:      float;
    isInAir:             bool;
    structgen_pad0:      [3] u8;
    tireContactActor:    *physx_PxActor_Pod;
    tireContactShape:    *physx_PxShape_Pod;
    tireSurfaceMaterial: *physx_PxMaterial_Pod;
    tireSurfaceType:     u32;
    tireContactPoint:    physx_PxVec3_Pod;
    tireContactNormal:   physx_PxVec3_Pod;
    tireFriction:        float;
    suspJounce:          float;
    suspSpringForce:     float;
    tireLongitudinalDir: physx_PxVec3_Pod;
    tireLateralDir:      physx_PxVec3_Pod;
    longitudinalSlip:    float;
    lateralSlip:         float;
    steerAngle:          float;
    localPose:           physx_PxTransform_Pod;
}
#run {
    instance: physx_PxWheelQueryResult_Pod;
    assert(((cast(*void)(*instance.suspLineStart)) - cast(*void)(*instance)) == 0, "physx_PxWheelQueryResult_Pod.suspLineStart has unexpected offset % instead of 0", ((cast(*void)(*instance.suspLineStart)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxWheelQueryResult_Pod.suspLineStart)) == 12, "physx_PxWheelQueryResult_Pod.suspLineStart has unexpected size % instead of 12", size_of(type_of(physx_PxWheelQueryResult_Pod.suspLineStart)));
    assert(((cast(*void)(*instance.suspLineDir)) - cast(*void)(*instance)) == 12, "physx_PxWheelQueryResult_Pod.suspLineDir has unexpected offset % instead of 12", ((cast(*void)(*instance.suspLineDir)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxWheelQueryResult_Pod.suspLineDir)) == 12, "physx_PxWheelQueryResult_Pod.suspLineDir has unexpected size % instead of 12", size_of(type_of(physx_PxWheelQueryResult_Pod.suspLineDir)));
    assert(((cast(*void)(*instance.suspLineLength)) - cast(*void)(*instance)) == 24, "physx_PxWheelQueryResult_Pod.suspLineLength has unexpected offset % instead of 24", ((cast(*void)(*instance.suspLineLength)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxWheelQueryResult_Pod.suspLineLength)) == 4, "physx_PxWheelQueryResult_Pod.suspLineLength has unexpected size % instead of 4", size_of(type_of(physx_PxWheelQueryResult_Pod.suspLineLength)));
    assert(((cast(*void)(*instance.isInAir)) - cast(*void)(*instance)) == 28, "physx_PxWheelQueryResult_Pod.isInAir has unexpected offset % instead of 28", ((cast(*void)(*instance.isInAir)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxWheelQueryResult_Pod.isInAir)) == 1, "physx_PxWheelQueryResult_Pod.isInAir has unexpected size % instead of 1", size_of(type_of(physx_PxWheelQueryResult_Pod.isInAir)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 29, "physx_PxWheelQueryResult_Pod.structgen_pad0 has unexpected offset % instead of 29", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxWheelQueryResult_Pod.structgen_pad0)) == 3, "physx_PxWheelQueryResult_Pod.structgen_pad0 has unexpected size % instead of 3", size_of(type_of(physx_PxWheelQueryResult_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.tireContactActor)) - cast(*void)(*instance)) == 32, "physx_PxWheelQueryResult_Pod.tireContactActor has unexpected offset % instead of 32", ((cast(*void)(*instance.tireContactActor)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxWheelQueryResult_Pod.tireContactActor)) == 8, "physx_PxWheelQueryResult_Pod.tireContactActor has unexpected size % instead of 8", size_of(type_of(physx_PxWheelQueryResult_Pod.tireContactActor)));
    assert(((cast(*void)(*instance.tireContactShape)) - cast(*void)(*instance)) == 40, "physx_PxWheelQueryResult_Pod.tireContactShape has unexpected offset % instead of 40", ((cast(*void)(*instance.tireContactShape)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxWheelQueryResult_Pod.tireContactShape)) == 8, "physx_PxWheelQueryResult_Pod.tireContactShape has unexpected size % instead of 8", size_of(type_of(physx_PxWheelQueryResult_Pod.tireContactShape)));
    assert(((cast(*void)(*instance.tireSurfaceMaterial)) - cast(*void)(*instance)) == 48, "physx_PxWheelQueryResult_Pod.tireSurfaceMaterial has unexpected offset % instead of 48", ((cast(*void)(*instance.tireSurfaceMaterial)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxWheelQueryResult_Pod.tireSurfaceMaterial)) == 8, "physx_PxWheelQueryResult_Pod.tireSurfaceMaterial has unexpected size % instead of 8", size_of(type_of(physx_PxWheelQueryResult_Pod.tireSurfaceMaterial)));
    assert(((cast(*void)(*instance.tireSurfaceType)) - cast(*void)(*instance)) == 56, "physx_PxWheelQueryResult_Pod.tireSurfaceType has unexpected offset % instead of 56", ((cast(*void)(*instance.tireSurfaceType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxWheelQueryResult_Pod.tireSurfaceType)) == 4, "physx_PxWheelQueryResult_Pod.tireSurfaceType has unexpected size % instead of 4", size_of(type_of(physx_PxWheelQueryResult_Pod.tireSurfaceType)));
    assert(((cast(*void)(*instance.tireContactPoint)) - cast(*void)(*instance)) == 60, "physx_PxWheelQueryResult_Pod.tireContactPoint has unexpected offset % instead of 60", ((cast(*void)(*instance.tireContactPoint)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxWheelQueryResult_Pod.tireContactPoint)) == 12, "physx_PxWheelQueryResult_Pod.tireContactPoint has unexpected size % instead of 12", size_of(type_of(physx_PxWheelQueryResult_Pod.tireContactPoint)));
    assert(((cast(*void)(*instance.tireContactNormal)) - cast(*void)(*instance)) == 72, "physx_PxWheelQueryResult_Pod.tireContactNormal has unexpected offset % instead of 72", ((cast(*void)(*instance.tireContactNormal)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxWheelQueryResult_Pod.tireContactNormal)) == 12, "physx_PxWheelQueryResult_Pod.tireContactNormal has unexpected size % instead of 12", size_of(type_of(physx_PxWheelQueryResult_Pod.tireContactNormal)));
    assert(((cast(*void)(*instance.tireFriction)) - cast(*void)(*instance)) == 84, "physx_PxWheelQueryResult_Pod.tireFriction has unexpected offset % instead of 84", ((cast(*void)(*instance.tireFriction)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxWheelQueryResult_Pod.tireFriction)) == 4, "physx_PxWheelQueryResult_Pod.tireFriction has unexpected size % instead of 4", size_of(type_of(physx_PxWheelQueryResult_Pod.tireFriction)));
    assert(((cast(*void)(*instance.suspJounce)) - cast(*void)(*instance)) == 88, "physx_PxWheelQueryResult_Pod.suspJounce has unexpected offset % instead of 88", ((cast(*void)(*instance.suspJounce)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxWheelQueryResult_Pod.suspJounce)) == 4, "physx_PxWheelQueryResult_Pod.suspJounce has unexpected size % instead of 4", size_of(type_of(physx_PxWheelQueryResult_Pod.suspJounce)));
    assert(((cast(*void)(*instance.suspSpringForce)) - cast(*void)(*instance)) == 92, "physx_PxWheelQueryResult_Pod.suspSpringForce has unexpected offset % instead of 92", ((cast(*void)(*instance.suspSpringForce)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxWheelQueryResult_Pod.suspSpringForce)) == 4, "physx_PxWheelQueryResult_Pod.suspSpringForce has unexpected size % instead of 4", size_of(type_of(physx_PxWheelQueryResult_Pod.suspSpringForce)));
    assert(((cast(*void)(*instance.tireLongitudinalDir)) - cast(*void)(*instance)) == 96, "physx_PxWheelQueryResult_Pod.tireLongitudinalDir has unexpected offset % instead of 96", ((cast(*void)(*instance.tireLongitudinalDir)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxWheelQueryResult_Pod.tireLongitudinalDir)) == 12, "physx_PxWheelQueryResult_Pod.tireLongitudinalDir has unexpected size % instead of 12", size_of(type_of(physx_PxWheelQueryResult_Pod.tireLongitudinalDir)));
    assert(((cast(*void)(*instance.tireLateralDir)) - cast(*void)(*instance)) == 108, "physx_PxWheelQueryResult_Pod.tireLateralDir has unexpected offset % instead of 108", ((cast(*void)(*instance.tireLateralDir)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxWheelQueryResult_Pod.tireLateralDir)) == 12, "physx_PxWheelQueryResult_Pod.tireLateralDir has unexpected size % instead of 12", size_of(type_of(physx_PxWheelQueryResult_Pod.tireLateralDir)));
    assert(((cast(*void)(*instance.longitudinalSlip)) - cast(*void)(*instance)) == 120, "physx_PxWheelQueryResult_Pod.longitudinalSlip has unexpected offset % instead of 120", ((cast(*void)(*instance.longitudinalSlip)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxWheelQueryResult_Pod.longitudinalSlip)) == 4, "physx_PxWheelQueryResult_Pod.longitudinalSlip has unexpected size % instead of 4", size_of(type_of(physx_PxWheelQueryResult_Pod.longitudinalSlip)));
    assert(((cast(*void)(*instance.lateralSlip)) - cast(*void)(*instance)) == 124, "physx_PxWheelQueryResult_Pod.lateralSlip has unexpected offset % instead of 124", ((cast(*void)(*instance.lateralSlip)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxWheelQueryResult_Pod.lateralSlip)) == 4, "physx_PxWheelQueryResult_Pod.lateralSlip has unexpected size % instead of 4", size_of(type_of(physx_PxWheelQueryResult_Pod.lateralSlip)));
    assert(((cast(*void)(*instance.steerAngle)) - cast(*void)(*instance)) == 128, "physx_PxWheelQueryResult_Pod.steerAngle has unexpected offset % instead of 128", ((cast(*void)(*instance.steerAngle)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxWheelQueryResult_Pod.steerAngle)) == 4, "physx_PxWheelQueryResult_Pod.steerAngle has unexpected size % instead of 4", size_of(type_of(physx_PxWheelQueryResult_Pod.steerAngle)));
    assert(((cast(*void)(*instance.localPose)) - cast(*void)(*instance)) == 132, "physx_PxWheelQueryResult_Pod.localPose has unexpected offset % instead of 132", ((cast(*void)(*instance.localPose)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxWheelQueryResult_Pod.localPose)) == 28, "physx_PxWheelQueryResult_Pod.localPose has unexpected size % instead of 28", size_of(type_of(physx_PxWheelQueryResult_Pod.localPose)));
    assert(size_of(physx_PxWheelQueryResult_Pod) == 160, "physx_PxWheelQueryResult_Pod has size % instead of 160", size_of(physx_PxWheelQueryResult_Pod));
}

physx_PxVehicleWheelConcurrentUpdateData_Pod :: struct {
    structgen_pad0: [64] u8;
}
#run {
    instance: physx_PxVehicleWheelConcurrentUpdateData_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxVehicleWheelConcurrentUpdateData_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleWheelConcurrentUpdateData_Pod.structgen_pad0)) == 64, "physx_PxVehicleWheelConcurrentUpdateData_Pod.structgen_pad0 has unexpected size % instead of 64", size_of(type_of(physx_PxVehicleWheelConcurrentUpdateData_Pod.structgen_pad0)));
    assert(size_of(physx_PxVehicleWheelConcurrentUpdateData_Pod) == 64, "physx_PxVehicleWheelConcurrentUpdateData_Pod has size % instead of 64", size_of(physx_PxVehicleWheelConcurrentUpdateData_Pod));
}

physx_PxVehicleConcurrentUpdateData_Pod :: struct {
    concurrentWheelUpdates:   *physx_PxVehicleWheelConcurrentUpdateData_Pod;
    nbConcurrentWheelUpdates: u32;
    structgen_pad0:           [28] u8;
}
#run {
    instance: physx_PxVehicleConcurrentUpdateData_Pod;
    assert(((cast(*void)(*instance.concurrentWheelUpdates)) - cast(*void)(*instance)) == 0, "physx_PxVehicleConcurrentUpdateData_Pod.concurrentWheelUpdates has unexpected offset % instead of 0", ((cast(*void)(*instance.concurrentWheelUpdates)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleConcurrentUpdateData_Pod.concurrentWheelUpdates)) == 8, "physx_PxVehicleConcurrentUpdateData_Pod.concurrentWheelUpdates has unexpected size % instead of 8", size_of(type_of(physx_PxVehicleConcurrentUpdateData_Pod.concurrentWheelUpdates)));
    assert(((cast(*void)(*instance.nbConcurrentWheelUpdates)) - cast(*void)(*instance)) == 8, "physx_PxVehicleConcurrentUpdateData_Pod.nbConcurrentWheelUpdates has unexpected offset % instead of 8", ((cast(*void)(*instance.nbConcurrentWheelUpdates)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleConcurrentUpdateData_Pod.nbConcurrentWheelUpdates)) == 4, "physx_PxVehicleConcurrentUpdateData_Pod.nbConcurrentWheelUpdates has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleConcurrentUpdateData_Pod.nbConcurrentWheelUpdates)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 12, "physx_PxVehicleConcurrentUpdateData_Pod.structgen_pad0 has unexpected offset % instead of 12", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleConcurrentUpdateData_Pod.structgen_pad0)) == 28, "physx_PxVehicleConcurrentUpdateData_Pod.structgen_pad0 has unexpected size % instead of 28", size_of(type_of(physx_PxVehicleConcurrentUpdateData_Pod.structgen_pad0)));
    assert(size_of(physx_PxVehicleConcurrentUpdateData_Pod) == 40, "physx_PxVehicleConcurrentUpdateData_Pod has size % instead of 40", size_of(physx_PxVehicleConcurrentUpdateData_Pod));
}

physx_PxVehicleWheelQueryResult_Pod :: struct {
    wheelQueryResults:   *physx_PxWheelQueryResult_Pod;
    nbWheelQueryResults: u32;
    structgen_pad0:      [4] u8;
}
#run {
    instance: physx_PxVehicleWheelQueryResult_Pod;
    assert(((cast(*void)(*instance.wheelQueryResults)) - cast(*void)(*instance)) == 0, "physx_PxVehicleWheelQueryResult_Pod.wheelQueryResults has unexpected offset % instead of 0", ((cast(*void)(*instance.wheelQueryResults)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleWheelQueryResult_Pod.wheelQueryResults)) == 8, "physx_PxVehicleWheelQueryResult_Pod.wheelQueryResults has unexpected size % instead of 8", size_of(type_of(physx_PxVehicleWheelQueryResult_Pod.wheelQueryResults)));
    assert(((cast(*void)(*instance.nbWheelQueryResults)) - cast(*void)(*instance)) == 8, "physx_PxVehicleWheelQueryResult_Pod.nbWheelQueryResults has unexpected offset % instead of 8", ((cast(*void)(*instance.nbWheelQueryResults)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleWheelQueryResult_Pod.nbWheelQueryResults)) == 4, "physx_PxVehicleWheelQueryResult_Pod.nbWheelQueryResults has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleWheelQueryResult_Pod.nbWheelQueryResults)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 12, "physx_PxVehicleWheelQueryResult_Pod.structgen_pad0 has unexpected offset % instead of 12", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleWheelQueryResult_Pod.structgen_pad0)) == 4, "physx_PxVehicleWheelQueryResult_Pod.structgen_pad0 has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleWheelQueryResult_Pod.structgen_pad0)));
    assert(size_of(physx_PxVehicleWheelQueryResult_Pod) == 16, "physx_PxVehicleWheelQueryResult_Pod has size % instead of 16", size_of(physx_PxVehicleWheelQueryResult_Pod));
}

physx_PxVehicleGraph_Pod :: struct {
    structgen_pad0: [15840] u8;
}
#run {
    instance: physx_PxVehicleGraph_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxVehicleGraph_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleGraph_Pod.structgen_pad0)) == 15840, "physx_PxVehicleGraph_Pod.structgen_pad0 has unexpected size % instead of 15840", size_of(type_of(physx_PxVehicleGraph_Pod.structgen_pad0)));
    assert(size_of(physx_PxVehicleGraph_Pod) == 15840, "physx_PxVehicleGraph_Pod has size % instead of 15840", size_of(physx_PxVehicleGraph_Pod));
}

physx_PxVehicleTelemetryData_Pod :: struct {
    structgen_pad0: [48] u8;
}
#run {
    instance: physx_PxVehicleTelemetryData_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxVehicleTelemetryData_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleTelemetryData_Pod.structgen_pad0)) == 48, "physx_PxVehicleTelemetryData_Pod.structgen_pad0 has unexpected size % instead of 48", size_of(type_of(physx_PxVehicleTelemetryData_Pod.structgen_pad0)));
    assert(size_of(physx_PxVehicleTelemetryData_Pod) == 48, "physx_PxVehicleTelemetryData_Pod has size % instead of 48", size_of(physx_PxVehicleTelemetryData_Pod));
}

physx_PxVehicleDriveSimDataNW_Pod :: struct {
    mEngine:        physx_PxVehicleEngineData_Pod;
    mGears:         physx_PxVehicleGearsData_Pod;
    mClutch:        physx_PxVehicleClutchData_Pod;
    mAutoBox:       physx_PxVehicleAutoBoxData_Pod;
    structgen_pad0: [16] u8;
}
#run {
    instance: physx_PxVehicleDriveSimDataNW_Pod;
    assert(((cast(*void)(*instance.mEngine)) - cast(*void)(*instance)) == 0, "physx_PxVehicleDriveSimDataNW_Pod.mEngine has unexpected offset % instead of 0", ((cast(*void)(*instance.mEngine)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDriveSimDataNW_Pod.mEngine)) == 112, "physx_PxVehicleDriveSimDataNW_Pod.mEngine has unexpected size % instead of 112", size_of(type_of(physx_PxVehicleDriveSimDataNW_Pod.mEngine)));
    assert(((cast(*void)(*instance.mGears)) - cast(*void)(*instance)) == 112, "physx_PxVehicleDriveSimDataNW_Pod.mGears has unexpected offset % instead of 112", ((cast(*void)(*instance.mGears)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDriveSimDataNW_Pod.mGears)) == 144, "physx_PxVehicleDriveSimDataNW_Pod.mGears has unexpected size % instead of 144", size_of(type_of(physx_PxVehicleDriveSimDataNW_Pod.mGears)));
    assert(((cast(*void)(*instance.mClutch)) - cast(*void)(*instance)) == 256, "physx_PxVehicleDriveSimDataNW_Pod.mClutch has unexpected offset % instead of 256", ((cast(*void)(*instance.mClutch)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDriveSimDataNW_Pod.mClutch)) == 16, "physx_PxVehicleDriveSimDataNW_Pod.mClutch has unexpected size % instead of 16", size_of(type_of(physx_PxVehicleDriveSimDataNW_Pod.mClutch)));
    assert(((cast(*void)(*instance.mAutoBox)) - cast(*void)(*instance)) == 272, "physx_PxVehicleDriveSimDataNW_Pod.mAutoBox has unexpected offset % instead of 272", ((cast(*void)(*instance.mAutoBox)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDriveSimDataNW_Pod.mAutoBox)) == 256, "physx_PxVehicleDriveSimDataNW_Pod.mAutoBox has unexpected size % instead of 256", size_of(type_of(physx_PxVehicleDriveSimDataNW_Pod.mAutoBox)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 528, "physx_PxVehicleDriveSimDataNW_Pod.structgen_pad0 has unexpected offset % instead of 528", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDriveSimDataNW_Pod.structgen_pad0)) == 16, "physx_PxVehicleDriveSimDataNW_Pod.structgen_pad0 has unexpected size % instead of 16", size_of(type_of(physx_PxVehicleDriveSimDataNW_Pod.structgen_pad0)));
    assert(size_of(physx_PxVehicleDriveSimDataNW_Pod) == 544, "physx_PxVehicleDriveSimDataNW_Pod has size % instead of 544", size_of(physx_PxVehicleDriveSimDataNW_Pod));
}

physx_PxVehicleDriveNW_Pod :: struct {
    structgen_pad0: [8] u8;
    mConcreteType:  u16;
    mBaseFlags:     physx_PxBaseFlags_Pod;
    structgen_pad1: [4] u8;
    mWheelsSimData: physx_PxVehicleWheelsSimData_Pod;
    mWheelsDynData: physx_PxVehicleWheelsDynData_Pod;
    mActor:         *physx_PxRigidDynamic_Pod;
    structgen_pad2: [5] u8;
    mType:          u8;
    mPad0:          [14] u8;
    structgen_pad3: [4] u8;
    mDriveDynData:  physx_PxVehicleDriveDynData_Pod;
    mDriveSimData:  physx_PxVehicleDriveSimDataNW_Pod;
}
#run {
    instance: physx_PxVehicleDriveNW_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxVehicleDriveNW_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDriveNW_Pod.structgen_pad0)) == 8, "physx_PxVehicleDriveNW_Pod.structgen_pad0 has unexpected size % instead of 8", size_of(type_of(physx_PxVehicleDriveNW_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)) == 8, "physx_PxVehicleDriveNW_Pod.mConcreteType has unexpected offset % instead of 8", ((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDriveNW_Pod.mConcreteType)) == 2, "physx_PxVehicleDriveNW_Pod.mConcreteType has unexpected size % instead of 2", size_of(type_of(physx_PxVehicleDriveNW_Pod.mConcreteType)));
    assert(((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)) == 10, "physx_PxVehicleDriveNW_Pod.mBaseFlags has unexpected offset % instead of 10", ((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDriveNW_Pod.mBaseFlags)) == 2, "physx_PxVehicleDriveNW_Pod.mBaseFlags has unexpected size % instead of 2", size_of(type_of(physx_PxVehicleDriveNW_Pod.mBaseFlags)));
    assert(((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)) == 12, "physx_PxVehicleDriveNW_Pod.structgen_pad1 has unexpected offset % instead of 12", ((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDriveNW_Pod.structgen_pad1)) == 4, "physx_PxVehicleDriveNW_Pod.structgen_pad1 has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleDriveNW_Pod.structgen_pad1)));
    assert(((cast(*void)(*instance.mWheelsSimData)) - cast(*void)(*instance)) == 16, "physx_PxVehicleDriveNW_Pod.mWheelsSimData has unexpected offset % instead of 16", ((cast(*void)(*instance.mWheelsSimData)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDriveNW_Pod.mWheelsSimData)) == 96, "physx_PxVehicleDriveNW_Pod.mWheelsSimData has unexpected size % instead of 96", size_of(type_of(physx_PxVehicleDriveNW_Pod.mWheelsSimData)));
    assert(((cast(*void)(*instance.mWheelsDynData)) - cast(*void)(*instance)) == 112, "physx_PxVehicleDriveNW_Pod.mWheelsDynData has unexpected offset % instead of 112", ((cast(*void)(*instance.mWheelsDynData)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDriveNW_Pod.mWheelsDynData)) == 48, "physx_PxVehicleDriveNW_Pod.mWheelsDynData has unexpected size % instead of 48", size_of(type_of(physx_PxVehicleDriveNW_Pod.mWheelsDynData)));
    assert(((cast(*void)(*instance.mActor)) - cast(*void)(*instance)) == 160, "physx_PxVehicleDriveNW_Pod.mActor has unexpected offset % instead of 160", ((cast(*void)(*instance.mActor)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDriveNW_Pod.mActor)) == 8, "physx_PxVehicleDriveNW_Pod.mActor has unexpected size % instead of 8", size_of(type_of(physx_PxVehicleDriveNW_Pod.mActor)));
    assert(((cast(*void)(*instance.structgen_pad2)) - cast(*void)(*instance)) == 168, "physx_PxVehicleDriveNW_Pod.structgen_pad2 has unexpected offset % instead of 168", ((cast(*void)(*instance.structgen_pad2)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDriveNW_Pod.structgen_pad2)) == 5, "physx_PxVehicleDriveNW_Pod.structgen_pad2 has unexpected size % instead of 5", size_of(type_of(physx_PxVehicleDriveNW_Pod.structgen_pad2)));
    assert(((cast(*void)(*instance.mType)) - cast(*void)(*instance)) == 173, "physx_PxVehicleDriveNW_Pod.mType has unexpected offset % instead of 173", ((cast(*void)(*instance.mType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDriveNW_Pod.mType)) == 1, "physx_PxVehicleDriveNW_Pod.mType has unexpected size % instead of 1", size_of(type_of(physx_PxVehicleDriveNW_Pod.mType)));
    assert(((cast(*void)(*instance.mPad0)) - cast(*void)(*instance)) == 174, "physx_PxVehicleDriveNW_Pod.mPad0 has unexpected offset % instead of 174", ((cast(*void)(*instance.mPad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDriveNW_Pod.mPad0)) == 14, "physx_PxVehicleDriveNW_Pod.mPad0 has unexpected size % instead of 14", size_of(type_of(physx_PxVehicleDriveNW_Pod.mPad0)));
    assert(((cast(*void)(*instance.structgen_pad3)) - cast(*void)(*instance)) == 188, "physx_PxVehicleDriveNW_Pod.structgen_pad3 has unexpected offset % instead of 188", ((cast(*void)(*instance.structgen_pad3)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDriveNW_Pod.structgen_pad3)) == 4, "physx_PxVehicleDriveNW_Pod.structgen_pad3 has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleDriveNW_Pod.structgen_pad3)));
    assert(((cast(*void)(*instance.mDriveDynData)) - cast(*void)(*instance)) == 192, "physx_PxVehicleDriveNW_Pod.mDriveDynData has unexpected offset % instead of 192", ((cast(*void)(*instance.mDriveDynData)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDriveNW_Pod.mDriveDynData)) == 96, "physx_PxVehicleDriveNW_Pod.mDriveDynData has unexpected size % instead of 96", size_of(type_of(physx_PxVehicleDriveNW_Pod.mDriveDynData)));
    assert(((cast(*void)(*instance.mDriveSimData)) - cast(*void)(*instance)) == 288, "physx_PxVehicleDriveNW_Pod.mDriveSimData has unexpected offset % instead of 288", ((cast(*void)(*instance.mDriveSimData)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDriveNW_Pod.mDriveSimData)) == 544, "physx_PxVehicleDriveNW_Pod.mDriveSimData has unexpected size % instead of 544", size_of(type_of(physx_PxVehicleDriveNW_Pod.mDriveSimData)));
    assert(size_of(physx_PxVehicleDriveNW_Pod) == 832, "physx_PxVehicleDriveNW_Pod has size % instead of 832", size_of(physx_PxVehicleDriveNW_Pod));
}

physx_PxVehicleDrive4WRawInputData_Pod :: struct {
    structgen_pad0: [40] u8;
}
#run {
    instance: physx_PxVehicleDrive4WRawInputData_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxVehicleDrive4WRawInputData_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDrive4WRawInputData_Pod.structgen_pad0)) == 40, "physx_PxVehicleDrive4WRawInputData_Pod.structgen_pad0 has unexpected size % instead of 40", size_of(type_of(physx_PxVehicleDrive4WRawInputData_Pod.structgen_pad0)));
    assert(size_of(physx_PxVehicleDrive4WRawInputData_Pod) == 40, "physx_PxVehicleDrive4WRawInputData_Pod has size % instead of 40", size_of(physx_PxVehicleDrive4WRawInputData_Pod));
}

physx_PxVehicleKeySmoothingData_Pod :: struct {
    mRiseRates: [16] float;
    mFallRates: [16] float;
}
#run {
    instance: physx_PxVehicleKeySmoothingData_Pod;
    assert(((cast(*void)(*instance.mRiseRates)) - cast(*void)(*instance)) == 0, "physx_PxVehicleKeySmoothingData_Pod.mRiseRates has unexpected offset % instead of 0", ((cast(*void)(*instance.mRiseRates)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleKeySmoothingData_Pod.mRiseRates)) == 64, "physx_PxVehicleKeySmoothingData_Pod.mRiseRates has unexpected size % instead of 64", size_of(type_of(physx_PxVehicleKeySmoothingData_Pod.mRiseRates)));
    assert(((cast(*void)(*instance.mFallRates)) - cast(*void)(*instance)) == 64, "physx_PxVehicleKeySmoothingData_Pod.mFallRates has unexpected offset % instead of 64", ((cast(*void)(*instance.mFallRates)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleKeySmoothingData_Pod.mFallRates)) == 64, "physx_PxVehicleKeySmoothingData_Pod.mFallRates has unexpected size % instead of 64", size_of(type_of(physx_PxVehicleKeySmoothingData_Pod.mFallRates)));
    assert(size_of(physx_PxVehicleKeySmoothingData_Pod) == 128, "physx_PxVehicleKeySmoothingData_Pod has size % instead of 128", size_of(physx_PxVehicleKeySmoothingData_Pod));
}

PxFixedSizeLookupTable_8__Pod :: struct {
    mDataPairs:   [16] float;
    mNbDataPairs: u32;
    mPad:         [3] u32;
}
#run {
    instance: PxFixedSizeLookupTable_8__Pod;
    assert(((cast(*void)(*instance.mDataPairs)) - cast(*void)(*instance)) == 0, "PxFixedSizeLookupTable_8__Pod.mDataPairs has unexpected offset % instead of 0", ((cast(*void)(*instance.mDataPairs)) - cast(*void)(*instance)));
    assert(size_of(type_of(PxFixedSizeLookupTable_8__Pod.mDataPairs)) == 64, "PxFixedSizeLookupTable_8__Pod.mDataPairs has unexpected size % instead of 64", size_of(type_of(PxFixedSizeLookupTable_8__Pod.mDataPairs)));
    assert(((cast(*void)(*instance.mNbDataPairs)) - cast(*void)(*instance)) == 64, "PxFixedSizeLookupTable_8__Pod.mNbDataPairs has unexpected offset % instead of 64", ((cast(*void)(*instance.mNbDataPairs)) - cast(*void)(*instance)));
    assert(size_of(type_of(PxFixedSizeLookupTable_8__Pod.mNbDataPairs)) == 4, "PxFixedSizeLookupTable_8__Pod.mNbDataPairs has unexpected size % instead of 4", size_of(type_of(PxFixedSizeLookupTable_8__Pod.mNbDataPairs)));
    assert(((cast(*void)(*instance.mPad)) - cast(*void)(*instance)) == 68, "PxFixedSizeLookupTable_8__Pod.mPad has unexpected offset % instead of 68", ((cast(*void)(*instance.mPad)) - cast(*void)(*instance)));
    assert(size_of(type_of(PxFixedSizeLookupTable_8__Pod.mPad)) == 12, "PxFixedSizeLookupTable_8__Pod.mPad has unexpected size % instead of 12", size_of(type_of(PxFixedSizeLookupTable_8__Pod.mPad)));
    assert(size_of(PxFixedSizeLookupTable_8__Pod) == 80, "PxFixedSizeLookupTable_8__Pod has size % instead of 80", size_of(PxFixedSizeLookupTable_8__Pod));
}

physx_PxVehiclePadSmoothingData_Pod :: struct {
    mRiseRates: [16] float;
    mFallRates: [16] float;
}
#run {
    instance: physx_PxVehiclePadSmoothingData_Pod;
    assert(((cast(*void)(*instance.mRiseRates)) - cast(*void)(*instance)) == 0, "physx_PxVehiclePadSmoothingData_Pod.mRiseRates has unexpected offset % instead of 0", ((cast(*void)(*instance.mRiseRates)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehiclePadSmoothingData_Pod.mRiseRates)) == 64, "physx_PxVehiclePadSmoothingData_Pod.mRiseRates has unexpected size % instead of 64", size_of(type_of(physx_PxVehiclePadSmoothingData_Pod.mRiseRates)));
    assert(((cast(*void)(*instance.mFallRates)) - cast(*void)(*instance)) == 64, "physx_PxVehiclePadSmoothingData_Pod.mFallRates has unexpected offset % instead of 64", ((cast(*void)(*instance.mFallRates)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehiclePadSmoothingData_Pod.mFallRates)) == 64, "physx_PxVehiclePadSmoothingData_Pod.mFallRates has unexpected size % instead of 64", size_of(type_of(physx_PxVehiclePadSmoothingData_Pod.mFallRates)));
    assert(size_of(physx_PxVehiclePadSmoothingData_Pod) == 128, "physx_PxVehiclePadSmoothingData_Pod has size % instead of 128", size_of(physx_PxVehiclePadSmoothingData_Pod));
}

physx_PxVehicleDriveNWRawInputData_Pod :: struct {
    structgen_pad0: [40] u8;
}
#run {
    instance: physx_PxVehicleDriveNWRawInputData_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxVehicleDriveNWRawInputData_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDriveNWRawInputData_Pod.structgen_pad0)) == 40, "physx_PxVehicleDriveNWRawInputData_Pod.structgen_pad0 has unexpected size % instead of 40", size_of(type_of(physx_PxVehicleDriveNWRawInputData_Pod.structgen_pad0)));
    assert(size_of(physx_PxVehicleDriveNWRawInputData_Pod) == 40, "physx_PxVehicleDriveNWRawInputData_Pod has size % instead of 40", size_of(physx_PxVehicleDriveNWRawInputData_Pod));
}

physx_PxVehicleDriveTankRawInputData_Pod :: struct {
    structgen_pad0: [32] u8;
}
#run {
    instance: physx_PxVehicleDriveTankRawInputData_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxVehicleDriveTankRawInputData_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleDriveTankRawInputData_Pod.structgen_pad0)) == 32, "physx_PxVehicleDriveTankRawInputData_Pod.structgen_pad0 has unexpected size % instead of 32", size_of(type_of(physx_PxVehicleDriveTankRawInputData_Pod.structgen_pad0)));
    assert(size_of(physx_PxVehicleDriveTankRawInputData_Pod) == 32, "physx_PxVehicleDriveTankRawInputData_Pod has size % instead of 32", size_of(physx_PxVehicleDriveTankRawInputData_Pod));
}

physx_PxVehicleCopyDynamicsMap_Pod :: struct {
    sourceWheelIds: [20] u8;
    targetWheelIds: [20] u8;
}
#run {
    instance: physx_PxVehicleCopyDynamicsMap_Pod;
    assert(((cast(*void)(*instance.sourceWheelIds)) - cast(*void)(*instance)) == 0, "physx_PxVehicleCopyDynamicsMap_Pod.sourceWheelIds has unexpected offset % instead of 0", ((cast(*void)(*instance.sourceWheelIds)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleCopyDynamicsMap_Pod.sourceWheelIds)) == 20, "physx_PxVehicleCopyDynamicsMap_Pod.sourceWheelIds has unexpected size % instead of 20", size_of(type_of(physx_PxVehicleCopyDynamicsMap_Pod.sourceWheelIds)));
    assert(((cast(*void)(*instance.targetWheelIds)) - cast(*void)(*instance)) == 20, "physx_PxVehicleCopyDynamicsMap_Pod.targetWheelIds has unexpected offset % instead of 20", ((cast(*void)(*instance.targetWheelIds)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleCopyDynamicsMap_Pod.targetWheelIds)) == 20, "physx_PxVehicleCopyDynamicsMap_Pod.targetWheelIds has unexpected size % instead of 20", size_of(type_of(physx_PxVehicleCopyDynamicsMap_Pod.targetWheelIds)));
    assert(size_of(physx_PxVehicleCopyDynamicsMap_Pod) == 40, "physx_PxVehicleCopyDynamicsMap_Pod has size % instead of 40", size_of(physx_PxVehicleCopyDynamicsMap_Pod));
}

physx_PxVehicleGraphChannelDesc_Pod :: struct {
    mMinY:          float;
    mMaxY:          float;
    mMidY:          float;
    mColorLow:      physx_PxVec3_Pod;
    mColorHigh:     physx_PxVec3_Pod;
    structgen_pad0: [4] u8;
    mTitle:         *u8;
}
#run {
    instance: physx_PxVehicleGraphChannelDesc_Pod;
    assert(((cast(*void)(*instance.mMinY)) - cast(*void)(*instance)) == 0, "physx_PxVehicleGraphChannelDesc_Pod.mMinY has unexpected offset % instead of 0", ((cast(*void)(*instance.mMinY)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleGraphChannelDesc_Pod.mMinY)) == 4, "physx_PxVehicleGraphChannelDesc_Pod.mMinY has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleGraphChannelDesc_Pod.mMinY)));
    assert(((cast(*void)(*instance.mMaxY)) - cast(*void)(*instance)) == 4, "physx_PxVehicleGraphChannelDesc_Pod.mMaxY has unexpected offset % instead of 4", ((cast(*void)(*instance.mMaxY)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleGraphChannelDesc_Pod.mMaxY)) == 4, "physx_PxVehicleGraphChannelDesc_Pod.mMaxY has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleGraphChannelDesc_Pod.mMaxY)));
    assert(((cast(*void)(*instance.mMidY)) - cast(*void)(*instance)) == 8, "physx_PxVehicleGraphChannelDesc_Pod.mMidY has unexpected offset % instead of 8", ((cast(*void)(*instance.mMidY)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleGraphChannelDesc_Pod.mMidY)) == 4, "physx_PxVehicleGraphChannelDesc_Pod.mMidY has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleGraphChannelDesc_Pod.mMidY)));
    assert(((cast(*void)(*instance.mColorLow)) - cast(*void)(*instance)) == 12, "physx_PxVehicleGraphChannelDesc_Pod.mColorLow has unexpected offset % instead of 12", ((cast(*void)(*instance.mColorLow)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleGraphChannelDesc_Pod.mColorLow)) == 12, "physx_PxVehicleGraphChannelDesc_Pod.mColorLow has unexpected size % instead of 12", size_of(type_of(physx_PxVehicleGraphChannelDesc_Pod.mColorLow)));
    assert(((cast(*void)(*instance.mColorHigh)) - cast(*void)(*instance)) == 24, "physx_PxVehicleGraphChannelDesc_Pod.mColorHigh has unexpected offset % instead of 24", ((cast(*void)(*instance.mColorHigh)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleGraphChannelDesc_Pod.mColorHigh)) == 12, "physx_PxVehicleGraphChannelDesc_Pod.mColorHigh has unexpected size % instead of 12", size_of(type_of(physx_PxVehicleGraphChannelDesc_Pod.mColorHigh)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 36, "physx_PxVehicleGraphChannelDesc_Pod.structgen_pad0 has unexpected offset % instead of 36", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleGraphChannelDesc_Pod.structgen_pad0)) == 4, "physx_PxVehicleGraphChannelDesc_Pod.structgen_pad0 has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleGraphChannelDesc_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.mTitle)) - cast(*void)(*instance)) == 40, "physx_PxVehicleGraphChannelDesc_Pod.mTitle has unexpected offset % instead of 40", ((cast(*void)(*instance.mTitle)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleGraphChannelDesc_Pod.mTitle)) == 8, "physx_PxVehicleGraphChannelDesc_Pod.mTitle has unexpected size % instead of 8", size_of(type_of(physx_PxVehicleGraphChannelDesc_Pod.mTitle)));
    assert(size_of(physx_PxVehicleGraphChannelDesc_Pod) == 48, "physx_PxVehicleGraphChannelDesc_Pod has size % instead of 48", size_of(physx_PxVehicleGraphChannelDesc_Pod));
}

physx_PxVehicleGraphDesc_Pod :: struct {
    structgen_pad0: [32] u8;
}
#run {
    instance: physx_PxVehicleGraphDesc_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxVehicleGraphDesc_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleGraphDesc_Pod.structgen_pad0)) == 32, "physx_PxVehicleGraphDesc_Pod.structgen_pad0 has unexpected size % instead of 32", size_of(type_of(physx_PxVehicleGraphDesc_Pod.structgen_pad0)));
    assert(size_of(physx_PxVehicleGraphDesc_Pod) == 32, "physx_PxVehicleGraphDesc_Pod has size % instead of 32", size_of(physx_PxVehicleGraphDesc_Pod));
}

physx_PxVehicleNoDrive_Pod :: struct {
    structgen_pad0: [8] u8;
    mConcreteType:  u16;
    mBaseFlags:     physx_PxBaseFlags_Pod;
    structgen_pad1: [4] u8;
    mWheelsSimData: physx_PxVehicleWheelsSimData_Pod;
    mWheelsDynData: physx_PxVehicleWheelsDynData_Pod;
    mActor:         *physx_PxRigidDynamic_Pod;
    structgen_pad2: [5] u8;
    mType:          u8;
    mPad0:          [14] u8;
    structgen_pad3: [36] u8;
}
#run {
    instance: physx_PxVehicleNoDrive_Pod;
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 0, "physx_PxVehicleNoDrive_Pod.structgen_pad0 has unexpected offset % instead of 0", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleNoDrive_Pod.structgen_pad0)) == 8, "physx_PxVehicleNoDrive_Pod.structgen_pad0 has unexpected size % instead of 8", size_of(type_of(physx_PxVehicleNoDrive_Pod.structgen_pad0)));
    assert(((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)) == 8, "physx_PxVehicleNoDrive_Pod.mConcreteType has unexpected offset % instead of 8", ((cast(*void)(*instance.mConcreteType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleNoDrive_Pod.mConcreteType)) == 2, "physx_PxVehicleNoDrive_Pod.mConcreteType has unexpected size % instead of 2", size_of(type_of(physx_PxVehicleNoDrive_Pod.mConcreteType)));
    assert(((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)) == 10, "physx_PxVehicleNoDrive_Pod.mBaseFlags has unexpected offset % instead of 10", ((cast(*void)(*instance.mBaseFlags)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleNoDrive_Pod.mBaseFlags)) == 2, "physx_PxVehicleNoDrive_Pod.mBaseFlags has unexpected size % instead of 2", size_of(type_of(physx_PxVehicleNoDrive_Pod.mBaseFlags)));
    assert(((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)) == 12, "physx_PxVehicleNoDrive_Pod.structgen_pad1 has unexpected offset % instead of 12", ((cast(*void)(*instance.structgen_pad1)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleNoDrive_Pod.structgen_pad1)) == 4, "physx_PxVehicleNoDrive_Pod.structgen_pad1 has unexpected size % instead of 4", size_of(type_of(physx_PxVehicleNoDrive_Pod.structgen_pad1)));
    assert(((cast(*void)(*instance.mWheelsSimData)) - cast(*void)(*instance)) == 16, "physx_PxVehicleNoDrive_Pod.mWheelsSimData has unexpected offset % instead of 16", ((cast(*void)(*instance.mWheelsSimData)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleNoDrive_Pod.mWheelsSimData)) == 96, "physx_PxVehicleNoDrive_Pod.mWheelsSimData has unexpected size % instead of 96", size_of(type_of(physx_PxVehicleNoDrive_Pod.mWheelsSimData)));
    assert(((cast(*void)(*instance.mWheelsDynData)) - cast(*void)(*instance)) == 112, "physx_PxVehicleNoDrive_Pod.mWheelsDynData has unexpected offset % instead of 112", ((cast(*void)(*instance.mWheelsDynData)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleNoDrive_Pod.mWheelsDynData)) == 48, "physx_PxVehicleNoDrive_Pod.mWheelsDynData has unexpected size % instead of 48", size_of(type_of(physx_PxVehicleNoDrive_Pod.mWheelsDynData)));
    assert(((cast(*void)(*instance.mActor)) - cast(*void)(*instance)) == 160, "physx_PxVehicleNoDrive_Pod.mActor has unexpected offset % instead of 160", ((cast(*void)(*instance.mActor)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleNoDrive_Pod.mActor)) == 8, "physx_PxVehicleNoDrive_Pod.mActor has unexpected size % instead of 8", size_of(type_of(physx_PxVehicleNoDrive_Pod.mActor)));
    assert(((cast(*void)(*instance.structgen_pad2)) - cast(*void)(*instance)) == 168, "physx_PxVehicleNoDrive_Pod.structgen_pad2 has unexpected offset % instead of 168", ((cast(*void)(*instance.structgen_pad2)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleNoDrive_Pod.structgen_pad2)) == 5, "physx_PxVehicleNoDrive_Pod.structgen_pad2 has unexpected size % instead of 5", size_of(type_of(physx_PxVehicleNoDrive_Pod.structgen_pad2)));
    assert(((cast(*void)(*instance.mType)) - cast(*void)(*instance)) == 173, "physx_PxVehicleNoDrive_Pod.mType has unexpected offset % instead of 173", ((cast(*void)(*instance.mType)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleNoDrive_Pod.mType)) == 1, "physx_PxVehicleNoDrive_Pod.mType has unexpected size % instead of 1", size_of(type_of(physx_PxVehicleNoDrive_Pod.mType)));
    assert(((cast(*void)(*instance.mPad0)) - cast(*void)(*instance)) == 174, "physx_PxVehicleNoDrive_Pod.mPad0 has unexpected offset % instead of 174", ((cast(*void)(*instance.mPad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleNoDrive_Pod.mPad0)) == 14, "physx_PxVehicleNoDrive_Pod.mPad0 has unexpected size % instead of 14", size_of(type_of(physx_PxVehicleNoDrive_Pod.mPad0)));
    assert(((cast(*void)(*instance.structgen_pad3)) - cast(*void)(*instance)) == 188, "physx_PxVehicleNoDrive_Pod.structgen_pad3 has unexpected offset % instead of 188", ((cast(*void)(*instance.structgen_pad3)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxVehicleNoDrive_Pod.structgen_pad3)) == 36, "physx_PxVehicleNoDrive_Pod.structgen_pad3 has unexpected size % instead of 36", size_of(type_of(physx_PxVehicleNoDrive_Pod.structgen_pad3)));
    assert(size_of(physx_PxVehicleNoDrive_Pod) == 224, "physx_PxVehicleNoDrive_Pod has size % instead of 224", size_of(physx_PxVehicleNoDrive_Pod));
}

physx_PxProfileScoped_Pod :: struct {
    mCallback:      *physx_PxProfilerCallback_Pod;
    mEventName:     *u8;
    mProfilerData:  *void;
    mContextId:     u64;
    mDetached:      bool;
    structgen_pad0: [7] u8;
}
#run {
    instance: physx_PxProfileScoped_Pod;
    assert(((cast(*void)(*instance.mCallback)) - cast(*void)(*instance)) == 0, "physx_PxProfileScoped_Pod.mCallback has unexpected offset % instead of 0", ((cast(*void)(*instance.mCallback)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxProfileScoped_Pod.mCallback)) == 8, "physx_PxProfileScoped_Pod.mCallback has unexpected size % instead of 8", size_of(type_of(physx_PxProfileScoped_Pod.mCallback)));
    assert(((cast(*void)(*instance.mEventName)) - cast(*void)(*instance)) == 8, "physx_PxProfileScoped_Pod.mEventName has unexpected offset % instead of 8", ((cast(*void)(*instance.mEventName)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxProfileScoped_Pod.mEventName)) == 8, "physx_PxProfileScoped_Pod.mEventName has unexpected size % instead of 8", size_of(type_of(physx_PxProfileScoped_Pod.mEventName)));
    assert(((cast(*void)(*instance.mProfilerData)) - cast(*void)(*instance)) == 16, "physx_PxProfileScoped_Pod.mProfilerData has unexpected offset % instead of 16", ((cast(*void)(*instance.mProfilerData)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxProfileScoped_Pod.mProfilerData)) == 8, "physx_PxProfileScoped_Pod.mProfilerData has unexpected size % instead of 8", size_of(type_of(physx_PxProfileScoped_Pod.mProfilerData)));
    assert(((cast(*void)(*instance.mContextId)) - cast(*void)(*instance)) == 24, "physx_PxProfileScoped_Pod.mContextId has unexpected offset % instead of 24", ((cast(*void)(*instance.mContextId)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxProfileScoped_Pod.mContextId)) == 8, "physx_PxProfileScoped_Pod.mContextId has unexpected size % instead of 8", size_of(type_of(physx_PxProfileScoped_Pod.mContextId)));
    assert(((cast(*void)(*instance.mDetached)) - cast(*void)(*instance)) == 32, "physx_PxProfileScoped_Pod.mDetached has unexpected offset % instead of 32", ((cast(*void)(*instance.mDetached)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxProfileScoped_Pod.mDetached)) == 1, "physx_PxProfileScoped_Pod.mDetached has unexpected size % instead of 1", size_of(type_of(physx_PxProfileScoped_Pod.mDetached)));
    assert(((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)) == 33, "physx_PxProfileScoped_Pod.structgen_pad0 has unexpected offset % instead of 33", ((cast(*void)(*instance.structgen_pad0)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxProfileScoped_Pod.structgen_pad0)) == 7, "physx_PxProfileScoped_Pod.structgen_pad0 has unexpected size % instead of 7", size_of(type_of(physx_PxProfileScoped_Pod.structgen_pad0)));
    assert(size_of(physx_PxProfileScoped_Pod) == 40, "physx_PxProfileScoped_Pod has size % instead of 40", size_of(physx_PxProfileScoped_Pod));
}

physx_PxPvdTransport_Pod :: struct {
    vtable_: *void;
}
#run {
    instance: physx_PxPvdTransport_Pod;
    assert(((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)) == 0, "physx_PxPvdTransport_Pod.vtable_ has unexpected offset % instead of 0", ((cast(*void)(*instance.vtable_)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxPvdTransport_Pod.vtable_)) == 8, "physx_PxPvdTransport_Pod.vtable_ has unexpected size % instead of 8", size_of(type_of(physx_PxPvdTransport_Pod.vtable_)));
    assert(size_of(physx_PxPvdTransport_Pod) == 8, "physx_PxPvdTransport_Pod has size % instead of 8", size_of(physx_PxPvdTransport_Pod));
}

physx_PxPvdInstrumentationFlags_Pod :: struct {
    mBits: u8;
}
#run {
    instance: physx_PxPvdInstrumentationFlags_Pod;
    assert(((cast(*void)(*instance.mBits)) - cast(*void)(*instance)) == 0, "physx_PxPvdInstrumentationFlags_Pod.mBits has unexpected offset % instead of 0", ((cast(*void)(*instance.mBits)) - cast(*void)(*instance)));
    assert(size_of(type_of(physx_PxPvdInstrumentationFlags_Pod.mBits)) == 1, "physx_PxPvdInstrumentationFlags_Pod.mBits has unexpected size % instead of 1", size_of(type_of(physx_PxPvdInstrumentationFlags_Pod.mBits)));
    assert(size_of(physx_PxPvdInstrumentationFlags_Pod) == 1, "physx_PxPvdInstrumentationFlags_Pod has size % instead of 1", size_of(physx_PxPvdInstrumentationFlags_Pod));
}

PxAllocatorCallback_delete :: (self__pod: *physx_PxAllocatorCallback_Pod) -> void #foreign physx_lib;

PxAllocatorCallback_allocate_mut :: (self__pod: *physx_PxAllocatorCallback_Pod, size: u64, typeName: *u8, filename: *u8, line: s32) -> *void #foreign physx_lib;

PxAllocatorCallback_deallocate_mut :: (self__pod: *physx_PxAllocatorCallback_Pod, ptr: *void) -> void #foreign physx_lib;

PxAssertHandler_delete :: (self__pod: *physx_PxAssertHandler_Pod) -> void #foreign physx_lib;

phys_PxGetAssertHandler :: () -> *physx_PxAssertHandler_Pod #foreign physx_lib;

phys_PxSetAssertHandler :: (handler_pod: *physx_PxAssertHandler_Pod) -> void #foreign physx_lib;

phys_PxAbs :: (a: float) -> float #foreign physx_lib;

phys_PxEquals :: (a: float, b: float, eps: float) -> bool #foreign physx_lib;

phys_PxAbs_1 :: (a: float64) -> float64 #foreign physx_lib;

phys_PxAbs_2 :: (a: s32) -> s32 #foreign physx_lib;

phys_PxSqrt :: (a: float) -> float #foreign physx_lib;

phys_PxSqrt_1 :: (a: float64) -> float64 #foreign physx_lib;

phys_PxRecipSqrt :: (a: float) -> float #foreign physx_lib;

phys_PxRecipSqrt_1 :: (a: float64) -> float64 #foreign physx_lib;

phys_PxSin :: (a: float) -> float #foreign physx_lib;

phys_PxSin_1 :: (a: float64) -> float64 #foreign physx_lib;

phys_PxCos :: (a: float) -> float #foreign physx_lib;

phys_PxCos_1 :: (a: float64) -> float64 #foreign physx_lib;

phys_PxTan :: (a: float) -> float #foreign physx_lib;

phys_PxTan_1 :: (a: float64) -> float64 #foreign physx_lib;

phys_PxAsin :: (f: float) -> float #foreign physx_lib;

phys_PxAsin_1 :: (f: float64) -> float64 #foreign physx_lib;

phys_PxAcos :: (f: float) -> float #foreign physx_lib;

phys_PxAcos_1 :: (f: float64) -> float64 #foreign physx_lib;

phys_PxAtan :: (a: float) -> float #foreign physx_lib;

phys_PxAtan_1 :: (a: float64) -> float64 #foreign physx_lib;

phys_PxAtan2 :: (x: float, y: float) -> float #foreign physx_lib;

phys_PxAtan2_1 :: (x: float64, y: float64) -> float64 #foreign physx_lib;

phys_PxIsFinite :: (f: float) -> bool #foreign physx_lib;

phys_PxIsFinite_1 :: (f: float64) -> bool #foreign physx_lib;

phys_PxFloor :: (a: float) -> float #foreign physx_lib;

phys_PxExp :: (a: float) -> float #foreign physx_lib;

phys_PxCeil :: (a: float) -> float #foreign physx_lib;

phys_PxSign :: (a: float) -> float #foreign physx_lib;

phys_PxPow :: (x: float, y: float) -> float #foreign physx_lib;

phys_PxLog :: (x: float) -> float #foreign physx_lib;

PxVec3_new :: () -> physx_PxVec3_Pod #foreign physx_lib;

PxVec3_new_1 :: (r_pod: u32) -> physx_PxVec3_Pod #foreign physx_lib;

PxVec3_new_2 :: (a: float) -> physx_PxVec3_Pod #foreign physx_lib;

PxVec3_new_3 :: (nx: float, ny: float, nz: float) -> physx_PxVec3_Pod #foreign physx_lib;

PxVec3_isZero :: (self__pod: *physx_PxVec3_Pod) -> bool #foreign physx_lib;

PxVec3_isFinite :: (self__pod: *physx_PxVec3_Pod) -> bool #foreign physx_lib;

PxVec3_isNormalized :: (self__pod: *physx_PxVec3_Pod) -> bool #foreign physx_lib;

PxVec3_magnitudeSquared :: (self__pod: *physx_PxVec3_Pod) -> float #foreign physx_lib;

PxVec3_magnitude :: (self__pod: *physx_PxVec3_Pod) -> float #foreign physx_lib;

PxVec3_dot :: (self__pod: *physx_PxVec3_Pod, v_pod: *physx_PxVec3_Pod) -> float #foreign physx_lib;

PxVec3_cross :: (self__pod: *physx_PxVec3_Pod, v_pod: *physx_PxVec3_Pod) -> physx_PxVec3_Pod #foreign physx_lib;

PxVec3_getNormalized :: (self__pod: *physx_PxVec3_Pod) -> physx_PxVec3_Pod #foreign physx_lib;

PxVec3_normalize_mut :: (self__pod: *physx_PxVec3_Pod) -> float #foreign physx_lib;

PxVec3_normalizeSafe_mut :: (self__pod: *physx_PxVec3_Pod) -> float #foreign physx_lib;

PxVec3_normalizeFast_mut :: (self__pod: *physx_PxVec3_Pod) -> float #foreign physx_lib;

PxVec3_multiply :: (self__pod: *physx_PxVec3_Pod, a_pod: *physx_PxVec3_Pod) -> physx_PxVec3_Pod #foreign physx_lib;

PxVec3_minimum :: (self__pod: *physx_PxVec3_Pod, v_pod: *physx_PxVec3_Pod) -> physx_PxVec3_Pod #foreign physx_lib;

PxVec3_minElement :: (self__pod: *physx_PxVec3_Pod) -> float #foreign physx_lib;

PxVec3_maximum :: (self__pod: *physx_PxVec3_Pod, v_pod: *physx_PxVec3_Pod) -> physx_PxVec3_Pod #foreign physx_lib;

PxVec3_maxElement :: (self__pod: *physx_PxVec3_Pod) -> float #foreign physx_lib;

PxVec3_abs :: (self__pod: *physx_PxVec3_Pod) -> physx_PxVec3_Pod #foreign physx_lib;

PxQuat_new :: () -> physx_PxQuat_Pod #foreign physx_lib;

PxQuat_new_1 :: (r_pod: u32) -> physx_PxQuat_Pod #foreign physx_lib;

PxQuat_new_2 :: (r: float) -> physx_PxQuat_Pod #foreign physx_lib;

PxQuat_new_3 :: (nx: float, ny: float, nz: float, nw: float) -> physx_PxQuat_Pod #foreign physx_lib;

PxQuat_new_4 :: (angleRadians: float, unitAxis_pod: *physx_PxVec3_Pod) -> physx_PxQuat_Pod #foreign physx_lib;

PxQuat_new_5 :: (m_pod: *physx_PxMat33_Pod) -> physx_PxQuat_Pod #foreign physx_lib;

PxQuat_isIdentity :: (self__pod: *physx_PxQuat_Pod) -> bool #foreign physx_lib;

PxQuat_isFinite :: (self__pod: *physx_PxQuat_Pod) -> bool #foreign physx_lib;

PxQuat_isUnit :: (self__pod: *physx_PxQuat_Pod) -> bool #foreign physx_lib;

PxQuat_isSane :: (self__pod: *physx_PxQuat_Pod) -> bool #foreign physx_lib;

PxQuat_toRadiansAndUnitAxis :: (self__pod: *physx_PxQuat_Pod, angle_pod: *float, axis_pod: *physx_PxVec3_Pod) -> void #foreign physx_lib;

PxQuat_getAngle :: (self__pod: *physx_PxQuat_Pod) -> float #foreign physx_lib;

PxQuat_getAngle_1 :: (self__pod: *physx_PxQuat_Pod, q_pod: *physx_PxQuat_Pod) -> float #foreign physx_lib;

PxQuat_magnitudeSquared :: (self__pod: *physx_PxQuat_Pod) -> float #foreign physx_lib;

PxQuat_dot :: (self__pod: *physx_PxQuat_Pod, v_pod: *physx_PxQuat_Pod) -> float #foreign physx_lib;

PxQuat_getNormalized :: (self__pod: *physx_PxQuat_Pod) -> physx_PxQuat_Pod #foreign physx_lib;

PxQuat_magnitude :: (self__pod: *physx_PxQuat_Pod) -> float #foreign physx_lib;

PxQuat_normalize_mut :: (self__pod: *physx_PxQuat_Pod) -> float #foreign physx_lib;

PxQuat_getConjugate :: (self__pod: *physx_PxQuat_Pod) -> physx_PxQuat_Pod #foreign physx_lib;

PxQuat_getImaginaryPart :: (self__pod: *physx_PxQuat_Pod) -> physx_PxVec3_Pod #foreign physx_lib;

PxQuat_getBasisVector0 :: (self__pod: *physx_PxQuat_Pod) -> physx_PxVec3_Pod #foreign physx_lib;

PxQuat_getBasisVector1 :: (self__pod: *physx_PxQuat_Pod) -> physx_PxVec3_Pod #foreign physx_lib;

PxQuat_getBasisVector2 :: (self__pod: *physx_PxQuat_Pod) -> physx_PxVec3_Pod #foreign physx_lib;

PxQuat_rotate :: (self__pod: *physx_PxQuat_Pod, v_pod: *physx_PxVec3_Pod) -> physx_PxVec3_Pod #foreign physx_lib;

PxQuat_rotateInv :: (self__pod: *physx_PxQuat_Pod, v_pod: *physx_PxVec3_Pod) -> physx_PxVec3_Pod #foreign physx_lib;

PxPlane_new :: () -> physx_PxPlane_Pod #foreign physx_lib;

PxPlane_new_1 :: (nx: float, ny: float, nz: float, distance: float) -> physx_PxPlane_Pod #foreign physx_lib;

PxPlane_new_2 :: (normal_pod: *physx_PxVec3_Pod, distance: float) -> physx_PxPlane_Pod #foreign physx_lib;

PxPlane_new_3 :: (point_pod: *physx_PxVec3_Pod, normal_pod: *physx_PxVec3_Pod) -> physx_PxPlane_Pod #foreign physx_lib;

PxPlane_new_4 :: (p0_pod: *physx_PxVec3_Pod, p1_pod: *physx_PxVec3_Pod, p2_pod: *physx_PxVec3_Pod) -> physx_PxPlane_Pod #foreign physx_lib;

PxPlane_distance :: (self__pod: *physx_PxPlane_Pod, p_pod: *physx_PxVec3_Pod) -> float #foreign physx_lib;

PxPlane_contains :: (self__pod: *physx_PxPlane_Pod, p_pod: *physx_PxVec3_Pod) -> bool #foreign physx_lib;

PxPlane_project :: (self__pod: *physx_PxPlane_Pod, p_pod: *physx_PxVec3_Pod) -> physx_PxVec3_Pod #foreign physx_lib;

PxPlane_pointInPlane :: (self__pod: *physx_PxPlane_Pod) -> physx_PxVec3_Pod #foreign physx_lib;

PxPlane_normalize_mut :: (self__pod: *physx_PxPlane_Pod) -> void #foreign physx_lib;

PxTransform_new :: () -> physx_PxTransform_Pod #foreign physx_lib;

PxTransform_new_1 :: (position_pod: *physx_PxVec3_Pod) -> physx_PxTransform_Pod #foreign physx_lib;

PxTransform_new_2 :: (r_pod: u32) -> physx_PxTransform_Pod #foreign physx_lib;

PxTransform_new_3 :: (orientation_pod: *physx_PxQuat_Pod) -> physx_PxTransform_Pod #foreign physx_lib;

PxTransform_new_4 :: (x: float, y: float, z: float, aQ_pod: physx_PxQuat_Pod) -> physx_PxTransform_Pod #foreign physx_lib;

PxTransform_new_5 :: (p0_pod: *physx_PxVec3_Pod, q0_pod: *physx_PxQuat_Pod) -> physx_PxTransform_Pod #foreign physx_lib;

PxTransform_new_6 :: (m_pod: *physx_PxMat44_Pod) -> physx_PxTransform_Pod #foreign physx_lib;

PxTransform_getInverse :: (self__pod: *physx_PxTransform_Pod) -> physx_PxTransform_Pod #foreign physx_lib;

PxTransform_transform :: (self__pod: *physx_PxTransform_Pod, input_pod: *physx_PxVec3_Pod) -> physx_PxVec3_Pod #foreign physx_lib;

PxTransform_transformInv :: (self__pod: *physx_PxTransform_Pod, input_pod: *physx_PxVec3_Pod) -> physx_PxVec3_Pod #foreign physx_lib;

PxTransform_rotate :: (self__pod: *physx_PxTransform_Pod, input_pod: *physx_PxVec3_Pod) -> physx_PxVec3_Pod #foreign physx_lib;

PxTransform_rotateInv :: (self__pod: *physx_PxTransform_Pod, input_pod: *physx_PxVec3_Pod) -> physx_PxVec3_Pod #foreign physx_lib;

PxTransform_transform_1 :: (self__pod: *physx_PxTransform_Pod, src_pod: *physx_PxTransform_Pod) -> physx_PxTransform_Pod #foreign physx_lib;

PxTransform_isValid :: (self__pod: *physx_PxTransform_Pod) -> bool #foreign physx_lib;

PxTransform_isSane :: (self__pod: *physx_PxTransform_Pod) -> bool #foreign physx_lib;

PxTransform_isFinite :: (self__pod: *physx_PxTransform_Pod) -> bool #foreign physx_lib;

PxTransform_transformInv_1 :: (self__pod: *physx_PxTransform_Pod, src_pod: *physx_PxTransform_Pod) -> physx_PxTransform_Pod #foreign physx_lib;

PxTransform_transform_2 :: (self__pod: *physx_PxTransform_Pod, plane_pod: *physx_PxPlane_Pod) -> physx_PxPlane_Pod #foreign physx_lib;

PxTransform_inverseTransform :: (self__pod: *physx_PxTransform_Pod, plane_pod: *physx_PxPlane_Pod) -> physx_PxPlane_Pod #foreign physx_lib;

PxTransform_getNormalized :: (self__pod: *physx_PxTransform_Pod) -> physx_PxTransform_Pod #foreign physx_lib;

PxMat33_new :: () -> physx_PxMat33_Pod #foreign physx_lib;

PxMat33_new_1 :: (r_pod: u32) -> physx_PxMat33_Pod #foreign physx_lib;

PxMat33_new_2 :: (r_pod: u32) -> physx_PxMat33_Pod #foreign physx_lib;

PxMat33_new_3 :: (col0_pod: *physx_PxVec3_Pod, col1_pod: *physx_PxVec3_Pod, col2_pod: *physx_PxVec3_Pod) -> physx_PxMat33_Pod #foreign physx_lib;

PxMat33_new_4 :: (r: float) -> physx_PxMat33_Pod #foreign physx_lib;

PxMat33_new_5 :: (values: *float) -> physx_PxMat33_Pod #foreign physx_lib;

PxMat33_new_6 :: (q_pod: *physx_PxQuat_Pod) -> physx_PxMat33_Pod #foreign physx_lib;

PxMat33_createDiagonal_mut :: (d_pod: *physx_PxVec3_Pod) -> physx_PxMat33_Pod #foreign physx_lib;

PxMat33_getTranspose :: (self__pod: *physx_PxMat33_Pod) -> physx_PxMat33_Pod #foreign physx_lib;

PxMat33_getInverse :: (self__pod: *physx_PxMat33_Pod) -> physx_PxMat33_Pod #foreign physx_lib;

PxMat33_getDeterminant :: (self__pod: *physx_PxMat33_Pod) -> float #foreign physx_lib;

PxMat33_transform :: (self__pod: *physx_PxMat33_Pod, other_pod: *physx_PxVec3_Pod) -> physx_PxVec3_Pod #foreign physx_lib;

PxMat33_transformTranspose :: (self__pod: *physx_PxMat33_Pod, other_pod: *physx_PxVec3_Pod) -> physx_PxVec3_Pod #foreign physx_lib;

PxMat33_front :: (self__pod: *physx_PxMat33_Pod) -> *float #foreign physx_lib;

PxQuat_new_6 :: (m_pod: *physx_PxMat33_Pod) -> physx_PxQuat_Pod #foreign physx_lib;

PxBounds3_new :: () -> physx_PxBounds3_Pod #foreign physx_lib;

PxBounds3_new_1 :: (minimum_pod: *physx_PxVec3_Pod, maximum_pod: *physx_PxVec3_Pod) -> physx_PxBounds3_Pod #foreign physx_lib;

PxBounds3_empty_mut :: () -> physx_PxBounds3_Pod #foreign physx_lib;

PxBounds3_boundsOfPoints_mut :: (v0_pod: *physx_PxVec3_Pod, v1_pod: *physx_PxVec3_Pod) -> physx_PxBounds3_Pod #foreign physx_lib;

PxBounds3_centerExtents_mut :: (center_pod: *physx_PxVec3_Pod, extent_pod: *physx_PxVec3_Pod) -> physx_PxBounds3_Pod #foreign physx_lib;

PxBounds3_basisExtent_mut :: (center_pod: *physx_PxVec3_Pod, basis_pod: *physx_PxMat33_Pod, extent_pod: *physx_PxVec3_Pod) -> physx_PxBounds3_Pod #foreign physx_lib;

PxBounds3_poseExtent_mut :: (pose_pod: *physx_PxTransform_Pod, extent_pod: *physx_PxVec3_Pod) -> physx_PxBounds3_Pod #foreign physx_lib;

PxBounds3_transformSafe_mut :: (matrix_pod: *physx_PxMat33_Pod, bounds_pod: *physx_PxBounds3_Pod) -> physx_PxBounds3_Pod #foreign physx_lib;

PxBounds3_transformFast_mut :: (matrix_pod: *physx_PxMat33_Pod, bounds_pod: *physx_PxBounds3_Pod) -> physx_PxBounds3_Pod #foreign physx_lib;

PxBounds3_transformSafe_mut_1 :: (transform_pod: *physx_PxTransform_Pod, bounds_pod: *physx_PxBounds3_Pod) -> physx_PxBounds3_Pod #foreign physx_lib;

PxBounds3_transformFast_mut_1 :: (transform_pod: *physx_PxTransform_Pod, bounds_pod: *physx_PxBounds3_Pod) -> physx_PxBounds3_Pod #foreign physx_lib;

PxBounds3_setEmpty_mut :: (self__pod: *physx_PxBounds3_Pod) -> void #foreign physx_lib;

PxBounds3_setMaximal_mut :: (self__pod: *physx_PxBounds3_Pod) -> void #foreign physx_lib;

PxBounds3_include_mut :: (self__pod: *physx_PxBounds3_Pod, v_pod: *physx_PxVec3_Pod) -> void #foreign physx_lib;

PxBounds3_include_mut_1 :: (self__pod: *physx_PxBounds3_Pod, b_pod: *physx_PxBounds3_Pod) -> void #foreign physx_lib;

PxBounds3_isEmpty :: (self__pod: *physx_PxBounds3_Pod) -> bool #foreign physx_lib;

PxBounds3_intersects :: (self__pod: *physx_PxBounds3_Pod, b_pod: *physx_PxBounds3_Pod) -> bool #foreign physx_lib;

PxBounds3_intersects1D :: (self__pod: *physx_PxBounds3_Pod, a_pod: *physx_PxBounds3_Pod, axis: u32) -> bool #foreign physx_lib;

PxBounds3_contains :: (self__pod: *physx_PxBounds3_Pod, v_pod: *physx_PxVec3_Pod) -> bool #foreign physx_lib;

PxBounds3_isInside :: (self__pod: *physx_PxBounds3_Pod, box_pod: *physx_PxBounds3_Pod) -> bool #foreign physx_lib;

PxBounds3_getCenter :: (self__pod: *physx_PxBounds3_Pod) -> physx_PxVec3_Pod #foreign physx_lib;

PxBounds3_getCenter_1 :: (self__pod: *physx_PxBounds3_Pod, axis: u32) -> float #foreign physx_lib;

PxBounds3_getExtents :: (self__pod: *physx_PxBounds3_Pod, axis: u32) -> float #foreign physx_lib;

PxBounds3_getDimensions :: (self__pod: *physx_PxBounds3_Pod) -> physx_PxVec3_Pod #foreign physx_lib;

PxBounds3_getExtents_1 :: (self__pod: *physx_PxBounds3_Pod) -> physx_PxVec3_Pod #foreign physx_lib;

PxBounds3_scaleSafe_mut :: (self__pod: *physx_PxBounds3_Pod, scale: float) -> void #foreign physx_lib;

PxBounds3_scaleFast_mut :: (self__pod: *physx_PxBounds3_Pod, scale: float) -> void #foreign physx_lib;

PxBounds3_fattenSafe_mut :: (self__pod: *physx_PxBounds3_Pod, distance: float) -> void #foreign physx_lib;

PxBounds3_fattenFast_mut :: (self__pod: *physx_PxBounds3_Pod, distance: float) -> void #foreign physx_lib;

PxBounds3_isFinite :: (self__pod: *physx_PxBounds3_Pod) -> bool #foreign physx_lib;

PxBounds3_isValid :: (self__pod: *physx_PxBounds3_Pod) -> bool #foreign physx_lib;

PxBounds3_new_2 :: (minimum__pod: *physx_PxVec3_Pod, maximum__pod: *physx_PxVec3_Pod) -> physx_PxBounds3_Pod #foreign physx_lib;

PxBounds3_empty_mut_1 :: () -> physx_PxBounds3_Pod #foreign physx_lib;

PxBounds3_isFinite_1 :: (self__pod: *physx_PxBounds3_Pod) -> bool #foreign physx_lib;

PxBounds3_boundsOfPoints_mut_1 :: (v0_pod: *physx_PxVec3_Pod, v1_pod: *physx_PxVec3_Pod) -> physx_PxBounds3_Pod #foreign physx_lib;

PxBounds3_centerExtents_mut_1 :: (center_pod: *physx_PxVec3_Pod, extent_pod: *physx_PxVec3_Pod) -> physx_PxBounds3_Pod #foreign physx_lib;

PxBounds3_basisExtent_mut_1 :: (center_pod: *physx_PxVec3_Pod, basis_pod: *physx_PxMat33_Pod, extent_pod: *physx_PxVec3_Pod) -> physx_PxBounds3_Pod #foreign physx_lib;

PxBounds3_poseExtent_mut_1 :: (pose_pod: *physx_PxTransform_Pod, extent_pod: *physx_PxVec3_Pod) -> physx_PxBounds3_Pod #foreign physx_lib;

PxBounds3_setEmpty_mut_1 :: (self__pod: *physx_PxBounds3_Pod) -> void #foreign physx_lib;

PxBounds3_setMaximal_mut_1 :: (self__pod: *physx_PxBounds3_Pod) -> void #foreign physx_lib;

PxBounds3_include_mut_2 :: (self__pod: *physx_PxBounds3_Pod, v_pod: *physx_PxVec3_Pod) -> void #foreign physx_lib;

PxBounds3_include_mut_3 :: (self__pod: *physx_PxBounds3_Pod, b_pod: *physx_PxBounds3_Pod) -> void #foreign physx_lib;

PxBounds3_isEmpty_1 :: (self__pod: *physx_PxBounds3_Pod) -> bool #foreign physx_lib;

PxBounds3_intersects_1 :: (self__pod: *physx_PxBounds3_Pod, b_pod: *physx_PxBounds3_Pod) -> bool #foreign physx_lib;

PxBounds3_intersects1D_1 :: (self__pod: *physx_PxBounds3_Pod, a_pod: *physx_PxBounds3_Pod, axis: u32) -> bool #foreign physx_lib;

PxBounds3_contains_1 :: (self__pod: *physx_PxBounds3_Pod, v_pod: *physx_PxVec3_Pod) -> bool #foreign physx_lib;

PxBounds3_isInside_1 :: (self__pod: *physx_PxBounds3_Pod, box_pod: *physx_PxBounds3_Pod) -> bool #foreign physx_lib;

PxBounds3_getCenter_2 :: (self__pod: *physx_PxBounds3_Pod) -> physx_PxVec3_Pod #foreign physx_lib;

PxBounds3_getCenter_3 :: (self__pod: *physx_PxBounds3_Pod, axis: u32) -> float #foreign physx_lib;

PxBounds3_getExtents_2 :: (self__pod: *physx_PxBounds3_Pod, axis: u32) -> float #foreign physx_lib;

PxBounds3_getDimensions_1 :: (self__pod: *physx_PxBounds3_Pod) -> physx_PxVec3_Pod #foreign physx_lib;

PxBounds3_getExtents_3 :: (self__pod: *physx_PxBounds3_Pod) -> physx_PxVec3_Pod #foreign physx_lib;

PxBounds3_scaleSafe_mut_1 :: (self__pod: *physx_PxBounds3_Pod, scale: float) -> void #foreign physx_lib;

PxBounds3_scaleFast_mut_1 :: (self__pod: *physx_PxBounds3_Pod, scale: float) -> void #foreign physx_lib;

PxBounds3_fattenSafe_mut_1 :: (self__pod: *physx_PxBounds3_Pod, distance: float) -> void #foreign physx_lib;

PxBounds3_fattenFast_mut_1 :: (self__pod: *physx_PxBounds3_Pod, distance: float) -> void #foreign physx_lib;

PxBounds3_transformSafe_mut_2 :: (matrix_pod: *physx_PxMat33_Pod, bounds_pod: *physx_PxBounds3_Pod) -> physx_PxBounds3_Pod #foreign physx_lib;

PxBounds3_transformFast_mut_2 :: (matrix_pod: *physx_PxMat33_Pod, bounds_pod: *physx_PxBounds3_Pod) -> physx_PxBounds3_Pod #foreign physx_lib;

PxBounds3_transformSafe_mut_3 :: (transform_pod: *physx_PxTransform_Pod, bounds_pod: *physx_PxBounds3_Pod) -> physx_PxBounds3_Pod #foreign physx_lib;

PxBounds3_transformFast_mut_3 :: (transform_pod: *physx_PxTransform_Pod, bounds_pod: *physx_PxBounds3_Pod) -> physx_PxBounds3_Pod #foreign physx_lib;

PxBounds3_isValid_1 :: (self__pod: *physx_PxBounds3_Pod) -> bool #foreign physx_lib;

PxErrorCallback_delete :: (self__pod: *physx_PxErrorCallback_Pod) -> void #foreign physx_lib;

PxErrorCallback_reportError_mut :: (self__pod: *physx_PxErrorCallback_Pod, code_pod: s32, message: *u8, file: *u8, line: s32) -> void #foreign physx_lib;

PxInputStream_read_mut :: (self__pod: *physx_PxInputStream_Pod, dest: *void, count: u32) -> u32 #foreign physx_lib;

PxInputStream_delete :: (self__pod: *physx_PxInputStream_Pod) -> void #foreign physx_lib;

PxInputData_getLength :: (self__pod: *physx_PxInputData_Pod) -> u32 #foreign physx_lib;

PxInputData_seek_mut :: (self__pod: *physx_PxInputData_Pod, offset: u32) -> void #foreign physx_lib;

PxInputData_tell :: (self__pod: *physx_PxInputData_Pod) -> u32 #foreign physx_lib;

PxInputData_delete :: (self__pod: *physx_PxInputData_Pod) -> void #foreign physx_lib;

PxOutputStream_write_mut :: (self__pod: *physx_PxOutputStream_Pod, src: *void, count: u32) -> u32 #foreign physx_lib;

PxOutputStream_delete :: (self__pod: *physx_PxOutputStream_Pod) -> void #foreign physx_lib;

PxVec4_new :: () -> physx_PxVec4_Pod #foreign physx_lib;

PxVec4_new_1 :: (r_pod: u32) -> physx_PxVec4_Pod #foreign physx_lib;

PxVec4_new_2 :: (a: float) -> physx_PxVec4_Pod #foreign physx_lib;

PxVec4_new_3 :: (nx: float, ny: float, nz: float, nw: float) -> physx_PxVec4_Pod #foreign physx_lib;

PxVec4_new_4 :: (v_pod: *physx_PxVec3_Pod, nw: float) -> physx_PxVec4_Pod #foreign physx_lib;

PxVec4_new_5 :: (v: *float) -> physx_PxVec4_Pod #foreign physx_lib;

PxVec4_isZero :: (self__pod: *physx_PxVec4_Pod) -> bool #foreign physx_lib;

PxVec4_isFinite :: (self__pod: *physx_PxVec4_Pod) -> bool #foreign physx_lib;

PxVec4_isNormalized :: (self__pod: *physx_PxVec4_Pod) -> bool #foreign physx_lib;

PxVec4_magnitudeSquared :: (self__pod: *physx_PxVec4_Pod) -> float #foreign physx_lib;

PxVec4_magnitude :: (self__pod: *physx_PxVec4_Pod) -> float #foreign physx_lib;

PxVec4_dot :: (self__pod: *physx_PxVec4_Pod, v_pod: *physx_PxVec4_Pod) -> float #foreign physx_lib;

PxVec4_getNormalized :: (self__pod: *physx_PxVec4_Pod) -> physx_PxVec4_Pod #foreign physx_lib;

PxVec4_normalize_mut :: (self__pod: *physx_PxVec4_Pod) -> float #foreign physx_lib;

PxVec4_multiply :: (self__pod: *physx_PxVec4_Pod, a_pod: *physx_PxVec4_Pod) -> physx_PxVec4_Pod #foreign physx_lib;

PxVec4_minimum :: (self__pod: *physx_PxVec4_Pod, v_pod: *physx_PxVec4_Pod) -> physx_PxVec4_Pod #foreign physx_lib;

PxVec4_maximum :: (self__pod: *physx_PxVec4_Pod, v_pod: *physx_PxVec4_Pod) -> physx_PxVec4_Pod #foreign physx_lib;

PxVec4_getXYZ :: (self__pod: *physx_PxVec4_Pod) -> physx_PxVec3_Pod #foreign physx_lib;

PxVec4_setZero_mut :: (self__pod: *physx_PxVec4_Pod) -> void #foreign physx_lib;

PxMat44_new :: () -> physx_PxMat44_Pod #foreign physx_lib;

PxMat44_new_1 :: (r_pod: u32) -> physx_PxMat44_Pod #foreign physx_lib;

PxMat44_new_2 :: (r_pod: u32) -> physx_PxMat44_Pod #foreign physx_lib;

PxMat44_new_3 :: (col0_pod: *physx_PxVec4_Pod, col1_pod: *physx_PxVec4_Pod, col2_pod: *physx_PxVec4_Pod, col3_pod: *physx_PxVec4_Pod) -> physx_PxMat44_Pod #foreign physx_lib;

PxMat44_new_4 :: (r: float) -> physx_PxMat44_Pod #foreign physx_lib;

PxMat44_new_5 :: (col0_pod: *physx_PxVec3_Pod, col1_pod: *physx_PxVec3_Pod, col2_pod: *physx_PxVec3_Pod, col3_pod: *physx_PxVec3_Pod) -> physx_PxMat44_Pod #foreign physx_lib;

PxMat44_new_6 :: (values: *float) -> physx_PxMat44_Pod #foreign physx_lib;

PxMat44_new_7 :: (q_pod: *physx_PxQuat_Pod) -> physx_PxMat44_Pod #foreign physx_lib;

PxMat44_new_8 :: (diagonal_pod: *physx_PxVec4_Pod) -> physx_PxMat44_Pod #foreign physx_lib;

PxMat44_new_9 :: (axes_pod: *physx_PxMat33_Pod, position_pod: *physx_PxVec3_Pod) -> physx_PxMat44_Pod #foreign physx_lib;

PxMat44_new_10 :: (t_pod: *physx_PxTransform_Pod) -> physx_PxMat44_Pod #foreign physx_lib;

PxMat44_getTranspose :: (self__pod: *physx_PxMat44_Pod) -> physx_PxMat44_Pod #foreign physx_lib;

PxMat44_transform :: (self__pod: *physx_PxMat44_Pod, other_pod: *physx_PxVec4_Pod) -> physx_PxVec4_Pod #foreign physx_lib;

PxMat44_transform_1 :: (self__pod: *physx_PxMat44_Pod, other_pod: *physx_PxVec3_Pod) -> physx_PxVec3_Pod #foreign physx_lib;

PxMat44_rotate :: (self__pod: *physx_PxMat44_Pod, other_pod: *physx_PxVec4_Pod) -> physx_PxVec4_Pod #foreign physx_lib;

PxMat44_rotate_1 :: (self__pod: *physx_PxMat44_Pod, other_pod: *physx_PxVec3_Pod) -> physx_PxVec3_Pod #foreign physx_lib;

PxMat44_getBasis :: (self__pod: *physx_PxMat44_Pod, num: s32) -> physx_PxVec3_Pod #foreign physx_lib;

PxMat44_getPosition :: (self__pod: *physx_PxMat44_Pod) -> physx_PxVec3_Pod #foreign physx_lib;

PxMat44_setPosition_mut :: (self__pod: *physx_PxMat44_Pod, position_pod: *physx_PxVec3_Pod) -> void #foreign physx_lib;

PxMat44_front :: (self__pod: *physx_PxMat44_Pod) -> *float #foreign physx_lib;

PxMat44_scale_mut :: (self__pod: *physx_PxMat44_Pod, p_pod: *physx_PxVec4_Pod) -> void #foreign physx_lib;

PxMat44_inverseRT :: (self__pod: *physx_PxMat44_Pod) -> physx_PxMat44_Pod #foreign physx_lib;

PxMat44_isFinite :: (self__pod: *physx_PxMat44_Pod) -> bool #foreign physx_lib;

PxTransform_new_7 :: (m_pod: *physx_PxMat44_Pod) -> physx_PxTransform_Pod #foreign physx_lib;

phys_PxShortestRotation :: (from_pod: *physx_PxVec3_Pod, target_pod: *physx_PxVec3_Pod) -> physx_PxQuat_Pod #foreign physx_lib;

phys_PxDiagonalize :: (m_pod: *physx_PxMat33_Pod, axes_pod: *physx_PxQuat_Pod) -> physx_PxVec3_Pod #foreign physx_lib;

PxVec2_new :: () -> physx_PxVec2_Pod #foreign physx_lib;

PxVec2_new_1 :: (r_pod: u32) -> physx_PxVec2_Pod #foreign physx_lib;

PxVec2_new_2 :: (a: float) -> physx_PxVec2_Pod #foreign physx_lib;

PxVec2_new_3 :: (nx: float, ny: float) -> physx_PxVec2_Pod #foreign physx_lib;

PxVec2_isZero :: (self__pod: *physx_PxVec2_Pod) -> bool #foreign physx_lib;

PxVec2_isFinite :: (self__pod: *physx_PxVec2_Pod) -> bool #foreign physx_lib;

PxVec2_isNormalized :: (self__pod: *physx_PxVec2_Pod) -> bool #foreign physx_lib;

PxVec2_magnitudeSquared :: (self__pod: *physx_PxVec2_Pod) -> float #foreign physx_lib;

PxVec2_magnitude :: (self__pod: *physx_PxVec2_Pod) -> float #foreign physx_lib;

PxVec2_dot :: (self__pod: *physx_PxVec2_Pod, v_pod: *physx_PxVec2_Pod) -> float #foreign physx_lib;

PxVec2_getNormalized :: (self__pod: *physx_PxVec2_Pod) -> physx_PxVec2_Pod #foreign physx_lib;

PxVec2_normalize_mut :: (self__pod: *physx_PxVec2_Pod) -> float #foreign physx_lib;

PxVec2_multiply :: (self__pod: *physx_PxVec2_Pod, a_pod: *physx_PxVec2_Pod) -> physx_PxVec2_Pod #foreign physx_lib;

PxVec2_minimum :: (self__pod: *physx_PxVec2_Pod, v_pod: *physx_PxVec2_Pod) -> physx_PxVec2_Pod #foreign physx_lib;

PxVec2_minElement :: (self__pod: *physx_PxVec2_Pod) -> float #foreign physx_lib;

PxVec2_maximum :: (self__pod: *physx_PxVec2_Pod, v_pod: *physx_PxVec2_Pod) -> physx_PxVec2_Pod #foreign physx_lib;

PxVec2_maxElement :: (self__pod: *physx_PxVec2_Pod) -> float #foreign physx_lib;

phys_PxMemZero :: (dest: *void, count: u32) -> *void #foreign physx_lib;

phys_PxMemSet :: (dest: *void, c: s32, count: u32) -> *void #foreign physx_lib;

phys_PxMemCopy :: (dest: *void, src: *void, count: u32) -> *void #foreign physx_lib;

phys_PxMemMove :: (dest: *void, src: *void, count: u32) -> *void #foreign physx_lib;

PxStridedData_new :: () -> physx_PxStridedData_Pod #foreign physx_lib;

PxBoundedData_new :: () -> physx_PxBoundedData_Pod #foreign physx_lib;

PxDebugPoint_new :: (p_pod: *physx_PxVec3_Pod, c_pod: *u32) -> physx_PxDebugPoint_Pod #foreign physx_lib;

PxDebugLine_new :: (p0_pod: *physx_PxVec3_Pod, p1_pod: *physx_PxVec3_Pod, c_pod: *u32) -> physx_PxDebugLine_Pod #foreign physx_lib;

PxDebugTriangle_new :: (p0_pod: *physx_PxVec3_Pod, p1_pod: *physx_PxVec3_Pod, p2_pod: *physx_PxVec3_Pod, c_pod: *u32) -> physx_PxDebugTriangle_Pod #foreign physx_lib;

PxDebugText_new :: () -> physx_PxDebugText_Pod #foreign physx_lib;

PxDebugText_new_1 :: (p_pod: *physx_PxVec3_Pod, s_pod: *float, c_pod: *u32, str: *u8) -> physx_PxDebugText_Pod #foreign physx_lib;

PxRenderBuffer_delete :: (self__pod: *physx_PxRenderBuffer_Pod) -> void #foreign physx_lib;

PxRenderBuffer_getNbPoints :: (self__pod: *physx_PxRenderBuffer_Pod) -> u32 #foreign physx_lib;

PxRenderBuffer_getPoints :: (self__pod: *physx_PxRenderBuffer_Pod) -> *physx_PxDebugPoint_Pod #foreign physx_lib;

PxRenderBuffer_getNbLines :: (self__pod: *physx_PxRenderBuffer_Pod) -> u32 #foreign physx_lib;

PxRenderBuffer_getLines :: (self__pod: *physx_PxRenderBuffer_Pod) -> *physx_PxDebugLine_Pod #foreign physx_lib;

PxRenderBuffer_getNbTriangles :: (self__pod: *physx_PxRenderBuffer_Pod) -> u32 #foreign physx_lib;

PxRenderBuffer_getTriangles :: (self__pod: *physx_PxRenderBuffer_Pod) -> *physx_PxDebugTriangle_Pod #foreign physx_lib;

PxRenderBuffer_getNbTexts :: (self__pod: *physx_PxRenderBuffer_Pod) -> u32 #foreign physx_lib;

PxRenderBuffer_getTexts :: (self__pod: *physx_PxRenderBuffer_Pod) -> *physx_PxDebugText_Pod #foreign physx_lib;

PxRenderBuffer_append_mut :: (self__pod: *physx_PxRenderBuffer_Pod, other_pod: *physx_PxRenderBuffer_Pod) -> void #foreign physx_lib;

PxRenderBuffer_clear_mut :: (self__pod: *physx_PxRenderBuffer_Pod) -> void #foreign physx_lib;

PxProcessPxBaseCallback_delete :: (self__pod: *physx_PxProcessPxBaseCallback_Pod) -> void #foreign physx_lib;

PxProcessPxBaseCallback_process_mut :: (self__pod: *physx_PxProcessPxBaseCallback_Pod, anonymous_arg0_pod: *physx_PxBase_Pod) -> void #foreign physx_lib;

PxSerializationContext_registerReference_mut :: (self__pod: *physx_PxSerializationContext_Pod, base_pod: *physx_PxBase_Pod, kind: u32, reference: u64) -> void #foreign physx_lib;

PxSerializationContext_getCollection :: (self__pod: *physx_PxSerializationContext_Pod) -> *physx_PxCollection_Pod #foreign physx_lib;

PxSerializationContext_writeData_mut :: (self__pod: *physx_PxSerializationContext_Pod, data: *void, size: u32) -> void #foreign physx_lib;

PxSerializationContext_alignData_mut :: (self__pod: *physx_PxSerializationContext_Pod, alignment: u32) -> void #foreign physx_lib;

PxSerializationContext_writeName_mut :: (self__pod: *physx_PxSerializationContext_Pod, name: *u8) -> void #foreign physx_lib;

PxDeserializationContext_resolveReference :: (self__pod: *physx_PxDeserializationContext_Pod, kind: u32, reference: u64) -> *physx_PxBase_Pod #foreign physx_lib;

PxDeserializationContext_readName_mut :: (self__pod: *physx_PxDeserializationContext_Pod, name_pod: **u8) -> void #foreign physx_lib;

PxDeserializationContext_alignExtraData_mut :: (self__pod: *physx_PxDeserializationContext_Pod, alignment: u32) -> void #foreign physx_lib;

PxSerializationRegistry_registerSerializer_mut :: (self__pod: *physx_PxSerializationRegistry_Pod, type: u16, serializer_pod: *physx_PxSerializer_Pod) -> void #foreign physx_lib;

PxSerializationRegistry_unregisterSerializer_mut :: (self__pod: *physx_PxSerializationRegistry_Pod, type: u16) -> *physx_PxSerializer_Pod #foreign physx_lib;

PxSerializationRegistry_registerBinaryMetaDataCallback_mut :: (self__pod: *physx_PxSerializationRegistry_Pod, callback_pod: *void) -> void #foreign physx_lib;

PxSerializationRegistry_getSerializer :: (self__pod: *physx_PxSerializationRegistry_Pod, type: u16) -> *physx_PxSerializer_Pod #foreign physx_lib;

PxSerializationRegistry_registerRepXSerializer_mut :: (self__pod: *physx_PxSerializationRegistry_Pod, type: u16, serializer_pod: *physx_PxRepXSerializer_Pod) -> void #foreign physx_lib;

PxSerializationRegistry_unregisterRepXSerializer_mut :: (self__pod: *physx_PxSerializationRegistry_Pod, type: u16) -> *physx_PxRepXSerializer_Pod #foreign physx_lib;

PxSerializationRegistry_getRepXSerializer :: (self__pod: *physx_PxSerializationRegistry_Pod, typeName: *u8) -> *physx_PxRepXSerializer_Pod #foreign physx_lib;

PxSerializationRegistry_release_mut :: (self__pod: *physx_PxSerializationRegistry_Pod) -> void #foreign physx_lib;

PxCollection_add_mut :: (self__pod: *physx_PxCollection_Pod, object_pod: *physx_PxBase_Pod, id: u64) -> void #foreign physx_lib;

PxCollection_remove_mut :: (self__pod: *physx_PxCollection_Pod, object_pod: *physx_PxBase_Pod) -> void #foreign physx_lib;

PxCollection_contains :: (self__pod: *physx_PxCollection_Pod, object_pod: *physx_PxBase_Pod) -> bool #foreign physx_lib;

PxCollection_addId_mut :: (self__pod: *physx_PxCollection_Pod, object_pod: *physx_PxBase_Pod, id: u64) -> void #foreign physx_lib;

PxCollection_removeId_mut :: (self__pod: *physx_PxCollection_Pod, id: u64) -> void #foreign physx_lib;

PxCollection_add_mut_1 :: (self__pod: *physx_PxCollection_Pod, collection_pod: *physx_PxCollection_Pod) -> void #foreign physx_lib;

PxCollection_remove_mut_1 :: (self__pod: *physx_PxCollection_Pod, collection_pod: *physx_PxCollection_Pod) -> void #foreign physx_lib;

PxCollection_getNbObjects :: (self__pod: *physx_PxCollection_Pod) -> u32 #foreign physx_lib;

PxCollection_getObject :: (self__pod: *physx_PxCollection_Pod, index: u32) -> *physx_PxBase_Pod #foreign physx_lib;

PxCollection_getObjects :: (self__pod: *physx_PxCollection_Pod, userBuffer_pod: **physx_PxBase_Pod, bufferSize: u32, startIndex: u32) -> u32 #foreign physx_lib;

PxCollection_find :: (self__pod: *physx_PxCollection_Pod, id: u64) -> *physx_PxBase_Pod #foreign physx_lib;

PxCollection_getNbIds :: (self__pod: *physx_PxCollection_Pod) -> u32 #foreign physx_lib;

PxCollection_getIds :: (self__pod: *physx_PxCollection_Pod, userBuffer: *u64, bufferSize: u32, startIndex: u32) -> u32 #foreign physx_lib;

PxCollection_getId :: (self__pod: *physx_PxCollection_Pod, object_pod: *physx_PxBase_Pod) -> u64 #foreign physx_lib;

PxCollection_release_mut :: (self__pod: *physx_PxCollection_Pod) -> void #foreign physx_lib;

phys_PxCreateCollection :: () -> *physx_PxCollection_Pod #foreign physx_lib;

PxBase_release_mut :: (self__pod: *physx_PxBase_Pod) -> void #foreign physx_lib;

PxBase_getConcreteTypeName :: (self__pod: *physx_PxBase_Pod) -> *u8 #foreign physx_lib;

PxBase_getConcreteType :: (self__pod: *physx_PxBase_Pod) -> u16 #foreign physx_lib;

PxBase_setBaseFlag_mut :: (self__pod: *physx_PxBase_Pod, flag_pod: u32, value: bool) -> void #foreign physx_lib;

PxBase_setBaseFlags_mut :: (self__pod: *physx_PxBase_Pod, inFlags_pod: physx_PxBaseFlags_Pod) -> void #foreign physx_lib;

PxBase_getBaseFlags :: (self__pod: *physx_PxBase_Pod) -> physx_PxBaseFlags_Pod #foreign physx_lib;

PxBase_isReleasable :: (self__pod: *physx_PxBase_Pod) -> bool #foreign physx_lib;

PxTolerancesScale_new :: () -> physx_PxTolerancesScale_Pod #foreign physx_lib;

PxTolerancesScale_isValid :: (self__pod: *physx_PxTolerancesScale_Pod) -> bool #foreign physx_lib;

PxTolerancesScale_new_1 :: () -> physx_PxTolerancesScale_Pod #foreign physx_lib;

PxTolerancesScale_isValid_1 :: (self__pod: *physx_PxTolerancesScale_Pod) -> bool #foreign physx_lib;

PxStringTable_allocateStr_mut :: (self__pod: *physx_PxStringTable_Pod, inSrc: *u8) -> *u8 #foreign physx_lib;

PxStringTable_release_mut :: (self__pod: *physx_PxStringTable_Pod) -> void #foreign physx_lib;

PxFoundation_release_mut :: (self__pod: *physx_PxFoundation_Pod) -> void #foreign physx_lib;

PxFoundation_getErrorCallback_mut :: (self__pod: *physx_PxFoundation_Pod) -> *physx_PxErrorCallback_Pod #foreign physx_lib;

PxFoundation_setErrorLevel_mut :: (self__pod: *physx_PxFoundation_Pod, mask_pod: s32) -> void #foreign physx_lib;

PxFoundation_getErrorLevel :: (self__pod: *physx_PxFoundation_Pod) -> s32 #foreign physx_lib;

PxFoundation_getAllocatorCallback_mut :: (self__pod: *physx_PxFoundation_Pod) -> *physx_PxAllocatorCallback_Pod #foreign physx_lib;

PxFoundation_getReportAllocationNames :: (self__pod: *physx_PxFoundation_Pod) -> bool #foreign physx_lib;

PxFoundation_setReportAllocationNames_mut :: (self__pod: *physx_PxFoundation_Pod, value: bool) -> void #foreign physx_lib;

phys_PxCreateFoundation :: (version: u32, allocator_pod: *physx_PxAllocatorCallback_Pod, errorCallback_pod: *physx_PxErrorCallback_Pod) -> *physx_PxFoundation_Pod #foreign physx_lib;

phys_PxGetFoundation :: () -> *physx_PxFoundation_Pod #foreign physx_lib;

phys_PxGetProfilerCallback :: () -> *physx_PxProfilerCallback_Pod #foreign physx_lib;

phys_PxSetProfilerCallback :: (profiler_pod: *physx_PxProfilerCallback_Pod) -> void #foreign physx_lib;

PxSerializer_getConcreteTypeName :: (self__pod: *physx_PxSerializer_Pod) -> *u8 #foreign physx_lib;

PxSerializer_requiresObjects :: (self__pod: *physx_PxSerializer_Pod, anonymous_arg0_pod: *physx_PxBase_Pod, anonymous_arg1_pod: *physx_PxProcessPxBaseCallback_Pod) -> void #foreign physx_lib;

PxSerializer_isSubordinate :: (self__pod: *physx_PxSerializer_Pod) -> bool #foreign physx_lib;

PxSerializer_exportExtraData :: (self__pod: *physx_PxSerializer_Pod, anonymous_arg0_pod: *physx_PxBase_Pod, anonymous_arg1_pod: *physx_PxSerializationContext_Pod) -> void #foreign physx_lib;

PxSerializer_exportData :: (self__pod: *physx_PxSerializer_Pod, anonymous_arg0_pod: *physx_PxBase_Pod, anonymous_arg1_pod: *physx_PxSerializationContext_Pod) -> void #foreign physx_lib;

PxSerializer_registerReferences :: (self__pod: *physx_PxSerializer_Pod, obj_pod: *physx_PxBase_Pod, s_pod: *physx_PxSerializationContext_Pod) -> void #foreign physx_lib;

PxSerializer_getClassSize :: (self__pod: *physx_PxSerializer_Pod) -> u64 #foreign physx_lib;

PxSerializer_createObject :: (self__pod: *physx_PxSerializer_Pod, address_pod: **u8, context_pod: *physx_PxDeserializationContext_Pod) -> *physx_PxBase_Pod #foreign physx_lib;

PxSerializer_delete :: (self__pod: *physx_PxSerializer_Pod) -> void #foreign physx_lib;

PxPhysicsInsertionCallback_buildObjectFromData_mut :: (self__pod: *physx_PxPhysicsInsertionCallback_Pod, type_pod: u32, data: *void) -> *physx_PxBase_Pod #foreign physx_lib;

PxTaskManager_setCpuDispatcher_mut :: (self__pod: *physx_PxTaskManager_Pod, ref_pod: *physx_PxCpuDispatcher_Pod) -> void #foreign physx_lib;

PxTaskManager_getCpuDispatcher :: (self__pod: *physx_PxTaskManager_Pod) -> *physx_PxCpuDispatcher_Pod #foreign physx_lib;

PxTaskManager_resetDependencies_mut :: (self__pod: *physx_PxTaskManager_Pod) -> void #foreign physx_lib;

PxTaskManager_startSimulation_mut :: (self__pod: *physx_PxTaskManager_Pod) -> void #foreign physx_lib;

PxTaskManager_stopSimulation_mut :: (self__pod: *physx_PxTaskManager_Pod) -> void #foreign physx_lib;

PxTaskManager_taskCompleted_mut :: (self__pod: *physx_PxTaskManager_Pod, task_pod: *physx_PxTask_Pod) -> void #foreign physx_lib;

PxTaskManager_getNamedTask_mut :: (self__pod: *physx_PxTaskManager_Pod, name: *u8) -> u32 #foreign physx_lib;

PxTaskManager_submitNamedTask_mut :: (self__pod: *physx_PxTaskManager_Pod, task_pod: *physx_PxTask_Pod, name: *u8, type_pod: u32) -> u32 #foreign physx_lib;

PxTaskManager_submitUnnamedTask_mut :: (self__pod: *physx_PxTaskManager_Pod, task_pod: *physx_PxTask_Pod, type_pod: u32) -> u32 #foreign physx_lib;

PxTaskManager_getTaskFromID_mut :: (self__pod: *physx_PxTaskManager_Pod, id: u32) -> *physx_PxTask_Pod #foreign physx_lib;

PxTaskManager_release_mut :: (self__pod: *physx_PxTaskManager_Pod) -> void #foreign physx_lib;

PxTaskManager_createTaskManager_mut :: (errorCallback_pod: *physx_PxErrorCallback_Pod, anonymous_arg1_pod: *physx_PxCpuDispatcher_Pod) -> *physx_PxTaskManager_Pod #foreign physx_lib;

PxCpuDispatcher_submitTask_mut :: (self__pod: *physx_PxCpuDispatcher_Pod, task_pod: *physx_PxBaseTask_Pod) -> void #foreign physx_lib;

PxCpuDispatcher_getWorkerCount :: (self__pod: *physx_PxCpuDispatcher_Pod) -> u32 #foreign physx_lib;

PxCpuDispatcher_delete :: (self__pod: *physx_PxCpuDispatcher_Pod) -> void #foreign physx_lib;

PxBaseTask_run_mut :: (self__pod: *physx_PxBaseTask_Pod) -> void #foreign physx_lib;

PxBaseTask_getName :: (self__pod: *physx_PxBaseTask_Pod) -> *u8 #foreign physx_lib;

PxBaseTask_addReference_mut :: (self__pod: *physx_PxBaseTask_Pod) -> void #foreign physx_lib;

PxBaseTask_removeReference_mut :: (self__pod: *physx_PxBaseTask_Pod) -> void #foreign physx_lib;

PxBaseTask_getReference :: (self__pod: *physx_PxBaseTask_Pod) -> s32 #foreign physx_lib;

PxBaseTask_release_mut :: (self__pod: *physx_PxBaseTask_Pod) -> void #foreign physx_lib;

PxBaseTask_getTaskManager :: (self__pod: *physx_PxBaseTask_Pod) -> *physx_PxTaskManager_Pod #foreign physx_lib;

PxBaseTask_setContextId_mut :: (self__pod: *physx_PxBaseTask_Pod, id: u64) -> void #foreign physx_lib;

PxBaseTask_getContextId :: (self__pod: *physx_PxBaseTask_Pod) -> u64 #foreign physx_lib;

PxTask_release_mut :: (self__pod: *physx_PxTask_Pod) -> void #foreign physx_lib;

PxTask_finishBefore_mut :: (self__pod: *physx_PxTask_Pod, taskID: u32) -> void #foreign physx_lib;

PxTask_startAfter_mut :: (self__pod: *physx_PxTask_Pod, taskID: u32) -> void #foreign physx_lib;

PxTask_addReference_mut :: (self__pod: *physx_PxTask_Pod) -> void #foreign physx_lib;

PxTask_removeReference_mut :: (self__pod: *physx_PxTask_Pod) -> void #foreign physx_lib;

PxTask_getReference :: (self__pod: *physx_PxTask_Pod) -> s32 #foreign physx_lib;

PxTask_getTaskID :: (self__pod: *physx_PxTask_Pod) -> u32 #foreign physx_lib;

PxTask_submitted_mut :: (self__pod: *physx_PxTask_Pod) -> void #foreign physx_lib;

PxLightCpuTask_setContinuation_mut :: (self__pod: *physx_PxLightCpuTask_Pod, tm_pod: *physx_PxTaskManager_Pod, c_pod: *physx_PxBaseTask_Pod) -> void #foreign physx_lib;

PxLightCpuTask_setContinuation_mut_1 :: (self__pod: *physx_PxLightCpuTask_Pod, c_pod: *physx_PxBaseTask_Pod) -> void #foreign physx_lib;

PxLightCpuTask_getContinuation :: (self__pod: *physx_PxLightCpuTask_Pod) -> *physx_PxBaseTask_Pod #foreign physx_lib;

PxLightCpuTask_removeReference_mut :: (self__pod: *physx_PxLightCpuTask_Pod) -> void #foreign physx_lib;

PxLightCpuTask_getReference :: (self__pod: *physx_PxLightCpuTask_Pod) -> s32 #foreign physx_lib;

PxLightCpuTask_addReference_mut :: (self__pod: *physx_PxLightCpuTask_Pod) -> void #foreign physx_lib;

PxLightCpuTask_release_mut :: (self__pod: *physx_PxLightCpuTask_Pod) -> void #foreign physx_lib;

PxGeometry_getType :: (self__pod: *physx_PxGeometry_Pod) -> s32 #foreign physx_lib;

PxBoxGeometry_new :: () -> physx_PxBoxGeometry_Pod #foreign physx_lib;

PxBoxGeometry_new_1 :: (hx: float, hy: float, hz: float) -> physx_PxBoxGeometry_Pod #foreign physx_lib;

PxBoxGeometry_new_2 :: (halfExtents__pod: physx_PxVec3_Pod) -> physx_PxBoxGeometry_Pod #foreign physx_lib;

PxBoxGeometry_isValid :: (self__pod: *physx_PxBoxGeometry_Pod) -> bool #foreign physx_lib;

PxBoxGeometry_isValid_1 :: (self__pod: *physx_PxBoxGeometry_Pod) -> bool #foreign physx_lib;

PxBVHStructure_raycast :: (self__pod: *physx_PxBVHStructure_Pod, origin_pod: *physx_PxVec3_Pod, unitDir_pod: *physx_PxVec3_Pod, maxDist: float, maxHits: u32, rayHits: *u32) -> u32 #foreign physx_lib;

PxBVHStructure_sweep :: (self__pod: *physx_PxBVHStructure_Pod, aabb_pod: *physx_PxBounds3_Pod, unitDir_pod: *physx_PxVec3_Pod, maxDist: float, maxHits: u32, sweepHits: *u32) -> u32 #foreign physx_lib;

PxBVHStructure_overlap :: (self__pod: *physx_PxBVHStructure_Pod, aabb_pod: *physx_PxBounds3_Pod, maxHits: u32, overlapHits: *u32) -> u32 #foreign physx_lib;

PxBVHStructure_getBounds :: (self__pod: *physx_PxBVHStructure_Pod) -> *physx_PxBounds3_Pod #foreign physx_lib;

PxBVHStructure_getNbBounds :: (self__pod: *physx_PxBVHStructure_Pod) -> u32 #foreign physx_lib;

PxBVHStructure_getConcreteTypeName :: (self__pod: *physx_PxBVHStructure_Pod) -> *u8 #foreign physx_lib;

PxCapsuleGeometry_new :: () -> physx_PxCapsuleGeometry_Pod #foreign physx_lib;

PxCapsuleGeometry_new_1 :: (radius_: float, halfHeight_: float) -> physx_PxCapsuleGeometry_Pod #foreign physx_lib;

PxCapsuleGeometry_isValid :: (self__pod: *physx_PxCapsuleGeometry_Pod) -> bool #foreign physx_lib;

PxCapsuleGeometry_isValid_1 :: (self__pod: *physx_PxCapsuleGeometry_Pod) -> bool #foreign physx_lib;

phys_PxTransformFromSegment :: (p0_pod: *physx_PxVec3_Pod, p1_pod: *physx_PxVec3_Pod, halfHeight: *float) -> physx_PxTransform_Pod #foreign physx_lib;

PxConvexMesh_getNbVertices :: (self__pod: *physx_PxConvexMesh_Pod) -> u32 #foreign physx_lib;

PxConvexMesh_getVertices :: (self__pod: *physx_PxConvexMesh_Pod) -> *physx_PxVec3_Pod #foreign physx_lib;

PxConvexMesh_getIndexBuffer :: (self__pod: *physx_PxConvexMesh_Pod) -> *u8 #foreign physx_lib;

PxConvexMesh_getNbPolygons :: (self__pod: *physx_PxConvexMesh_Pod) -> u32 #foreign physx_lib;

PxConvexMesh_getPolygonData :: (self__pod: *physx_PxConvexMesh_Pod, index: u32, data_pod: *physx_PxHullPolygon_Pod) -> bool #foreign physx_lib;

PxConvexMesh_release_mut :: (self__pod: *physx_PxConvexMesh_Pod) -> void #foreign physx_lib;

PxConvexMesh_getReferenceCount :: (self__pod: *physx_PxConvexMesh_Pod) -> u32 #foreign physx_lib;

PxConvexMesh_acquireReference_mut :: (self__pod: *physx_PxConvexMesh_Pod) -> void #foreign physx_lib;

PxConvexMesh_getMassInformation :: (self__pod: *physx_PxConvexMesh_Pod, mass_pod: *float, localInertia_pod: *physx_PxMat33_Pod, localCenterOfMass_pod: *physx_PxVec3_Pod) -> void #foreign physx_lib;

PxConvexMesh_getLocalBounds :: (self__pod: *physx_PxConvexMesh_Pod) -> physx_PxBounds3_Pod #foreign physx_lib;

PxConvexMesh_getConcreteTypeName :: (self__pod: *physx_PxConvexMesh_Pod) -> *u8 #foreign physx_lib;

PxConvexMesh_isGpuCompatible :: (self__pod: *physx_PxConvexMesh_Pod) -> bool #foreign physx_lib;

PxMeshScale_new :: () -> physx_PxMeshScale_Pod #foreign physx_lib;

PxMeshScale_new_1 :: (r: float) -> physx_PxMeshScale_Pod #foreign physx_lib;

PxMeshScale_new_2 :: (s_pod: *physx_PxVec3_Pod) -> physx_PxMeshScale_Pod #foreign physx_lib;

PxMeshScale_new_3 :: (s_pod: *physx_PxVec3_Pod, r_pod: *physx_PxQuat_Pod) -> physx_PxMeshScale_Pod #foreign physx_lib;

PxMeshScale_isIdentity :: (self__pod: *physx_PxMeshScale_Pod) -> bool #foreign physx_lib;

PxMeshScale_getInverse :: (self__pod: *physx_PxMeshScale_Pod) -> physx_PxMeshScale_Pod #foreign physx_lib;

PxMeshScale_toMat33 :: (self__pod: *physx_PxMeshScale_Pod) -> physx_PxMat33_Pod #foreign physx_lib;

PxMeshScale_hasNegativeDeterminant :: (self__pod: *physx_PxMeshScale_Pod) -> bool #foreign physx_lib;

PxMeshScale_transform :: (self__pod: *physx_PxMeshScale_Pod, v_pod: *physx_PxVec3_Pod) -> physx_PxVec3_Pod #foreign physx_lib;

PxMeshScale_isValidForTriangleMesh :: (self__pod: *physx_PxMeshScale_Pod) -> bool #foreign physx_lib;

PxMeshScale_isValidForConvexMesh :: (self__pod: *physx_PxMeshScale_Pod) -> bool #foreign physx_lib;

PxConvexMeshGeometry_new :: () -> physx_PxConvexMeshGeometry_Pod #foreign physx_lib;

PxConvexMeshGeometry_new_1 :: (mesh_pod: *physx_PxConvexMesh_Pod, scaling_pod: *physx_PxMeshScale_Pod, flags_pod: physx_PxConvexMeshGeometryFlags_Pod) -> physx_PxConvexMeshGeometry_Pod #foreign physx_lib;

PxConvexMeshGeometry_isValid :: (self__pod: *physx_PxConvexMeshGeometry_Pod) -> bool #foreign physx_lib;

PxConvexMeshGeometry_isValid_1 :: (self__pod: *physx_PxConvexMeshGeometry_Pod) -> bool #foreign physx_lib;

PxSphereGeometry_new :: () -> physx_PxSphereGeometry_Pod #foreign physx_lib;

PxSphereGeometry_new_1 :: (ir: float) -> physx_PxSphereGeometry_Pod #foreign physx_lib;

PxSphereGeometry_isValid :: (self__pod: *physx_PxSphereGeometry_Pod) -> bool #foreign physx_lib;

PxSphereGeometry_isValid_1 :: (self__pod: *physx_PxSphereGeometry_Pod) -> bool #foreign physx_lib;

PxPlaneGeometry_new :: () -> physx_PxPlaneGeometry_Pod #foreign physx_lib;

PxPlaneGeometry_isValid :: (self__pod: *physx_PxPlaneGeometry_Pod) -> bool #foreign physx_lib;

PxPlaneGeometry_isValid_1 :: (self__pod: *physx_PxPlaneGeometry_Pod) -> bool #foreign physx_lib;

phys_PxTransformFromPlaneEquation :: (plane_pod: *physx_PxPlane_Pod) -> physx_PxTransform_Pod #foreign physx_lib;

phys_PxPlaneEquationFromTransform :: (transform_pod: *physx_PxTransform_Pod) -> physx_PxPlane_Pod #foreign physx_lib;

PxTriangleMeshGeometry_new :: () -> physx_PxTriangleMeshGeometry_Pod #foreign physx_lib;

PxTriangleMeshGeometry_new_1 :: (mesh_pod: *physx_PxTriangleMesh_Pod, scaling_pod: *physx_PxMeshScale_Pod, flags_pod: physx_PxMeshGeometryFlags_Pod) -> physx_PxTriangleMeshGeometry_Pod #foreign physx_lib;

PxTriangleMeshGeometry_isValid :: (self__pod: *physx_PxTriangleMeshGeometry_Pod) -> bool #foreign physx_lib;

PxTriangleMeshGeometry_isValid_1 :: (self__pod: *physx_PxTriangleMeshGeometry_Pod) -> bool #foreign physx_lib;

PxHeightFieldGeometry_new :: () -> physx_PxHeightFieldGeometry_Pod #foreign physx_lib;

PxHeightFieldGeometry_new_1 :: (hf_pod: *physx_PxHeightField_Pod, flags_pod: physx_PxMeshGeometryFlags_Pod, heightScale_: float, rowScale_: float, columnScale_: float) -> physx_PxHeightFieldGeometry_Pod #foreign physx_lib;

PxHeightFieldGeometry_isValid :: (self__pod: *physx_PxHeightFieldGeometry_Pod) -> bool #foreign physx_lib;

PxHeightFieldGeometry_isValid_1 :: (self__pod: *physx_PxHeightFieldGeometry_Pod) -> bool #foreign physx_lib;

PxGeometryHolder_getType :: (self__pod: *physx_PxGeometryHolder_Pod) -> s32 #foreign physx_lib;

PxGeometryHolder_any_mut :: (self__pod: *physx_PxGeometryHolder_Pod) -> *physx_PxGeometry_Pod #foreign physx_lib;

PxGeometryHolder_any :: (self__pod: *physx_PxGeometryHolder_Pod) -> *physx_PxGeometry_Pod #foreign physx_lib;

PxGeometryHolder_sphere_mut :: (self__pod: *physx_PxGeometryHolder_Pod) -> *physx_PxSphereGeometry_Pod #foreign physx_lib;

PxGeometryHolder_sphere :: (self__pod: *physx_PxGeometryHolder_Pod) -> *physx_PxSphereGeometry_Pod #foreign physx_lib;

PxGeometryHolder_plane_mut :: (self__pod: *physx_PxGeometryHolder_Pod) -> *physx_PxPlaneGeometry_Pod #foreign physx_lib;

PxGeometryHolder_plane :: (self__pod: *physx_PxGeometryHolder_Pod) -> *physx_PxPlaneGeometry_Pod #foreign physx_lib;

PxGeometryHolder_capsule_mut :: (self__pod: *physx_PxGeometryHolder_Pod) -> *physx_PxCapsuleGeometry_Pod #foreign physx_lib;

PxGeometryHolder_capsule :: (self__pod: *physx_PxGeometryHolder_Pod) -> *physx_PxCapsuleGeometry_Pod #foreign physx_lib;

PxGeometryHolder_box_mut :: (self__pod: *physx_PxGeometryHolder_Pod) -> *physx_PxBoxGeometry_Pod #foreign physx_lib;

PxGeometryHolder_box :: (self__pod: *physx_PxGeometryHolder_Pod) -> *physx_PxBoxGeometry_Pod #foreign physx_lib;

PxGeometryHolder_convexMesh_mut :: (self__pod: *physx_PxGeometryHolder_Pod) -> *physx_PxConvexMeshGeometry_Pod #foreign physx_lib;

PxGeometryHolder_convexMesh :: (self__pod: *physx_PxGeometryHolder_Pod) -> *physx_PxConvexMeshGeometry_Pod #foreign physx_lib;

PxGeometryHolder_triangleMesh_mut :: (self__pod: *physx_PxGeometryHolder_Pod) -> *physx_PxTriangleMeshGeometry_Pod #foreign physx_lib;

PxGeometryHolder_triangleMesh :: (self__pod: *physx_PxGeometryHolder_Pod) -> *physx_PxTriangleMeshGeometry_Pod #foreign physx_lib;

PxGeometryHolder_heightField_mut :: (self__pod: *physx_PxGeometryHolder_Pod) -> *physx_PxHeightFieldGeometry_Pod #foreign physx_lib;

PxGeometryHolder_heightField :: (self__pod: *physx_PxGeometryHolder_Pod) -> *physx_PxHeightFieldGeometry_Pod #foreign physx_lib;

PxGeometryHolder_storeAny_mut :: (self__pod: *physx_PxGeometryHolder_Pod, geometry_pod: *physx_PxGeometry_Pod) -> void #foreign physx_lib;

PxGeometryHolder_new :: () -> physx_PxGeometryHolder_Pod #foreign physx_lib;

PxGeometryHolder_new_1 :: (geometry_pod: *physx_PxGeometry_Pod) -> physx_PxGeometryHolder_Pod #foreign physx_lib;

PxActorShape_new :: () -> physx_PxActorShape_Pod #foreign physx_lib;

PxActorShape_new_1 :: (a_pod: *physx_PxRigidActor_Pod, s_pod: *physx_PxShape_Pod) -> physx_PxActorShape_Pod #foreign physx_lib;

PxQueryHit_new :: () -> physx_PxQueryHit_Pod #foreign physx_lib;

PxLocationHit_new :: () -> physx_PxLocationHit_Pod #foreign physx_lib;

PxLocationHit_hadInitialOverlap :: (self__pod: *physx_PxLocationHit_Pod) -> bool #foreign physx_lib;

PxRaycastHit_new :: () -> physx_PxRaycastHit_Pod #foreign physx_lib;

PxSweepHit_new :: () -> physx_PxSweepHit_Pod #foreign physx_lib;

PxGeometryQuery_sweep_mut :: (unitDir_pod: *physx_PxVec3_Pod, maxDist: float, geom0_pod: *physx_PxGeometry_Pod, pose0_pod: *physx_PxTransform_Pod, geom1_pod: *physx_PxGeometry_Pod, pose1_pod: *physx_PxTransform_Pod, sweepHit_pod: *physx_PxSweepHit_Pod, hitFlags_pod: physx_PxHitFlags_Pod, inflation: float) -> bool #foreign physx_lib;

PxGeometryQuery_overlap_mut :: (geom0_pod: *physx_PxGeometry_Pod, pose0_pod: *physx_PxTransform_Pod, geom1_pod: *physx_PxGeometry_Pod, pose1_pod: *physx_PxTransform_Pod) -> bool #foreign physx_lib;

PxGeometryQuery_raycast_mut :: (origin_pod: *physx_PxVec3_Pod, unitDir_pod: *physx_PxVec3_Pod, geom_pod: *physx_PxGeometry_Pod, pose_pod: *physx_PxTransform_Pod, maxDist: float, hitFlags_pod: physx_PxHitFlags_Pod, maxHits: u32, rayHits_pod: *physx_PxRaycastHit_Pod) -> u32 #foreign physx_lib;

PxGeometryQuery_computePenetration_mut :: (direction_pod: *physx_PxVec3_Pod, depth_pod: *float, geom0_pod: *physx_PxGeometry_Pod, pose0_pod: *physx_PxTransform_Pod, geom1_pod: *physx_PxGeometry_Pod, pose1_pod: *physx_PxTransform_Pod) -> bool #foreign physx_lib;

PxGeometryQuery_pointDistance_mut :: (point_pod: *physx_PxVec3_Pod, geom_pod: *physx_PxGeometry_Pod, pose_pod: *physx_PxTransform_Pod, closestPoint_pod: *physx_PxVec3_Pod) -> float #foreign physx_lib;

PxGeometryQuery_getWorldBounds_mut :: (geom_pod: *physx_PxGeometry_Pod, pose_pod: *physx_PxTransform_Pod, inflation: float) -> physx_PxBounds3_Pod #foreign physx_lib;

PxGeometryQuery_isValid_mut :: (geom_pod: *physx_PxGeometry_Pod) -> bool #foreign physx_lib;

PxHeightFieldSample_tessFlag :: (self__pod: *physx_PxHeightFieldSample_Pod) -> u8 #foreign physx_lib;

PxHeightFieldSample_setTessFlag_mut :: (self__pod: *physx_PxHeightFieldSample_Pod) -> void #foreign physx_lib;

PxHeightFieldSample_clearTessFlag_mut :: (self__pod: *physx_PxHeightFieldSample_Pod) -> void #foreign physx_lib;

PxHeightField_release_mut :: (self__pod: *physx_PxHeightField_Pod) -> void #foreign physx_lib;

PxHeightField_saveCells :: (self__pod: *physx_PxHeightField_Pod, destBuffer: *void, destBufferSize: u32) -> u32 #foreign physx_lib;

PxHeightField_modifySamples_mut :: (self__pod: *physx_PxHeightField_Pod, startCol: s32, startRow: s32, subfieldDesc_pod: *physx_PxHeightFieldDesc_Pod, shrinkBounds: bool) -> bool #foreign physx_lib;

PxHeightField_getNbRows :: (self__pod: *physx_PxHeightField_Pod) -> u32 #foreign physx_lib;

PxHeightField_getNbColumns :: (self__pod: *physx_PxHeightField_Pod) -> u32 #foreign physx_lib;

PxHeightField_getFormat :: (self__pod: *physx_PxHeightField_Pod) -> u32 #foreign physx_lib;

PxHeightField_getSampleStride :: (self__pod: *physx_PxHeightField_Pod) -> u32 #foreign physx_lib;

PxHeightField_getConvexEdgeThreshold :: (self__pod: *physx_PxHeightField_Pod) -> float #foreign physx_lib;

PxHeightField_getFlags :: (self__pod: *physx_PxHeightField_Pod) -> physx_PxHeightFieldFlags_Pod #foreign physx_lib;

PxHeightField_getHeight :: (self__pod: *physx_PxHeightField_Pod, x: float, z: float) -> float #foreign physx_lib;

PxHeightField_getReferenceCount :: (self__pod: *physx_PxHeightField_Pod) -> u32 #foreign physx_lib;

PxHeightField_acquireReference_mut :: (self__pod: *physx_PxHeightField_Pod) -> void #foreign physx_lib;

PxHeightField_getTriangleMaterialIndex :: (self__pod: *physx_PxHeightField_Pod, triangleIndex: u32) -> u16 #foreign physx_lib;

PxHeightField_getTriangleNormal :: (self__pod: *physx_PxHeightField_Pod, triangleIndex: u32) -> physx_PxVec3_Pod #foreign physx_lib;

PxHeightField_getSample :: (self__pod: *physx_PxHeightField_Pod, row: u32, column: u32) -> *physx_PxHeightFieldSample_Pod #foreign physx_lib;

PxHeightField_getTimestamp :: (self__pod: *physx_PxHeightField_Pod) -> u32 #foreign physx_lib;

PxHeightField_getConcreteTypeName :: (self__pod: *physx_PxHeightField_Pod) -> *u8 #foreign physx_lib;

PxHeightFieldDesc_new :: () -> physx_PxHeightFieldDesc_Pod #foreign physx_lib;

PxHeightFieldDesc_setToDefault_mut :: (self__pod: *physx_PxHeightFieldDesc_Pod) -> void #foreign physx_lib;

PxHeightFieldDesc_isValid :: (self__pod: *physx_PxHeightFieldDesc_Pod) -> bool #foreign physx_lib;

PxHeightFieldDesc_new_1 :: () -> physx_PxHeightFieldDesc_Pod #foreign physx_lib;

PxHeightFieldDesc_setToDefault_mut_1 :: (self__pod: *physx_PxHeightFieldDesc_Pod) -> void #foreign physx_lib;

PxHeightFieldDesc_isValid_1 :: (self__pod: *physx_PxHeightFieldDesc_Pod) -> bool #foreign physx_lib;

PxMeshQuery_getTriangle_mut :: (triGeom_pod: *physx_PxTriangleMeshGeometry_Pod, transform_pod: *physx_PxTransform_Pod, triangleIndex: u32, triangle_pod: *physx_PxTriangle_Pod, vertexIndices: *u32, adjacencyIndices: *u32) -> void #foreign physx_lib;

PxMeshQuery_getTriangle_mut_1 :: (hfGeom_pod: *physx_PxHeightFieldGeometry_Pod, transform_pod: *physx_PxTransform_Pod, triangleIndex: u32, triangle_pod: *physx_PxTriangle_Pod, vertexIndices: *u32, adjacencyIndices: *u32) -> void #foreign physx_lib;

PxMeshQuery_findOverlapTriangleMesh_mut :: (geom_pod: *physx_PxGeometry_Pod, geomPose_pod: *physx_PxTransform_Pod, meshGeom_pod: *physx_PxTriangleMeshGeometry_Pod, meshPose_pod: *physx_PxTransform_Pod, results: *u32, maxResults: u32, startIndex: u32, overflow_pod: *bool) -> u32 #foreign physx_lib;

PxMeshQuery_findOverlapHeightField_mut :: (geom_pod: *physx_PxGeometry_Pod, geomPose_pod: *physx_PxTransform_Pod, hfGeom_pod: *physx_PxHeightFieldGeometry_Pod, hfPose_pod: *physx_PxTransform_Pod, results: *u32, maxResults: u32, startIndex: u32, overflow_pod: *bool) -> u32 #foreign physx_lib;

PxMeshQuery_sweep_mut :: (unitDir_pod: *physx_PxVec3_Pod, distance: float, geom_pod: *physx_PxGeometry_Pod, pose_pod: *physx_PxTransform_Pod, triangleCount: u32, triangles_pod: *physx_PxTriangle_Pod, sweepHit_pod: *physx_PxSweepHit_Pod, hitFlags_pod: physx_PxHitFlags_Pod, cachedIndex: *u32, inflation: float, doubleSided: bool) -> bool #foreign physx_lib;

PxSimpleTriangleMesh_new :: () -> physx_PxSimpleTriangleMesh_Pod #foreign physx_lib;

PxSimpleTriangleMesh_setToDefault_mut :: (self__pod: *physx_PxSimpleTriangleMesh_Pod) -> void #foreign physx_lib;

PxSimpleTriangleMesh_isValid :: (self__pod: *physx_PxSimpleTriangleMesh_Pod) -> bool #foreign physx_lib;

PxSimpleTriangleMesh_new_1 :: () -> physx_PxSimpleTriangleMesh_Pod #foreign physx_lib;

PxSimpleTriangleMesh_setToDefault_mut_1 :: (self__pod: *physx_PxSimpleTriangleMesh_Pod) -> void #foreign physx_lib;

PxSimpleTriangleMesh_isValid_1 :: (self__pod: *physx_PxSimpleTriangleMesh_Pod) -> bool #foreign physx_lib;

PxTriangle_new_alloc :: () -> *physx_PxTriangle_Pod #foreign physx_lib;

PxTriangle_new_alloc_1 :: (p0_pod: *physx_PxVec3_Pod, p1_pod: *physx_PxVec3_Pod, p2_pod: *physx_PxVec3_Pod) -> *physx_PxTriangle_Pod #foreign physx_lib;

PxTriangle_delete :: (self__pod: *physx_PxTriangle_Pod) -> void #foreign physx_lib;

PxTriangle_normal :: (self__pod: *physx_PxTriangle_Pod, _normal_pod: *physx_PxVec3_Pod) -> void #foreign physx_lib;

PxTriangle_denormalizedNormal :: (self__pod: *physx_PxTriangle_Pod, _normal_pod: *physx_PxVec3_Pod) -> void #foreign physx_lib;

PxTriangle_area :: (self__pod: *physx_PxTriangle_Pod) -> float #foreign physx_lib;

PxTriangle_pointFromUV :: (self__pod: *physx_PxTriangle_Pod, u: float, v: float) -> physx_PxVec3_Pod #foreign physx_lib;

PxTriangleMesh_getNbVertices :: (self__pod: *physx_PxTriangleMesh_Pod) -> u32 #foreign physx_lib;

PxTriangleMesh_getVertices :: (self__pod: *physx_PxTriangleMesh_Pod) -> *physx_PxVec3_Pod #foreign physx_lib;

PxTriangleMesh_getVerticesForModification_mut :: (self__pod: *physx_PxTriangleMesh_Pod) -> *physx_PxVec3_Pod #foreign physx_lib;

PxTriangleMesh_refitBVH_mut :: (self__pod: *physx_PxTriangleMesh_Pod) -> physx_PxBounds3_Pod #foreign physx_lib;

PxTriangleMesh_getNbTriangles :: (self__pod: *physx_PxTriangleMesh_Pod) -> u32 #foreign physx_lib;

PxTriangleMesh_getTriangles :: (self__pod: *physx_PxTriangleMesh_Pod) -> *void #foreign physx_lib;

PxTriangleMesh_getTriangleMeshFlags :: (self__pod: *physx_PxTriangleMesh_Pod) -> physx_PxTriangleMeshFlags_Pod #foreign physx_lib;

PxTriangleMesh_getTrianglesRemap :: (self__pod: *physx_PxTriangleMesh_Pod) -> *u32 #foreign physx_lib;

PxTriangleMesh_release_mut :: (self__pod: *physx_PxTriangleMesh_Pod) -> void #foreign physx_lib;

PxTriangleMesh_getTriangleMaterialIndex :: (self__pod: *physx_PxTriangleMesh_Pod, triangleIndex: u32) -> u16 #foreign physx_lib;

PxTriangleMesh_getLocalBounds :: (self__pod: *physx_PxTriangleMesh_Pod) -> physx_PxBounds3_Pod #foreign physx_lib;

PxTriangleMesh_getReferenceCount :: (self__pod: *physx_PxTriangleMesh_Pod) -> u32 #foreign physx_lib;

PxTriangleMesh_acquireReference_mut :: (self__pod: *physx_PxTriangleMesh_Pod) -> void #foreign physx_lib;

PxActor_release_mut :: (self__pod: *physx_PxActor_Pod) -> void #foreign physx_lib;

PxActor_getType :: (self__pod: *physx_PxActor_Pod) -> u32 #foreign physx_lib;

PxActor_getScene :: (self__pod: *physx_PxActor_Pod) -> *physx_PxScene_Pod #foreign physx_lib;

PxActor_setName_mut :: (self__pod: *physx_PxActor_Pod, name: *u8) -> void #foreign physx_lib;

PxActor_getName :: (self__pod: *physx_PxActor_Pod) -> *u8 #foreign physx_lib;

PxActor_getWorldBounds :: (self__pod: *physx_PxActor_Pod, inflation: float) -> physx_PxBounds3_Pod #foreign physx_lib;

PxActor_setActorFlag_mut :: (self__pod: *physx_PxActor_Pod, flag_pod: u32, value: bool) -> void #foreign physx_lib;

PxActor_setActorFlags_mut :: (self__pod: *physx_PxActor_Pod, inFlags_pod: physx_PxActorFlags_Pod) -> void #foreign physx_lib;

PxActor_getActorFlags :: (self__pod: *physx_PxActor_Pod) -> physx_PxActorFlags_Pod #foreign physx_lib;

PxActor_setDominanceGroup_mut :: (self__pod: *physx_PxActor_Pod, dominanceGroup: u8) -> void #foreign physx_lib;

PxActor_getDominanceGroup :: (self__pod: *physx_PxActor_Pod) -> u8 #foreign physx_lib;

PxActor_setOwnerClient_mut :: (self__pod: *physx_PxActor_Pod, inClient: u8) -> void #foreign physx_lib;

PxActor_getOwnerClient :: (self__pod: *physx_PxActor_Pod) -> u8 #foreign physx_lib;

PxActor_getAggregate :: (self__pod: *physx_PxActor_Pod) -> *physx_PxAggregate_Pod #foreign physx_lib;

PxAggregate_release_mut :: (self__pod: *physx_PxAggregate_Pod) -> void #foreign physx_lib;

PxAggregate_addActor_mut :: (self__pod: *physx_PxAggregate_Pod, actor_pod: *physx_PxActor_Pod, bvhStructure_pod: *physx_PxBVHStructure_Pod) -> bool #foreign physx_lib;

PxAggregate_removeActor_mut :: (self__pod: *physx_PxAggregate_Pod, actor_pod: *physx_PxActor_Pod) -> bool #foreign physx_lib;

PxAggregate_addArticulation_mut :: (self__pod: *physx_PxAggregate_Pod, articulation_pod: *physx_PxArticulationBase_Pod) -> bool #foreign physx_lib;

PxAggregate_removeArticulation_mut :: (self__pod: *physx_PxAggregate_Pod, articulation_pod: *physx_PxArticulationBase_Pod) -> bool #foreign physx_lib;

PxAggregate_getNbActors :: (self__pod: *physx_PxAggregate_Pod) -> u32 #foreign physx_lib;

PxAggregate_getMaxNbActors :: (self__pod: *physx_PxAggregate_Pod) -> u32 #foreign physx_lib;

PxAggregate_getActors :: (self__pod: *physx_PxAggregate_Pod, userBuffer_pod: **physx_PxActor_Pod, bufferSize: u32, startIndex: u32) -> u32 #foreign physx_lib;

PxAggregate_getScene_mut :: (self__pod: *physx_PxAggregate_Pod) -> *physx_PxScene_Pod #foreign physx_lib;

PxAggregate_getSelfCollision :: (self__pod: *physx_PxAggregate_Pod) -> bool #foreign physx_lib;

PxAggregate_getConcreteTypeName :: (self__pod: *physx_PxAggregate_Pod) -> *u8 #foreign physx_lib;

PxArticulationBase_getScene :: (self__pod: *physx_PxArticulationBase_Pod) -> *physx_PxScene_Pod #foreign physx_lib;

PxArticulationBase_setSolverIterationCounts_mut :: (self__pod: *physx_PxArticulationBase_Pod, minPositionIters: u32, minVelocityIters: u32) -> void #foreign physx_lib;

PxArticulationBase_getSolverIterationCounts :: (self__pod: *physx_PxArticulationBase_Pod, minPositionIters_pod: *u32, minVelocityIters_pod: *u32) -> void #foreign physx_lib;

PxArticulationBase_isSleeping :: (self__pod: *physx_PxArticulationBase_Pod) -> bool #foreign physx_lib;

PxArticulationBase_setSleepThreshold_mut :: (self__pod: *physx_PxArticulationBase_Pod, threshold: float) -> void #foreign physx_lib;

PxArticulationBase_getSleepThreshold :: (self__pod: *physx_PxArticulationBase_Pod) -> float #foreign physx_lib;

PxArticulationBase_setStabilizationThreshold_mut :: (self__pod: *physx_PxArticulationBase_Pod, threshold: float) -> void #foreign physx_lib;

PxArticulationBase_getStabilizationThreshold :: (self__pod: *physx_PxArticulationBase_Pod) -> float #foreign physx_lib;

PxArticulationBase_setWakeCounter_mut :: (self__pod: *physx_PxArticulationBase_Pod, wakeCounterValue: float) -> void #foreign physx_lib;

PxArticulationBase_getWakeCounter :: (self__pod: *physx_PxArticulationBase_Pod) -> float #foreign physx_lib;

PxArticulationBase_wakeUp_mut :: (self__pod: *physx_PxArticulationBase_Pod) -> void #foreign physx_lib;

PxArticulationBase_putToSleep_mut :: (self__pod: *physx_PxArticulationBase_Pod) -> void #foreign physx_lib;

PxArticulationBase_createLink_mut :: (self__pod: *physx_PxArticulationBase_Pod, parent_pod: *physx_PxArticulationLink_Pod, pose_pod: *physx_PxTransform_Pod) -> *physx_PxArticulationLink_Pod #foreign physx_lib;

PxArticulationBase_getNbLinks :: (self__pod: *physx_PxArticulationBase_Pod) -> u32 #foreign physx_lib;

PxArticulationBase_getLinks :: (self__pod: *physx_PxArticulationBase_Pod, userBuffer_pod: **physx_PxArticulationLink_Pod, bufferSize: u32, startIndex: u32) -> u32 #foreign physx_lib;

PxArticulationBase_setName_mut :: (self__pod: *physx_PxArticulationBase_Pod, name: *u8) -> void #foreign physx_lib;

PxArticulationBase_getName :: (self__pod: *physx_PxArticulationBase_Pod) -> *u8 #foreign physx_lib;

PxArticulationBase_getWorldBounds :: (self__pod: *physx_PxArticulationBase_Pod, inflation: float) -> physx_PxBounds3_Pod #foreign physx_lib;

PxArticulationBase_getAggregate :: (self__pod: *physx_PxArticulationBase_Pod) -> *physx_PxAggregate_Pod #foreign physx_lib;

PxArticulationBase_getImpl_mut :: (self__pod: *physx_PxArticulationBase_Pod) -> *physx_PxArticulationImpl_Pod #foreign physx_lib;

PxArticulationBase_getImpl :: (self__pod: *physx_PxArticulationBase_Pod) -> *physx_PxArticulationImpl_Pod #foreign physx_lib;

PxArticulationBase_createArticulationJoint_mut :: (self__pod: *physx_PxArticulationBase_Pod, parent_pod: *physx_PxArticulationLink_Pod, parentFrame_pod: *physx_PxTransform_Pod, child_pod: *physx_PxArticulationLink_Pod, childFrame_pod: *physx_PxTransform_Pod) -> *physx_PxArticulationJointBase_Pod #foreign physx_lib;

PxArticulationBase_releaseArticulationJoint_mut :: (self__pod: *physx_PxArticulationBase_Pod, joint_pod: *physx_PxArticulationJointBase_Pod) -> void #foreign physx_lib;

PxArticulation_release_mut :: (self__pod: *physx_PxArticulation_Pod) -> void #foreign physx_lib;

PxArticulation_setMaxProjectionIterations_mut :: (self__pod: *physx_PxArticulation_Pod, iterations: u32) -> void #foreign physx_lib;

PxArticulation_getMaxProjectionIterations :: (self__pod: *physx_PxArticulation_Pod) -> u32 #foreign physx_lib;

PxArticulation_setSeparationTolerance_mut :: (self__pod: *physx_PxArticulation_Pod, tolerance: float) -> void #foreign physx_lib;

PxArticulation_getSeparationTolerance :: (self__pod: *physx_PxArticulation_Pod) -> float #foreign physx_lib;

PxArticulation_setInternalDriveIterations_mut :: (self__pod: *physx_PxArticulation_Pod, iterations: u32) -> void #foreign physx_lib;

PxArticulation_getInternalDriveIterations :: (self__pod: *physx_PxArticulation_Pod) -> u32 #foreign physx_lib;

PxArticulation_setExternalDriveIterations_mut :: (self__pod: *physx_PxArticulation_Pod, iterations: u32) -> void #foreign physx_lib;

PxArticulation_getExternalDriveIterations :: (self__pod: *physx_PxArticulation_Pod) -> u32 #foreign physx_lib;

PxArticulation_createDriveCache :: (self__pod: *physx_PxArticulation_Pod, compliance: float, driveIterations: u32) -> *physx_PxArticulationDriveCache_Pod #foreign physx_lib;

PxArticulation_updateDriveCache :: (self__pod: *physx_PxArticulation_Pod, driveCache_pod: *physx_PxArticulationDriveCache_Pod, compliance: float, driveIterations: u32) -> void #foreign physx_lib;

PxArticulation_releaseDriveCache :: (self__pod: *physx_PxArticulation_Pod, driveCache_pod: *physx_PxArticulationDriveCache_Pod) -> void #foreign physx_lib;

PxArticulation_applyImpulse_mut :: (self__pod: *physx_PxArticulation_Pod, link_pod: *physx_PxArticulationLink_Pod, driveCache_pod: *physx_PxArticulationDriveCache_Pod, linearImpulse_pod: *physx_PxVec3_Pod, angularImpulse_pod: *physx_PxVec3_Pod) -> void #foreign physx_lib;

PxArticulation_computeImpulseResponse :: (self__pod: *physx_PxArticulation_Pod, link_pod: *physx_PxArticulationLink_Pod, linearResponse_pod: *physx_PxVec3_Pod, angularResponse_pod: *physx_PxVec3_Pod, driveCache_pod: *physx_PxArticulationDriveCache_Pod, linearImpulse_pod: *physx_PxVec3_Pod, angularImpulse_pod: *physx_PxVec3_Pod) -> void #foreign physx_lib;

PxConstraintInvMassScale_new :: () -> physx_PxConstraintInvMassScale_Pod #foreign physx_lib;

PxConstraintInvMassScale_new_1 :: (lin0: float, ang0: float, lin1: float, ang1: float) -> physx_PxConstraintInvMassScale_Pod #foreign physx_lib;

PxConstraintVisualizer_visualizeJointFrames_mut :: (self__pod: *physx_PxConstraintVisualizer_Pod, parent_pod: *physx_PxTransform_Pod, child_pod: *physx_PxTransform_Pod) -> void #foreign physx_lib;

PxConstraintVisualizer_visualizeLinearLimit_mut :: (self__pod: *physx_PxConstraintVisualizer_Pod, t0_pod: *physx_PxTransform_Pod, t1_pod: *physx_PxTransform_Pod, value: float, active: bool) -> void #foreign physx_lib;

PxConstraintVisualizer_visualizeAngularLimit_mut :: (self__pod: *physx_PxConstraintVisualizer_Pod, t0_pod: *physx_PxTransform_Pod, lower: float, upper: float, active: bool) -> void #foreign physx_lib;

PxConstraintVisualizer_visualizeLimitCone_mut :: (self__pod: *physx_PxConstraintVisualizer_Pod, t_pod: *physx_PxTransform_Pod, tanQSwingY: float, tanQSwingZ: float, active: bool) -> void #foreign physx_lib;

PxConstraintVisualizer_visualizeDoubleCone_mut :: (self__pod: *physx_PxConstraintVisualizer_Pod, t_pod: *physx_PxTransform_Pod, angle: float, active: bool) -> void #foreign physx_lib;

PxConstraintVisualizer_visualizeLine_mut :: (self__pod: *physx_PxConstraintVisualizer_Pod, p0_pod: *physx_PxVec3_Pod, p1_pod: *physx_PxVec3_Pod, color: u32) -> void #foreign physx_lib;

PxConstraintConnector_prepareData_mut :: (self__pod: *physx_PxConstraintConnector_Pod) -> *void #foreign physx_lib;

PxConstraintConnector_updatePvdProperties :: (self__pod: *physx_PxConstraintConnector_Pod, pvdConnection_pod: *physx_pvdsdk_PvdDataStream_Pod, c_pod: *physx_PxConstraint_Pod, updateType_pod: u32) -> bool #foreign physx_lib;

PxConstraintConnector_onConstraintRelease_mut :: (self__pod: *physx_PxConstraintConnector_Pod) -> void #foreign physx_lib;

PxConstraintConnector_onComShift_mut :: (self__pod: *physx_PxConstraintConnector_Pod, actor: u32) -> void #foreign physx_lib;

PxConstraintConnector_onOriginShift_mut :: (self__pod: *physx_PxConstraintConnector_Pod, shift_pod: *physx_PxVec3_Pod) -> void #foreign physx_lib;

PxConstraintConnector_getExternalReference_mut :: (self__pod: *physx_PxConstraintConnector_Pod, typeID_pod: *u32) -> *void #foreign physx_lib;

PxConstraintConnector_getSerializable_mut :: (self__pod: *physx_PxConstraintConnector_Pod) -> *physx_PxBase_Pod #foreign physx_lib;

PxConstraintConnector_getPrep :: (self__pod: *physx_PxConstraintConnector_Pod) -> *void #foreign physx_lib;

PxConstraintConnector_getConstantBlock :: (self__pod: *physx_PxConstraintConnector_Pod) -> *void #foreign physx_lib;

PxConstraintConnector_delete :: (self__pod: *physx_PxConstraintConnector_Pod) -> void #foreign physx_lib;

PxSolverBody_new :: () -> physx_PxSolverBody_Pod #foreign physx_lib;

PxSolverBodyData_projectVelocity :: (self__pod: *physx_PxSolverBodyData_Pod, lin_pod: *physx_PxVec3_Pod, ang_pod: *physx_PxVec3_Pod) -> float #foreign physx_lib;

PxConstraintAllocator_reserveConstraintData_mut :: (self__pod: *physx_PxConstraintAllocator_Pod, byteSize: u32) -> *u8 #foreign physx_lib;

PxConstraintAllocator_reserveFrictionData_mut :: (self__pod: *physx_PxConstraintAllocator_Pod, byteSize: u32) -> *u8 #foreign physx_lib;

PxConstraintAllocator_delete :: (self__pod: *physx_PxConstraintAllocator_Pod) -> void #foreign physx_lib;

PxTGSSolverBodyVel_projectVelocity :: (self__pod: *physx_PxTGSSolverBodyVel_Pod, lin_pod: *physx_PxVec3_Pod, ang_pod: *physx_PxVec3_Pod) -> float #foreign physx_lib;

PxTGSSolverBodyData_projectVelocity :: (self__pod: *physx_PxTGSSolverBodyData_Pod, linear_pod: *physx_PxVec3_Pod, angular_pod: *physx_PxVec3_Pod) -> float #foreign physx_lib;

PxArticulationCache_new :: () -> physx_PxArticulationCache_Pod #foreign physx_lib;

PxArticulationReducedCoordinate_release_mut :: (self__pod: *physx_PxArticulationReducedCoordinate_Pod) -> void #foreign physx_lib;

PxArticulationReducedCoordinate_setArticulationFlags_mut :: (self__pod: *physx_PxArticulationReducedCoordinate_Pod, flags_pod: physx_PxArticulationFlags_Pod) -> void #foreign physx_lib;

PxArticulationReducedCoordinate_setArticulationFlag_mut :: (self__pod: *physx_PxArticulationReducedCoordinate_Pod, flag_pod: u32, value: bool) -> void #foreign physx_lib;

PxArticulationReducedCoordinate_getArticulationFlags :: (self__pod: *physx_PxArticulationReducedCoordinate_Pod) -> physx_PxArticulationFlags_Pod #foreign physx_lib;

PxArticulationReducedCoordinate_getDofs :: (self__pod: *physx_PxArticulationReducedCoordinate_Pod) -> u32 #foreign physx_lib;

PxArticulationReducedCoordinate_createCache :: (self__pod: *physx_PxArticulationReducedCoordinate_Pod) -> *physx_PxArticulationCache_Pod #foreign physx_lib;

PxArticulationReducedCoordinate_getCacheDataSize :: (self__pod: *physx_PxArticulationReducedCoordinate_Pod) -> u32 #foreign physx_lib;

PxArticulationReducedCoordinate_zeroCache_mut :: (self__pod: *physx_PxArticulationReducedCoordinate_Pod, cache_pod: *physx_PxArticulationCache_Pod) -> void #foreign physx_lib;

PxArticulationReducedCoordinate_applyCache_mut :: (self__pod: *physx_PxArticulationReducedCoordinate_Pod, cache_pod: *physx_PxArticulationCache_Pod, flag_pod: physx_PxArticulationCacheFlags_Pod, autowake: bool) -> void #foreign physx_lib;

PxArticulationReducedCoordinate_copyInternalStateToCache :: (self__pod: *physx_PxArticulationReducedCoordinate_Pod, cache_pod: *physx_PxArticulationCache_Pod, flag_pod: physx_PxArticulationCacheFlags_Pod) -> void #foreign physx_lib;

PxArticulationReducedCoordinate_releaseCache :: (self__pod: *physx_PxArticulationReducedCoordinate_Pod, cache_pod: *physx_PxArticulationCache_Pod) -> void #foreign physx_lib;

PxArticulationReducedCoordinate_packJointData :: (self__pod: *physx_PxArticulationReducedCoordinate_Pod, maximum: *float, reduced: *float) -> void #foreign physx_lib;

PxArticulationReducedCoordinate_unpackJointData :: (self__pod: *physx_PxArticulationReducedCoordinate_Pod, reduced: *float, maximum: *float) -> void #foreign physx_lib;

PxArticulationReducedCoordinate_commonInit :: (self__pod: *physx_PxArticulationReducedCoordinate_Pod) -> void #foreign physx_lib;

PxArticulationReducedCoordinate_computeGeneralizedGravityForce :: (self__pod: *physx_PxArticulationReducedCoordinate_Pod, cache_pod: *physx_PxArticulationCache_Pod) -> void #foreign physx_lib;

PxArticulationReducedCoordinate_computeCoriolisAndCentrifugalForce :: (self__pod: *physx_PxArticulationReducedCoordinate_Pod, cache_pod: *physx_PxArticulationCache_Pod) -> void #foreign physx_lib;

PxArticulationReducedCoordinate_computeGeneralizedExternalForce :: (self__pod: *physx_PxArticulationReducedCoordinate_Pod, cache_pod: *physx_PxArticulationCache_Pod) -> void #foreign physx_lib;

PxArticulationReducedCoordinate_computeJointAcceleration :: (self__pod: *physx_PxArticulationReducedCoordinate_Pod, cache_pod: *physx_PxArticulationCache_Pod) -> void #foreign physx_lib;

PxArticulationReducedCoordinate_computeJointForce :: (self__pod: *physx_PxArticulationReducedCoordinate_Pod, cache_pod: *physx_PxArticulationCache_Pod) -> void #foreign physx_lib;

PxArticulationReducedCoordinate_computeDenseJacobian :: (self__pod: *physx_PxArticulationReducedCoordinate_Pod, cache_pod: *physx_PxArticulationCache_Pod, nRows_pod: *u32, nCols_pod: *u32) -> void #foreign physx_lib;

PxArticulationReducedCoordinate_computeCoefficientMatrix :: (self__pod: *physx_PxArticulationReducedCoordinate_Pod, cache_pod: *physx_PxArticulationCache_Pod) -> void #foreign physx_lib;

PxArticulationReducedCoordinate_computeLambda :: (self__pod: *physx_PxArticulationReducedCoordinate_Pod, cache_pod: *physx_PxArticulationCache_Pod, initialState_pod: *physx_PxArticulationCache_Pod, jointTorque: *float, maxIter: u32) -> bool #foreign physx_lib;

PxArticulationReducedCoordinate_computeGeneralizedMassMatrix :: (self__pod: *physx_PxArticulationReducedCoordinate_Pod, cache_pod: *physx_PxArticulationCache_Pod) -> void #foreign physx_lib;

PxArticulationReducedCoordinate_addLoopJoint_mut :: (self__pod: *physx_PxArticulationReducedCoordinate_Pod, joint_pod: *physx_PxJoint_Pod) -> void #foreign physx_lib;

PxArticulationReducedCoordinate_removeLoopJoint_mut :: (self__pod: *physx_PxArticulationReducedCoordinate_Pod, joint_pod: *physx_PxJoint_Pod) -> void #foreign physx_lib;

PxArticulationReducedCoordinate_getNbLoopJoints :: (self__pod: *physx_PxArticulationReducedCoordinate_Pod) -> u32 #foreign physx_lib;

PxArticulationReducedCoordinate_getLoopJoints :: (self__pod: *physx_PxArticulationReducedCoordinate_Pod, userBuffer_pod: **physx_PxJoint_Pod, bufferSize: u32, startIndex: u32) -> u32 #foreign physx_lib;

PxArticulationReducedCoordinate_getCoefficientMatrixSize :: (self__pod: *physx_PxArticulationReducedCoordinate_Pod) -> u32 #foreign physx_lib;

PxArticulationReducedCoordinate_teleportRootLink_mut :: (self__pod: *physx_PxArticulationReducedCoordinate_Pod, pose_pod: *physx_PxTransform_Pod, autowake: bool) -> void #foreign physx_lib;

PxArticulationReducedCoordinate_getLinkVelocity_mut :: (self__pod: *physx_PxArticulationReducedCoordinate_Pod, linkId: u32) -> physx_PxSpatialVelocity_Pod #foreign physx_lib;

PxArticulationReducedCoordinate_getLinkAcceleration_mut :: (self__pod: *physx_PxArticulationReducedCoordinate_Pod, linkId: u32) -> physx_PxSpatialVelocity_Pod #foreign physx_lib;

PxArticulationJointBase_getParentArticulationLink :: (self__pod: *physx_PxArticulationJointBase_Pod) -> *physx_PxArticulationLink_Pod #foreign physx_lib;

PxArticulationJointBase_setParentPose_mut :: (self__pod: *physx_PxArticulationJointBase_Pod, pose_pod: *physx_PxTransform_Pod) -> void #foreign physx_lib;

PxArticulationJointBase_getParentPose :: (self__pod: *physx_PxArticulationJointBase_Pod) -> physx_PxTransform_Pod #foreign physx_lib;

PxArticulationJointBase_getChildArticulationLink :: (self__pod: *physx_PxArticulationJointBase_Pod) -> *physx_PxArticulationLink_Pod #foreign physx_lib;

PxArticulationJointBase_setChildPose_mut :: (self__pod: *physx_PxArticulationJointBase_Pod, pose_pod: *physx_PxTransform_Pod) -> void #foreign physx_lib;

PxArticulationJointBase_getChildPose :: (self__pod: *physx_PxArticulationJointBase_Pod) -> physx_PxTransform_Pod #foreign physx_lib;

PxArticulationJointBase_getImpl_mut :: (self__pod: *physx_PxArticulationJointBase_Pod) -> *physx_PxArticulationJointImpl_Pod #foreign physx_lib;

PxArticulationJointBase_getImpl :: (self__pod: *physx_PxArticulationJointBase_Pod) -> *physx_PxArticulationJointImpl_Pod #foreign physx_lib;

PxArticulationJoint_setTargetOrientation_mut :: (self__pod: *physx_PxArticulationJoint_Pod, orientation_pod: *physx_PxQuat_Pod) -> void #foreign physx_lib;

PxArticulationJoint_getTargetOrientation :: (self__pod: *physx_PxArticulationJoint_Pod) -> physx_PxQuat_Pod #foreign physx_lib;

PxArticulationJoint_setTargetVelocity_mut :: (self__pod: *physx_PxArticulationJoint_Pod, velocity_pod: *physx_PxVec3_Pod) -> void #foreign physx_lib;

PxArticulationJoint_getTargetVelocity :: (self__pod: *physx_PxArticulationJoint_Pod) -> physx_PxVec3_Pod #foreign physx_lib;

PxArticulationJoint_setDriveType_mut :: (self__pod: *physx_PxArticulationJoint_Pod, driveType_pod: u32) -> void #foreign physx_lib;

PxArticulationJoint_getDriveType :: (self__pod: *physx_PxArticulationJoint_Pod) -> u32 #foreign physx_lib;

PxArticulationJoint_setStiffness_mut :: (self__pod: *physx_PxArticulationJoint_Pod, spring: float) -> void #foreign physx_lib;

PxArticulationJoint_getStiffness :: (self__pod: *physx_PxArticulationJoint_Pod) -> float #foreign physx_lib;

PxArticulationJoint_setDamping_mut :: (self__pod: *physx_PxArticulationJoint_Pod, damping: float) -> void #foreign physx_lib;

PxArticulationJoint_getDamping :: (self__pod: *physx_PxArticulationJoint_Pod) -> float #foreign physx_lib;

PxArticulationJoint_setInternalCompliance_mut :: (self__pod: *physx_PxArticulationJoint_Pod, compliance: float) -> void #foreign physx_lib;

PxArticulationJoint_getInternalCompliance :: (self__pod: *physx_PxArticulationJoint_Pod) -> float #foreign physx_lib;

PxArticulationJoint_setExternalCompliance_mut :: (self__pod: *physx_PxArticulationJoint_Pod, compliance: float) -> void #foreign physx_lib;

PxArticulationJoint_getExternalCompliance :: (self__pod: *physx_PxArticulationJoint_Pod) -> float #foreign physx_lib;

PxArticulationJoint_setSwingLimit_mut :: (self__pod: *physx_PxArticulationJoint_Pod, zLimit: float, yLimit: float) -> void #foreign physx_lib;

PxArticulationJoint_getSwingLimit :: (self__pod: *physx_PxArticulationJoint_Pod, zLimit_pod: *float, yLimit_pod: *float) -> void #foreign physx_lib;

PxArticulationJoint_setTangentialStiffness_mut :: (self__pod: *physx_PxArticulationJoint_Pod, spring: float) -> void #foreign physx_lib;

PxArticulationJoint_getTangentialStiffness :: (self__pod: *physx_PxArticulationJoint_Pod) -> float #foreign physx_lib;

PxArticulationJoint_setTangentialDamping_mut :: (self__pod: *physx_PxArticulationJoint_Pod, damping: float) -> void #foreign physx_lib;

PxArticulationJoint_getTangentialDamping :: (self__pod: *physx_PxArticulationJoint_Pod) -> float #foreign physx_lib;

PxArticulationJoint_setSwingLimitContactDistance_mut :: (self__pod: *physx_PxArticulationJoint_Pod, contactDistance: float) -> void #foreign physx_lib;

PxArticulationJoint_getSwingLimitContactDistance :: (self__pod: *physx_PxArticulationJoint_Pod) -> float #foreign physx_lib;

PxArticulationJoint_setSwingLimitEnabled_mut :: (self__pod: *physx_PxArticulationJoint_Pod, enabled: bool) -> void #foreign physx_lib;

PxArticulationJoint_getSwingLimitEnabled :: (self__pod: *physx_PxArticulationJoint_Pod) -> bool #foreign physx_lib;

PxArticulationJoint_setTwistLimit_mut :: (self__pod: *physx_PxArticulationJoint_Pod, lower: float, upper: float) -> void #foreign physx_lib;

PxArticulationJoint_getTwistLimit :: (self__pod: *physx_PxArticulationJoint_Pod, lower_pod: *float, upper_pod: *float) -> void #foreign physx_lib;

PxArticulationJoint_setTwistLimitEnabled_mut :: (self__pod: *physx_PxArticulationJoint_Pod, enabled: bool) -> void #foreign physx_lib;

PxArticulationJoint_getTwistLimitEnabled :: (self__pod: *physx_PxArticulationJoint_Pod) -> bool #foreign physx_lib;

PxArticulationJoint_setTwistLimitContactDistance_mut :: (self__pod: *physx_PxArticulationJoint_Pod, contactDistance: float) -> void #foreign physx_lib;

PxArticulationJoint_getTwistLimitContactDistance :: (self__pod: *physx_PxArticulationJoint_Pod) -> float #foreign physx_lib;

PxArticulationJoint_getConcreteTypeName :: (self__pod: *physx_PxArticulationJoint_Pod) -> *u8 #foreign physx_lib;

PxArticulationJointReducedCoordinate_setJointType_mut :: (self__pod: *physx_PxArticulationJointReducedCoordinate_Pod, jointType_pod: u32) -> void #foreign physx_lib;

PxArticulationJointReducedCoordinate_getJointType :: (self__pod: *physx_PxArticulationJointReducedCoordinate_Pod) -> u32 #foreign physx_lib;

PxArticulationJointReducedCoordinate_setMotion_mut :: (self__pod: *physx_PxArticulationJointReducedCoordinate_Pod, axis_pod: u32, motion_pod: u32) -> void #foreign physx_lib;

PxArticulationJointReducedCoordinate_getMotion :: (self__pod: *physx_PxArticulationJointReducedCoordinate_Pod, axis_pod: u32) -> u32 #foreign physx_lib;

PxArticulationJointReducedCoordinate_setLimit_mut :: (self__pod: *physx_PxArticulationJointReducedCoordinate_Pod, axis_pod: u32, lowLimit: float, highLimit: float) -> void #foreign physx_lib;

PxArticulationJointReducedCoordinate_getLimit_mut :: (self__pod: *physx_PxArticulationJointReducedCoordinate_Pod, axis_pod: u32, lowLimit_pod: *float, highLimit_pod: *float) -> void #foreign physx_lib;

PxArticulationJointReducedCoordinate_setDrive_mut :: (self__pod: *physx_PxArticulationJointReducedCoordinate_Pod, axis_pod: u32, stiffness: float, damping: float, maxForce: float, driveType_pod: u32) -> void #foreign physx_lib;

PxArticulationJointReducedCoordinate_getDrive_mut :: (self__pod: *physx_PxArticulationJointReducedCoordinate_Pod, axis_pod: u32, stiffness_pod: *float, damping_pod: *float, maxForce_pod: *float, driveType_pod: *u32) -> void #foreign physx_lib;

PxArticulationJointReducedCoordinate_setDriveTarget_mut :: (self__pod: *physx_PxArticulationJointReducedCoordinate_Pod, axis_pod: u32, target: float) -> void #foreign physx_lib;

PxArticulationJointReducedCoordinate_setDriveVelocity_mut :: (self__pod: *physx_PxArticulationJointReducedCoordinate_Pod, axis_pod: u32, targetVel: float) -> void #foreign physx_lib;

PxArticulationJointReducedCoordinate_getDriveTarget_mut :: (self__pod: *physx_PxArticulationJointReducedCoordinate_Pod, axis_pod: u32) -> float #foreign physx_lib;

PxArticulationJointReducedCoordinate_getDriveVelocity_mut :: (self__pod: *physx_PxArticulationJointReducedCoordinate_Pod, axis_pod: u32) -> float #foreign physx_lib;

PxArticulationJointReducedCoordinate_setFrictionCoefficient_mut :: (self__pod: *physx_PxArticulationJointReducedCoordinate_Pod, coefficient: float) -> void #foreign physx_lib;

PxArticulationJointReducedCoordinate_getFrictionCoefficient :: (self__pod: *physx_PxArticulationJointReducedCoordinate_Pod) -> float #foreign physx_lib;

PxArticulationJointReducedCoordinate_getConcreteTypeName :: (self__pod: *physx_PxArticulationJointReducedCoordinate_Pod) -> *u8 #foreign physx_lib;

PxArticulationJointReducedCoordinate_setMaxJointVelocity_mut :: (self__pod: *physx_PxArticulationJointReducedCoordinate_Pod, maxJointV: float) -> void #foreign physx_lib;

PxArticulationJointReducedCoordinate_getMaxJointVelocity :: (self__pod: *physx_PxArticulationJointReducedCoordinate_Pod) -> float #foreign physx_lib;

PxShape_release_mut :: (self__pod: *physx_PxShape_Pod) -> void #foreign physx_lib;

PxShape_getReferenceCount :: (self__pod: *physx_PxShape_Pod) -> u32 #foreign physx_lib;

PxShape_acquireReference_mut :: (self__pod: *physx_PxShape_Pod) -> void #foreign physx_lib;

PxShape_getGeometryType :: (self__pod: *physx_PxShape_Pod) -> s32 #foreign physx_lib;

PxShape_setGeometry_mut :: (self__pod: *physx_PxShape_Pod, geometry_pod: *physx_PxGeometry_Pod) -> void #foreign physx_lib;

PxShape_getGeometry :: (self__pod: *physx_PxShape_Pod) -> physx_PxGeometryHolder_Pod #foreign physx_lib;

PxShape_getBoxGeometry :: (self__pod: *physx_PxShape_Pod, geometry_pod: *physx_PxBoxGeometry_Pod) -> bool #foreign physx_lib;

PxShape_getSphereGeometry :: (self__pod: *physx_PxShape_Pod, geometry_pod: *physx_PxSphereGeometry_Pod) -> bool #foreign physx_lib;

PxShape_getCapsuleGeometry :: (self__pod: *physx_PxShape_Pod, geometry_pod: *physx_PxCapsuleGeometry_Pod) -> bool #foreign physx_lib;

PxShape_getPlaneGeometry :: (self__pod: *physx_PxShape_Pod, geometry_pod: *physx_PxPlaneGeometry_Pod) -> bool #foreign physx_lib;

PxShape_getConvexMeshGeometry :: (self__pod: *physx_PxShape_Pod, geometry_pod: *physx_PxConvexMeshGeometry_Pod) -> bool #foreign physx_lib;

PxShape_getTriangleMeshGeometry :: (self__pod: *physx_PxShape_Pod, geometry_pod: *physx_PxTriangleMeshGeometry_Pod) -> bool #foreign physx_lib;

PxShape_getHeightFieldGeometry :: (self__pod: *physx_PxShape_Pod, geometry_pod: *physx_PxHeightFieldGeometry_Pod) -> bool #foreign physx_lib;

PxShape_getActor :: (self__pod: *physx_PxShape_Pod) -> *physx_PxRigidActor_Pod #foreign physx_lib;

PxShape_setLocalPose_mut :: (self__pod: *physx_PxShape_Pod, pose_pod: *physx_PxTransform_Pod) -> void #foreign physx_lib;

PxShape_getLocalPose :: (self__pod: *physx_PxShape_Pod) -> physx_PxTransform_Pod #foreign physx_lib;

PxShape_setSimulationFilterData_mut :: (self__pod: *physx_PxShape_Pod, data_pod: *physx_PxFilterData_Pod) -> void #foreign physx_lib;

PxShape_getSimulationFilterData :: (self__pod: *physx_PxShape_Pod) -> physx_PxFilterData_Pod #foreign physx_lib;

PxShape_setQueryFilterData_mut :: (self__pod: *physx_PxShape_Pod, data_pod: *physx_PxFilterData_Pod) -> void #foreign physx_lib;

PxShape_getQueryFilterData :: (self__pod: *physx_PxShape_Pod) -> physx_PxFilterData_Pod #foreign physx_lib;

PxShape_setMaterials_mut :: (self__pod: *physx_PxShape_Pod, materials_pod: **physx_PxMaterial_Pod, materialCount: u16) -> void #foreign physx_lib;

PxShape_getNbMaterials :: (self__pod: *physx_PxShape_Pod) -> u16 #foreign physx_lib;

PxShape_getMaterials :: (self__pod: *physx_PxShape_Pod, userBuffer_pod: **physx_PxMaterial_Pod, bufferSize: u32, startIndex: u32) -> u32 #foreign physx_lib;

PxShape_getMaterialFromInternalFaceIndex :: (self__pod: *physx_PxShape_Pod, faceIndex: u32) -> *physx_PxMaterial_Pod #foreign physx_lib;

PxShape_setContactOffset_mut :: (self__pod: *physx_PxShape_Pod, contactOffset: float) -> void #foreign physx_lib;

PxShape_getContactOffset :: (self__pod: *physx_PxShape_Pod) -> float #foreign physx_lib;

PxShape_setRestOffset_mut :: (self__pod: *physx_PxShape_Pod, restOffset: float) -> void #foreign physx_lib;

PxShape_getRestOffset :: (self__pod: *physx_PxShape_Pod) -> float #foreign physx_lib;

PxShape_setTorsionalPatchRadius_mut :: (self__pod: *physx_PxShape_Pod, radius: float) -> void #foreign physx_lib;

PxShape_getTorsionalPatchRadius :: (self__pod: *physx_PxShape_Pod) -> float #foreign physx_lib;

PxShape_setMinTorsionalPatchRadius_mut :: (self__pod: *physx_PxShape_Pod, radius: float) -> void #foreign physx_lib;

PxShape_getMinTorsionalPatchRadius :: (self__pod: *physx_PxShape_Pod) -> float #foreign physx_lib;

PxShape_setFlag_mut :: (self__pod: *physx_PxShape_Pod, flag_pod: u32, value: bool) -> void #foreign physx_lib;

PxShape_setFlags_mut :: (self__pod: *physx_PxShape_Pod, inFlags_pod: physx_PxShapeFlags_Pod) -> void #foreign physx_lib;

PxShape_getFlags :: (self__pod: *physx_PxShape_Pod) -> physx_PxShapeFlags_Pod #foreign physx_lib;

PxShape_isExclusive :: (self__pod: *physx_PxShape_Pod) -> bool #foreign physx_lib;

PxShape_setName_mut :: (self__pod: *physx_PxShape_Pod, name: *u8) -> void #foreign physx_lib;

PxShape_getName :: (self__pod: *physx_PxShape_Pod) -> *u8 #foreign physx_lib;

PxShape_getConcreteTypeName :: (self__pod: *physx_PxShape_Pod) -> *u8 #foreign physx_lib;

PxRigidActor_release_mut :: (self__pod: *physx_PxRigidActor_Pod) -> void #foreign physx_lib;

PxRigidActor_getGlobalPose :: (self__pod: *physx_PxRigidActor_Pod) -> physx_PxTransform_Pod #foreign physx_lib;

PxRigidActor_setGlobalPose_mut :: (self__pod: *physx_PxRigidActor_Pod, pose_pod: *physx_PxTransform_Pod, autowake: bool) -> void #foreign physx_lib;

PxRigidActor_attachShape_mut :: (self__pod: *physx_PxRigidActor_Pod, shape_pod: *physx_PxShape_Pod) -> bool #foreign physx_lib;

PxRigidActor_detachShape_mut :: (self__pod: *physx_PxRigidActor_Pod, shape_pod: *physx_PxShape_Pod, wakeOnLostTouch: bool) -> void #foreign physx_lib;

PxRigidActor_getNbShapes :: (self__pod: *physx_PxRigidActor_Pod) -> u32 #foreign physx_lib;

PxRigidActor_getShapes :: (self__pod: *physx_PxRigidActor_Pod, userBuffer_pod: **physx_PxShape_Pod, bufferSize: u32, startIndex: u32) -> u32 #foreign physx_lib;

PxRigidActor_getNbConstraints :: (self__pod: *physx_PxRigidActor_Pod) -> u32 #foreign physx_lib;

PxRigidActor_getConstraints :: (self__pod: *physx_PxRigidActor_Pod, userBuffer_pod: **physx_PxConstraint_Pod, bufferSize: u32, startIndex: u32) -> u32 #foreign physx_lib;

PxRigidBody_setCMassLocalPose_mut :: (self__pod: *physx_PxRigidBody_Pod, pose_pod: *physx_PxTransform_Pod) -> void #foreign physx_lib;

PxRigidBody_getCMassLocalPose :: (self__pod: *physx_PxRigidBody_Pod) -> physx_PxTransform_Pod #foreign physx_lib;

PxRigidBody_setMass_mut :: (self__pod: *physx_PxRigidBody_Pod, mass: float) -> void #foreign physx_lib;

PxRigidBody_getMass :: (self__pod: *physx_PxRigidBody_Pod) -> float #foreign physx_lib;

PxRigidBody_getInvMass :: (self__pod: *physx_PxRigidBody_Pod) -> float #foreign physx_lib;

PxRigidBody_setMassSpaceInertiaTensor_mut :: (self__pod: *physx_PxRigidBody_Pod, m_pod: *physx_PxVec3_Pod) -> void #foreign physx_lib;

PxRigidBody_getMassSpaceInertiaTensor :: (self__pod: *physx_PxRigidBody_Pod) -> physx_PxVec3_Pod #foreign physx_lib;

PxRigidBody_getMassSpaceInvInertiaTensor :: (self__pod: *physx_PxRigidBody_Pod) -> physx_PxVec3_Pod #foreign physx_lib;

PxRigidBody_setLinearDamping_mut :: (self__pod: *physx_PxRigidBody_Pod, linDamp: float) -> void #foreign physx_lib;

PxRigidBody_getLinearDamping :: (self__pod: *physx_PxRigidBody_Pod) -> float #foreign physx_lib;

PxRigidBody_setAngularDamping_mut :: (self__pod: *physx_PxRigidBody_Pod, angDamp: float) -> void #foreign physx_lib;

PxRigidBody_getAngularDamping :: (self__pod: *physx_PxRigidBody_Pod) -> float #foreign physx_lib;

PxRigidBody_getLinearVelocity :: (self__pod: *physx_PxRigidBody_Pod) -> physx_PxVec3_Pod #foreign physx_lib;

PxRigidBody_setLinearVelocity_mut :: (self__pod: *physx_PxRigidBody_Pod, linVel_pod: *physx_PxVec3_Pod, autowake: bool) -> void #foreign physx_lib;

PxRigidBody_getAngularVelocity :: (self__pod: *physx_PxRigidBody_Pod) -> physx_PxVec3_Pod #foreign physx_lib;

PxRigidBody_setAngularVelocity_mut :: (self__pod: *physx_PxRigidBody_Pod, angVel_pod: *physx_PxVec3_Pod, autowake: bool) -> void #foreign physx_lib;

PxRigidBody_setMaxAngularVelocity_mut :: (self__pod: *physx_PxRigidBody_Pod, maxAngVel: float) -> void #foreign physx_lib;

PxRigidBody_getMaxAngularVelocity :: (self__pod: *physx_PxRigidBody_Pod) -> float #foreign physx_lib;

PxRigidBody_setMaxLinearVelocity_mut :: (self__pod: *physx_PxRigidBody_Pod, maxLinVel: float) -> void #foreign physx_lib;

PxRigidBody_getMaxLinearVelocity :: (self__pod: *physx_PxRigidBody_Pod) -> float #foreign physx_lib;

PxRigidBody_addForce_mut :: (self__pod: *physx_PxRigidBody_Pod, force_pod: *physx_PxVec3_Pod, mode_pod: u32, autowake: bool) -> void #foreign physx_lib;

PxRigidBody_addTorque_mut :: (self__pod: *physx_PxRigidBody_Pod, torque_pod: *physx_PxVec3_Pod, mode_pod: u32, autowake: bool) -> void #foreign physx_lib;

PxRigidBody_clearForce_mut :: (self__pod: *physx_PxRigidBody_Pod, mode_pod: u32) -> void #foreign physx_lib;

PxRigidBody_clearTorque_mut :: (self__pod: *physx_PxRigidBody_Pod, mode_pod: u32) -> void #foreign physx_lib;

PxRigidBody_setForceAndTorque_mut :: (self__pod: *physx_PxRigidBody_Pod, force_pod: *physx_PxVec3_Pod, torque_pod: *physx_PxVec3_Pod, mode_pod: u32) -> void #foreign physx_lib;

PxRigidBody_setRigidBodyFlag_mut :: (self__pod: *physx_PxRigidBody_Pod, flag_pod: u32, value: bool) -> void #foreign physx_lib;

PxRigidBody_setRigidBodyFlags_mut :: (self__pod: *physx_PxRigidBody_Pod, inFlags_pod: physx_PxRigidBodyFlags_Pod) -> void #foreign physx_lib;

PxRigidBody_getRigidBodyFlags :: (self__pod: *physx_PxRigidBody_Pod) -> physx_PxRigidBodyFlags_Pod #foreign physx_lib;

PxRigidBody_setMinCCDAdvanceCoefficient_mut :: (self__pod: *physx_PxRigidBody_Pod, advanceCoefficient: float) -> void #foreign physx_lib;

PxRigidBody_getMinCCDAdvanceCoefficient :: (self__pod: *physx_PxRigidBody_Pod) -> float #foreign physx_lib;

PxRigidBody_setMaxDepenetrationVelocity_mut :: (self__pod: *physx_PxRigidBody_Pod, biasClamp: float) -> void #foreign physx_lib;

PxRigidBody_getMaxDepenetrationVelocity :: (self__pod: *physx_PxRigidBody_Pod) -> float #foreign physx_lib;

PxRigidBody_setMaxContactImpulse_mut :: (self__pod: *physx_PxRigidBody_Pod, maxImpulse: float) -> void #foreign physx_lib;

PxRigidBody_getMaxContactImpulse :: (self__pod: *physx_PxRigidBody_Pod) -> float #foreign physx_lib;

PxRigidBody_getInternalIslandNodeIndex :: (self__pod: *physx_PxRigidBody_Pod) -> u32 #foreign physx_lib;

PxArticulationLink_release_mut :: (self__pod: *physx_PxArticulationLink_Pod) -> void #foreign physx_lib;

PxArticulationLink_getArticulation :: (self__pod: *physx_PxArticulationLink_Pod) -> *physx_PxArticulationBase_Pod #foreign physx_lib;

PxArticulationLink_getInboundJoint :: (self__pod: *physx_PxArticulationLink_Pod) -> *physx_PxArticulationJointBase_Pod #foreign physx_lib;

PxArticulationLink_getInboundJointDof :: (self__pod: *physx_PxArticulationLink_Pod) -> u32 #foreign physx_lib;

PxArticulationLink_getNbChildren :: (self__pod: *physx_PxArticulationLink_Pod) -> u32 #foreign physx_lib;

PxArticulationLink_getLinkIndex :: (self__pod: *physx_PxArticulationLink_Pod) -> u32 #foreign physx_lib;

PxArticulationLink_getChildren :: (self__pod: *physx_PxArticulationLink_Pod, userBuffer_pod: **physx_PxArticulationLink_Pod, bufferSize: u32, startIndex: u32) -> u32 #foreign physx_lib;

PxArticulationLink_getConcreteTypeName :: (self__pod: *physx_PxArticulationLink_Pod) -> *u8 #foreign physx_lib;

PxFilterData_new :: (anonymous_arg0_pod: u32) -> physx_PxFilterData_Pod #foreign physx_lib;

PxFilterData_new_1 :: () -> physx_PxFilterData_Pod #foreign physx_lib;

PxFilterData_new_2 :: (w0: u32, w1: u32, w2: u32, w3: u32) -> physx_PxFilterData_Pod #foreign physx_lib;

PxFilterData_setToDefault_mut :: (self__pod: *physx_PxFilterData_Pod) -> void #foreign physx_lib;

phys_PxGetFilterObjectType :: (attr: u32) -> u32 #foreign physx_lib;

phys_PxFilterObjectIsKinematic :: (attr: u32) -> bool #foreign physx_lib;

phys_PxFilterObjectIsTrigger :: (attr: u32) -> bool #foreign physx_lib;

PxSimulationFilterCallback_pairFound_mut :: (self__pod: *physx_PxSimulationFilterCallback_Pod, pairID: u32, attributes0: u32, filterData0_pod: physx_PxFilterData_Pod, a0_pod: *physx_PxActor_Pod, s0_pod: *physx_PxShape_Pod, attributes1: u32, filterData1_pod: physx_PxFilterData_Pod, a1_pod: *physx_PxActor_Pod, s1_pod: *physx_PxShape_Pod, pairFlags_pod: *physx_PxPairFlags_Pod) -> physx_PxFilterFlags_Pod #foreign physx_lib;

PxSimulationFilterCallback_pairLost_mut :: (self__pod: *physx_PxSimulationFilterCallback_Pod, pairID: u32, attributes0: u32, filterData0_pod: physx_PxFilterData_Pod, attributes1: u32, filterData1_pod: physx_PxFilterData_Pod, objectRemoved: bool) -> void #foreign physx_lib;

PxSimulationFilterCallback_statusChange_mut :: (self__pod: *physx_PxSimulationFilterCallback_Pod, pairID_pod: *u32, pairFlags_pod: *physx_PxPairFlags_Pod, filterFlags_pod: *physx_PxFilterFlags_Pod) -> bool #foreign physx_lib;

PxQueryFilterData_new :: () -> physx_PxQueryFilterData_Pod #foreign physx_lib;

PxQueryFilterData_new_1 :: (fd_pod: *physx_PxFilterData_Pod, f_pod: physx_PxQueryFlags_Pod) -> physx_PxQueryFilterData_Pod #foreign physx_lib;

PxQueryFilterData_new_2 :: (f_pod: physx_PxQueryFlags_Pod) -> physx_PxQueryFilterData_Pod #foreign physx_lib;

PxQueryFilterCallback_preFilter_mut :: (self__pod: *physx_PxQueryFilterCallback_Pod, filterData_pod: *physx_PxFilterData_Pod, shape_pod: *physx_PxShape_Pod, actor_pod: *physx_PxRigidActor_Pod, queryFlags_pod: *physx_PxHitFlags_Pod) -> u32 #foreign physx_lib;

PxQueryFilterCallback_postFilter_mut :: (self__pod: *physx_PxQueryFilterCallback_Pod, filterData_pod: *physx_PxFilterData_Pod, hit_pod: *physx_PxQueryHit_Pod) -> u32 #foreign physx_lib;

PxQueryFilterCallback_delete :: (self__pod: *physx_PxQueryFilterCallback_Pod) -> void #foreign physx_lib;

PxBatchQueryMemory_getMaxRaycastsPerExecute :: (self__pod: *physx_PxBatchQueryMemory_Pod) -> u32 #foreign physx_lib;

PxBatchQueryMemory_getMaxSweepsPerExecute :: (self__pod: *physx_PxBatchQueryMemory_Pod) -> u32 #foreign physx_lib;

PxBatchQueryMemory_getMaxOverlapsPerExecute :: (self__pod: *physx_PxBatchQueryMemory_Pod) -> u32 #foreign physx_lib;

PxBatchQueryMemory_new :: (raycastResultBufferSize_: u32, sweepResultBufferSize_: u32, overlapResultBufferSize_: u32) -> physx_PxBatchQueryMemory_Pod #foreign physx_lib;

PxBatchQueryDesc_new :: (maxRaycastsPerExecute: u32, maxSweepsPerExecute: u32, maxOverlapsPerExecute: u32) -> physx_PxBatchQueryDesc_Pod #foreign physx_lib;

PxBatchQueryDesc_isValid :: (self__pod: *physx_PxBatchQueryDesc_Pod) -> bool #foreign physx_lib;

PxBatchQueryDesc_new_1 :: (maxRaycastsPerExecute: u32, maxSweepsPerExecute: u32, maxOverlapsPerExecute: u32) -> physx_PxBatchQueryDesc_Pod #foreign physx_lib;

PxBatchQueryDesc_isValid_1 :: (self__pod: *physx_PxBatchQueryDesc_Pod) -> bool #foreign physx_lib;

PxBatchQuery_execute_mut :: (self__pod: *physx_PxBatchQuery_Pod) -> void #foreign physx_lib;

PxBatchQuery_getPreFilterShader :: (self__pod: *physx_PxBatchQuery_Pod) -> *void #foreign physx_lib;

PxBatchQuery_getPostFilterShader :: (self__pod: *physx_PxBatchQuery_Pod) -> *void #foreign physx_lib;

PxBatchQuery_getFilterShaderData :: (self__pod: *physx_PxBatchQuery_Pod) -> *void #foreign physx_lib;

PxBatchQuery_getFilterShaderDataSize :: (self__pod: *physx_PxBatchQuery_Pod) -> u32 #foreign physx_lib;

PxBatchQuery_setUserMemory_mut :: (self__pod: *physx_PxBatchQuery_Pod, anonymous_arg0_pod: *physx_PxBatchQueryMemory_Pod) -> void #foreign physx_lib;

PxBatchQuery_getUserMemory_mut :: (self__pod: *physx_PxBatchQuery_Pod) -> *physx_PxBatchQueryMemory_Pod #foreign physx_lib;

PxBatchQuery_release_mut :: (self__pod: *physx_PxBatchQuery_Pod) -> void #foreign physx_lib;

PxBatchQuery_raycast_mut :: (self__pod: *physx_PxBatchQuery_Pod, origin_pod: *physx_PxVec3_Pod, unitDir_pod: *physx_PxVec3_Pod, distance: float, maxTouchHits: u16, hitFlags_pod: physx_PxHitFlags_Pod, filterData_pod: *physx_PxQueryFilterData_Pod, userData: *void, cache_pod: *physx_PxQueryCache_Pod) -> void #foreign physx_lib;

PxBatchQuery_overlap_mut :: (self__pod: *physx_PxBatchQuery_Pod, geometry_pod: *physx_PxGeometry_Pod, pose_pod: *physx_PxTransform_Pod, maxTouchHits: u16, filterData_pod: *physx_PxQueryFilterData_Pod, userData: *void, cache_pod: *physx_PxQueryCache_Pod) -> void #foreign physx_lib;

PxBatchQuery_sweep_mut :: (self__pod: *physx_PxBatchQuery_Pod, geometry_pod: *physx_PxGeometry_Pod, pose_pod: *physx_PxTransform_Pod, unitDir_pod: *physx_PxVec3_Pod, distance: float, maxTouchHits: u16, hitFlags_pod: physx_PxHitFlags_Pod, filterData_pod: *physx_PxQueryFilterData_Pod, userData: *void, cache_pod: *physx_PxQueryCache_Pod, inflation: float) -> void #foreign physx_lib;

PxConstraint_release_mut :: (self__pod: *physx_PxConstraint_Pod) -> void #foreign physx_lib;

PxConstraint_getScene :: (self__pod: *physx_PxConstraint_Pod) -> *physx_PxScene_Pod #foreign physx_lib;

PxConstraint_getActors :: (self__pod: *physx_PxConstraint_Pod, actor0_pod: **physx_PxRigidActor_Pod, actor1_pod: **physx_PxRigidActor_Pod) -> void #foreign physx_lib;

PxConstraint_setActors_mut :: (self__pod: *physx_PxConstraint_Pod, actor0_pod: *physx_PxRigidActor_Pod, actor1_pod: *physx_PxRigidActor_Pod) -> void #foreign physx_lib;

PxConstraint_markDirty_mut :: (self__pod: *physx_PxConstraint_Pod) -> void #foreign physx_lib;

PxConstraint_setFlags_mut :: (self__pod: *physx_PxConstraint_Pod, flags_pod: physx_PxConstraintFlags_Pod) -> void #foreign physx_lib;

PxConstraint_getFlags :: (self__pod: *physx_PxConstraint_Pod) -> physx_PxConstraintFlags_Pod #foreign physx_lib;

PxConstraint_setFlag_mut :: (self__pod: *physx_PxConstraint_Pod, flag_pod: u32, value: bool) -> void #foreign physx_lib;

PxConstraint_getForce :: (self__pod: *physx_PxConstraint_Pod, linear_pod: *physx_PxVec3_Pod, angular_pod: *physx_PxVec3_Pod) -> void #foreign physx_lib;

PxConstraint_isValid :: (self__pod: *physx_PxConstraint_Pod) -> bool #foreign physx_lib;

PxConstraint_setBreakForce_mut :: (self__pod: *physx_PxConstraint_Pod, linear: float, angular: float) -> void #foreign physx_lib;

PxConstraint_getBreakForce :: (self__pod: *physx_PxConstraint_Pod, linear_pod: *float, angular_pod: *float) -> void #foreign physx_lib;

PxConstraint_setMinResponseThreshold_mut :: (self__pod: *physx_PxConstraint_Pod, threshold: float) -> void #foreign physx_lib;

PxConstraint_getMinResponseThreshold :: (self__pod: *physx_PxConstraint_Pod) -> float #foreign physx_lib;

PxConstraint_getExternalReference_mut :: (self__pod: *physx_PxConstraint_Pod, typeID_pod: *u32) -> *void #foreign physx_lib;

PxConstraint_setConstraintFunctions_mut :: (self__pod: *physx_PxConstraint_Pod, connector_pod: *physx_PxConstraintConnector_Pod, shaders_pod: *physx_PxConstraintShaderTable_Pod) -> void #foreign physx_lib;

PxConstraint_getConcreteTypeName :: (self__pod: *physx_PxConstraint_Pod) -> *u8 #foreign physx_lib;

PxContactStreamIterator_new :: (contactPatches: *u8, contactPoints: *u8, contactFaceIndices: *u32, nbPatches: u32, nbContacts: u32) -> physx_PxContactStreamIterator_Pod #foreign physx_lib;

PxContactStreamIterator_hasNextPatch :: (self__pod: *physx_PxContactStreamIterator_Pod) -> bool #foreign physx_lib;

PxContactStreamIterator_getTotalContactCount :: (self__pod: *physx_PxContactStreamIterator_Pod) -> u32 #foreign physx_lib;

PxContactStreamIterator_getTotalPatchCount :: (self__pod: *physx_PxContactStreamIterator_Pod) -> u32 #foreign physx_lib;

PxContactStreamIterator_nextPatch_mut :: (self__pod: *physx_PxContactStreamIterator_Pod) -> void #foreign physx_lib;

PxContactStreamIterator_hasNextContact :: (self__pod: *physx_PxContactStreamIterator_Pod) -> bool #foreign physx_lib;

PxContactStreamIterator_nextContact_mut :: (self__pod: *physx_PxContactStreamIterator_Pod) -> void #foreign physx_lib;

PxContactStreamIterator_getContactNormal :: (self__pod: *physx_PxContactStreamIterator_Pod) -> *physx_PxVec3_Pod #foreign physx_lib;

PxContactStreamIterator_getInvMassScale0 :: (self__pod: *physx_PxContactStreamIterator_Pod) -> float #foreign physx_lib;

PxContactStreamIterator_getInvMassScale1 :: (self__pod: *physx_PxContactStreamIterator_Pod) -> float #foreign physx_lib;

PxContactStreamIterator_getInvInertiaScale0 :: (self__pod: *physx_PxContactStreamIterator_Pod) -> float #foreign physx_lib;

PxContactStreamIterator_getInvInertiaScale1 :: (self__pod: *physx_PxContactStreamIterator_Pod) -> float #foreign physx_lib;

PxContactStreamIterator_getMaxImpulse :: (self__pod: *physx_PxContactStreamIterator_Pod) -> float #foreign physx_lib;

PxContactStreamIterator_getTargetVel :: (self__pod: *physx_PxContactStreamIterator_Pod) -> *physx_PxVec3_Pod #foreign physx_lib;

PxContactStreamIterator_getContactPoint :: (self__pod: *physx_PxContactStreamIterator_Pod) -> *physx_PxVec3_Pod #foreign physx_lib;

PxContactStreamIterator_getSeparation :: (self__pod: *physx_PxContactStreamIterator_Pod) -> float #foreign physx_lib;

PxContactStreamIterator_getFaceIndex0 :: (self__pod: *physx_PxContactStreamIterator_Pod) -> u32 #foreign physx_lib;

PxContactStreamIterator_getFaceIndex1 :: (self__pod: *physx_PxContactStreamIterator_Pod) -> u32 #foreign physx_lib;

PxContactStreamIterator_getStaticFriction :: (self__pod: *physx_PxContactStreamIterator_Pod) -> float #foreign physx_lib;

PxContactStreamIterator_getDynamicFriction :: (self__pod: *physx_PxContactStreamIterator_Pod) -> float #foreign physx_lib;

PxContactStreamIterator_getRestitution :: (self__pod: *physx_PxContactStreamIterator_Pod) -> float #foreign physx_lib;

PxContactStreamIterator_getMaterialFlags :: (self__pod: *physx_PxContactStreamIterator_Pod) -> u32 #foreign physx_lib;

PxContactStreamIterator_getMaterialIndex0 :: (self__pod: *physx_PxContactStreamIterator_Pod) -> u16 #foreign physx_lib;

PxContactStreamIterator_getMaterialIndex1 :: (self__pod: *physx_PxContactStreamIterator_Pod) -> u16 #foreign physx_lib;

PxContactStreamIterator_advanceToIndex_mut :: (self__pod: *physx_PxContactStreamIterator_Pod, initialIndex: u32) -> bool #foreign physx_lib;

PxContactSet_getPoint :: (self__pod: *physx_PxContactSet_Pod, i: u32) -> *physx_PxVec3_Pod #foreign physx_lib;

PxContactSet_setPoint_mut :: (self__pod: *physx_PxContactSet_Pod, i: u32, p_pod: *physx_PxVec3_Pod) -> void #foreign physx_lib;

PxContactSet_getNormal :: (self__pod: *physx_PxContactSet_Pod, i: u32) -> *physx_PxVec3_Pod #foreign physx_lib;

PxContactSet_setNormal_mut :: (self__pod: *physx_PxContactSet_Pod, i: u32, n_pod: *physx_PxVec3_Pod) -> void #foreign physx_lib;

PxContactSet_getSeparation :: (self__pod: *physx_PxContactSet_Pod, i: u32) -> float #foreign physx_lib;

PxContactSet_setSeparation_mut :: (self__pod: *physx_PxContactSet_Pod, i: u32, s: float) -> void #foreign physx_lib;

PxContactSet_getTargetVelocity :: (self__pod: *physx_PxContactSet_Pod, i: u32) -> *physx_PxVec3_Pod #foreign physx_lib;

PxContactSet_setTargetVelocity_mut :: (self__pod: *physx_PxContactSet_Pod, i: u32, v_pod: *physx_PxVec3_Pod) -> void #foreign physx_lib;

PxContactSet_getInternalFaceIndex0_mut :: (self__pod: *physx_PxContactSet_Pod, i: u32) -> u32 #foreign physx_lib;

PxContactSet_getInternalFaceIndex1_mut :: (self__pod: *physx_PxContactSet_Pod, i: u32) -> u32 #foreign physx_lib;

PxContactSet_getMaxImpulse :: (self__pod: *physx_PxContactSet_Pod, i: u32) -> float #foreign physx_lib;

PxContactSet_setMaxImpulse_mut :: (self__pod: *physx_PxContactSet_Pod, i: u32, s: float) -> void #foreign physx_lib;

PxContactSet_getRestitution :: (self__pod: *physx_PxContactSet_Pod, i: u32) -> float #foreign physx_lib;

PxContactSet_setRestitution_mut :: (self__pod: *physx_PxContactSet_Pod, i: u32, r: float) -> void #foreign physx_lib;

PxContactSet_getStaticFriction :: (self__pod: *physx_PxContactSet_Pod, i: u32) -> float #foreign physx_lib;

PxContactSet_setStaticFriction_mut :: (self__pod: *physx_PxContactSet_Pod, i: u32, f: float) -> void #foreign physx_lib;

PxContactSet_getDynamicFriction :: (self__pod: *physx_PxContactSet_Pod, i: u32) -> float #foreign physx_lib;

PxContactSet_setDynamicFriction_mut :: (self__pod: *physx_PxContactSet_Pod, i: u32, f: float) -> void #foreign physx_lib;

PxContactSet_ignore_mut :: (self__pod: *physx_PxContactSet_Pod, i: u32) -> void #foreign physx_lib;

PxContactSet_size :: (self__pod: *physx_PxContactSet_Pod) -> u32 #foreign physx_lib;

PxContactSet_getInvMassScale0 :: (self__pod: *physx_PxContactSet_Pod) -> float #foreign physx_lib;

PxContactSet_getInvMassScale1 :: (self__pod: *physx_PxContactSet_Pod) -> float #foreign physx_lib;

PxContactSet_getInvInertiaScale0 :: (self__pod: *physx_PxContactSet_Pod) -> float #foreign physx_lib;

PxContactSet_getInvInertiaScale1 :: (self__pod: *physx_PxContactSet_Pod) -> float #foreign physx_lib;

PxContactSet_setInvMassScale0_mut :: (self__pod: *physx_PxContactSet_Pod, scale: float) -> void #foreign physx_lib;

PxContactSet_setInvMassScale1_mut :: (self__pod: *physx_PxContactSet_Pod, scale: float) -> void #foreign physx_lib;

PxContactSet_setInvInertiaScale0_mut :: (self__pod: *physx_PxContactSet_Pod, scale: float) -> void #foreign physx_lib;

PxContactSet_setInvInertiaScale1_mut :: (self__pod: *physx_PxContactSet_Pod, scale: float) -> void #foreign physx_lib;

PxContactModifyCallback_onContactModify_mut :: (self__pod: *physx_PxContactModifyCallback_Pod, pairs_pod: *physx_PxContactModifyPair_Pod, count: u32) -> void #foreign physx_lib;

PxCCDContactModifyCallback_onCCDContactModify_mut :: (self__pod: *physx_PxCCDContactModifyCallback_Pod, pairs_pod: *physx_PxContactModifyPair_Pod, count: u32) -> void #foreign physx_lib;

PxDeletionListener_onRelease_mut :: (self__pod: *physx_PxDeletionListener_Pod, observed_pod: *physx_PxBase_Pod, userData: *void, deletionEvent_pod: u32) -> void #foreign physx_lib;

PxLockedData_getDataAccessFlags_mut :: (self__pod: *physx_PxLockedData_Pod) -> physx_PxDataAccessFlags_Pod #foreign physx_lib;

PxLockedData_unlock_mut :: (self__pod: *physx_PxLockedData_Pod) -> void #foreign physx_lib;

PxLockedData_delete :: (self__pod: *physx_PxLockedData_Pod) -> void #foreign physx_lib;

PxMaterial_release_mut :: (self__pod: *physx_PxMaterial_Pod) -> void #foreign physx_lib;

PxMaterial_getReferenceCount :: (self__pod: *physx_PxMaterial_Pod) -> u32 #foreign physx_lib;

PxMaterial_acquireReference_mut :: (self__pod: *physx_PxMaterial_Pod) -> void #foreign physx_lib;

PxMaterial_setDynamicFriction_mut :: (self__pod: *physx_PxMaterial_Pod, coef: float) -> void #foreign physx_lib;

PxMaterial_getDynamicFriction :: (self__pod: *physx_PxMaterial_Pod) -> float #foreign physx_lib;

PxMaterial_setStaticFriction_mut :: (self__pod: *physx_PxMaterial_Pod, coef: float) -> void #foreign physx_lib;

PxMaterial_getStaticFriction :: (self__pod: *physx_PxMaterial_Pod) -> float #foreign physx_lib;

PxMaterial_setRestitution_mut :: (self__pod: *physx_PxMaterial_Pod, rest: float) -> void #foreign physx_lib;

PxMaterial_getRestitution :: (self__pod: *physx_PxMaterial_Pod) -> float #foreign physx_lib;

PxMaterial_setFlag_mut :: (self__pod: *physx_PxMaterial_Pod, flag_pod: u32, anonymous_arg1: bool) -> void #foreign physx_lib;

PxMaterial_setFlags_mut :: (self__pod: *physx_PxMaterial_Pod, inFlags_pod: physx_PxMaterialFlags_Pod) -> void #foreign physx_lib;

PxMaterial_getFlags :: (self__pod: *physx_PxMaterial_Pod) -> physx_PxMaterialFlags_Pod #foreign physx_lib;

PxMaterial_setFrictionCombineMode_mut :: (self__pod: *physx_PxMaterial_Pod, combMode_pod: u32) -> void #foreign physx_lib;

PxMaterial_getFrictionCombineMode :: (self__pod: *physx_PxMaterial_Pod) -> u32 #foreign physx_lib;

PxMaterial_setRestitutionCombineMode_mut :: (self__pod: *physx_PxMaterial_Pod, combMode_pod: u32) -> void #foreign physx_lib;

PxMaterial_getRestitutionCombineMode :: (self__pod: *physx_PxMaterial_Pod) -> u32 #foreign physx_lib;

PxMaterial_getConcreteTypeName :: (self__pod: *physx_PxMaterial_Pod) -> *u8 #foreign physx_lib;

PxPhysics_release_mut :: (self__pod: *physx_PxPhysics_Pod) -> void #foreign physx_lib;

PxPhysics_getFoundation_mut :: (self__pod: *physx_PxPhysics_Pod) -> *physx_PxFoundation_Pod #foreign physx_lib;

PxPhysics_createAggregate_mut :: (self__pod: *physx_PxPhysics_Pod, maxSize: u32, enableSelfCollision: bool) -> *physx_PxAggregate_Pod #foreign physx_lib;

PxPhysics_getTolerancesScale :: (self__pod: *physx_PxPhysics_Pod) -> *physx_PxTolerancesScale_Pod #foreign physx_lib;

PxPhysics_createTriangleMesh_mut :: (self__pod: *physx_PxPhysics_Pod, stream_pod: *physx_PxInputStream_Pod) -> *physx_PxTriangleMesh_Pod #foreign physx_lib;

PxPhysics_getNbTriangleMeshes :: (self__pod: *physx_PxPhysics_Pod) -> u32 #foreign physx_lib;

PxPhysics_getTriangleMeshes :: (self__pod: *physx_PxPhysics_Pod, userBuffer_pod: **physx_PxTriangleMesh_Pod, bufferSize: u32, startIndex: u32) -> u32 #foreign physx_lib;

PxPhysics_createHeightField_mut :: (self__pod: *physx_PxPhysics_Pod, stream_pod: *physx_PxInputStream_Pod) -> *physx_PxHeightField_Pod #foreign physx_lib;

PxPhysics_getNbHeightFields :: (self__pod: *physx_PxPhysics_Pod) -> u32 #foreign physx_lib;

PxPhysics_getHeightFields :: (self__pod: *physx_PxPhysics_Pod, userBuffer_pod: **physx_PxHeightField_Pod, bufferSize: u32, startIndex: u32) -> u32 #foreign physx_lib;

PxPhysics_createConvexMesh_mut :: (self__pod: *physx_PxPhysics_Pod, stream_pod: *physx_PxInputStream_Pod) -> *physx_PxConvexMesh_Pod #foreign physx_lib;

PxPhysics_getNbConvexMeshes :: (self__pod: *physx_PxPhysics_Pod) -> u32 #foreign physx_lib;

PxPhysics_getConvexMeshes :: (self__pod: *physx_PxPhysics_Pod, userBuffer_pod: **physx_PxConvexMesh_Pod, bufferSize: u32, startIndex: u32) -> u32 #foreign physx_lib;

PxPhysics_createBVHStructure_mut :: (self__pod: *physx_PxPhysics_Pod, stream_pod: *physx_PxInputStream_Pod) -> *physx_PxBVHStructure_Pod #foreign physx_lib;

PxPhysics_getNbBVHStructures :: (self__pod: *physx_PxPhysics_Pod) -> u32 #foreign physx_lib;

PxPhysics_getBVHStructures :: (self__pod: *physx_PxPhysics_Pod, userBuffer_pod: **physx_PxBVHStructure_Pod, bufferSize: u32, startIndex: u32) -> u32 #foreign physx_lib;

PxPhysics_createScene_mut :: (self__pod: *physx_PxPhysics_Pod, sceneDesc_pod: *physx_PxSceneDesc_Pod) -> *physx_PxScene_Pod #foreign physx_lib;

PxPhysics_getNbScenes :: (self__pod: *physx_PxPhysics_Pod) -> u32 #foreign physx_lib;

PxPhysics_getScenes :: (self__pod: *physx_PxPhysics_Pod, userBuffer_pod: **physx_PxScene_Pod, bufferSize: u32, startIndex: u32) -> u32 #foreign physx_lib;

PxPhysics_createRigidStatic_mut :: (self__pod: *physx_PxPhysics_Pod, pose_pod: *physx_PxTransform_Pod) -> *physx_PxRigidStatic_Pod #foreign physx_lib;

PxPhysics_createRigidDynamic_mut :: (self__pod: *physx_PxPhysics_Pod, pose_pod: *physx_PxTransform_Pod) -> *physx_PxRigidDynamic_Pod #foreign physx_lib;

PxPhysics_createPruningStructure_mut :: (self__pod: *physx_PxPhysics_Pod, actors_pod: **physx_PxRigidActor_Pod, nbActors: u32) -> *physx_PxPruningStructure_Pod #foreign physx_lib;

PxPhysics_createShape_mut :: (self__pod: *physx_PxPhysics_Pod, geometry_pod: *physx_PxGeometry_Pod, material_pod: *physx_PxMaterial_Pod, isExclusive: bool, shapeFlags_pod: physx_PxShapeFlags_Pod) -> *physx_PxShape_Pod #foreign physx_lib;

PxPhysics_createShape_mut_1 :: (self__pod: *physx_PxPhysics_Pod, geometry_pod: *physx_PxGeometry_Pod, materials_pod: **physx_PxMaterial_Pod, materialCount: u16, isExclusive: bool, shapeFlags_pod: physx_PxShapeFlags_Pod) -> *physx_PxShape_Pod #foreign physx_lib;

PxPhysics_getNbShapes :: (self__pod: *physx_PxPhysics_Pod) -> u32 #foreign physx_lib;

PxPhysics_getShapes :: (self__pod: *physx_PxPhysics_Pod, userBuffer_pod: **physx_PxShape_Pod, bufferSize: u32, startIndex: u32) -> u32 #foreign physx_lib;

PxPhysics_createConstraint_mut :: (self__pod: *physx_PxPhysics_Pod, actor0_pod: *physx_PxRigidActor_Pod, actor1_pod: *physx_PxRigidActor_Pod, connector_pod: *physx_PxConstraintConnector_Pod, shaders_pod: *physx_PxConstraintShaderTable_Pod, dataSize: u32) -> *physx_PxConstraint_Pod #foreign physx_lib;

PxPhysics_createArticulation_mut :: (self__pod: *physx_PxPhysics_Pod) -> *physx_PxArticulation_Pod #foreign physx_lib;

PxPhysics_createArticulationReducedCoordinate_mut :: (self__pod: *physx_PxPhysics_Pod) -> *physx_PxArticulationReducedCoordinate_Pod #foreign physx_lib;

PxPhysics_createMaterial_mut :: (self__pod: *physx_PxPhysics_Pod, staticFriction: float, dynamicFriction: float, restitution: float) -> *physx_PxMaterial_Pod #foreign physx_lib;

PxPhysics_getNbMaterials :: (self__pod: *physx_PxPhysics_Pod) -> u32 #foreign physx_lib;

PxPhysics_getMaterials :: (self__pod: *physx_PxPhysics_Pod, userBuffer_pod: **physx_PxMaterial_Pod, bufferSize: u32, startIndex: u32) -> u32 #foreign physx_lib;

PxPhysics_registerDeletionListener_mut :: (self__pod: *physx_PxPhysics_Pod, observer_pod: *physx_PxDeletionListener_Pod, deletionEvents_pod: *physx_PxDeletionEventFlags_Pod, restrictedObjectSet: bool) -> void #foreign physx_lib;

PxPhysics_unregisterDeletionListener_mut :: (self__pod: *physx_PxPhysics_Pod, observer_pod: *physx_PxDeletionListener_Pod) -> void #foreign physx_lib;

PxPhysics_registerDeletionListenerObjects_mut :: (self__pod: *physx_PxPhysics_Pod, observer_pod: *physx_PxDeletionListener_Pod, observables_pod: **physx_PxBase_Pod, observableCount: u32) -> void #foreign physx_lib;

PxPhysics_unregisterDeletionListenerObjects_mut :: (self__pod: *physx_PxPhysics_Pod, observer_pod: *physx_PxDeletionListener_Pod, observables_pod: **physx_PxBase_Pod, observableCount: u32) -> void #foreign physx_lib;

PxPhysics_getPhysicsInsertionCallback_mut :: (self__pod: *physx_PxPhysics_Pod) -> *physx_PxPhysicsInsertionCallback_Pod #foreign physx_lib;

phys_PxRegisterArticulations :: (physics_pod: *physx_PxPhysics_Pod) -> void #foreign physx_lib;

phys_PxRegisterArticulationsReducedCoordinate :: (physics_pod: *physx_PxPhysics_Pod) -> void #foreign physx_lib;

phys_PxRegisterHeightFields :: (physics_pod: *physx_PxPhysics_Pod) -> void #foreign physx_lib;

phys_PxCreateBasePhysics :: (version: u32, foundation_pod: *physx_PxFoundation_Pod, scale_pod: *physx_PxTolerancesScale_Pod, trackOutstandingAllocations: bool, pvd_pod: *physx_PxPvd_Pod) -> *physx_PxPhysics_Pod #foreign physx_lib;

phys_PxCreatePhysics :: (version: u32, foundation_pod: *physx_PxFoundation_Pod, scale_pod: *physx_PxTolerancesScale_Pod, trackOutstandingAllocations: bool, pvd_pod: *physx_PxPvd_Pod) -> *physx_PxPhysics_Pod #foreign physx_lib;

phys_PxGetPhysics :: () -> *physx_PxPhysics_Pod #foreign physx_lib;

PxRigidDynamic_setKinematicTarget_mut :: (self__pod: *physx_PxRigidDynamic_Pod, destination_pod: *physx_PxTransform_Pod) -> void #foreign physx_lib;

PxRigidDynamic_getKinematicTarget :: (self__pod: *physx_PxRigidDynamic_Pod, target_pod: *physx_PxTransform_Pod) -> bool #foreign physx_lib;

PxRigidDynamic_isSleeping :: (self__pod: *physx_PxRigidDynamic_Pod) -> bool #foreign physx_lib;

PxRigidDynamic_setSleepThreshold_mut :: (self__pod: *physx_PxRigidDynamic_Pod, threshold: float) -> void #foreign physx_lib;

PxRigidDynamic_getSleepThreshold :: (self__pod: *physx_PxRigidDynamic_Pod) -> float #foreign physx_lib;

PxRigidDynamic_setStabilizationThreshold_mut :: (self__pod: *physx_PxRigidDynamic_Pod, threshold: float) -> void #foreign physx_lib;

PxRigidDynamic_getStabilizationThreshold :: (self__pod: *physx_PxRigidDynamic_Pod) -> float #foreign physx_lib;

PxRigidDynamic_getRigidDynamicLockFlags :: (self__pod: *physx_PxRigidDynamic_Pod) -> physx_PxRigidDynamicLockFlags_Pod #foreign physx_lib;

PxRigidDynamic_setRigidDynamicLockFlag_mut :: (self__pod: *physx_PxRigidDynamic_Pod, flag_pod: u32, value: bool) -> void #foreign physx_lib;

PxRigidDynamic_setRigidDynamicLockFlags_mut :: (self__pod: *physx_PxRigidDynamic_Pod, flags_pod: physx_PxRigidDynamicLockFlags_Pod) -> void #foreign physx_lib;

PxRigidDynamic_setWakeCounter_mut :: (self__pod: *physx_PxRigidDynamic_Pod, wakeCounterValue: float) -> void #foreign physx_lib;

PxRigidDynamic_getWakeCounter :: (self__pod: *physx_PxRigidDynamic_Pod) -> float #foreign physx_lib;

PxRigidDynamic_wakeUp_mut :: (self__pod: *physx_PxRigidDynamic_Pod) -> void #foreign physx_lib;

PxRigidDynamic_putToSleep_mut :: (self__pod: *physx_PxRigidDynamic_Pod) -> void #foreign physx_lib;

PxRigidDynamic_setSolverIterationCounts_mut :: (self__pod: *physx_PxRigidDynamic_Pod, minPositionIters: u32, minVelocityIters: u32) -> void #foreign physx_lib;

PxRigidDynamic_getSolverIterationCounts :: (self__pod: *physx_PxRigidDynamic_Pod, minPositionIters_pod: *u32, minVelocityIters_pod: *u32) -> void #foreign physx_lib;

PxRigidDynamic_getContactReportThreshold :: (self__pod: *physx_PxRigidDynamic_Pod) -> float #foreign physx_lib;

PxRigidDynamic_setContactReportThreshold_mut :: (self__pod: *physx_PxRigidDynamic_Pod, threshold: float) -> void #foreign physx_lib;

PxRigidDynamic_getConcreteTypeName :: (self__pod: *physx_PxRigidDynamic_Pod) -> *u8 #foreign physx_lib;

PxRigidStatic_getConcreteTypeName :: (self__pod: *physx_PxRigidStatic_Pod) -> *u8 #foreign physx_lib;

PxBroadPhaseCallback_delete :: (self__pod: *physx_PxBroadPhaseCallback_Pod) -> void #foreign physx_lib;

PxBroadPhaseCallback_onObjectOutOfBounds_mut :: (self__pod: *physx_PxBroadPhaseCallback_Pod, shape_pod: *physx_PxShape_Pod, actor_pod: *physx_PxActor_Pod) -> void #foreign physx_lib;

PxBroadPhaseCallback_onObjectOutOfBounds_mut_1 :: (self__pod: *physx_PxBroadPhaseCallback_Pod, aggregate_pod: *physx_PxAggregate_Pod) -> void #foreign physx_lib;

PxSceneLimits_new :: () -> physx_PxSceneLimits_Pod #foreign physx_lib;

PxSceneLimits_setToDefault_mut :: (self__pod: *physx_PxSceneLimits_Pod) -> void #foreign physx_lib;

PxSceneLimits_isValid :: (self__pod: *physx_PxSceneLimits_Pod) -> bool #foreign physx_lib;

PxSceneLimits_new_1 :: () -> physx_PxSceneLimits_Pod #foreign physx_lib;

PxSceneLimits_setToDefault_mut_1 :: (self__pod: *physx_PxSceneLimits_Pod) -> void #foreign physx_lib;

PxSceneLimits_isValid_1 :: (self__pod: *physx_PxSceneLimits_Pod) -> bool #foreign physx_lib;

PxgDynamicsMemoryConfig_new :: () -> physx_PxgDynamicsMemoryConfig_Pod #foreign physx_lib;

PxSceneDesc_new :: (scale_pod: *physx_PxTolerancesScale_Pod) -> physx_PxSceneDesc_Pod #foreign physx_lib;

PxSceneDesc_setToDefault_mut :: (self__pod: *physx_PxSceneDesc_Pod, scale_pod: *physx_PxTolerancesScale_Pod) -> void #foreign physx_lib;

PxSceneDesc_isValid :: (self__pod: *physx_PxSceneDesc_Pod) -> bool #foreign physx_lib;

PxSceneDesc_getTolerancesScale :: (self__pod: *physx_PxSceneDesc_Pod) -> *physx_PxTolerancesScale_Pod #foreign physx_lib;

PxSceneDesc_new_1 :: (scale_pod: *physx_PxTolerancesScale_Pod) -> physx_PxSceneDesc_Pod #foreign physx_lib;

PxSceneDesc_setToDefault_mut_1 :: (self__pod: *physx_PxSceneDesc_Pod, scale_pod: *physx_PxTolerancesScale_Pod) -> void #foreign physx_lib;

PxSceneDesc_isValid_1 :: (self__pod: *physx_PxSceneDesc_Pod) -> bool #foreign physx_lib;

PxSimulationStatistics_getNbBroadPhaseAdds :: (self__pod: *physx_PxSimulationStatistics_Pod) -> u32 #foreign physx_lib;

PxSimulationStatistics_getNbBroadPhaseRemoves :: (self__pod: *physx_PxSimulationStatistics_Pod) -> u32 #foreign physx_lib;

PxSimulationStatistics_getRbPairStats :: (self__pod: *physx_PxSimulationStatistics_Pod, pairType_pod: u32, g0_pod: s32, g1_pod: s32) -> u32 #foreign physx_lib;

PxSimulationStatistics_new :: () -> physx_PxSimulationStatistics_Pod #foreign physx_lib;

PxPvdSceneClient_setScenePvdFlag_mut :: (self__pod: *physx_PxPvdSceneClient_Pod, flag_pod: u32, value: bool) -> void #foreign physx_lib;

PxPvdSceneClient_setScenePvdFlags_mut :: (self__pod: *physx_PxPvdSceneClient_Pod, flags_pod: physx_PxPvdSceneFlags_Pod) -> void #foreign physx_lib;

PxPvdSceneClient_getScenePvdFlags :: (self__pod: *physx_PxPvdSceneClient_Pod) -> physx_PxPvdSceneFlags_Pod #foreign physx_lib;

PxPvdSceneClient_updateCamera_mut :: (self__pod: *physx_PxPvdSceneClient_Pod, name: *u8, origin_pod: *physx_PxVec3_Pod, up_pod: *physx_PxVec3_Pod, target_pod: *physx_PxVec3_Pod) -> void #foreign physx_lib;

PxPvdSceneClient_drawPoints_mut :: (self__pod: *physx_PxPvdSceneClient_Pod, points_pod: *physx_pvdsdk_PvdDebugPoint_Pod, count: u32) -> void #foreign physx_lib;

PxPvdSceneClient_drawLines_mut :: (self__pod: *physx_PxPvdSceneClient_Pod, lines_pod: *physx_pvdsdk_PvdDebugLine_Pod, count: u32) -> void #foreign physx_lib;

PxPvdSceneClient_drawTriangles_mut :: (self__pod: *physx_PxPvdSceneClient_Pod, triangles_pod: *physx_pvdsdk_PvdDebugTriangle_Pod, count: u32) -> void #foreign physx_lib;

PxPvdSceneClient_drawText_mut :: (self__pod: *physx_PxPvdSceneClient_Pod, text_pod: *physx_pvdsdk_PvdDebugText_Pod) -> void #foreign physx_lib;

PxPvdSceneClient_getClientInternal_mut :: (self__pod: *physx_PxPvdSceneClient_Pod) -> *physx_pvdsdk_PvdClient_Pod #foreign physx_lib;

PxDominanceGroupPair_new :: (a: u8, b: u8) -> physx_PxDominanceGroupPair_Pod #foreign physx_lib;

PxQueryCache_new :: () -> physx_PxQueryCache_Pod #foreign physx_lib;

PxQueryCache_new_1 :: (s_pod: *physx_PxShape_Pod, findex: u32) -> physx_PxQueryCache_Pod #foreign physx_lib;

PxScene_release_mut :: (self__pod: *physx_PxScene_Pod) -> void #foreign physx_lib;

PxScene_setFlag_mut :: (self__pod: *physx_PxScene_Pod, flag_pod: u32, value: bool) -> void #foreign physx_lib;

PxScene_getFlags :: (self__pod: *physx_PxScene_Pod) -> physx_PxSceneFlags_Pod #foreign physx_lib;

PxScene_setLimits_mut :: (self__pod: *physx_PxScene_Pod, limits_pod: *physx_PxSceneLimits_Pod) -> void #foreign physx_lib;

PxScene_getLimits :: (self__pod: *physx_PxScene_Pod) -> physx_PxSceneLimits_Pod #foreign physx_lib;

PxScene_getPhysics_mut :: (self__pod: *physx_PxScene_Pod) -> *physx_PxPhysics_Pod #foreign physx_lib;

PxScene_getTimestamp :: (self__pod: *physx_PxScene_Pod) -> u32 #foreign physx_lib;

PxScene_addArticulation_mut :: (self__pod: *physx_PxScene_Pod, articulation_pod: *physx_PxArticulationBase_Pod) -> void #foreign physx_lib;

PxScene_removeArticulation_mut :: (self__pod: *physx_PxScene_Pod, articulation_pod: *physx_PxArticulationBase_Pod, wakeOnLostTouch: bool) -> void #foreign physx_lib;

PxScene_addActor_mut :: (self__pod: *physx_PxScene_Pod, actor_pod: *physx_PxActor_Pod, bvhStructure_pod: *physx_PxBVHStructure_Pod) -> void #foreign physx_lib;

PxScene_addActors_mut :: (self__pod: *physx_PxScene_Pod, actors_pod: **physx_PxActor_Pod, nbActors: u32) -> void #foreign physx_lib;

PxScene_addActors_mut_1 :: (self__pod: *physx_PxScene_Pod, pruningStructure_pod: *physx_PxPruningStructure_Pod) -> void #foreign physx_lib;

PxScene_removeActor_mut :: (self__pod: *physx_PxScene_Pod, actor_pod: *physx_PxActor_Pod, wakeOnLostTouch: bool) -> void #foreign physx_lib;

PxScene_removeActors_mut :: (self__pod: *physx_PxScene_Pod, actors_pod: **physx_PxActor_Pod, nbActors: u32, wakeOnLostTouch: bool) -> void #foreign physx_lib;

PxScene_addAggregate_mut :: (self__pod: *physx_PxScene_Pod, aggregate_pod: *physx_PxAggregate_Pod) -> void #foreign physx_lib;

PxScene_removeAggregate_mut :: (self__pod: *physx_PxScene_Pod, aggregate_pod: *physx_PxAggregate_Pod, wakeOnLostTouch: bool) -> void #foreign physx_lib;

PxScene_addCollection_mut :: (self__pod: *physx_PxScene_Pod, collection_pod: *physx_PxCollection_Pod) -> void #foreign physx_lib;

PxScene_getNbActors :: (self__pod: *physx_PxScene_Pod, types_pod: physx_PxActorTypeFlags_Pod) -> u32 #foreign physx_lib;

PxScene_getActors :: (self__pod: *physx_PxScene_Pod, types_pod: physx_PxActorTypeFlags_Pod, userBuffer_pod: **physx_PxActor_Pod, bufferSize: u32, startIndex: u32) -> u32 #foreign physx_lib;

PxScene_getActiveActors_mut :: (self__pod: *physx_PxScene_Pod, nbActorsOut_pod: *u32) -> **physx_PxActor_Pod #foreign physx_lib;

PxScene_getNbArticulations :: (self__pod: *physx_PxScene_Pod) -> u32 #foreign physx_lib;

PxScene_getArticulations :: (self__pod: *physx_PxScene_Pod, userBuffer_pod: **physx_PxArticulationBase_Pod, bufferSize: u32, startIndex: u32) -> u32 #foreign physx_lib;

PxScene_getNbConstraints :: (self__pod: *physx_PxScene_Pod) -> u32 #foreign physx_lib;

PxScene_getConstraints :: (self__pod: *physx_PxScene_Pod, userBuffer_pod: **physx_PxConstraint_Pod, bufferSize: u32, startIndex: u32) -> u32 #foreign physx_lib;

PxScene_getNbAggregates :: (self__pod: *physx_PxScene_Pod) -> u32 #foreign physx_lib;

PxScene_getAggregates :: (self__pod: *physx_PxScene_Pod, userBuffer_pod: **physx_PxAggregate_Pod, bufferSize: u32, startIndex: u32) -> u32 #foreign physx_lib;

PxScene_setDominanceGroupPair_mut :: (self__pod: *physx_PxScene_Pod, group1: u8, group2: u8, dominance_pod: *physx_PxDominanceGroupPair_Pod) -> void #foreign physx_lib;

PxScene_getDominanceGroupPair :: (self__pod: *physx_PxScene_Pod, group1: u8, group2: u8) -> physx_PxDominanceGroupPair_Pod #foreign physx_lib;

PxScene_getCpuDispatcher :: (self__pod: *physx_PxScene_Pod) -> *physx_PxCpuDispatcher_Pod #foreign physx_lib;

PxScene_getCudaContextManager :: (self__pod: *physx_PxScene_Pod) -> *physx_PxCudaContextManager_Pod #foreign physx_lib;

PxScene_createClient_mut :: (self__pod: *physx_PxScene_Pod) -> u8 #foreign physx_lib;

PxScene_setSimulationEventCallback_mut :: (self__pod: *physx_PxScene_Pod, callback_pod: *physx_PxSimulationEventCallback_Pod) -> void #foreign physx_lib;

PxScene_getSimulationEventCallback :: (self__pod: *physx_PxScene_Pod) -> *physx_PxSimulationEventCallback_Pod #foreign physx_lib;

PxScene_setContactModifyCallback_mut :: (self__pod: *physx_PxScene_Pod, callback_pod: *physx_PxContactModifyCallback_Pod) -> void #foreign physx_lib;

PxScene_setCCDContactModifyCallback_mut :: (self__pod: *physx_PxScene_Pod, callback_pod: *physx_PxCCDContactModifyCallback_Pod) -> void #foreign physx_lib;

PxScene_getContactModifyCallback :: (self__pod: *physx_PxScene_Pod) -> *physx_PxContactModifyCallback_Pod #foreign physx_lib;

PxScene_getCCDContactModifyCallback :: (self__pod: *physx_PxScene_Pod) -> *physx_PxCCDContactModifyCallback_Pod #foreign physx_lib;

PxScene_setBroadPhaseCallback_mut :: (self__pod: *physx_PxScene_Pod, callback_pod: *physx_PxBroadPhaseCallback_Pod) -> void #foreign physx_lib;

PxScene_getBroadPhaseCallback :: (self__pod: *physx_PxScene_Pod) -> *physx_PxBroadPhaseCallback_Pod #foreign physx_lib;

PxScene_setFilterShaderData_mut :: (self__pod: *physx_PxScene_Pod, data: *void, dataSize: u32) -> void #foreign physx_lib;

PxScene_getFilterShaderData :: (self__pod: *physx_PxScene_Pod) -> *void #foreign physx_lib;

PxScene_getFilterShaderDataSize :: (self__pod: *physx_PxScene_Pod) -> u32 #foreign physx_lib;

PxScene_getFilterShader :: (self__pod: *physx_PxScene_Pod) -> *void #foreign physx_lib;

PxScene_getFilterCallback :: (self__pod: *physx_PxScene_Pod) -> *physx_PxSimulationFilterCallback_Pod #foreign physx_lib;

PxScene_resetFiltering_mut :: (self__pod: *physx_PxScene_Pod, actor_pod: *physx_PxActor_Pod) -> void #foreign physx_lib;

PxScene_resetFiltering_mut_1 :: (self__pod: *physx_PxScene_Pod, actor_pod: *physx_PxRigidActor_Pod, shapes_pod: **physx_PxShape_Pod, shapeCount: u32) -> void #foreign physx_lib;

PxScene_getKinematicKinematicFilteringMode :: (self__pod: *physx_PxScene_Pod) -> u32 #foreign physx_lib;

PxScene_getStaticKinematicFilteringMode :: (self__pod: *physx_PxScene_Pod) -> u32 #foreign physx_lib;

PxScene_simulate_mut :: (self__pod: *physx_PxScene_Pod, elapsedTime: float, completionTask_pod: *physx_PxBaseTask_Pod, scratchMemBlock: *void, scratchMemBlockSize: u32, controlSimulation: bool) -> void #foreign physx_lib;

PxScene_advance_mut :: (self__pod: *physx_PxScene_Pod, completionTask_pod: *physx_PxBaseTask_Pod) -> void #foreign physx_lib;

PxScene_collide_mut :: (self__pod: *physx_PxScene_Pod, elapsedTime: float, completionTask_pod: *physx_PxBaseTask_Pod, scratchMemBlock: *void, scratchMemBlockSize: u32, controlSimulation: bool) -> void #foreign physx_lib;

PxScene_checkResults_mut :: (self__pod: *physx_PxScene_Pod, block: bool) -> bool #foreign physx_lib;

PxScene_fetchCollision_mut :: (self__pod: *physx_PxScene_Pod, block: bool) -> bool #foreign physx_lib;

PxScene_fetchResults_mut :: (self__pod: *physx_PxScene_Pod, block: bool, errorState: *u32) -> bool #foreign physx_lib;

PxScene_fetchResultsStart_mut :: (self__pod: *physx_PxScene_Pod, contactPairs_pod: **physx_PxContactPairHeader_Pod, nbContactPairs_pod: *u32, block: bool) -> bool #foreign physx_lib;

PxScene_processCallbacks_mut :: (self__pod: *physx_PxScene_Pod, continuation_pod: *physx_PxBaseTask_Pod) -> void #foreign physx_lib;

PxScene_fetchResultsFinish_mut :: (self__pod: *physx_PxScene_Pod, errorState: *u32) -> void #foreign physx_lib;

PxScene_flushSimulation_mut :: (self__pod: *physx_PxScene_Pod, sendPendingReports: bool) -> void #foreign physx_lib;

PxScene_setGravity_mut :: (self__pod: *physx_PxScene_Pod, vec_pod: *physx_PxVec3_Pod) -> void #foreign physx_lib;

PxScene_getGravity :: (self__pod: *physx_PxScene_Pod) -> physx_PxVec3_Pod #foreign physx_lib;

PxScene_setBounceThresholdVelocity_mut :: (self__pod: *physx_PxScene_Pod, t: float) -> void #foreign physx_lib;

PxScene_getBounceThresholdVelocity :: (self__pod: *physx_PxScene_Pod) -> float #foreign physx_lib;

PxScene_setCCDMaxPasses_mut :: (self__pod: *physx_PxScene_Pod, ccdMaxPasses: u32) -> void #foreign physx_lib;

PxScene_getCCDMaxPasses :: (self__pod: *physx_PxScene_Pod) -> u32 #foreign physx_lib;

PxScene_getFrictionOffsetThreshold :: (self__pod: *physx_PxScene_Pod) -> float #foreign physx_lib;

PxScene_setFrictionType_mut :: (self__pod: *physx_PxScene_Pod, frictionType_pod: u32) -> void #foreign physx_lib;

PxScene_getFrictionType :: (self__pod: *physx_PxScene_Pod) -> u32 #foreign physx_lib;

PxScene_setVisualizationParameter_mut :: (self__pod: *physx_PxScene_Pod, param_pod: u32, value: float) -> bool #foreign physx_lib;

PxScene_getVisualizationParameter :: (self__pod: *physx_PxScene_Pod, paramEnum_pod: u32) -> float #foreign physx_lib;

PxScene_setVisualizationCullingBox_mut :: (self__pod: *physx_PxScene_Pod, box_pod: *physx_PxBounds3_Pod) -> void #foreign physx_lib;

PxScene_getVisualizationCullingBox :: (self__pod: *physx_PxScene_Pod) -> physx_PxBounds3_Pod #foreign physx_lib;

PxScene_getRenderBuffer_mut :: (self__pod: *physx_PxScene_Pod) -> *physx_PxRenderBuffer_Pod #foreign physx_lib;

PxScene_getSimulationStatistics :: (self__pod: *physx_PxScene_Pod, stats_pod: *physx_PxSimulationStatistics_Pod) -> void #foreign physx_lib;

PxScene_getStaticStructure :: (self__pod: *physx_PxScene_Pod) -> u32 #foreign physx_lib;

PxScene_getDynamicStructure :: (self__pod: *physx_PxScene_Pod) -> u32 #foreign physx_lib;

PxScene_flushQueryUpdates_mut :: (self__pod: *physx_PxScene_Pod) -> void #foreign physx_lib;

PxScene_createBatchQuery_mut :: (self__pod: *physx_PxScene_Pod, desc_pod: *physx_PxBatchQueryDesc_Pod) -> *physx_PxBatchQuery_Pod #foreign physx_lib;

PxScene_setDynamicTreeRebuildRateHint_mut :: (self__pod: *physx_PxScene_Pod, dynamicTreeRebuildRateHint: u32) -> void #foreign physx_lib;

PxScene_getDynamicTreeRebuildRateHint :: (self__pod: *physx_PxScene_Pod) -> u32 #foreign physx_lib;

PxScene_forceDynamicTreeRebuild_mut :: (self__pod: *physx_PxScene_Pod, rebuildStaticStructure: bool, rebuildDynamicStructure: bool) -> void #foreign physx_lib;

PxScene_setSceneQueryUpdateMode_mut :: (self__pod: *physx_PxScene_Pod, updateMode_pod: u32) -> void #foreign physx_lib;

PxScene_getSceneQueryUpdateMode :: (self__pod: *physx_PxScene_Pod) -> u32 #foreign physx_lib;

PxScene_sceneQueriesUpdate_mut :: (self__pod: *physx_PxScene_Pod, completionTask_pod: *physx_PxBaseTask_Pod, controlSimulation: bool) -> void #foreign physx_lib;

PxScene_checkQueries_mut :: (self__pod: *physx_PxScene_Pod, block: bool) -> bool #foreign physx_lib;

PxScene_fetchQueries_mut :: (self__pod: *physx_PxScene_Pod, block: bool) -> bool #foreign physx_lib;

PxScene_raycast :: (self__pod: *physx_PxScene_Pod, origin_pod: *physx_PxVec3_Pod, unitDir_pod: *physx_PxVec3_Pod, distance: float, hitCall_pod: *physx_PxRaycastCallback_Pod, hitFlags_pod: physx_PxHitFlags_Pod, filterData_pod: *physx_PxQueryFilterData_Pod, filterCall_pod: *physx_PxQueryFilterCallback_Pod, cache_pod: *physx_PxQueryCache_Pod) -> bool #foreign physx_lib;

PxScene_sweep :: (self__pod: *physx_PxScene_Pod, geometry_pod: *physx_PxGeometry_Pod, pose_pod: *physx_PxTransform_Pod, unitDir_pod: *physx_PxVec3_Pod, distance: float, hitCall_pod: *physx_PxSweepCallback_Pod, hitFlags_pod: physx_PxHitFlags_Pod, filterData_pod: *physx_PxQueryFilterData_Pod, filterCall_pod: *physx_PxQueryFilterCallback_Pod, cache_pod: *physx_PxQueryCache_Pod, inflation: float) -> bool #foreign physx_lib;

PxScene_overlap :: (self__pod: *physx_PxScene_Pod, geometry_pod: *physx_PxGeometry_Pod, pose_pod: *physx_PxTransform_Pod, hitCall_pod: *physx_PxOverlapCallback_Pod, filterData_pod: *physx_PxQueryFilterData_Pod, filterCall_pod: *physx_PxQueryFilterCallback_Pod) -> bool #foreign physx_lib;

PxScene_getSceneQueryStaticTimestamp :: (self__pod: *physx_PxScene_Pod) -> u32 #foreign physx_lib;

PxScene_getBroadPhaseType :: (self__pod: *physx_PxScene_Pod) -> u32 #foreign physx_lib;

PxScene_getBroadPhaseCaps :: (self__pod: *physx_PxScene_Pod, caps_pod: *physx_PxBroadPhaseCaps_Pod) -> bool #foreign physx_lib;

PxScene_getNbBroadPhaseRegions :: (self__pod: *physx_PxScene_Pod) -> u32 #foreign physx_lib;

PxScene_getBroadPhaseRegions :: (self__pod: *physx_PxScene_Pod, userBuffer_pod: *physx_PxBroadPhaseRegionInfo_Pod, bufferSize: u32, startIndex: u32) -> u32 #foreign physx_lib;

PxScene_addBroadPhaseRegion_mut :: (self__pod: *physx_PxScene_Pod, region_pod: *physx_PxBroadPhaseRegion_Pod, populateRegion: bool) -> u32 #foreign physx_lib;

PxScene_removeBroadPhaseRegion_mut :: (self__pod: *physx_PxScene_Pod, handle: u32) -> bool #foreign physx_lib;

PxScene_getTaskManager :: (self__pod: *physx_PxScene_Pod) -> *physx_PxTaskManager_Pod #foreign physx_lib;

PxScene_lockRead_mut :: (self__pod: *physx_PxScene_Pod, file: *u8, line: u32) -> void #foreign physx_lib;

PxScene_unlockRead_mut :: (self__pod: *physx_PxScene_Pod) -> void #foreign physx_lib;

PxScene_lockWrite_mut :: (self__pod: *physx_PxScene_Pod, file: *u8, line: u32) -> void #foreign physx_lib;

PxScene_unlockWrite_mut :: (self__pod: *physx_PxScene_Pod) -> void #foreign physx_lib;

PxScene_setNbContactDataBlocks_mut :: (self__pod: *physx_PxScene_Pod, numBlocks: u32) -> void #foreign physx_lib;

PxScene_getNbContactDataBlocksUsed :: (self__pod: *physx_PxScene_Pod) -> u32 #foreign physx_lib;

PxScene_getMaxNbContactDataBlocksUsed :: (self__pod: *physx_PxScene_Pod) -> u32 #foreign physx_lib;

PxScene_getContactReportStreamBufferSize :: (self__pod: *physx_PxScene_Pod) -> u32 #foreign physx_lib;

PxScene_setSolverBatchSize_mut :: (self__pod: *physx_PxScene_Pod, solverBatchSize: u32) -> void #foreign physx_lib;

PxScene_getSolverBatchSize :: (self__pod: *physx_PxScene_Pod) -> u32 #foreign physx_lib;

PxScene_setSolverArticulationBatchSize_mut :: (self__pod: *physx_PxScene_Pod, solverBatchSize: u32) -> void #foreign physx_lib;

PxScene_getSolverArticulationBatchSize :: (self__pod: *physx_PxScene_Pod) -> u32 #foreign physx_lib;

PxScene_getWakeCounterResetValue :: (self__pod: *physx_PxScene_Pod) -> float #foreign physx_lib;

PxScene_shiftOrigin_mut :: (self__pod: *physx_PxScene_Pod, shift_pod: *physx_PxVec3_Pod) -> void #foreign physx_lib;

PxScene_getScenePvdClient_mut :: (self__pod: *physx_PxScene_Pod) -> *physx_PxPvdSceneClient_Pod #foreign physx_lib;

PxSceneReadLock_new_alloc :: (scene_pod: *physx_PxScene_Pod, file: *u8, line: u32) -> *physx_PxSceneReadLock_Pod #foreign physx_lib;

PxSceneReadLock_delete :: (self__pod: *physx_PxSceneReadLock_Pod) -> void #foreign physx_lib;

PxSceneWriteLock_new_alloc :: (scene_pod: *physx_PxScene_Pod, file: *u8, line: u32) -> *physx_PxSceneWriteLock_Pod #foreign physx_lib;

PxSceneWriteLock_delete :: (self__pod: *physx_PxSceneWriteLock_Pod) -> void #foreign physx_lib;

PxContactPairExtraDataItem_new :: () -> physx_PxContactPairExtraDataItem_Pod #foreign physx_lib;

PxContactPairVelocity_new :: () -> physx_PxContactPairVelocity_Pod #foreign physx_lib;

PxContactPairPose_new :: () -> physx_PxContactPairPose_Pod #foreign physx_lib;

PxContactPairIndex_new :: () -> physx_PxContactPairIndex_Pod #foreign physx_lib;

PxContactPairExtraDataIterator_new :: (stream: *u8, size: u32) -> physx_PxContactPairExtraDataIterator_Pod #foreign physx_lib;

PxContactPairExtraDataIterator_nextItemSet_mut :: (self__pod: *physx_PxContactPairExtraDataIterator_Pod) -> bool #foreign physx_lib;

PxContactPairHeader_new :: () -> physx_PxContactPairHeader_Pod #foreign physx_lib;

PxContactPair_new :: () -> physx_PxContactPair_Pod #foreign physx_lib;

PxContactPair_extractContacts :: (self__pod: *physx_PxContactPair_Pod, userBuffer_pod: *physx_PxContactPairPoint_Pod, bufferSize: u32) -> u32 #foreign physx_lib;

PxContactPair_bufferContacts :: (self__pod: *physx_PxContactPair_Pod, newPair_pod: *physx_PxContactPair_Pod, bufferMemory: *u8) -> void #foreign physx_lib;

PxContactPair_getInternalFaceIndices :: (self__pod: *physx_PxContactPair_Pod) -> *u32 #foreign physx_lib;

PxContactPair_extractContacts_1 :: (self__pod: *physx_PxContactPair_Pod, userBuffer_pod: *physx_PxContactPairPoint_Pod, bufferSize: u32) -> u32 #foreign physx_lib;

PxContactPair_bufferContacts_1 :: (self__pod: *physx_PxContactPair_Pod, newPair_pod: *physx_PxContactPair_Pod, bufferMemory: *u8) -> void #foreign physx_lib;

PxContactPair_getInternalFaceIndices_1 :: (self__pod: *physx_PxContactPair_Pod) -> *u32 #foreign physx_lib;

PxTriggerPair_new :: () -> physx_PxTriggerPair_Pod #foreign physx_lib;

PxConstraintInfo_new :: () -> physx_PxConstraintInfo_Pod #foreign physx_lib;

PxConstraintInfo_new_1 :: (c_pod: *physx_PxConstraint_Pod, extRef: *void, t: u32) -> physx_PxConstraintInfo_Pod #foreign physx_lib;

PxSimulationEventCallback_onConstraintBreak_mut :: (self__pod: *physx_PxSimulationEventCallback_Pod, constraints_pod: *physx_PxConstraintInfo_Pod, count: u32) -> void #foreign physx_lib;

PxSimulationEventCallback_onWake_mut :: (self__pod: *physx_PxSimulationEventCallback_Pod, actors_pod: **physx_PxActor_Pod, count: u32) -> void #foreign physx_lib;

PxSimulationEventCallback_onSleep_mut :: (self__pod: *physx_PxSimulationEventCallback_Pod, actors_pod: **physx_PxActor_Pod, count: u32) -> void #foreign physx_lib;

PxSimulationEventCallback_onContact_mut :: (self__pod: *physx_PxSimulationEventCallback_Pod, pairHeader_pod: *physx_PxContactPairHeader_Pod, pairs_pod: *physx_PxContactPair_Pod, nbPairs: u32) -> void #foreign physx_lib;

PxSimulationEventCallback_onTrigger_mut :: (self__pod: *physx_PxSimulationEventCallback_Pod, pairs_pod: *physx_PxTriggerPair_Pod, count: u32) -> void #foreign physx_lib;

PxSimulationEventCallback_onAdvance_mut :: (self__pod: *physx_PxSimulationEventCallback_Pod, bodyBuffer_pod: **physx_PxRigidBody_Pod, poseBuffer_pod: *physx_PxTransform_Pod, count: u32) -> void #foreign physx_lib;

PxSimulationEventCallback_delete :: (self__pod: *physx_PxSimulationEventCallback_Pod) -> void #foreign physx_lib;

PxPruningStructure_release_mut :: (self__pod: *physx_PxPruningStructure_Pod) -> void #foreign physx_lib;

PxPruningStructure_getRigidActors :: (self__pod: *physx_PxPruningStructure_Pod, userBuffer_pod: **physx_PxRigidActor_Pod, bufferSize: u32, startIndex: u32) -> u32 #foreign physx_lib;

PxPruningStructure_getNbRigidActors :: (self__pod: *physx_PxPruningStructure_Pod) -> u32 #foreign physx_lib;

PxPruningStructure_getConcreteTypeName :: (self__pod: *physx_PxPruningStructure_Pod) -> *u8 #foreign physx_lib;

PxExtendedVec3_new :: () -> physx_PxExtendedVec3_Pod #foreign physx_lib;

PxExtendedVec3_new_1 :: (_x: float64, _y: float64, _z: float64) -> physx_PxExtendedVec3_Pod #foreign physx_lib;

PxExtendedVec3_isZero :: (self__pod: *physx_PxExtendedVec3_Pod) -> bool #foreign physx_lib;

PxExtendedVec3_dot :: (self__pod: *physx_PxExtendedVec3_Pod, v_pod: *physx_PxVec3_Pod) -> float64 #foreign physx_lib;

PxExtendedVec3_distanceSquared :: (self__pod: *physx_PxExtendedVec3_Pod, v_pod: *physx_PxExtendedVec3_Pod) -> float64 #foreign physx_lib;

PxExtendedVec3_magnitudeSquared :: (self__pod: *physx_PxExtendedVec3_Pod) -> float64 #foreign physx_lib;

PxExtendedVec3_magnitude :: (self__pod: *physx_PxExtendedVec3_Pod) -> float64 #foreign physx_lib;

PxExtendedVec3_normalize_mut :: (self__pod: *physx_PxExtendedVec3_Pod) -> float64 #foreign physx_lib;

PxExtendedVec3_isFinite :: (self__pod: *physx_PxExtendedVec3_Pod) -> bool #foreign physx_lib;

PxExtendedVec3_maximum_mut :: (self__pod: *physx_PxExtendedVec3_Pod, v_pod: *physx_PxExtendedVec3_Pod) -> void #foreign physx_lib;

PxExtendedVec3_minimum_mut :: (self__pod: *physx_PxExtendedVec3_Pod, v_pod: *physx_PxExtendedVec3_Pod) -> void #foreign physx_lib;

PxExtendedVec3_set_mut :: (self__pod: *physx_PxExtendedVec3_Pod, x_: float64, y_: float64, z_: float64) -> void #foreign physx_lib;

PxExtendedVec3_setPlusInfinity_mut :: (self__pod: *physx_PxExtendedVec3_Pod) -> void #foreign physx_lib;

PxExtendedVec3_setMinusInfinity_mut :: (self__pod: *physx_PxExtendedVec3_Pod) -> void #foreign physx_lib;

PxExtendedVec3_cross_mut :: (self__pod: *physx_PxExtendedVec3_Pod, left_pod: *physx_PxExtendedVec3_Pod, right_pod: *physx_PxVec3_Pod) -> void #foreign physx_lib;

PxExtendedVec3_cross_mut_1 :: (self__pod: *physx_PxExtendedVec3_Pod, left_pod: *physx_PxExtendedVec3_Pod, right_pod: *physx_PxExtendedVec3_Pod) -> void #foreign physx_lib;

PxExtendedVec3_cross :: (self__pod: *physx_PxExtendedVec3_Pod, v_pod: *physx_PxExtendedVec3_Pod) -> physx_PxExtendedVec3_Pod #foreign physx_lib;

PxExtendedVec3_cross_mut_2 :: (self__pod: *physx_PxExtendedVec3_Pod, left_pod: *physx_PxVec3_Pod, right_pod: *physx_PxExtendedVec3_Pod) -> void #foreign physx_lib;

PxObstacle_getType :: (self__pod: *physx_PxObstacle_Pod) -> s32 #foreign physx_lib;

PxBoxObstacle_new :: () -> physx_PxBoxObstacle_Pod #foreign physx_lib;

PxCapsuleObstacle_new :: () -> physx_PxCapsuleObstacle_Pod #foreign physx_lib;

PxObstacleContext_release_mut :: (self__pod: *physx_PxObstacleContext_Pod) -> void #foreign physx_lib;

PxObstacleContext_getControllerManager :: (self__pod: *physx_PxObstacleContext_Pod) -> *physx_PxControllerManager_Pod #foreign physx_lib;

PxObstacleContext_addObstacle_mut :: (self__pod: *physx_PxObstacleContext_Pod, obstacle_pod: *physx_PxObstacle_Pod) -> u32 #foreign physx_lib;

PxObstacleContext_removeObstacle_mut :: (self__pod: *physx_PxObstacleContext_Pod, handle: u32) -> bool #foreign physx_lib;

PxObstacleContext_updateObstacle_mut :: (self__pod: *physx_PxObstacleContext_Pod, handle: u32, obstacle_pod: *physx_PxObstacle_Pod) -> bool #foreign physx_lib;

PxObstacleContext_getNbObstacles :: (self__pod: *physx_PxObstacleContext_Pod) -> u32 #foreign physx_lib;

PxObstacleContext_getObstacle :: (self__pod: *physx_PxObstacleContext_Pod, i: u32) -> *physx_PxObstacle_Pod #foreign physx_lib;

PxObstacleContext_getObstacleByHandle :: (self__pod: *physx_PxObstacleContext_Pod, handle: u32) -> *physx_PxObstacle_Pod #foreign physx_lib;

PxUserControllerHitReport_onShapeHit_mut :: (self__pod: *physx_PxUserControllerHitReport_Pod, hit_pod: *physx_PxControllerShapeHit_Pod) -> void #foreign physx_lib;

PxUserControllerHitReport_onControllerHit_mut :: (self__pod: *physx_PxUserControllerHitReport_Pod, hit_pod: *physx_PxControllersHit_Pod) -> void #foreign physx_lib;

PxUserControllerHitReport_onObstacleHit_mut :: (self__pod: *physx_PxUserControllerHitReport_Pod, hit_pod: *physx_PxControllerObstacleHit_Pod) -> void #foreign physx_lib;

PxControllerFilterCallback_delete :: (self__pod: *physx_PxControllerFilterCallback_Pod) -> void #foreign physx_lib;

PxControllerFilterCallback_filter_mut :: (self__pod: *physx_PxControllerFilterCallback_Pod, a_pod: *physx_PxController_Pod, b_pod: *physx_PxController_Pod) -> bool #foreign physx_lib;

PxControllerFilters_new :: (filterData_pod: *physx_PxFilterData_Pod, cb_pod: *physx_PxQueryFilterCallback_Pod, cctFilterCb_pod: *physx_PxControllerFilterCallback_Pod) -> physx_PxControllerFilters_Pod #foreign physx_lib;

PxControllerDesc_isValid :: (self__pod: *physx_PxControllerDesc_Pod) -> bool #foreign physx_lib;

PxControllerDesc_getType :: (self__pod: *physx_PxControllerDesc_Pod) -> u32 #foreign physx_lib;

PxControllerDesc_isValid_1 :: (self__pod: *physx_PxControllerDesc_Pod) -> bool #foreign physx_lib;

PxController_getType :: (self__pod: *physx_PxController_Pod) -> u32 #foreign physx_lib;

PxController_release_mut :: (self__pod: *physx_PxController_Pod) -> void #foreign physx_lib;

PxController_move_mut :: (self__pod: *physx_PxController_Pod, disp_pod: *physx_PxVec3_Pod, minDist: float, elapsedTime: float, filters_pod: *physx_PxControllerFilters_Pod, obstacles_pod: *physx_PxObstacleContext_Pod) -> physx_PxControllerCollisionFlags_Pod #foreign physx_lib;

PxController_setPosition_mut :: (self__pod: *physx_PxController_Pod, position_pod: *physx_PxExtendedVec3_Pod) -> bool #foreign physx_lib;

PxController_getPosition :: (self__pod: *physx_PxController_Pod) -> *physx_PxExtendedVec3_Pod #foreign physx_lib;

PxController_setFootPosition_mut :: (self__pod: *physx_PxController_Pod, position_pod: *physx_PxExtendedVec3_Pod) -> bool #foreign physx_lib;

PxController_getFootPosition :: (self__pod: *physx_PxController_Pod) -> physx_PxExtendedVec3_Pod #foreign physx_lib;

PxController_getActor :: (self__pod: *physx_PxController_Pod) -> *physx_PxRigidDynamic_Pod #foreign physx_lib;

PxController_setStepOffset_mut :: (self__pod: *physx_PxController_Pod, offset: float) -> void #foreign physx_lib;

PxController_getStepOffset :: (self__pod: *physx_PxController_Pod) -> float #foreign physx_lib;

PxController_setNonWalkableMode_mut :: (self__pod: *physx_PxController_Pod, flag_pod: u32) -> void #foreign physx_lib;

PxController_getNonWalkableMode :: (self__pod: *physx_PxController_Pod) -> u32 #foreign physx_lib;

PxController_getContactOffset :: (self__pod: *physx_PxController_Pod) -> float #foreign physx_lib;

PxController_setContactOffset_mut :: (self__pod: *physx_PxController_Pod, offset: float) -> void #foreign physx_lib;

PxController_getUpDirection :: (self__pod: *physx_PxController_Pod) -> physx_PxVec3_Pod #foreign physx_lib;

PxController_setUpDirection_mut :: (self__pod: *physx_PxController_Pod, up_pod: *physx_PxVec3_Pod) -> void #foreign physx_lib;

PxController_getSlopeLimit :: (self__pod: *physx_PxController_Pod) -> float #foreign physx_lib;

PxController_setSlopeLimit_mut :: (self__pod: *physx_PxController_Pod, slopeLimit: float) -> void #foreign physx_lib;

PxController_invalidateCache_mut :: (self__pod: *physx_PxController_Pod) -> void #foreign physx_lib;

PxController_getScene_mut :: (self__pod: *physx_PxController_Pod) -> *physx_PxScene_Pod #foreign physx_lib;

PxController_getUserData :: (self__pod: *physx_PxController_Pod) -> *void #foreign physx_lib;

PxController_setUserData_mut :: (self__pod: *physx_PxController_Pod, userData: *void) -> void #foreign physx_lib;

PxController_getState :: (self__pod: *physx_PxController_Pod, state_pod: *physx_PxControllerState_Pod) -> void #foreign physx_lib;

PxController_getStats :: (self__pod: *physx_PxController_Pod, stats_pod: *physx_PxControllerStats_Pod) -> void #foreign physx_lib;

PxController_resize_mut :: (self__pod: *physx_PxController_Pod, height: float) -> void #foreign physx_lib;

PxBoxControllerDesc_new_alloc :: () -> *physx_PxBoxControllerDesc_Pod #foreign physx_lib;

PxBoxControllerDesc_delete :: (self__pod: *physx_PxBoxControllerDesc_Pod) -> void #foreign physx_lib;

PxBoxControllerDesc_setToDefault_mut :: (self__pod: *physx_PxBoxControllerDesc_Pod) -> void #foreign physx_lib;

PxBoxControllerDesc_isValid :: (self__pod: *physx_PxBoxControllerDesc_Pod) -> bool #foreign physx_lib;

PxBoxControllerDesc_new_alloc_1 :: () -> *physx_PxBoxControllerDesc_Pod #foreign physx_lib;

PxBoxControllerDesc_setToDefault_mut_1 :: (self__pod: *physx_PxBoxControllerDesc_Pod) -> void #foreign physx_lib;

PxBoxControllerDesc_isValid_1 :: (self__pod: *physx_PxBoxControllerDesc_Pod) -> bool #foreign physx_lib;

PxBoxController_getHalfHeight :: (self__pod: *physx_PxBoxController_Pod) -> float #foreign physx_lib;

PxBoxController_getHalfSideExtent :: (self__pod: *physx_PxBoxController_Pod) -> float #foreign physx_lib;

PxBoxController_getHalfForwardExtent :: (self__pod: *physx_PxBoxController_Pod) -> float #foreign physx_lib;

PxBoxController_setHalfHeight_mut :: (self__pod: *physx_PxBoxController_Pod, halfHeight: float) -> bool #foreign physx_lib;

PxBoxController_setHalfSideExtent_mut :: (self__pod: *physx_PxBoxController_Pod, halfSideExtent: float) -> bool #foreign physx_lib;

PxBoxController_setHalfForwardExtent_mut :: (self__pod: *physx_PxBoxController_Pod, halfForwardExtent: float) -> bool #foreign physx_lib;

PxCapsuleControllerDesc_new_alloc :: () -> *physx_PxCapsuleControllerDesc_Pod #foreign physx_lib;

PxCapsuleControllerDesc_delete :: (self__pod: *physx_PxCapsuleControllerDesc_Pod) -> void #foreign physx_lib;

PxCapsuleControllerDesc_setToDefault_mut :: (self__pod: *physx_PxCapsuleControllerDesc_Pod) -> void #foreign physx_lib;

PxCapsuleControllerDesc_isValid :: (self__pod: *physx_PxCapsuleControllerDesc_Pod) -> bool #foreign physx_lib;

PxCapsuleControllerDesc_new_alloc_1 :: () -> *physx_PxCapsuleControllerDesc_Pod #foreign physx_lib;

PxCapsuleControllerDesc_setToDefault_mut_1 :: (self__pod: *physx_PxCapsuleControllerDesc_Pod) -> void #foreign physx_lib;

PxCapsuleControllerDesc_isValid_1 :: (self__pod: *physx_PxCapsuleControllerDesc_Pod) -> bool #foreign physx_lib;

PxCapsuleController_getRadius :: (self__pod: *physx_PxCapsuleController_Pod) -> float #foreign physx_lib;

PxCapsuleController_setRadius_mut :: (self__pod: *physx_PxCapsuleController_Pod, radius: float) -> bool #foreign physx_lib;

PxCapsuleController_getHeight :: (self__pod: *physx_PxCapsuleController_Pod) -> float #foreign physx_lib;

PxCapsuleController_setHeight_mut :: (self__pod: *physx_PxCapsuleController_Pod, height: float) -> bool #foreign physx_lib;

PxCapsuleController_getClimbingMode :: (self__pod: *physx_PxCapsuleController_Pod) -> u32 #foreign physx_lib;

PxCapsuleController_setClimbingMode_mut :: (self__pod: *physx_PxCapsuleController_Pod, mode_pod: u32) -> bool #foreign physx_lib;

PxControllerBehaviorCallback_getBehaviorFlags_mut :: (self__pod: *physx_PxControllerBehaviorCallback_Pod, shape_pod: *physx_PxShape_Pod, actor_pod: *physx_PxActor_Pod) -> physx_PxControllerBehaviorFlags_Pod #foreign physx_lib;

PxControllerBehaviorCallback_getBehaviorFlags_mut_1 :: (self__pod: *physx_PxControllerBehaviorCallback_Pod, controller_pod: *physx_PxController_Pod) -> physx_PxControllerBehaviorFlags_Pod #foreign physx_lib;

PxControllerBehaviorCallback_getBehaviorFlags_mut_2 :: (self__pod: *physx_PxControllerBehaviorCallback_Pod, obstacle_pod: *physx_PxObstacle_Pod) -> physx_PxControllerBehaviorFlags_Pod #foreign physx_lib;

PxControllerManager_release_mut :: (self__pod: *physx_PxControllerManager_Pod) -> void #foreign physx_lib;

PxControllerManager_getScene :: (self__pod: *physx_PxControllerManager_Pod) -> *physx_PxScene_Pod #foreign physx_lib;

PxControllerManager_getNbControllers :: (self__pod: *physx_PxControllerManager_Pod) -> u32 #foreign physx_lib;

PxControllerManager_getController_mut :: (self__pod: *physx_PxControllerManager_Pod, index: u32) -> *physx_PxController_Pod #foreign physx_lib;

PxControllerManager_createController_mut :: (self__pod: *physx_PxControllerManager_Pod, desc_pod: *physx_PxControllerDesc_Pod) -> *physx_PxController_Pod #foreign physx_lib;

PxControllerManager_purgeControllers_mut :: (self__pod: *physx_PxControllerManager_Pod) -> void #foreign physx_lib;

PxControllerManager_getRenderBuffer_mut :: (self__pod: *physx_PxControllerManager_Pod) -> *physx_PxRenderBuffer_Pod #foreign physx_lib;

PxControllerManager_setDebugRenderingFlags_mut :: (self__pod: *physx_PxControllerManager_Pod, flags_pod: physx_PxControllerDebugRenderFlags_Pod) -> void #foreign physx_lib;

PxControllerManager_getNbObstacleContexts :: (self__pod: *physx_PxControllerManager_Pod) -> u32 #foreign physx_lib;

PxControllerManager_getObstacleContext_mut :: (self__pod: *physx_PxControllerManager_Pod, index: u32) -> *physx_PxObstacleContext_Pod #foreign physx_lib;

PxControllerManager_createObstacleContext_mut :: (self__pod: *physx_PxControllerManager_Pod) -> *physx_PxObstacleContext_Pod #foreign physx_lib;

PxControllerManager_computeInteractions_mut :: (self__pod: *physx_PxControllerManager_Pod, elapsedTime: float, cctFilterCb_pod: *physx_PxControllerFilterCallback_Pod) -> void #foreign physx_lib;

PxControllerManager_setTessellation_mut :: (self__pod: *physx_PxControllerManager_Pod, flag: bool, maxEdgeLength: float) -> void #foreign physx_lib;

PxControllerManager_setOverlapRecoveryModule_mut :: (self__pod: *physx_PxControllerManager_Pod, flag: bool) -> void #foreign physx_lib;

PxControllerManager_setPreciseSweeps_mut :: (self__pod: *physx_PxControllerManager_Pod, flag: bool) -> void #foreign physx_lib;

PxControllerManager_setPreventVerticalSlidingAgainstCeiling_mut :: (self__pod: *physx_PxControllerManager_Pod, flag: bool) -> void #foreign physx_lib;

PxControllerManager_shiftOrigin_mut :: (self__pod: *physx_PxControllerManager_Pod, shift_pod: *physx_PxVec3_Pod) -> void #foreign physx_lib;

phys_PxCreateControllerManager :: (scene_pod: *physx_PxScene_Pod, lockingEnabled: bool) -> *physx_PxControllerManager_Pod #foreign physx_lib;

PxConvexMeshDesc_new :: () -> physx_PxConvexMeshDesc_Pod #foreign physx_lib;

PxConvexMeshDesc_setToDefault_mut :: (self__pod: *physx_PxConvexMeshDesc_Pod) -> void #foreign physx_lib;

PxConvexMeshDesc_isValid :: (self__pod: *physx_PxConvexMeshDesc_Pod) -> bool #foreign physx_lib;

PxConvexMeshDesc_new_1 :: () -> physx_PxConvexMeshDesc_Pod #foreign physx_lib;

PxConvexMeshDesc_setToDefault_mut_1 :: (self__pod: *physx_PxConvexMeshDesc_Pod) -> void #foreign physx_lib;

PxConvexMeshDesc_isValid_1 :: (self__pod: *physx_PxConvexMeshDesc_Pod) -> bool #foreign physx_lib;

PxTriangleMeshDesc_new :: () -> physx_PxTriangleMeshDesc_Pod #foreign physx_lib;

PxTriangleMeshDesc_setToDefault_mut :: (self__pod: *physx_PxTriangleMeshDesc_Pod) -> void #foreign physx_lib;

PxTriangleMeshDesc_isValid :: (self__pod: *physx_PxTriangleMeshDesc_Pod) -> bool #foreign physx_lib;

PxTriangleMeshDesc_new_1 :: () -> physx_PxTriangleMeshDesc_Pod #foreign physx_lib;

PxTriangleMeshDesc_setToDefault_mut_1 :: (self__pod: *physx_PxTriangleMeshDesc_Pod) -> void #foreign physx_lib;

PxTriangleMeshDesc_isValid_1 :: (self__pod: *physx_PxTriangleMeshDesc_Pod) -> bool #foreign physx_lib;

PxBVH33MidphaseDesc_setToDefault_mut :: (self__pod: *physx_PxBVH33MidphaseDesc_Pod) -> void #foreign physx_lib;

PxBVH33MidphaseDesc_isValid :: (self__pod: *physx_PxBVH33MidphaseDesc_Pod) -> bool #foreign physx_lib;

PxBVH34MidphaseDesc_setToDefault_mut :: (self__pod: *physx_PxBVH34MidphaseDesc_Pod) -> void #foreign physx_lib;

PxBVH34MidphaseDesc_isValid :: (self__pod: *physx_PxBVH34MidphaseDesc_Pod) -> bool #foreign physx_lib;

PxMidphaseDesc_new :: () -> physx_PxMidphaseDesc_Pod #foreign physx_lib;

PxMidphaseDesc_getType :: (self__pod: *physx_PxMidphaseDesc_Pod) -> u32 #foreign physx_lib;

PxMidphaseDesc_setToDefault_mut :: (self__pod: *physx_PxMidphaseDesc_Pod, type_pod: u32) -> void #foreign physx_lib;

PxMidphaseDesc_isValid :: (self__pod: *physx_PxMidphaseDesc_Pod) -> bool #foreign physx_lib;

PxBVHStructureDesc_new :: () -> physx_PxBVHStructureDesc_Pod #foreign physx_lib;

PxBVHStructureDesc_setToDefault_mut :: (self__pod: *physx_PxBVHStructureDesc_Pod) -> void #foreign physx_lib;

PxBVHStructureDesc_isValid :: (self__pod: *physx_PxBVHStructureDesc_Pod) -> bool #foreign physx_lib;

PxBVHStructureDesc_new_1 :: () -> physx_PxBVHStructureDesc_Pod #foreign physx_lib;

PxBVHStructureDesc_setToDefault_mut_1 :: (self__pod: *physx_PxBVHStructureDesc_Pod) -> void #foreign physx_lib;

PxBVHStructureDesc_isValid_1 :: (self__pod: *physx_PxBVHStructureDesc_Pod) -> bool #foreign physx_lib;

PxCookingParams_new :: (sc_pod: *physx_PxTolerancesScale_Pod) -> physx_PxCookingParams_Pod #foreign physx_lib;

PxCooking_release_mut :: (self__pod: *physx_PxCooking_Pod) -> void #foreign physx_lib;

PxCooking_setParams_mut :: (self__pod: *physx_PxCooking_Pod, params_pod: *physx_PxCookingParams_Pod) -> void #foreign physx_lib;

PxCooking_getParams :: (self__pod: *physx_PxCooking_Pod) -> *physx_PxCookingParams_Pod #foreign physx_lib;

PxCooking_platformMismatch :: (self__pod: *physx_PxCooking_Pod) -> bool #foreign physx_lib;

PxCooking_cookTriangleMesh :: (self__pod: *physx_PxCooking_Pod, desc_pod: *physx_PxTriangleMeshDesc_Pod, stream_pod: *physx_PxOutputStream_Pod, condition_pod: *u32) -> bool #foreign physx_lib;

PxCooking_createTriangleMesh :: (self__pod: *physx_PxCooking_Pod, desc_pod: *physx_PxTriangleMeshDesc_Pod, insertionCallback_pod: *physx_PxPhysicsInsertionCallback_Pod, condition_pod: *u32) -> *physx_PxTriangleMesh_Pod #foreign physx_lib;

PxCooking_validateTriangleMesh :: (self__pod: *physx_PxCooking_Pod, desc_pod: *physx_PxTriangleMeshDesc_Pod) -> bool #foreign physx_lib;

PxCooking_cookConvexMesh :: (self__pod: *physx_PxCooking_Pod, desc_pod: *physx_PxConvexMeshDesc_Pod, stream_pod: *physx_PxOutputStream_Pod, condition_pod: *u32) -> bool #foreign physx_lib;

PxCooking_createConvexMesh :: (self__pod: *physx_PxCooking_Pod, desc_pod: *physx_PxConvexMeshDesc_Pod, insertionCallback_pod: *physx_PxPhysicsInsertionCallback_Pod, condition_pod: *u32) -> *physx_PxConvexMesh_Pod #foreign physx_lib;

PxCooking_validateConvexMesh :: (self__pod: *physx_PxCooking_Pod, desc_pod: *physx_PxConvexMeshDesc_Pod) -> bool #foreign physx_lib;

PxCooking_computeHullPolygons :: (self__pod: *physx_PxCooking_Pod, mesh_pod: *physx_PxSimpleTriangleMesh_Pod, inCallback_pod: *physx_PxAllocatorCallback_Pod, nbVerts_pod: *u32, vertices_pod: **physx_PxVec3_Pod, nbIndices_pod: *u32, indices_pod: **u32, nbPolygons_pod: *u32, hullPolygons_pod: **physx_PxHullPolygon_Pod) -> bool #foreign physx_lib;

PxCooking_cookHeightField :: (self__pod: *physx_PxCooking_Pod, desc_pod: *physx_PxHeightFieldDesc_Pod, stream_pod: *physx_PxOutputStream_Pod) -> bool #foreign physx_lib;

PxCooking_createHeightField :: (self__pod: *physx_PxCooking_Pod, desc_pod: *physx_PxHeightFieldDesc_Pod, insertionCallback_pod: *physx_PxPhysicsInsertionCallback_Pod) -> *physx_PxHeightField_Pod #foreign physx_lib;

PxCooking_cookBVHStructure :: (self__pod: *physx_PxCooking_Pod, desc_pod: *physx_PxBVHStructureDesc_Pod, stream_pod: *physx_PxOutputStream_Pod) -> bool #foreign physx_lib;

PxCooking_createBVHStructure :: (self__pod: *physx_PxCooking_Pod, desc_pod: *physx_PxBVHStructureDesc_Pod, insertionCallback_pod: *physx_PxPhysicsInsertionCallback_Pod) -> *physx_PxBVHStructure_Pod #foreign physx_lib;

phys_PxCreateCooking :: (version: u32, foundation_pod: *physx_PxFoundation_Pod, params_pod: *physx_PxCookingParams_Pod) -> *physx_PxCooking_Pod #foreign physx_lib;

PxDefaultMemoryOutputStream_new_alloc :: (allocator_pod: *physx_PxAllocatorCallback_Pod) -> *physx_PxDefaultMemoryOutputStream_Pod #foreign physx_lib;

PxDefaultMemoryOutputStream_delete :: (self__pod: *physx_PxDefaultMemoryOutputStream_Pod) -> void #foreign physx_lib;

PxDefaultMemoryOutputStream_write_mut :: (self__pod: *physx_PxDefaultMemoryOutputStream_Pod, src: *void, count: u32) -> u32 #foreign physx_lib;

PxDefaultMemoryOutputStream_getSize :: (self__pod: *physx_PxDefaultMemoryOutputStream_Pod) -> u32 #foreign physx_lib;

PxDefaultMemoryOutputStream_getData :: (self__pod: *physx_PxDefaultMemoryOutputStream_Pod) -> *u8 #foreign physx_lib;

PxDefaultMemoryInputData_new_alloc :: (data: *u8, length: u32) -> *physx_PxDefaultMemoryInputData_Pod #foreign physx_lib;

PxDefaultMemoryInputData_read_mut :: (self__pod: *physx_PxDefaultMemoryInputData_Pod, dest: *void, count: u32) -> u32 #foreign physx_lib;

PxDefaultMemoryInputData_getLength :: (self__pod: *physx_PxDefaultMemoryInputData_Pod) -> u32 #foreign physx_lib;

PxDefaultMemoryInputData_seek_mut :: (self__pod: *physx_PxDefaultMemoryInputData_Pod, pos: u32) -> void #foreign physx_lib;

PxDefaultMemoryInputData_tell :: (self__pod: *physx_PxDefaultMemoryInputData_Pod) -> u32 #foreign physx_lib;

PxDefaultMemoryInputData_delete :: (self__pod: *physx_PxDefaultMemoryInputData_Pod) -> void #foreign physx_lib;

PxDefaultFileOutputStream_new_alloc :: (name: *u8) -> *physx_PxDefaultFileOutputStream_Pod #foreign physx_lib;

PxDefaultFileOutputStream_delete :: (self__pod: *physx_PxDefaultFileOutputStream_Pod) -> void #foreign physx_lib;

PxDefaultFileOutputStream_write_mut :: (self__pod: *physx_PxDefaultFileOutputStream_Pod, src: *void, count: u32) -> u32 #foreign physx_lib;

PxDefaultFileOutputStream_isValid_mut :: (self__pod: *physx_PxDefaultFileOutputStream_Pod) -> bool #foreign physx_lib;

PxDefaultFileInputData_new_alloc :: (name: *u8) -> *physx_PxDefaultFileInputData_Pod #foreign physx_lib;

PxDefaultFileInputData_delete :: (self__pod: *physx_PxDefaultFileInputData_Pod) -> void #foreign physx_lib;

PxDefaultFileInputData_read_mut :: (self__pod: *physx_PxDefaultFileInputData_Pod, dest: *void, count: u32) -> u32 #foreign physx_lib;

PxDefaultFileInputData_seek_mut :: (self__pod: *physx_PxDefaultFileInputData_Pod, pos: u32) -> void #foreign physx_lib;

PxDefaultFileInputData_tell :: (self__pod: *physx_PxDefaultFileInputData_Pod) -> u32 #foreign physx_lib;

PxDefaultFileInputData_getLength :: (self__pod: *physx_PxDefaultFileInputData_Pod) -> u32 #foreign physx_lib;

PxDefaultFileInputData_isValid :: (self__pod: *physx_PxDefaultFileInputData_Pod) -> bool #foreign physx_lib;

PxJoint_setActors_mut :: (self__pod: *physx_PxJoint_Pod, actor0_pod: *physx_PxRigidActor_Pod, actor1_pod: *physx_PxRigidActor_Pod) -> void #foreign physx_lib;

PxJoint_getActors :: (self__pod: *physx_PxJoint_Pod, actor0_pod: **physx_PxRigidActor_Pod, actor1_pod: **physx_PxRigidActor_Pod) -> void #foreign physx_lib;

PxJoint_setLocalPose_mut :: (self__pod: *physx_PxJoint_Pod, actor_pod: u32, localPose_pod: *physx_PxTransform_Pod) -> void #foreign physx_lib;

PxJoint_getLocalPose :: (self__pod: *physx_PxJoint_Pod, actor_pod: u32) -> physx_PxTransform_Pod #foreign physx_lib;

PxJoint_getRelativeTransform :: (self__pod: *physx_PxJoint_Pod) -> physx_PxTransform_Pod #foreign physx_lib;

PxJoint_getRelativeLinearVelocity :: (self__pod: *physx_PxJoint_Pod) -> physx_PxVec3_Pod #foreign physx_lib;

PxJoint_getRelativeAngularVelocity :: (self__pod: *physx_PxJoint_Pod) -> physx_PxVec3_Pod #foreign physx_lib;

PxJoint_setBreakForce_mut :: (self__pod: *physx_PxJoint_Pod, force: float, torque: float) -> void #foreign physx_lib;

PxJoint_getBreakForce :: (self__pod: *physx_PxJoint_Pod, force_pod: *float, torque_pod: *float) -> void #foreign physx_lib;

PxJoint_setConstraintFlags_mut :: (self__pod: *physx_PxJoint_Pod, flags_pod: physx_PxConstraintFlags_Pod) -> void #foreign physx_lib;

PxJoint_setConstraintFlag_mut :: (self__pod: *physx_PxJoint_Pod, flag_pod: u32, value: bool) -> void #foreign physx_lib;

PxJoint_getConstraintFlags :: (self__pod: *physx_PxJoint_Pod) -> physx_PxConstraintFlags_Pod #foreign physx_lib;

PxJoint_setInvMassScale0_mut :: (self__pod: *physx_PxJoint_Pod, invMassScale: float) -> void #foreign physx_lib;

PxJoint_getInvMassScale0 :: (self__pod: *physx_PxJoint_Pod) -> float #foreign physx_lib;

PxJoint_setInvInertiaScale0_mut :: (self__pod: *physx_PxJoint_Pod, invInertiaScale: float) -> void #foreign physx_lib;

PxJoint_getInvInertiaScale0 :: (self__pod: *physx_PxJoint_Pod) -> float #foreign physx_lib;

PxJoint_setInvMassScale1_mut :: (self__pod: *physx_PxJoint_Pod, invMassScale: float) -> void #foreign physx_lib;

PxJoint_getInvMassScale1 :: (self__pod: *physx_PxJoint_Pod) -> float #foreign physx_lib;

PxJoint_setInvInertiaScale1_mut :: (self__pod: *physx_PxJoint_Pod, invInertiaScale: float) -> void #foreign physx_lib;

PxJoint_getInvInertiaScale1 :: (self__pod: *physx_PxJoint_Pod) -> float #foreign physx_lib;

PxJoint_getConstraint :: (self__pod: *physx_PxJoint_Pod) -> *physx_PxConstraint_Pod #foreign physx_lib;

PxJoint_setName_mut :: (self__pod: *physx_PxJoint_Pod, name: *u8) -> void #foreign physx_lib;

PxJoint_getName :: (self__pod: *physx_PxJoint_Pod) -> *u8 #foreign physx_lib;

PxJoint_release_mut :: (self__pod: *physx_PxJoint_Pod) -> void #foreign physx_lib;

PxJoint_getScene :: (self__pod: *physx_PxJoint_Pod) -> *physx_PxScene_Pod #foreign physx_lib;

PxJoint_getBinaryMetaData_mut :: (stream_pod: *physx_PxOutputStream_Pod) -> void #foreign physx_lib;

PxSpring_new :: (stiffness_: float, damping_: float) -> physx_PxSpring_Pod #foreign physx_lib;

phys_PxSetJointGlobalFrame :: (joint_pod: *physx_PxJoint_Pod, wsAnchor_pod: *physx_PxVec3_Pod, wsAxis_pod: *physx_PxVec3_Pod) -> void #foreign physx_lib;

phys_PxDistanceJointCreate :: (physics_pod: *physx_PxPhysics_Pod, actor0_pod: *physx_PxRigidActor_Pod, localFrame0_pod: *physx_PxTransform_Pod, actor1_pod: *physx_PxRigidActor_Pod, localFrame1_pod: *physx_PxTransform_Pod) -> *physx_PxDistanceJoint_Pod #foreign physx_lib;

PxDistanceJoint_getDistance :: (self__pod: *physx_PxDistanceJoint_Pod) -> float #foreign physx_lib;

PxDistanceJoint_setMinDistance_mut :: (self__pod: *physx_PxDistanceJoint_Pod, distance: float) -> void #foreign physx_lib;

PxDistanceJoint_getMinDistance :: (self__pod: *physx_PxDistanceJoint_Pod) -> float #foreign physx_lib;

PxDistanceJoint_setMaxDistance_mut :: (self__pod: *physx_PxDistanceJoint_Pod, distance: float) -> void #foreign physx_lib;

PxDistanceJoint_getMaxDistance :: (self__pod: *physx_PxDistanceJoint_Pod) -> float #foreign physx_lib;

PxDistanceJoint_setTolerance_mut :: (self__pod: *physx_PxDistanceJoint_Pod, tolerance: float) -> void #foreign physx_lib;

PxDistanceJoint_getTolerance :: (self__pod: *physx_PxDistanceJoint_Pod) -> float #foreign physx_lib;

PxDistanceJoint_setStiffness_mut :: (self__pod: *physx_PxDistanceJoint_Pod, stiffness: float) -> void #foreign physx_lib;

PxDistanceJoint_getStiffness :: (self__pod: *physx_PxDistanceJoint_Pod) -> float #foreign physx_lib;

PxDistanceJoint_setDamping_mut :: (self__pod: *physx_PxDistanceJoint_Pod, damping: float) -> void #foreign physx_lib;

PxDistanceJoint_getDamping :: (self__pod: *physx_PxDistanceJoint_Pod) -> float #foreign physx_lib;

PxDistanceJoint_setDistanceJointFlags_mut :: (self__pod: *physx_PxDistanceJoint_Pod, flags_pod: physx_PxDistanceJointFlags_Pod) -> void #foreign physx_lib;

PxDistanceJoint_setDistanceJointFlag_mut :: (self__pod: *physx_PxDistanceJoint_Pod, flag_pod: u32, value: bool) -> void #foreign physx_lib;

PxDistanceJoint_getDistanceJointFlags :: (self__pod: *physx_PxDistanceJoint_Pod) -> physx_PxDistanceJointFlags_Pod #foreign physx_lib;

PxDistanceJoint_getConcreteTypeName :: (self__pod: *physx_PxDistanceJoint_Pod) -> *u8 #foreign physx_lib;

PxDefaultAllocator_allocate_mut :: (self__pod: *physx_PxDefaultAllocator_Pod, size: u64, anonymous_arg1: *u8, anonymous_arg2: *u8, anonymous_arg3: s32) -> *void #foreign physx_lib;

PxDefaultAllocator_deallocate_mut :: (self__pod: *physx_PxDefaultAllocator_Pod, ptr: *void) -> void #foreign physx_lib;

PxDefaultAllocator_delete :: (self__pod: *physx_PxDefaultAllocator_Pod) -> void #foreign physx_lib;

phys_PxContactJointCreate :: (physics_pod: *physx_PxPhysics_Pod, actor0_pod: *physx_PxRigidActor_Pod, localFrame0_pod: *physx_PxTransform_Pod, actor1_pod: *physx_PxRigidActor_Pod, localFrame1_pod: *physx_PxTransform_Pod) -> *physx_PxContactJoint_Pod #foreign physx_lib;

PxJacobianRow_new :: () -> physx_PxJacobianRow_Pod #foreign physx_lib;

PxJacobianRow_new_1 :: (lin0_pod: *physx_PxVec3_Pod, lin1_pod: *physx_PxVec3_Pod, ang0_pod: *physx_PxVec3_Pod, ang1_pod: *physx_PxVec3_Pod) -> physx_PxJacobianRow_Pod #foreign physx_lib;

PxContactJoint_setContact_mut :: (self__pod: *physx_PxContactJoint_Pod, contact_pod: *physx_PxVec3_Pod) -> void #foreign physx_lib;

PxContactJoint_setContactNormal_mut :: (self__pod: *physx_PxContactJoint_Pod, contactNormal_pod: *physx_PxVec3_Pod) -> void #foreign physx_lib;

PxContactJoint_setPenetration_mut :: (self__pod: *physx_PxContactJoint_Pod, penetration: float) -> void #foreign physx_lib;

PxContactJoint_getContact :: (self__pod: *physx_PxContactJoint_Pod) -> physx_PxVec3_Pod #foreign physx_lib;

PxContactJoint_getContactNormal :: (self__pod: *physx_PxContactJoint_Pod) -> physx_PxVec3_Pod #foreign physx_lib;

PxContactJoint_getPenetration :: (self__pod: *physx_PxContactJoint_Pod) -> float #foreign physx_lib;

PxContactJoint_getResititution :: (self__pod: *physx_PxContactJoint_Pod) -> float #foreign physx_lib;

PxContactJoint_setResititution_mut :: (self__pod: *physx_PxContactJoint_Pod, resititution: float) -> void #foreign physx_lib;

PxContactJoint_getBounceThreshold :: (self__pod: *physx_PxContactJoint_Pod) -> float #foreign physx_lib;

PxContactJoint_setBounceThreshold_mut :: (self__pod: *physx_PxContactJoint_Pod, bounceThreshold: float) -> void #foreign physx_lib;

PxContactJoint_getConcreteTypeName :: (self__pod: *physx_PxContactJoint_Pod) -> *u8 #foreign physx_lib;

PxContactJoint_computeJacobians :: (self__pod: *physx_PxContactJoint_Pod, jacobian_pod: *physx_PxJacobianRow_Pod) -> void #foreign physx_lib;

PxContactJoint_getNbJacobianRows :: (self__pod: *physx_PxContactJoint_Pod) -> u32 #foreign physx_lib;

phys_PxFixedJointCreate :: (physics_pod: *physx_PxPhysics_Pod, actor0_pod: *physx_PxRigidActor_Pod, localFrame0_pod: *physx_PxTransform_Pod, actor1_pod: *physx_PxRigidActor_Pod, localFrame1_pod: *physx_PxTransform_Pod) -> *physx_PxFixedJoint_Pod #foreign physx_lib;

PxFixedJoint_setProjectionLinearTolerance_mut :: (self__pod: *physx_PxFixedJoint_Pod, tolerance: float) -> void #foreign physx_lib;

PxFixedJoint_getProjectionLinearTolerance :: (self__pod: *physx_PxFixedJoint_Pod) -> float #foreign physx_lib;

PxFixedJoint_setProjectionAngularTolerance_mut :: (self__pod: *physx_PxFixedJoint_Pod, tolerance: float) -> void #foreign physx_lib;

PxFixedJoint_getProjectionAngularTolerance :: (self__pod: *physx_PxFixedJoint_Pod) -> float #foreign physx_lib;

PxFixedJoint_getConcreteTypeName :: (self__pod: *physx_PxFixedJoint_Pod) -> *u8 #foreign physx_lib;

PxJointLimitParameters_new_alloc :: () -> *physx_PxJointLimitParameters_Pod #foreign physx_lib;

PxJointLimitParameters_isValid :: (self__pod: *physx_PxJointLimitParameters_Pod) -> bool #foreign physx_lib;

PxJointLimitParameters_isSoft :: (self__pod: *physx_PxJointLimitParameters_Pod) -> bool #foreign physx_lib;

PxJointLinearLimit_new :: (scale_pod: *physx_PxTolerancesScale_Pod, extent: float, contactDist: float) -> physx_PxJointLinearLimit_Pod #foreign physx_lib;

PxJointLinearLimit_new_1 :: (extent: float, spring_pod: *physx_PxSpring_Pod) -> physx_PxJointLinearLimit_Pod #foreign physx_lib;

PxJointLinearLimit_isValid :: (self__pod: *physx_PxJointLinearLimit_Pod) -> bool #foreign physx_lib;

PxJointLinearLimit_delete :: (self__pod: *physx_PxJointLinearLimit_Pod) -> void #foreign physx_lib;

PxJointLinearLimitPair_new :: (scale_pod: *physx_PxTolerancesScale_Pod, lowerLimit: float, upperLimit: float, contactDist: float) -> physx_PxJointLinearLimitPair_Pod #foreign physx_lib;

PxJointLinearLimitPair_new_1 :: (lowerLimit: float, upperLimit: float, spring_pod: *physx_PxSpring_Pod) -> physx_PxJointLinearLimitPair_Pod #foreign physx_lib;

PxJointLinearLimitPair_isValid :: (self__pod: *physx_PxJointLinearLimitPair_Pod) -> bool #foreign physx_lib;

PxJointLinearLimitPair_delete :: (self__pod: *physx_PxJointLinearLimitPair_Pod) -> void #foreign physx_lib;

PxJointAngularLimitPair_new :: (lowerLimit: float, upperLimit: float, contactDist: float) -> physx_PxJointAngularLimitPair_Pod #foreign physx_lib;

PxJointAngularLimitPair_new_1 :: (lowerLimit: float, upperLimit: float, spring_pod: *physx_PxSpring_Pod) -> physx_PxJointAngularLimitPair_Pod #foreign physx_lib;

PxJointAngularLimitPair_isValid :: (self__pod: *physx_PxJointAngularLimitPair_Pod) -> bool #foreign physx_lib;

PxJointAngularLimitPair_delete :: (self__pod: *physx_PxJointAngularLimitPair_Pod) -> void #foreign physx_lib;

PxJointLimitCone_new :: (yLimitAngle: float, zLimitAngle: float, contactDist: float) -> physx_PxJointLimitCone_Pod #foreign physx_lib;

PxJointLimitCone_new_1 :: (yLimitAngle: float, zLimitAngle: float, spring_pod: *physx_PxSpring_Pod) -> physx_PxJointLimitCone_Pod #foreign physx_lib;

PxJointLimitCone_isValid :: (self__pod: *physx_PxJointLimitCone_Pod) -> bool #foreign physx_lib;

PxJointLimitCone_delete :: (self__pod: *physx_PxJointLimitCone_Pod) -> void #foreign physx_lib;

PxJointLimitPyramid_new :: (yLimitAngleMin: float, yLimitAngleMax: float, zLimitAngleMin: float, zLimitAngleMax: float, contactDist: float) -> physx_PxJointLimitPyramid_Pod #foreign physx_lib;

PxJointLimitPyramid_new_1 :: (yLimitAngleMin: float, yLimitAngleMax: float, zLimitAngleMin: float, zLimitAngleMax: float, spring_pod: *physx_PxSpring_Pod) -> physx_PxJointLimitPyramid_Pod #foreign physx_lib;

PxJointLimitPyramid_isValid :: (self__pod: *physx_PxJointLimitPyramid_Pod) -> bool #foreign physx_lib;

PxJointLimitPyramid_delete :: (self__pod: *physx_PxJointLimitPyramid_Pod) -> void #foreign physx_lib;

phys_PxPrismaticJointCreate :: (physics_pod: *physx_PxPhysics_Pod, actor0_pod: *physx_PxRigidActor_Pod, localFrame0_pod: *physx_PxTransform_Pod, actor1_pod: *physx_PxRigidActor_Pod, localFrame1_pod: *physx_PxTransform_Pod) -> *physx_PxPrismaticJoint_Pod #foreign physx_lib;

PxPrismaticJoint_getPosition :: (self__pod: *physx_PxPrismaticJoint_Pod) -> float #foreign physx_lib;

PxPrismaticJoint_getVelocity :: (self__pod: *physx_PxPrismaticJoint_Pod) -> float #foreign physx_lib;

PxPrismaticJoint_setLimit_mut :: (self__pod: *physx_PxPrismaticJoint_Pod, anonymous_arg0_pod: *physx_PxJointLinearLimitPair_Pod) -> void #foreign physx_lib;

PxPrismaticJoint_getLimit :: (self__pod: *physx_PxPrismaticJoint_Pod) -> physx_PxJointLinearLimitPair_Pod #foreign physx_lib;

PxPrismaticJoint_setPrismaticJointFlags_mut :: (self__pod: *physx_PxPrismaticJoint_Pod, flags_pod: physx_PxPrismaticJointFlags_Pod) -> void #foreign physx_lib;

PxPrismaticJoint_setPrismaticJointFlag_mut :: (self__pod: *physx_PxPrismaticJoint_Pod, flag_pod: u32, value: bool) -> void #foreign physx_lib;

PxPrismaticJoint_getPrismaticJointFlags :: (self__pod: *physx_PxPrismaticJoint_Pod) -> physx_PxPrismaticJointFlags_Pod #foreign physx_lib;

PxPrismaticJoint_setProjectionLinearTolerance_mut :: (self__pod: *physx_PxPrismaticJoint_Pod, tolerance: float) -> void #foreign physx_lib;

PxPrismaticJoint_getProjectionLinearTolerance :: (self__pod: *physx_PxPrismaticJoint_Pod) -> float #foreign physx_lib;

PxPrismaticJoint_setProjectionAngularTolerance_mut :: (self__pod: *physx_PxPrismaticJoint_Pod, tolerance: float) -> void #foreign physx_lib;

PxPrismaticJoint_getProjectionAngularTolerance :: (self__pod: *physx_PxPrismaticJoint_Pod) -> float #foreign physx_lib;

PxPrismaticJoint_getConcreteTypeName :: (self__pod: *physx_PxPrismaticJoint_Pod) -> *u8 #foreign physx_lib;

phys_PxRevoluteJointCreate :: (physics_pod: *physx_PxPhysics_Pod, actor0_pod: *physx_PxRigidActor_Pod, localFrame0_pod: *physx_PxTransform_Pod, actor1_pod: *physx_PxRigidActor_Pod, localFrame1_pod: *physx_PxTransform_Pod) -> *physx_PxRevoluteJoint_Pod #foreign physx_lib;

PxRevoluteJoint_getAngle :: (self__pod: *physx_PxRevoluteJoint_Pod) -> float #foreign physx_lib;

PxRevoluteJoint_getVelocity :: (self__pod: *physx_PxRevoluteJoint_Pod) -> float #foreign physx_lib;

PxRevoluteJoint_setLimit_mut :: (self__pod: *physx_PxRevoluteJoint_Pod, limits_pod: *physx_PxJointAngularLimitPair_Pod) -> void #foreign physx_lib;

PxRevoluteJoint_getLimit :: (self__pod: *physx_PxRevoluteJoint_Pod) -> physx_PxJointAngularLimitPair_Pod #foreign physx_lib;

PxRevoluteJoint_setDriveVelocity_mut :: (self__pod: *physx_PxRevoluteJoint_Pod, velocity: float, autowake: bool) -> void #foreign physx_lib;

PxRevoluteJoint_getDriveVelocity :: (self__pod: *physx_PxRevoluteJoint_Pod) -> float #foreign physx_lib;

PxRevoluteJoint_setDriveForceLimit_mut :: (self__pod: *physx_PxRevoluteJoint_Pod, limit: float) -> void #foreign physx_lib;

PxRevoluteJoint_getDriveForceLimit :: (self__pod: *physx_PxRevoluteJoint_Pod) -> float #foreign physx_lib;

PxRevoluteJoint_setDriveGearRatio_mut :: (self__pod: *physx_PxRevoluteJoint_Pod, ratio: float) -> void #foreign physx_lib;

PxRevoluteJoint_getDriveGearRatio :: (self__pod: *physx_PxRevoluteJoint_Pod) -> float #foreign physx_lib;

PxRevoluteJoint_setRevoluteJointFlags_mut :: (self__pod: *physx_PxRevoluteJoint_Pod, flags_pod: physx_PxRevoluteJointFlags_Pod) -> void #foreign physx_lib;

PxRevoluteJoint_setRevoluteJointFlag_mut :: (self__pod: *physx_PxRevoluteJoint_Pod, flag_pod: u32, value: bool) -> void #foreign physx_lib;

PxRevoluteJoint_getRevoluteJointFlags :: (self__pod: *physx_PxRevoluteJoint_Pod) -> physx_PxRevoluteJointFlags_Pod #foreign physx_lib;

PxRevoluteJoint_setProjectionLinearTolerance_mut :: (self__pod: *physx_PxRevoluteJoint_Pod, tolerance: float) -> void #foreign physx_lib;

PxRevoluteJoint_getProjectionLinearTolerance :: (self__pod: *physx_PxRevoluteJoint_Pod) -> float #foreign physx_lib;

PxRevoluteJoint_setProjectionAngularTolerance_mut :: (self__pod: *physx_PxRevoluteJoint_Pod, tolerance: float) -> void #foreign physx_lib;

PxRevoluteJoint_getProjectionAngularTolerance :: (self__pod: *physx_PxRevoluteJoint_Pod) -> float #foreign physx_lib;

PxRevoluteJoint_getConcreteTypeName :: (self__pod: *physx_PxRevoluteJoint_Pod) -> *u8 #foreign physx_lib;

phys_PxSphericalJointCreate :: (physics_pod: *physx_PxPhysics_Pod, actor0_pod: *physx_PxRigidActor_Pod, localFrame0_pod: *physx_PxTransform_Pod, actor1_pod: *physx_PxRigidActor_Pod, localFrame1_pod: *physx_PxTransform_Pod) -> *physx_PxSphericalJoint_Pod #foreign physx_lib;

PxSphericalJoint_getLimitCone :: (self__pod: *physx_PxSphericalJoint_Pod) -> physx_PxJointLimitCone_Pod #foreign physx_lib;

PxSphericalJoint_setLimitCone_mut :: (self__pod: *physx_PxSphericalJoint_Pod, limit_pod: *physx_PxJointLimitCone_Pod) -> void #foreign physx_lib;

PxSphericalJoint_getSwingYAngle :: (self__pod: *physx_PxSphericalJoint_Pod) -> float #foreign physx_lib;

PxSphericalJoint_getSwingZAngle :: (self__pod: *physx_PxSphericalJoint_Pod) -> float #foreign physx_lib;

PxSphericalJoint_setSphericalJointFlags_mut :: (self__pod: *physx_PxSphericalJoint_Pod, flags_pod: physx_PxSphericalJointFlags_Pod) -> void #foreign physx_lib;

PxSphericalJoint_setSphericalJointFlag_mut :: (self__pod: *physx_PxSphericalJoint_Pod, flag_pod: u32, value: bool) -> void #foreign physx_lib;

PxSphericalJoint_getSphericalJointFlags :: (self__pod: *physx_PxSphericalJoint_Pod) -> physx_PxSphericalJointFlags_Pod #foreign physx_lib;

PxSphericalJoint_setProjectionLinearTolerance_mut :: (self__pod: *physx_PxSphericalJoint_Pod, tolerance: float) -> void #foreign physx_lib;

PxSphericalJoint_getProjectionLinearTolerance :: (self__pod: *physx_PxSphericalJoint_Pod) -> float #foreign physx_lib;

PxSphericalJoint_getConcreteTypeName :: (self__pod: *physx_PxSphericalJoint_Pod) -> *u8 #foreign physx_lib;

phys_PxD6JointCreate :: (physics_pod: *physx_PxPhysics_Pod, actor0_pod: *physx_PxRigidActor_Pod, localFrame0_pod: *physx_PxTransform_Pod, actor1_pod: *physx_PxRigidActor_Pod, localFrame1_pod: *physx_PxTransform_Pod) -> *physx_PxD6Joint_Pod #foreign physx_lib;

PxD6JointDrive_new :: () -> physx_PxD6JointDrive_Pod #foreign physx_lib;

PxD6JointDrive_new_1 :: (driveStiffness: float, driveDamping: float, driveForceLimit: float, isAcceleration: bool) -> physx_PxD6JointDrive_Pod #foreign physx_lib;

PxD6JointDrive_isValid :: (self__pod: *physx_PxD6JointDrive_Pod) -> bool #foreign physx_lib;

PxD6Joint_setMotion_mut :: (self__pod: *physx_PxD6Joint_Pod, axis_pod: u32, type_pod: u32) -> void #foreign physx_lib;

PxD6Joint_getMotion :: (self__pod: *physx_PxD6Joint_Pod, axis_pod: u32) -> u32 #foreign physx_lib;

PxD6Joint_getTwistAngle :: (self__pod: *physx_PxD6Joint_Pod) -> float #foreign physx_lib;

PxD6Joint_getTwist :: (self__pod: *physx_PxD6Joint_Pod) -> float #foreign physx_lib;

PxD6Joint_getSwingYAngle :: (self__pod: *physx_PxD6Joint_Pod) -> float #foreign physx_lib;

PxD6Joint_getSwingZAngle :: (self__pod: *physx_PxD6Joint_Pod) -> float #foreign physx_lib;

PxD6Joint_setDistanceLimit_mut :: (self__pod: *physx_PxD6Joint_Pod, limit_pod: *physx_PxJointLinearLimit_Pod) -> void #foreign physx_lib;

PxD6Joint_getDistanceLimit :: (self__pod: *physx_PxD6Joint_Pod) -> physx_PxJointLinearLimit_Pod #foreign physx_lib;

PxD6Joint_setLinearLimit_mut :: (self__pod: *physx_PxD6Joint_Pod, limit_pod: *physx_PxJointLinearLimit_Pod) -> void #foreign physx_lib;

PxD6Joint_getLinearLimit :: (self__pod: *physx_PxD6Joint_Pod) -> physx_PxJointLinearLimit_Pod #foreign physx_lib;

PxD6Joint_setLinearLimit_mut_1 :: (self__pod: *physx_PxD6Joint_Pod, axis_pod: u32, limit_pod: *physx_PxJointLinearLimitPair_Pod) -> void #foreign physx_lib;

PxD6Joint_getLinearLimit_1 :: (self__pod: *physx_PxD6Joint_Pod, axis_pod: u32) -> physx_PxJointLinearLimitPair_Pod #foreign physx_lib;

PxD6Joint_setTwistLimit_mut :: (self__pod: *physx_PxD6Joint_Pod, limit_pod: *physx_PxJointAngularLimitPair_Pod) -> void #foreign physx_lib;

PxD6Joint_getTwistLimit :: (self__pod: *physx_PxD6Joint_Pod) -> physx_PxJointAngularLimitPair_Pod #foreign physx_lib;

PxD6Joint_setSwingLimit_mut :: (self__pod: *physx_PxD6Joint_Pod, limit_pod: *physx_PxJointLimitCone_Pod) -> void #foreign physx_lib;

PxD6Joint_getSwingLimit :: (self__pod: *physx_PxD6Joint_Pod) -> physx_PxJointLimitCone_Pod #foreign physx_lib;

PxD6Joint_setPyramidSwingLimit_mut :: (self__pod: *physx_PxD6Joint_Pod, limit_pod: *physx_PxJointLimitPyramid_Pod) -> void #foreign physx_lib;

PxD6Joint_getPyramidSwingLimit :: (self__pod: *physx_PxD6Joint_Pod) -> physx_PxJointLimitPyramid_Pod #foreign physx_lib;

PxD6Joint_setDrive_mut :: (self__pod: *physx_PxD6Joint_Pod, index_pod: u32, drive_pod: *physx_PxD6JointDrive_Pod) -> void #foreign physx_lib;

PxD6Joint_getDrive :: (self__pod: *physx_PxD6Joint_Pod, index_pod: u32) -> physx_PxD6JointDrive_Pod #foreign physx_lib;

PxD6Joint_setDrivePosition_mut :: (self__pod: *physx_PxD6Joint_Pod, pose_pod: *physx_PxTransform_Pod, autowake: bool) -> void #foreign physx_lib;

PxD6Joint_getDrivePosition :: (self__pod: *physx_PxD6Joint_Pod) -> physx_PxTransform_Pod #foreign physx_lib;

PxD6Joint_setDriveVelocity_mut :: (self__pod: *physx_PxD6Joint_Pod, linear_pod: *physx_PxVec3_Pod, angular_pod: *physx_PxVec3_Pod, autowake: bool) -> void #foreign physx_lib;

PxD6Joint_getDriveVelocity :: (self__pod: *physx_PxD6Joint_Pod, linear_pod: *physx_PxVec3_Pod, angular_pod: *physx_PxVec3_Pod) -> void #foreign physx_lib;

PxD6Joint_setProjectionLinearTolerance_mut :: (self__pod: *physx_PxD6Joint_Pod, tolerance: float) -> void #foreign physx_lib;

PxD6Joint_getProjectionLinearTolerance :: (self__pod: *physx_PxD6Joint_Pod) -> float #foreign physx_lib;

PxD6Joint_setProjectionAngularTolerance_mut :: (self__pod: *physx_PxD6Joint_Pod, tolerance: float) -> void #foreign physx_lib;

PxD6Joint_getProjectionAngularTolerance :: (self__pod: *physx_PxD6Joint_Pod) -> float #foreign physx_lib;

PxD6Joint_getConcreteTypeName :: (self__pod: *physx_PxD6Joint_Pod) -> *u8 #foreign physx_lib;

PxGroupsMask_new_alloc :: () -> *physx_PxGroupsMask_Pod #foreign physx_lib;

PxGroupsMask_delete :: (self__pod: *physx_PxGroupsMask_Pod) -> void #foreign physx_lib;

phys_PxDefaultSimulationFilterShader :: (attributes0: u32, filterData0_pod: physx_PxFilterData_Pod, attributes1: u32, filterData1_pod: physx_PxFilterData_Pod, pairFlags_pod: *physx_PxPairFlags_Pod, constantBlock: *void, constantBlockSize: u32) -> physx_PxFilterFlags_Pod #foreign physx_lib;

phys_PxGetGroupCollisionFlag :: (group1: u16, group2: u16) -> bool #foreign physx_lib;

phys_PxSetGroupCollisionFlag :: (group1: u16, group2: u16, enable: bool) -> void #foreign physx_lib;

phys_PxGetGroup :: (actor_pod: *physx_PxActor_Pod) -> u16 #foreign physx_lib;

phys_PxSetGroup :: (actor_pod: *physx_PxActor_Pod, collisionGroup: u16) -> void #foreign physx_lib;

phys_PxGetFilterOps :: (op0_pod: *u32, op1_pod: *u32, op2_pod: *u32) -> void #foreign physx_lib;

phys_PxSetFilterOps :: (op0_pod: *u32, op1_pod: *u32, op2_pod: *u32) -> void #foreign physx_lib;

phys_PxGetFilterBool :: () -> bool #foreign physx_lib;

phys_PxSetFilterBool :: (enable: bool) -> void #foreign physx_lib;

phys_PxGetFilterConstants :: (c0_pod: *physx_PxGroupsMask_Pod, c1_pod: *physx_PxGroupsMask_Pod) -> void #foreign physx_lib;

phys_PxSetFilterConstants :: (c0_pod: *physx_PxGroupsMask_Pod, c1_pod: *physx_PxGroupsMask_Pod) -> void #foreign physx_lib;

phys_PxGetGroupsMask :: (actor_pod: *physx_PxActor_Pod) -> physx_PxGroupsMask_Pod #foreign physx_lib;

phys_PxSetGroupsMask :: (actor_pod: *physx_PxActor_Pod, mask_pod: *physx_PxGroupsMask_Pod) -> void #foreign physx_lib;

PxDefaultErrorCallback_new_alloc :: () -> *physx_PxDefaultErrorCallback_Pod #foreign physx_lib;

PxDefaultErrorCallback_delete :: (self__pod: *physx_PxDefaultErrorCallback_Pod) -> void #foreign physx_lib;

PxDefaultErrorCallback_reportError_mut :: (self__pod: *physx_PxDefaultErrorCallback_Pod, code_pod: s32, message: *u8, file: *u8, line: s32) -> void #foreign physx_lib;

PxRigidActorExt_createExclusiveShape_mut :: (actor_pod: *physx_PxRigidActor_Pod, geometry_pod: *physx_PxGeometry_Pod, materials_pod: **physx_PxMaterial_Pod, materialCount: u16, shapeFlags_pod: physx_PxShapeFlags_Pod) -> *physx_PxShape_Pod #foreign physx_lib;

PxRigidActorExt_createExclusiveShape_mut_1 :: (actor_pod: *physx_PxRigidActor_Pod, geometry_pod: *physx_PxGeometry_Pod, material_pod: *physx_PxMaterial_Pod, shapeFlags_pod: physx_PxShapeFlags_Pod) -> *physx_PxShape_Pod #foreign physx_lib;

PxRigidActorExt_getRigidActorShapeLocalBoundsList_mut :: (actor_pod: *physx_PxRigidActor_Pod, numBounds_pod: *u32) -> *physx_PxBounds3_Pod #foreign physx_lib;

PxMassProperties_new :: () -> physx_PxMassProperties_Pod #foreign physx_lib;

PxMassProperties_new_1 :: (m: float, inertiaT_pod: *physx_PxMat33_Pod, com_pod: *physx_PxVec3_Pod) -> physx_PxMassProperties_Pod #foreign physx_lib;

PxMassProperties_new_2 :: (geometry_pod: *physx_PxGeometry_Pod) -> physx_PxMassProperties_Pod #foreign physx_lib;

PxMassProperties_translate_mut :: (self__pod: *physx_PxMassProperties_Pod, t_pod: *physx_PxVec3_Pod) -> void #foreign physx_lib;

PxMassProperties_getMassSpaceInertia_mut :: (inertia_pod: *physx_PxMat33_Pod, massFrame_pod: *physx_PxQuat_Pod) -> physx_PxVec3_Pod #foreign physx_lib;

PxMassProperties_translateInertia_mut :: (inertia_pod: *physx_PxMat33_Pod, mass: float, t_pod: *physx_PxVec3_Pod) -> physx_PxMat33_Pod #foreign physx_lib;

PxMassProperties_rotateInertia_mut :: (inertia_pod: *physx_PxMat33_Pod, q_pod: *physx_PxQuat_Pod) -> physx_PxMat33_Pod #foreign physx_lib;

PxMassProperties_scaleInertia_mut :: (inertia_pod: *physx_PxMat33_Pod, scaleRotation_pod: *physx_PxQuat_Pod, scale_pod: *physx_PxVec3_Pod) -> physx_PxMat33_Pod #foreign physx_lib;

PxMassProperties_sum_mut :: (props_pod: *physx_PxMassProperties_Pod, transforms_pod: *physx_PxTransform_Pod, count: u32) -> physx_PxMassProperties_Pod #foreign physx_lib;

PxRigidBodyExt_updateMassAndInertia_mut :: (body_pod: *physx_PxRigidBody_Pod, shapeDensities: *float, shapeDensityCount: u32, massLocalPose_pod: *physx_PxVec3_Pod, includeNonSimShapes: bool) -> bool #foreign physx_lib;

PxRigidBodyExt_updateMassAndInertia_mut_1 :: (body_pod: *physx_PxRigidBody_Pod, density: float, massLocalPose_pod: *physx_PxVec3_Pod, includeNonSimShapes: bool) -> bool #foreign physx_lib;

PxRigidBodyExt_setMassAndUpdateInertia_mut :: (body_pod: *physx_PxRigidBody_Pod, shapeMasses: *float, shapeMassCount: u32, massLocalPose_pod: *physx_PxVec3_Pod, includeNonSimShapes: bool) -> bool #foreign physx_lib;

PxRigidBodyExt_setMassAndUpdateInertia_mut_1 :: (body_pod: *physx_PxRigidBody_Pod, mass: float, massLocalPose_pod: *physx_PxVec3_Pod, includeNonSimShapes: bool) -> bool #foreign physx_lib;

PxRigidBodyExt_computeMassPropertiesFromShapes_mut :: (shapes_pod: **physx_PxShape_Pod, shapeCount: u32) -> physx_PxMassProperties_Pod #foreign physx_lib;

PxRigidBodyExt_addForceAtPos_mut :: (body_pod: *physx_PxRigidBody_Pod, force_pod: *physx_PxVec3_Pod, pos_pod: *physx_PxVec3_Pod, mode_pod: u32, wakeup: bool) -> void #foreign physx_lib;

PxRigidBodyExt_addForceAtLocalPos_mut :: (body_pod: *physx_PxRigidBody_Pod, force_pod: *physx_PxVec3_Pod, pos_pod: *physx_PxVec3_Pod, mode_pod: u32, wakeup: bool) -> void #foreign physx_lib;

PxRigidBodyExt_addLocalForceAtPos_mut :: (body_pod: *physx_PxRigidBody_Pod, force_pod: *physx_PxVec3_Pod, pos_pod: *physx_PxVec3_Pod, mode_pod: u32, wakeup: bool) -> void #foreign physx_lib;

PxRigidBodyExt_addLocalForceAtLocalPos_mut :: (body_pod: *physx_PxRigidBody_Pod, force_pod: *physx_PxVec3_Pod, pos_pod: *physx_PxVec3_Pod, mode_pod: u32, wakeup: bool) -> void #foreign physx_lib;

PxRigidBodyExt_getVelocityAtPos_mut :: (body_pod: *physx_PxRigidBody_Pod, pos_pod: *physx_PxVec3_Pod) -> physx_PxVec3_Pod #foreign physx_lib;

PxRigidBodyExt_getLocalVelocityAtLocalPos_mut :: (body_pod: *physx_PxRigidBody_Pod, pos_pod: *physx_PxVec3_Pod) -> physx_PxVec3_Pod #foreign physx_lib;

PxRigidBodyExt_getVelocityAtOffset_mut :: (body_pod: *physx_PxRigidBody_Pod, pos_pod: *physx_PxVec3_Pod) -> physx_PxVec3_Pod #foreign physx_lib;

PxRigidBodyExt_linearSweepSingle_mut :: (body_pod: *physx_PxRigidBody_Pod, scene_pod: *physx_PxScene_Pod, unitDir_pod: *physx_PxVec3_Pod, distance: float, outputFlags_pod: physx_PxHitFlags_Pod, closestHit_pod: *physx_PxSweepHit_Pod, shapeIndex_pod: *u32, filterData_pod: *physx_PxQueryFilterData_Pod, filterCall_pod: *physx_PxQueryFilterCallback_Pod, cache_pod: *physx_PxQueryCache_Pod, inflation: float) -> bool #foreign physx_lib;

PxRigidBodyExt_linearSweepMultiple_mut :: (body_pod: *physx_PxRigidBody_Pod, scene_pod: *physx_PxScene_Pod, unitDir_pod: *physx_PxVec3_Pod, distance: float, outputFlags_pod: physx_PxHitFlags_Pod, touchHitBuffer_pod: *physx_PxSweepHit_Pod, touchHitShapeIndices: *u32, touchHitBufferSize: u32, block_pod: *physx_PxSweepHit_Pod, blockingShapeIndex_pod: *s32, overflow_pod: *bool, filterData_pod: *physx_PxQueryFilterData_Pod, filterCall_pod: *physx_PxQueryFilterCallback_Pod, cache_pod: *physx_PxQueryCache_Pod, inflation: float) -> u32 #foreign physx_lib;

PxRigidBodyExt_computeVelocityDeltaFromImpulse_mut :: (body_pod: *physx_PxRigidBody_Pod, impulsiveForce_pod: *physx_PxVec3_Pod, impulsiveTorque_pod: *physx_PxVec3_Pod, deltaLinearVelocity_pod: *physx_PxVec3_Pod, deltaAngularVelocity_pod: *physx_PxVec3_Pod) -> void #foreign physx_lib;

PxRigidBodyExt_computeVelocityDeltaFromImpulse_mut_1 :: (body_pod: *physx_PxRigidBody_Pod, globalPose_pod: *physx_PxTransform_Pod, point_pod: *physx_PxVec3_Pod, impulse_pod: *physx_PxVec3_Pod, invMassScale: float, invInertiaScale: float, deltaLinearVelocity_pod: *physx_PxVec3_Pod, deltaAngularVelocity_pod: *physx_PxVec3_Pod) -> void #foreign physx_lib;

PxRigidBodyExt_computeLinearAngularImpulse_mut :: (body_pod: *physx_PxRigidBody_Pod, globalPose_pod: *physx_PxTransform_Pod, point_pod: *physx_PxVec3_Pod, impulse_pod: *physx_PxVec3_Pod, invMassScale: float, invInertiaScale: float, linearImpulse_pod: *physx_PxVec3_Pod, angularImpulse_pod: *physx_PxVec3_Pod) -> void #foreign physx_lib;

PxShapeExt_getGlobalPose_mut :: (shape_pod: *physx_PxShape_Pod, actor_pod: *physx_PxRigidActor_Pod) -> physx_PxTransform_Pod #foreign physx_lib;

PxShapeExt_raycast_mut :: (shape_pod: *physx_PxShape_Pod, actor_pod: *physx_PxRigidActor_Pod, rayOrigin_pod: *physx_PxVec3_Pod, rayDir_pod: *physx_PxVec3_Pod, maxDist: float, hitFlags_pod: physx_PxHitFlags_Pod, maxHits: u32, rayHits_pod: *physx_PxRaycastHit_Pod) -> u32 #foreign physx_lib;

PxShapeExt_overlap_mut :: (shape_pod: *physx_PxShape_Pod, actor_pod: *physx_PxRigidActor_Pod, otherGeom_pod: *physx_PxGeometry_Pod, otherGeomPose_pod: *physx_PxTransform_Pod) -> bool #foreign physx_lib;

PxShapeExt_sweep_mut :: (shape_pod: *physx_PxShape_Pod, actor_pod: *physx_PxRigidActor_Pod, unitDir_pod: *physx_PxVec3_Pod, distance: float, otherGeom_pod: *physx_PxGeometry_Pod, otherGeomPose_pod: *physx_PxTransform_Pod, sweepHit_pod: *physx_PxSweepHit_Pod, hitFlags_pod: physx_PxHitFlags_Pod) -> bool #foreign physx_lib;

PxShapeExt_getWorldBounds_mut :: (shape_pod: *physx_PxShape_Pod, actor_pod: *physx_PxRigidActor_Pod, inflation: float) -> physx_PxBounds3_Pod #foreign physx_lib;

PxMeshOverlapUtil_new_alloc :: () -> *physx_PxMeshOverlapUtil_Pod #foreign physx_lib;

PxMeshOverlapUtil_delete :: (self__pod: *physx_PxMeshOverlapUtil_Pod) -> void #foreign physx_lib;

PxMeshOverlapUtil_findOverlap_mut :: (self__pod: *physx_PxMeshOverlapUtil_Pod, geom_pod: *physx_PxGeometry_Pod, geomPose_pod: *physx_PxTransform_Pod, meshGeom_pod: *physx_PxTriangleMeshGeometry_Pod, meshPose_pod: *physx_PxTransform_Pod) -> u32 #foreign physx_lib;

PxMeshOverlapUtil_findOverlap_mut_1 :: (self__pod: *physx_PxMeshOverlapUtil_Pod, geom_pod: *physx_PxGeometry_Pod, geomPose_pod: *physx_PxTransform_Pod, hfGeom_pod: *physx_PxHeightFieldGeometry_Pod, hfPose_pod: *physx_PxTransform_Pod) -> u32 #foreign physx_lib;

PxMeshOverlapUtil_getResults :: (self__pod: *physx_PxMeshOverlapUtil_Pod) -> *u32 #foreign physx_lib;

PxMeshOverlapUtil_getNbResults :: (self__pod: *physx_PxMeshOverlapUtil_Pod) -> u32 #foreign physx_lib;

phys_PxComputeTriangleMeshPenetration :: (direction_pod: *physx_PxVec3_Pod, depth_pod: *float, geom_pod: *physx_PxGeometry_Pod, geomPose_pod: *physx_PxTransform_Pod, meshGeom_pod: *physx_PxTriangleMeshGeometry_Pod, meshPose_pod: *physx_PxTransform_Pod, maxIter: u32, usedIter: *u32) -> bool #foreign physx_lib;

phys_PxComputeHeightFieldPenetration :: (direction_pod: *physx_PxVec3_Pod, depth_pod: *float, geom_pod: *physx_PxGeometry_Pod, geomPose_pod: *physx_PxTransform_Pod, heightFieldGeom_pod: *physx_PxHeightFieldGeometry_Pod, heightFieldPose_pod: *physx_PxTransform_Pod, maxIter: u32, usedIter: *u32) -> bool #foreign physx_lib;

PxXmlMiscParameter_new :: () -> physx_PxSerialization_PxXmlMiscParameter_Pod #foreign physx_lib;

PxXmlMiscParameter_new_1 :: (inUpVector_pod: *physx_PxVec3_Pod, inScale_pod: physx_PxTolerancesScale_Pod) -> physx_PxSerialization_PxXmlMiscParameter_Pod #foreign physx_lib;

PxSerialization_isSerializable_mut :: (collection_pod: *physx_PxCollection_Pod, sr_pod: *physx_PxSerializationRegistry_Pod, externalReferences_pod: *physx_PxCollection_Pod) -> bool #foreign physx_lib;

PxSerialization_complete_mut :: (collection_pod: *physx_PxCollection_Pod, sr_pod: *physx_PxSerializationRegistry_Pod, exceptFor_pod: *physx_PxCollection_Pod, followJoints: bool) -> void #foreign physx_lib;

PxSerialization_createSerialObjectIds_mut :: (collection_pod: *physx_PxCollection_Pod, base: u64) -> void #foreign physx_lib;

PxSerialization_createCollectionFromXml_mut :: (inputData_pod: *physx_PxInputData_Pod, cooking_pod: *physx_PxCooking_Pod, sr_pod: *physx_PxSerializationRegistry_Pod, externalRefs_pod: *physx_PxCollection_Pod, stringTable_pod: *physx_PxStringTable_Pod, outArgs_pod: *physx_PxSerialization_PxXmlMiscParameter_Pod) -> *physx_PxCollection_Pod #foreign physx_lib;

PxSerialization_createCollectionFromBinary_mut :: (memBlock: *void, sr_pod: *physx_PxSerializationRegistry_Pod, externalRefs_pod: *physx_PxCollection_Pod) -> *physx_PxCollection_Pod #foreign physx_lib;

PxSerialization_serializeCollectionToXml_mut :: (outputStream_pod: *physx_PxOutputStream_Pod, collection_pod: *physx_PxCollection_Pod, sr_pod: *physx_PxSerializationRegistry_Pod, cooking_pod: *physx_PxCooking_Pod, externalRefs_pod: *physx_PxCollection_Pod, inArgs_pod: *physx_PxSerialization_PxXmlMiscParameter_Pod) -> bool #foreign physx_lib;

PxSerialization_serializeCollectionToBinary_mut :: (outputStream_pod: *physx_PxOutputStream_Pod, collection_pod: *physx_PxCollection_Pod, sr_pod: *physx_PxSerializationRegistry_Pod, externalRefs_pod: *physx_PxCollection_Pod, exportNames: bool) -> bool #foreign physx_lib;

PxSerialization_serializeCollectionToBinaryDeterministic_mut :: (outputStream_pod: *physx_PxOutputStream_Pod, collection_pod: *physx_PxCollection_Pod, sr_pod: *physx_PxSerializationRegistry_Pod, externalRefs_pod: *physx_PxCollection_Pod, exportNames: bool) -> bool #foreign physx_lib;

PxSerialization_dumpBinaryMetaData_mut :: (outputStream_pod: *physx_PxOutputStream_Pod, sr_pod: *physx_PxSerializationRegistry_Pod) -> void #foreign physx_lib;

PxSerialization_createBinaryConverter_mut :: () -> *physx_PxBinaryConverter_Pod #foreign physx_lib;

PxSerialization_createSerializationRegistry_mut :: (physics_pod: *physx_PxPhysics_Pod) -> *physx_PxSerializationRegistry_Pod #foreign physx_lib;

PxDefaultCpuDispatcher_release_mut :: (self__pod: *physx_PxDefaultCpuDispatcher_Pod) -> void #foreign physx_lib;

PxDefaultCpuDispatcher_setRunProfiled_mut :: (self__pod: *physx_PxDefaultCpuDispatcher_Pod, runProfiled: bool) -> void #foreign physx_lib;

PxDefaultCpuDispatcher_getRunProfiled :: (self__pod: *physx_PxDefaultCpuDispatcher_Pod) -> bool #foreign physx_lib;

phys_PxDefaultCpuDispatcherCreate :: (numThreads: u32, affinityMasks: *u32) -> *physx_PxDefaultCpuDispatcher_Pod #foreign physx_lib;

phys_PxBuildSmoothNormals :: (nbTris: u32, nbVerts: u32, verts_pod: *physx_PxVec3_Pod, dFaces: *u32, wFaces: *u16, normals_pod: *physx_PxVec3_Pod, flip: bool) -> bool #foreign physx_lib;

phys_PxCreateDynamic :: (sdk_pod: *physx_PxPhysics_Pod, transform_pod: *physx_PxTransform_Pod, geometry_pod: *physx_PxGeometry_Pod, material_pod: *physx_PxMaterial_Pod, density: float, shapeOffset_pod: *physx_PxTransform_Pod) -> *physx_PxRigidDynamic_Pod #foreign physx_lib;

phys_PxCreateDynamic_1 :: (sdk_pod: *physx_PxPhysics_Pod, transform_pod: *physx_PxTransform_Pod, shape_pod: *physx_PxShape_Pod, density: float) -> *physx_PxRigidDynamic_Pod #foreign physx_lib;

phys_PxCreateKinematic :: (sdk_pod: *physx_PxPhysics_Pod, transform_pod: *physx_PxTransform_Pod, geometry_pod: *physx_PxGeometry_Pod, material_pod: *physx_PxMaterial_Pod, density: float, shapeOffset_pod: *physx_PxTransform_Pod) -> *physx_PxRigidDynamic_Pod #foreign physx_lib;

phys_PxCreateKinematic_1 :: (sdk_pod: *physx_PxPhysics_Pod, transform_pod: *physx_PxTransform_Pod, shape_pod: *physx_PxShape_Pod, density: float) -> *physx_PxRigidDynamic_Pod #foreign physx_lib;

phys_PxCreateStatic :: (sdk_pod: *physx_PxPhysics_Pod, transform_pod: *physx_PxTransform_Pod, geometry_pod: *physx_PxGeometry_Pod, material_pod: *physx_PxMaterial_Pod, shapeOffset_pod: *physx_PxTransform_Pod) -> *physx_PxRigidStatic_Pod #foreign physx_lib;

phys_PxCreateStatic_1 :: (sdk_pod: *physx_PxPhysics_Pod, transform_pod: *physx_PxTransform_Pod, shape_pod: *physx_PxShape_Pod) -> *physx_PxRigidStatic_Pod #foreign physx_lib;

phys_PxCreateStatic_2 :: (sdk_pod: *physx_PxPhysics_Pod, transform_pod: *physx_PxTransform_Pod, shape_pod: *physx_PxShape_Pod) -> *physx_PxRigidStatic_Pod #foreign physx_lib;

phys_PxCloneShape :: (physicsSDK_pod: *physx_PxPhysics_Pod, shape_pod: *physx_PxShape_Pod, isExclusive: bool) -> *physx_PxShape_Pod #foreign physx_lib;

phys_PxCloneStatic :: (physicsSDK_pod: *physx_PxPhysics_Pod, transform_pod: *physx_PxTransform_Pod, actor_pod: *physx_PxRigidActor_Pod) -> *physx_PxRigidStatic_Pod #foreign physx_lib;

phys_PxCloneDynamic :: (physicsSDK_pod: *physx_PxPhysics_Pod, transform_pod: *physx_PxTransform_Pod, body_pod: *physx_PxRigidDynamic_Pod) -> *physx_PxRigidDynamic_Pod #foreign physx_lib;

phys_PxCreatePlane :: (sdk_pod: *physx_PxPhysics_Pod, plane_pod: *physx_PxPlane_Pod, material_pod: *physx_PxMaterial_Pod) -> *physx_PxRigidStatic_Pod #foreign physx_lib;

phys_PxScaleRigidActor :: (actor_pod: *physx_PxRigidActor_Pod, scale: float, scaleMassProps: bool) -> void #foreign physx_lib;

PxStringTableExt_createStringTable_mut :: (inAllocator_pod: *physx_PxAllocatorCallback_Pod) -> *physx_PxStringTable_Pod #foreign physx_lib;

PxBroadPhaseExt_createRegionsFromWorldBounds_mut :: (regions_pod: *physx_PxBounds3_Pod, globalBounds_pod: *physx_PxBounds3_Pod, nbSubdiv: u32, upAxis: u32) -> u32 #foreign physx_lib;

PxSceneQueryExt_raycastAny_mut :: (scene_pod: *physx_PxScene_Pod, origin_pod: *physx_PxVec3_Pod, unitDir_pod: *physx_PxVec3_Pod, distance: float, hit_pod: *physx_PxSceneQueryHit_Pod, filterData_pod: *physx_PxSceneQueryFilterData_Pod, filterCall_pod: *physx_PxSceneQueryFilterCallback_Pod, cache_pod: *physx_PxSceneQueryCache_Pod) -> bool #foreign physx_lib;

PxSceneQueryExt_raycastSingle_mut :: (scene_pod: *physx_PxScene_Pod, origin_pod: *physx_PxVec3_Pod, unitDir_pod: *physx_PxVec3_Pod, distance: float, outputFlags_pod: physx_PxSceneQueryFlags_Pod, hit_pod: *physx_PxRaycastHit_Pod, filterData_pod: *physx_PxSceneQueryFilterData_Pod, filterCall_pod: *physx_PxSceneQueryFilterCallback_Pod, cache_pod: *physx_PxSceneQueryCache_Pod) -> bool #foreign physx_lib;

PxSceneQueryExt_raycastMultiple_mut :: (scene_pod: *physx_PxScene_Pod, origin_pod: *physx_PxVec3_Pod, unitDir_pod: *physx_PxVec3_Pod, distance: float, outputFlags_pod: physx_PxSceneQueryFlags_Pod, hitBuffer_pod: *physx_PxRaycastHit_Pod, hitBufferSize: u32, blockingHit_pod: *bool, filterData_pod: *physx_PxSceneQueryFilterData_Pod, filterCall_pod: *physx_PxSceneQueryFilterCallback_Pod, cache_pod: *physx_PxSceneQueryCache_Pod) -> s32 #foreign physx_lib;

PxSceneQueryExt_sweepAny_mut :: (scene_pod: *physx_PxScene_Pod, geometry_pod: *physx_PxGeometry_Pod, pose_pod: *physx_PxTransform_Pod, unitDir_pod: *physx_PxVec3_Pod, distance: float, queryFlags_pod: physx_PxSceneQueryFlags_Pod, hit_pod: *physx_PxSceneQueryHit_Pod, filterData_pod: *physx_PxSceneQueryFilterData_Pod, filterCall_pod: *physx_PxSceneQueryFilterCallback_Pod, cache_pod: *physx_PxSceneQueryCache_Pod, inflation: float) -> bool #foreign physx_lib;

PxSceneQueryExt_sweepSingle_mut :: (scene_pod: *physx_PxScene_Pod, geometry_pod: *physx_PxGeometry_Pod, pose_pod: *physx_PxTransform_Pod, unitDir_pod: *physx_PxVec3_Pod, distance: float, outputFlags_pod: physx_PxSceneQueryFlags_Pod, hit_pod: *physx_PxSweepHit_Pod, filterData_pod: *physx_PxSceneQueryFilterData_Pod, filterCall_pod: *physx_PxSceneQueryFilterCallback_Pod, cache_pod: *physx_PxSceneQueryCache_Pod, inflation: float) -> bool #foreign physx_lib;

PxSceneQueryExt_sweepMultiple_mut :: (scene_pod: *physx_PxScene_Pod, geometry_pod: *physx_PxGeometry_Pod, pose_pod: *physx_PxTransform_Pod, unitDir_pod: *physx_PxVec3_Pod, distance: float, outputFlags_pod: physx_PxSceneQueryFlags_Pod, hitBuffer_pod: *physx_PxSweepHit_Pod, hitBufferSize: u32, blockingHit_pod: *bool, filterData_pod: *physx_PxSceneQueryFilterData_Pod, filterCall_pod: *physx_PxSceneQueryFilterCallback_Pod, cache_pod: *physx_PxSceneQueryCache_Pod, inflation: float) -> s32 #foreign physx_lib;

PxSceneQueryExt_overlapMultiple_mut :: (scene_pod: *physx_PxScene_Pod, geometry_pod: *physx_PxGeometry_Pod, pose_pod: *physx_PxTransform_Pod, hitBuffer_pod: *physx_PxOverlapHit_Pod, hitBufferSize: u32, filterData_pod: *physx_PxSceneQueryFilterData_Pod, filterCall_pod: *physx_PxSceneQueryFilterCallback_Pod) -> s32 #foreign physx_lib;

PxSceneQueryExt_overlapAny_mut :: (scene_pod: *physx_PxScene_Pod, geometry_pod: *physx_PxGeometry_Pod, pose_pod: *physx_PxTransform_Pod, hit_pod: *physx_PxOverlapHit_Pod, filterData_pod: *physx_PxSceneQueryFilterData_Pod, filterCall_pod: *physx_PxSceneQueryFilterCallback_Pod) -> bool #foreign physx_lib;

phys_PxInitExtensions :: (physics_pod: *physx_PxPhysics_Pod, pvd_pod: *physx_PxPvd_Pod) -> bool #foreign physx_lib;

phys_PxCloseExtensions :: () -> void #foreign physx_lib;

phys_PxFindFaceIndex :: (convexGeom_pod: *physx_PxConvexMeshGeometry_Pod, geomPose_pod: *physx_PxTransform_Pod, impactPos_pod: *physx_PxVec3_Pod, unitDir_pod: *physx_PxVec3_Pod) -> u32 #foreign physx_lib;

PxBinaryConverter_release_mut :: (self__pod: *physx_PxBinaryConverter_Pod) -> void #foreign physx_lib;

PxBinaryConverter_setReportMode_mut :: (self__pod: *physx_PxBinaryConverter_Pod, mode_pod: u32) -> void #foreign physx_lib;

PxBinaryConverter_setMetaData_mut :: (self__pod: *physx_PxBinaryConverter_Pod, srcMetaData_pod: *physx_PxInputStream_Pod, dstMetaData_pod: *physx_PxInputStream_Pod) -> bool #foreign physx_lib;

PxBinaryConverter_compareMetaData :: (self__pod: *physx_PxBinaryConverter_Pod) -> bool #foreign physx_lib;

PxBinaryConverter_convert_mut :: (self__pod: *physx_PxBinaryConverter_Pod, srcStream_pod: *physx_PxInputStream_Pod, srcSize: u32, targetStream_pod: *physx_PxOutputStream_Pod) -> bool #foreign physx_lib;

PxRepXObject_new :: (inTypeName: *u8, inSerializable: *void, inId: u64) -> physx_PxRepXObject_Pod #foreign physx_lib;

PxRepXObject_isValid :: (self__pod: *physx_PxRepXObject_Pod) -> bool #foreign physx_lib;

PxRepXInstantiationArgs_new :: (inPhysics_pod: *physx_PxPhysics_Pod, inCooking_pod: *physx_PxCooking_Pod, inStringTable_pod: *physx_PxStringTable_Pod) -> physx_PxRepXInstantiationArgs_Pod #foreign physx_lib;

PxRepXSerializer_getTypeName_mut :: (self__pod: *physx_PxRepXSerializer_Pod) -> *u8 #foreign physx_lib;

PxRepXSerializer_objectToFile_mut :: (self__pod: *physx_PxRepXSerializer_Pod, inLiveObject_pod: *physx_PxRepXObject_Pod, inCollection_pod: *physx_PxCollection_Pod, inWriter_pod: *physx_XmlWriter_Pod, inTempBuffer_pod: *physx_MemoryBuffer_Pod, inArgs_pod: *physx_PxRepXInstantiationArgs_Pod) -> void #foreign physx_lib;

PxRepXSerializer_fileToObject_mut :: (self__pod: *physx_PxRepXSerializer_Pod, inReader_pod: *physx_XmlReader_Pod, inAllocator_pod: *physx_XmlMemoryAllocator_Pod, inArgs_pod: *physx_PxRepXInstantiationArgs_Pod, inCollection_pod: *physx_PxCollection_Pod) -> physx_PxRepXObject_Pod #foreign physx_lib;

phys_PxCreateRepXObject :: (inType_pod: *physx_PxBase_Pod, inId: u64) -> physx_PxRepXObject_Pod #foreign physx_lib;

phys_PxInitVehicleSDK :: (physics_pod: *physx_PxPhysics_Pod, serializationRegistry_pod: *physx_PxSerializationRegistry_Pod) -> bool #foreign physx_lib;

phys_PxCloseVehicleSDK :: (serializationRegistry_pod: *physx_PxSerializationRegistry_Pod) -> void #foreign physx_lib;

phys_PxVehicleSetBasisVectors :: (up_pod: *physx_PxVec3_Pod, forward_pod: *physx_PxVec3_Pod) -> void #foreign physx_lib;

phys_PxVehicleSetUpdateMode :: (vehicleUpdateMode_pod: u32) -> void #foreign physx_lib;

phys_PxVehicleSetSweepHitRejectionAngles :: (pointRejectAngle: float, normalRejectAngle: float) -> void #foreign physx_lib;

phys_PxVehicleSetMaxHitActorAcceleration :: (maxHitActorAcceleration: float) -> void #foreign physx_lib;

PxVehicleChassisData_new :: () -> physx_PxVehicleChassisData_Pod #foreign physx_lib;

PxVehicleEngineData_new :: () -> physx_PxVehicleEngineData_Pod #foreign physx_lib;

PxVehicleEngineData_getRecipMOI :: (self__pod: *physx_PxVehicleEngineData_Pod) -> float #foreign physx_lib;

PxVehicleEngineData_getRecipMaxOmega :: (self__pod: *physx_PxVehicleEngineData_Pod) -> float #foreign physx_lib;

PxVehicleEngineData_new_1 :: (anonymous_arg0_pod: u32) -> physx_PxVehicleEngineData_Pod #foreign physx_lib;

PxVehicleEngineData_delete :: (self__pod: *physx_PxVehicleEngineData_Pod) -> void #foreign physx_lib;

PxVehicleGearsData_new :: () -> physx_PxVehicleGearsData_Pod #foreign physx_lib;

PxVehicleGearsData_new_1 :: (anonymous_arg0_pod: u32) -> physx_PxVehicleGearsData_Pod #foreign physx_lib;

PxVehicleGearsData_getGearRatio :: (self__pod: *physx_PxVehicleGearsData_Pod, a_pod: u32) -> float #foreign physx_lib;

PxVehicleGearsData_setGearRatio_mut :: (self__pod: *physx_PxVehicleGearsData_Pod, a_pod: u32, ratio: float) -> void #foreign physx_lib;

PxVehicleAutoBoxData_new :: () -> physx_PxVehicleAutoBoxData_Pod #foreign physx_lib;

PxVehicleAutoBoxData_setLatency_mut :: (self__pod: *physx_PxVehicleAutoBoxData_Pod, latency: float) -> void #foreign physx_lib;

PxVehicleAutoBoxData_getLatency :: (self__pod: *physx_PxVehicleAutoBoxData_Pod) -> float #foreign physx_lib;

PxVehicleAutoBoxData_new_1 :: (anonymous_arg0_pod: u32) -> physx_PxVehicleAutoBoxData_Pod #foreign physx_lib;

PxVehicleAutoBoxData_getUpRatios :: (self__pod: *physx_PxVehicleAutoBoxData_Pod, a_pod: u32) -> float #foreign physx_lib;

PxVehicleAutoBoxData_setUpRatios_mut :: (self__pod: *physx_PxVehicleAutoBoxData_Pod, a_pod: u32, ratio: float) -> void #foreign physx_lib;

PxVehicleAutoBoxData_getDownRatios :: (self__pod: *physx_PxVehicleAutoBoxData_Pod, a_pod: u32) -> float #foreign physx_lib;

PxVehicleAutoBoxData_setDownRatios_mut :: (self__pod: *physx_PxVehicleAutoBoxData_Pod, a_pod: u32, ratio: float) -> void #foreign physx_lib;

PxVehicleDifferential4WData_new :: () -> physx_PxVehicleDifferential4WData_Pod #foreign physx_lib;

PxVehicleDifferential4WData_new_1 :: (anonymous_arg0_pod: u32) -> physx_PxVehicleDifferential4WData_Pod #foreign physx_lib;

PxVehicleDifferentialNWData_new :: () -> physx_PxVehicleDifferentialNWData_Pod #foreign physx_lib;

PxVehicleDifferentialNWData_setDrivenWheel_mut :: (self__pod: *physx_PxVehicleDifferentialNWData_Pod, wheelId: u32, drivenState: bool) -> void #foreign physx_lib;

PxVehicleDifferentialNWData_getIsDrivenWheel :: (self__pod: *physx_PxVehicleDifferentialNWData_Pod, wheelId: u32) -> bool #foreign physx_lib;

PxVehicleDifferentialNWData_new_1 :: (anonymous_arg0_pod: u32) -> physx_PxVehicleDifferentialNWData_Pod #foreign physx_lib;

PxVehicleDifferentialNWData_getDrivenWheelStatus :: (self__pod: *physx_PxVehicleDifferentialNWData_Pod) -> u32 #foreign physx_lib;

PxVehicleDifferentialNWData_setDrivenWheelStatus_mut :: (self__pod: *physx_PxVehicleDifferentialNWData_Pod, status: u32) -> void #foreign physx_lib;

PxVehicleAckermannGeometryData_new :: () -> physx_PxVehicleAckermannGeometryData_Pod #foreign physx_lib;

PxVehicleAckermannGeometryData_new_1 :: (anonymous_arg0_pod: u32) -> physx_PxVehicleAckermannGeometryData_Pod #foreign physx_lib;

PxVehicleClutchData_new :: () -> physx_PxVehicleClutchData_Pod #foreign physx_lib;

PxVehicleClutchData_new_1 :: (anonymous_arg0_pod: u32) -> physx_PxVehicleClutchData_Pod #foreign physx_lib;

PxVehicleTireLoadFilterData_new :: () -> physx_PxVehicleTireLoadFilterData_Pod #foreign physx_lib;

PxVehicleTireLoadFilterData_getDenominator :: (self__pod: *physx_PxVehicleTireLoadFilterData_Pod) -> float #foreign physx_lib;

PxVehicleTireLoadFilterData_new_1 :: (anonymous_arg0_pod: u32) -> physx_PxVehicleTireLoadFilterData_Pod #foreign physx_lib;

PxVehicleWheelData_new :: () -> physx_PxVehicleWheelData_Pod #foreign physx_lib;

PxVehicleWheelData_getRecipRadius :: (self__pod: *physx_PxVehicleWheelData_Pod) -> float #foreign physx_lib;

PxVehicleWheelData_getRecipMOI :: (self__pod: *physx_PxVehicleWheelData_Pod) -> float #foreign physx_lib;

PxVehicleSuspensionData_new :: () -> physx_PxVehicleSuspensionData_Pod #foreign physx_lib;

PxVehicleSuspensionData_getRecipMaxCompression :: (self__pod: *physx_PxVehicleSuspensionData_Pod) -> float #foreign physx_lib;

PxVehicleSuspensionData_getRecipMaxDroop :: (self__pod: *physx_PxVehicleSuspensionData_Pod) -> float #foreign physx_lib;

PxVehicleSuspensionData_setMassAndPreserveNaturalFrequency_mut :: (self__pod: *physx_PxVehicleSuspensionData_Pod, newSprungMass: float) -> void #foreign physx_lib;

PxVehicleAntiRollBarData_new :: () -> physx_PxVehicleAntiRollBarData_Pod #foreign physx_lib;

PxVehicleTireData_new :: () -> physx_PxVehicleTireData_Pod #foreign physx_lib;

PxVehicleTireData_getRecipLongitudinalStiffnessPerUnitGravity :: (self__pod: *physx_PxVehicleTireData_Pod) -> float #foreign physx_lib;

PxVehicleTireData_getFrictionVsSlipGraphRecipx1Minusx0 :: (self__pod: *physx_PxVehicleTireData_Pod) -> float #foreign physx_lib;

PxVehicleTireData_getFrictionVsSlipGraphRecipx2Minusx1 :: (self__pod: *physx_PxVehicleTireData_Pod) -> float #foreign physx_lib;

PxVehicleWheelsSimData_allocate_mut :: (nbWheels: u32) -> *physx_PxVehicleWheelsSimData_Pod #foreign physx_lib;

PxVehicleWheelsSimData_setChassisMass_mut :: (self__pod: *physx_PxVehicleWheelsSimData_Pod, chassisMass: float) -> void #foreign physx_lib;

PxVehicleWheelsSimData_free_mut :: (self__pod: *physx_PxVehicleWheelsSimData_Pod) -> void #foreign physx_lib;

PxVehicleWheelsSimData_copy_mut :: (self__pod: *physx_PxVehicleWheelsSimData_Pod, src_pod: *physx_PxVehicleWheelsSimData_Pod, srcWheel: u32, trgWheel: u32) -> void #foreign physx_lib;

PxVehicleWheelsSimData_getNbWheels :: (self__pod: *physx_PxVehicleWheelsSimData_Pod) -> u32 #foreign physx_lib;

PxVehicleWheelsSimData_getSuspensionData :: (self__pod: *physx_PxVehicleWheelsSimData_Pod, id: u32) -> *physx_PxVehicleSuspensionData_Pod #foreign physx_lib;

PxVehicleWheelsSimData_getWheelData :: (self__pod: *physx_PxVehicleWheelsSimData_Pod, id: u32) -> *physx_PxVehicleWheelData_Pod #foreign physx_lib;

PxVehicleWheelsSimData_getTireData :: (self__pod: *physx_PxVehicleWheelsSimData_Pod, id: u32) -> *physx_PxVehicleTireData_Pod #foreign physx_lib;

PxVehicleWheelsSimData_getSuspTravelDirection :: (self__pod: *physx_PxVehicleWheelsSimData_Pod, id: u32) -> *physx_PxVec3_Pod #foreign physx_lib;

PxVehicleWheelsSimData_getSuspForceAppPointOffset :: (self__pod: *physx_PxVehicleWheelsSimData_Pod, id: u32) -> *physx_PxVec3_Pod #foreign physx_lib;

PxVehicleWheelsSimData_getTireForceAppPointOffset :: (self__pod: *physx_PxVehicleWheelsSimData_Pod, id: u32) -> *physx_PxVec3_Pod #foreign physx_lib;

PxVehicleWheelsSimData_getWheelCentreOffset :: (self__pod: *physx_PxVehicleWheelsSimData_Pod, id: u32) -> *physx_PxVec3_Pod #foreign physx_lib;

PxVehicleWheelsSimData_getWheelShapeMapping :: (self__pod: *physx_PxVehicleWheelsSimData_Pod, wheelId: u32) -> s32 #foreign physx_lib;

PxVehicleWheelsSimData_getSceneQueryFilterData :: (self__pod: *physx_PxVehicleWheelsSimData_Pod, suspId: u32) -> *physx_PxFilterData_Pod #foreign physx_lib;

PxVehicleWheelsSimData_getNbAntiRollBars :: (self__pod: *physx_PxVehicleWheelsSimData_Pod) -> u32 #foreign physx_lib;

PxVehicleWheelsSimData_getAntiRollBarData :: (self__pod: *physx_PxVehicleWheelsSimData_Pod, antiRollId: u32) -> *physx_PxVehicleAntiRollBarData_Pod #foreign physx_lib;

PxVehicleWheelsSimData_getTireLoadFilterData :: (self__pod: *physx_PxVehicleWheelsSimData_Pod) -> *physx_PxVehicleTireLoadFilterData_Pod #foreign physx_lib;

PxVehicleWheelsSimData_setSuspensionData_mut :: (self__pod: *physx_PxVehicleWheelsSimData_Pod, id: u32, susp_pod: *physx_PxVehicleSuspensionData_Pod) -> void #foreign physx_lib;

PxVehicleWheelsSimData_setWheelData_mut :: (self__pod: *physx_PxVehicleWheelsSimData_Pod, id: u32, wheel_pod: *physx_PxVehicleWheelData_Pod) -> void #foreign physx_lib;

PxVehicleWheelsSimData_setTireData_mut :: (self__pod: *physx_PxVehicleWheelsSimData_Pod, id: u32, tire_pod: *physx_PxVehicleTireData_Pod) -> void #foreign physx_lib;

PxVehicleWheelsSimData_setSuspTravelDirection_mut :: (self__pod: *physx_PxVehicleWheelsSimData_Pod, id: u32, dir_pod: *physx_PxVec3_Pod) -> void #foreign physx_lib;

PxVehicleWheelsSimData_setSuspForceAppPointOffset_mut :: (self__pod: *physx_PxVehicleWheelsSimData_Pod, id: u32, offset_pod: *physx_PxVec3_Pod) -> void #foreign physx_lib;

PxVehicleWheelsSimData_setTireForceAppPointOffset_mut :: (self__pod: *physx_PxVehicleWheelsSimData_Pod, id: u32, offset_pod: *physx_PxVec3_Pod) -> void #foreign physx_lib;

PxVehicleWheelsSimData_setWheelCentreOffset_mut :: (self__pod: *physx_PxVehicleWheelsSimData_Pod, id: u32, offset_pod: *physx_PxVec3_Pod) -> void #foreign physx_lib;

PxVehicleWheelsSimData_setWheelShapeMapping_mut :: (self__pod: *physx_PxVehicleWheelsSimData_Pod, wheelId: u32, shapeId: s32) -> void #foreign physx_lib;

PxVehicleWheelsSimData_setSceneQueryFilterData_mut :: (self__pod: *physx_PxVehicleWheelsSimData_Pod, suspId: u32, sqFilterData_pod: *physx_PxFilterData_Pod) -> void #foreign physx_lib;

PxVehicleWheelsSimData_setTireLoadFilterData_mut :: (self__pod: *physx_PxVehicleWheelsSimData_Pod, tireLoadFilter_pod: *physx_PxVehicleTireLoadFilterData_Pod) -> void #foreign physx_lib;

PxVehicleWheelsSimData_addAntiRollBarData_mut :: (self__pod: *physx_PxVehicleWheelsSimData_Pod, antiRoll_pod: *physx_PxVehicleAntiRollBarData_Pod) -> u32 #foreign physx_lib;

PxVehicleWheelsSimData_disableWheel_mut :: (self__pod: *physx_PxVehicleWheelsSimData_Pod, wheel: u32) -> void #foreign physx_lib;

PxVehicleWheelsSimData_enableWheel_mut :: (self__pod: *physx_PxVehicleWheelsSimData_Pod, wheel: u32) -> void #foreign physx_lib;

PxVehicleWheelsSimData_getIsWheelDisabled :: (self__pod: *physx_PxVehicleWheelsSimData_Pod, wheel: u32) -> bool #foreign physx_lib;

PxVehicleWheelsSimData_setSubStepCount_mut :: (self__pod: *physx_PxVehicleWheelsSimData_Pod, thresholdLongitudinalSpeed: float, lowForwardSpeedSubStepCount: u32, highForwardSpeedSubStepCount: u32) -> void #foreign physx_lib;

PxVehicleWheelsSimData_setMinLongSlipDenominator_mut :: (self__pod: *physx_PxVehicleWheelsSimData_Pod, minLongSlipDenominator: float) -> void #foreign physx_lib;

PxVehicleWheelsSimData_setFlags_mut :: (self__pod: *physx_PxVehicleWheelsSimData_Pod, flags_pod: physx_PxVehicleWheelsSimFlags_Pod) -> void #foreign physx_lib;

PxVehicleWheelsSimData_getFlags :: (self__pod: *physx_PxVehicleWheelsSimData_Pod) -> physx_PxVehicleWheelsSimFlags_Pod #foreign physx_lib;

PxVehicleWheelsSimData_new_alloc :: (anonymous_arg0_pod: u32) -> *physx_PxVehicleWheelsSimData_Pod #foreign physx_lib;

PxVehicleWheelsSimData_getBinaryMetaData_mut :: (stream_pod: *physx_PxOutputStream_Pod) -> void #foreign physx_lib;

PxVehicleWheelsSimData_getNbWheels4 :: (self__pod: *physx_PxVehicleWheelsSimData_Pod) -> u32 #foreign physx_lib;

PxVehicleWheelsSimData_getNbSuspensionData :: (self__pod: *physx_PxVehicleWheelsSimData_Pod) -> u32 #foreign physx_lib;

PxVehicleWheelsSimData_getNbWheelData :: (self__pod: *physx_PxVehicleWheelsSimData_Pod) -> u32 #foreign physx_lib;

PxVehicleWheelsSimData_getNbSuspTravelDirection :: (self__pod: *physx_PxVehicleWheelsSimData_Pod) -> u32 #foreign physx_lib;

PxVehicleWheelsSimData_getNbTireData :: (self__pod: *physx_PxVehicleWheelsSimData_Pod) -> u32 #foreign physx_lib;

PxVehicleWheelsSimData_getNbSuspForceAppPointOffset :: (self__pod: *physx_PxVehicleWheelsSimData_Pod) -> u32 #foreign physx_lib;

PxVehicleWheelsSimData_getNbTireForceAppPointOffset :: (self__pod: *physx_PxVehicleWheelsSimData_Pod) -> u32 #foreign physx_lib;

PxVehicleWheelsSimData_getNbWheelCentreOffset :: (self__pod: *physx_PxVehicleWheelsSimData_Pod) -> u32 #foreign physx_lib;

PxVehicleWheelsSimData_getNbWheelShapeMapping :: (self__pod: *physx_PxVehicleWheelsSimData_Pod) -> u32 #foreign physx_lib;

PxVehicleWheelsSimData_getNbSceneQueryFilterData :: (self__pod: *physx_PxVehicleWheelsSimData_Pod) -> u32 #foreign physx_lib;

PxVehicleWheelsSimData_getMinLongSlipDenominator :: (self__pod: *physx_PxVehicleWheelsSimData_Pod) -> float #foreign physx_lib;

PxVehicleWheelsSimData_setThresholdLongSpeed_mut :: (self__pod: *physx_PxVehicleWheelsSimData_Pod, f: float) -> void #foreign physx_lib;

PxVehicleWheelsSimData_getThresholdLongSpeed :: (self__pod: *physx_PxVehicleWheelsSimData_Pod) -> float #foreign physx_lib;

PxVehicleWheelsSimData_setLowForwardSpeedSubStepCount_mut :: (self__pod: *physx_PxVehicleWheelsSimData_Pod, f: u32) -> void #foreign physx_lib;

PxVehicleWheelsSimData_getLowForwardSpeedSubStepCount :: (self__pod: *physx_PxVehicleWheelsSimData_Pod) -> u32 #foreign physx_lib;

PxVehicleWheelsSimData_setHighForwardSpeedSubStepCount_mut :: (self__pod: *physx_PxVehicleWheelsSimData_Pod, f: u32) -> void #foreign physx_lib;

PxVehicleWheelsSimData_getHighForwardSpeedSubStepCount :: (self__pod: *physx_PxVehicleWheelsSimData_Pod) -> u32 #foreign physx_lib;

PxVehicleWheelsSimData_setWheelEnabledState_mut :: (self__pod: *physx_PxVehicleWheelsSimData_Pod, wheel: u32, state: bool) -> void #foreign physx_lib;

PxVehicleWheelsSimData_getWheelEnabledState :: (self__pod: *physx_PxVehicleWheelsSimData_Pod, wheel: u32) -> bool #foreign physx_lib;

PxVehicleWheelsSimData_getNbWheelEnabledState :: (self__pod: *physx_PxVehicleWheelsSimData_Pod) -> u32 #foreign physx_lib;

PxVehicleWheelsSimData_getNbAntiRollBars4 :: (self__pod: *physx_PxVehicleWheelsSimData_Pod) -> u32 #foreign physx_lib;

PxVehicleWheelsSimData_getNbAntiRollBarData :: (self__pod: *physx_PxVehicleWheelsSimData_Pod) -> u32 #foreign physx_lib;

PxVehicleWheelsSimData_setAntiRollBarData_mut :: (self__pod: *physx_PxVehicleWheelsSimData_Pod, id: u32, antiRoll_pod: *physx_PxVehicleAntiRollBarData_Pod) -> void #foreign physx_lib;

PxVehicleWheelsSimData_new_alloc_1 :: () -> *physx_PxVehicleWheelsSimData_Pod #foreign physx_lib;

PxVehicleWheelsSimData_delete :: (self__pod: *physx_PxVehicleWheelsSimData_Pod) -> void #foreign physx_lib;

PxVehicleWheelsDynData_new_alloc :: () -> *physx_PxVehicleWheelsDynData_Pod #foreign physx_lib;

PxVehicleWheelsDynData_delete :: (self__pod: *physx_PxVehicleWheelsDynData_Pod) -> void #foreign physx_lib;

PxVehicleWheelsDynData_setToRestState_mut :: (self__pod: *physx_PxVehicleWheelsDynData_Pod) -> void #foreign physx_lib;

PxVehicleWheelsDynData_setTireForceShaderFunction_mut :: (self__pod: *physx_PxVehicleWheelsDynData_Pod, tireForceShaderFn_pod: *void) -> void #foreign physx_lib;

PxVehicleWheelsDynData_setTireForceShaderData_mut :: (self__pod: *physx_PxVehicleWheelsDynData_Pod, tireId: u32, tireForceShaderData: *void) -> void #foreign physx_lib;

PxVehicleWheelsDynData_getTireForceShaderData :: (self__pod: *physx_PxVehicleWheelsDynData_Pod, tireId: u32) -> *void #foreign physx_lib;

PxVehicleWheelsDynData_setWheelRotationSpeed_mut :: (self__pod: *physx_PxVehicleWheelsDynData_Pod, wheelIdx: u32, speed: float) -> void #foreign physx_lib;

PxVehicleWheelsDynData_getWheelRotationSpeed :: (self__pod: *physx_PxVehicleWheelsDynData_Pod, wheelIdx: u32) -> float #foreign physx_lib;

PxVehicleWheelsDynData_setWheelRotationAngle_mut :: (self__pod: *physx_PxVehicleWheelsDynData_Pod, wheelIdx: u32, angle: float) -> void #foreign physx_lib;

PxVehicleWheelsDynData_getWheelRotationAngle :: (self__pod: *physx_PxVehicleWheelsDynData_Pod, wheelIdx: u32) -> float #foreign physx_lib;

PxVehicleWheelsDynData_setUserData_mut :: (self__pod: *physx_PxVehicleWheelsDynData_Pod, tireIdx: u32, userData: *void) -> void #foreign physx_lib;

PxVehicleWheelsDynData_getUserData :: (self__pod: *physx_PxVehicleWheelsDynData_Pod, tireIdx: u32) -> *void #foreign physx_lib;

PxVehicleWheelsDynData_copy_mut :: (self__pod: *physx_PxVehicleWheelsDynData_Pod, src_pod: *physx_PxVehicleWheelsDynData_Pod, srcWheel: u32, trgWheel: u32) -> void #foreign physx_lib;

PxVehicleWheelsDynData_getBinaryMetaData_mut :: (stream_pod: *physx_PxOutputStream_Pod) -> void #foreign physx_lib;

PxVehicleWheelsDynData_getNbWheelRotationSpeed :: (self__pod: *physx_PxVehicleWheelsDynData_Pod) -> u32 #foreign physx_lib;

PxVehicleWheelsDynData_getNbWheelRotationAngle :: (self__pod: *physx_PxVehicleWheelsDynData_Pod) -> u32 #foreign physx_lib;

PxVehicleWheelsDynData_getWheel4DynData :: (self__pod: *physx_PxVehicleWheelsDynData_Pod) -> *physx_PxVehicleWheels4DynData_Pod #foreign physx_lib;

PxVehicleWheels_getVehicleType :: (self__pod: *physx_PxVehicleWheels_Pod) -> u32 #foreign physx_lib;

PxVehicleWheels_getRigidDynamicActor_mut :: (self__pod: *physx_PxVehicleWheels_Pod) -> *physx_PxRigidDynamic_Pod #foreign physx_lib;

PxVehicleWheels_getRigidDynamicActor :: (self__pod: *physx_PxVehicleWheels_Pod) -> *physx_PxRigidDynamic_Pod #foreign physx_lib;

PxVehicleWheels_computeForwardSpeed :: (self__pod: *physx_PxVehicleWheels_Pod) -> float #foreign physx_lib;

PxVehicleWheels_computeSidewaysSpeed :: (self__pod: *physx_PxVehicleWheels_Pod) -> float #foreign physx_lib;

PxVehicleWheels_requiresObjects_mut :: (self__pod: *physx_PxVehicleWheels_Pod, c_pod: *physx_PxProcessPxBaseCallback_Pod) -> void #foreign physx_lib;

PxVehicleWheels_getConcreteTypeName :: (self__pod: *physx_PxVehicleWheels_Pod) -> *u8 #foreign physx_lib;

PxVehicleWheels_isKindOf :: (self__pod: *physx_PxVehicleWheels_Pod, name: *u8) -> bool #foreign physx_lib;

PxVehicleWheels_preExportDataReset_mut :: (self__pod: *physx_PxVehicleWheels_Pod) -> void #foreign physx_lib;

PxVehicleWheels_exportExtraData_mut :: (self__pod: *physx_PxVehicleWheels_Pod, anonymous_arg0_pod: *physx_PxSerializationContext_Pod) -> void #foreign physx_lib;

PxVehicleWheels_importExtraData_mut :: (self__pod: *physx_PxVehicleWheels_Pod, anonymous_arg0_pod: *physx_PxDeserializationContext_Pod) -> void #foreign physx_lib;

PxVehicleWheels_resolveReferences_mut :: (self__pod: *physx_PxVehicleWheels_Pod, anonymous_arg0_pod: *physx_PxDeserializationContext_Pod) -> void #foreign physx_lib;

PxVehicleWheels_getBinaryMetaData_mut :: (stream_pod: *physx_PxOutputStream_Pod) -> void #foreign physx_lib;

PxVehicleWheels_getNbNonDrivenWheels :: (self__pod: *physx_PxVehicleWheels_Pod) -> u32 #foreign physx_lib;

PxVehicleWheels_new_alloc :: (concreteType: u16, baseFlags_pod: physx_PxBaseFlags_Pod) -> *physx_PxVehicleWheels_Pod #foreign physx_lib;

PxVehicleWheels_new_alloc_1 :: (baseFlags_pod: physx_PxBaseFlags_Pod) -> *physx_PxVehicleWheels_Pod #foreign physx_lib;

PxVehicleWheels_release_mut :: (self__pod: *physx_PxVehicleWheels_Pod) -> void #foreign physx_lib;

PxVehicleDriveSimData_getEngineData :: (self__pod: *physx_PxVehicleDriveSimData_Pod) -> *physx_PxVehicleEngineData_Pod #foreign physx_lib;

PxVehicleDriveSimData_setEngineData_mut :: (self__pod: *physx_PxVehicleDriveSimData_Pod, engine_pod: *physx_PxVehicleEngineData_Pod) -> void #foreign physx_lib;

PxVehicleDriveSimData_getGearsData :: (self__pod: *physx_PxVehicleDriveSimData_Pod) -> *physx_PxVehicleGearsData_Pod #foreign physx_lib;

PxVehicleDriveSimData_setGearsData_mut :: (self__pod: *physx_PxVehicleDriveSimData_Pod, gears_pod: *physx_PxVehicleGearsData_Pod) -> void #foreign physx_lib;

PxVehicleDriveSimData_getClutchData :: (self__pod: *physx_PxVehicleDriveSimData_Pod) -> *physx_PxVehicleClutchData_Pod #foreign physx_lib;

PxVehicleDriveSimData_setClutchData_mut :: (self__pod: *physx_PxVehicleDriveSimData_Pod, clutch_pod: *physx_PxVehicleClutchData_Pod) -> void #foreign physx_lib;

PxVehicleDriveSimData_getAutoBoxData :: (self__pod: *physx_PxVehicleDriveSimData_Pod) -> *physx_PxVehicleAutoBoxData_Pod #foreign physx_lib;

PxVehicleDriveSimData_setAutoBoxData_mut :: (self__pod: *physx_PxVehicleDriveSimData_Pod, autobox_pod: *physx_PxVehicleAutoBoxData_Pod) -> void #foreign physx_lib;

PxVehicleDriveSimData_new :: () -> physx_PxVehicleDriveSimData_Pod #foreign physx_lib;

PxVehicleDriveSimData_new_1 :: (anonymous_arg0_pod: u32) -> physx_PxVehicleDriveSimData_Pod #foreign physx_lib;

PxVehicleDriveSimData_getBinaryMetaData_mut :: (stream_pod: *physx_PxOutputStream_Pod) -> void #foreign physx_lib;

PxVehicleDriveSimData_delete :: (self__pod: *physx_PxVehicleDriveSimData_Pod) -> void #foreign physx_lib;

PxVehicleDriveDynData_setToRestState_mut :: (self__pod: *physx_PxVehicleDriveDynData_Pod) -> void #foreign physx_lib;

PxVehicleDriveDynData_setAnalogInput_mut :: (self__pod: *physx_PxVehicleDriveDynData_Pod, type: u32, analogVal: float) -> void #foreign physx_lib;

PxVehicleDriveDynData_getAnalogInput :: (self__pod: *physx_PxVehicleDriveDynData_Pod, type: u32) -> float #foreign physx_lib;

PxVehicleDriveDynData_setGearUp_mut :: (self__pod: *physx_PxVehicleDriveDynData_Pod, digitalVal: bool) -> void #foreign physx_lib;

PxVehicleDriveDynData_setGearDown_mut :: (self__pod: *physx_PxVehicleDriveDynData_Pod, digitalVal: bool) -> void #foreign physx_lib;

PxVehicleDriveDynData_getGearUp :: (self__pod: *physx_PxVehicleDriveDynData_Pod) -> bool #foreign physx_lib;

PxVehicleDriveDynData_getGearDown :: (self__pod: *physx_PxVehicleDriveDynData_Pod) -> bool #foreign physx_lib;

PxVehicleDriveDynData_setUseAutoGears_mut :: (self__pod: *physx_PxVehicleDriveDynData_Pod, useAutoGears: bool) -> void #foreign physx_lib;

PxVehicleDriveDynData_getUseAutoGears :: (self__pod: *physx_PxVehicleDriveDynData_Pod) -> bool #foreign physx_lib;

PxVehicleDriveDynData_toggleAutoGears_mut :: (self__pod: *physx_PxVehicleDriveDynData_Pod) -> void #foreign physx_lib;

PxVehicleDriveDynData_setCurrentGear_mut :: (self__pod: *physx_PxVehicleDriveDynData_Pod, currentGear: u32) -> void #foreign physx_lib;

PxVehicleDriveDynData_getCurrentGear :: (self__pod: *physx_PxVehicleDriveDynData_Pod) -> u32 #foreign physx_lib;

PxVehicleDriveDynData_setTargetGear_mut :: (self__pod: *physx_PxVehicleDriveDynData_Pod, targetGear: u32) -> void #foreign physx_lib;

PxVehicleDriveDynData_getTargetGear :: (self__pod: *physx_PxVehicleDriveDynData_Pod) -> u32 #foreign physx_lib;

PxVehicleDriveDynData_startGearChange_mut :: (self__pod: *physx_PxVehicleDriveDynData_Pod, targetGear: u32) -> void #foreign physx_lib;

PxVehicleDriveDynData_forceGearChange_mut :: (self__pod: *physx_PxVehicleDriveDynData_Pod, targetGear: u32) -> void #foreign physx_lib;

PxVehicleDriveDynData_setEngineRotationSpeed_mut :: (self__pod: *physx_PxVehicleDriveDynData_Pod, speed: float) -> void #foreign physx_lib;

PxVehicleDriveDynData_getEngineRotationSpeed :: (self__pod: *physx_PxVehicleDriveDynData_Pod) -> float #foreign physx_lib;

PxVehicleDriveDynData_getGearSwitchTime :: (self__pod: *physx_PxVehicleDriveDynData_Pod) -> float #foreign physx_lib;

PxVehicleDriveDynData_getAutoBoxSwitchTime :: (self__pod: *physx_PxVehicleDriveDynData_Pod) -> float #foreign physx_lib;

PxVehicleDriveDynData_new :: () -> physx_PxVehicleDriveDynData_Pod #foreign physx_lib;

PxVehicleDriveDynData_new_1 :: (anonymous_arg0_pod: u32) -> physx_PxVehicleDriveDynData_Pod #foreign physx_lib;

PxVehicleDriveDynData_getNbAnalogInput :: (self__pod: *physx_PxVehicleDriveDynData_Pod) -> u32 #foreign physx_lib;

PxVehicleDriveDynData_setGearChange_mut :: (self__pod: *physx_PxVehicleDriveDynData_Pod, gearChange: u32) -> void #foreign physx_lib;

PxVehicleDriveDynData_getGearChange :: (self__pod: *physx_PxVehicleDriveDynData_Pod) -> u32 #foreign physx_lib;

PxVehicleDriveDynData_setGearSwitchTime_mut :: (self__pod: *physx_PxVehicleDriveDynData_Pod, switchTime: float) -> void #foreign physx_lib;

PxVehicleDriveDynData_setAutoBoxSwitchTime_mut :: (self__pod: *physx_PxVehicleDriveDynData_Pod, autoBoxSwitchTime: float) -> void #foreign physx_lib;

PxVehicleDrive_getBinaryMetaData_mut :: (stream_pod: *physx_PxOutputStream_Pod) -> void #foreign physx_lib;

PxVehicleDrive_new_alloc :: (baseFlags_pod: physx_PxBaseFlags_Pod) -> *physx_PxVehicleDrive_Pod #foreign physx_lib;

PxVehicleDrive_getConcreteTypeName :: (self__pod: *physx_PxVehicleDrive_Pod) -> *u8 #foreign physx_lib;

PxVehicleDriveSimData4W_new :: () -> physx_PxVehicleDriveSimData4W_Pod #foreign physx_lib;

PxVehicleDriveSimData4W_getDiffData :: (self__pod: *physx_PxVehicleDriveSimData4W_Pod) -> *physx_PxVehicleDifferential4WData_Pod #foreign physx_lib;

PxVehicleDriveSimData4W_getAckermannGeometryData :: (self__pod: *physx_PxVehicleDriveSimData4W_Pod) -> *physx_PxVehicleAckermannGeometryData_Pod #foreign physx_lib;

PxVehicleDriveSimData4W_setDiffData_mut :: (self__pod: *physx_PxVehicleDriveSimData4W_Pod, diff_pod: *physx_PxVehicleDifferential4WData_Pod) -> void #foreign physx_lib;

PxVehicleDriveSimData4W_setAckermannGeometryData_mut :: (self__pod: *physx_PxVehicleDriveSimData4W_Pod, ackermannData_pod: *physx_PxVehicleAckermannGeometryData_Pod) -> void #foreign physx_lib;

PxVehicleDriveSimData4W_new_1 :: (anonymous_arg0_pod: u32) -> physx_PxVehicleDriveSimData4W_Pod #foreign physx_lib;

PxVehicleDriveSimData4W_getBinaryMetaData_mut :: (stream_pod: *physx_PxOutputStream_Pod) -> void #foreign physx_lib;

PxVehicleDriveSimData4W_delete :: (self__pod: *physx_PxVehicleDriveSimData4W_Pod) -> void #foreign physx_lib;

PxVehicleDrive4W_allocate_mut :: (nbWheels: u32) -> *physx_PxVehicleDrive4W_Pod #foreign physx_lib;

PxVehicleDrive4W_free_mut :: (self__pod: *physx_PxVehicleDrive4W_Pod) -> void #foreign physx_lib;

PxVehicleDrive4W_setup_mut :: (self__pod: *physx_PxVehicleDrive4W_Pod, physics_pod: *physx_PxPhysics_Pod, vehActor_pod: *physx_PxRigidDynamic_Pod, wheelsData_pod: *physx_PxVehicleWheelsSimData_Pod, driveData_pod: *physx_PxVehicleDriveSimData4W_Pod, nbNonDrivenWheels: u32) -> void #foreign physx_lib;

PxVehicleDrive4W_create_mut :: (physics_pod: *physx_PxPhysics_Pod, vehActor_pod: *physx_PxRigidDynamic_Pod, wheelsData_pod: *physx_PxVehicleWheelsSimData_Pod, driveData_pod: *physx_PxVehicleDriveSimData4W_Pod, nbNonDrivenWheels: u32) -> *physx_PxVehicleDrive4W_Pod #foreign physx_lib;

PxVehicleDrive4W_setToRestState_mut :: (self__pod: *physx_PxVehicleDrive4W_Pod) -> void #foreign physx_lib;

PxVehicleDrive4W_createObject_mut :: (address_pod: **u8, context_pod: *physx_PxDeserializationContext_Pod) -> *physx_PxVehicleDrive4W_Pod #foreign physx_lib;

PxVehicleDrive4W_getBinaryMetaData_mut :: (stream_pod: *physx_PxOutputStream_Pod) -> void #foreign physx_lib;

PxVehicleDrive4W_new_alloc :: (baseFlags_pod: physx_PxBaseFlags_Pod) -> *physx_PxVehicleDrive4W_Pod #foreign physx_lib;

PxVehicleDrive4W_getConcreteTypeName :: (self__pod: *physx_PxVehicleDrive4W_Pod) -> *u8 #foreign physx_lib;

PxVehicleDriveTank_allocate_mut :: (nbWheels: u32) -> *physx_PxVehicleDriveTank_Pod #foreign physx_lib;

PxVehicleDriveTank_free_mut :: (self__pod: *physx_PxVehicleDriveTank_Pod) -> void #foreign physx_lib;

PxVehicleDriveTank_setup_mut :: (self__pod: *physx_PxVehicleDriveTank_Pod, physics_pod: *physx_PxPhysics_Pod, vehActor_pod: *physx_PxRigidDynamic_Pod, wheelsData_pod: *physx_PxVehicleWheelsSimData_Pod, driveData_pod: *physx_PxVehicleDriveSimData_Pod, nbDrivenWheels: u32) -> void #foreign physx_lib;

PxVehicleDriveTank_create_mut :: (physics_pod: *physx_PxPhysics_Pod, vehActor_pod: *physx_PxRigidDynamic_Pod, wheelsData_pod: *physx_PxVehicleWheelsSimData_Pod, driveData_pod: *physx_PxVehicleDriveSimData_Pod, nbDrivenWheels: u32) -> *physx_PxVehicleDriveTank_Pod #foreign physx_lib;

PxVehicleDriveTank_setDriveModel_mut :: (self__pod: *physx_PxVehicleDriveTank_Pod, driveModel_pod: u32) -> void #foreign physx_lib;

PxVehicleDriveTank_getDriveModel :: (self__pod: *physx_PxVehicleDriveTank_Pod) -> u32 #foreign physx_lib;

PxVehicleDriveTank_setToRestState_mut :: (self__pod: *physx_PxVehicleDriveTank_Pod) -> void #foreign physx_lib;

PxVehicleDriveTank_new_alloc :: (baseFlags_pod: physx_PxBaseFlags_Pod) -> *physx_PxVehicleDriveTank_Pod #foreign physx_lib;

PxVehicleDriveTank_createObject_mut :: (address_pod: **u8, context_pod: *physx_PxDeserializationContext_Pod) -> *physx_PxVehicleDriveTank_Pod #foreign physx_lib;

PxVehicleDriveTank_getBinaryMetaData_mut :: (stream_pod: *physx_PxOutputStream_Pod) -> void #foreign physx_lib;

PxVehicleDriveTank_getConcreteTypeName :: (self__pod: *physx_PxVehicleDriveTank_Pod) -> *u8 #foreign physx_lib;

PxVehicleDriveTank_isKindOf :: (self__pod: *physx_PxVehicleDriveTank_Pod, name: *u8) -> bool #foreign physx_lib;

PxVehicleDrivableSurfaceToTireFrictionPairs_allocate_mut :: (maxNbTireTypes: u32, maxNbSurfaceTypes: u32) -> *physx_PxVehicleDrivableSurfaceToTireFrictionPairs_Pod #foreign physx_lib;

PxVehicleDrivableSurfaceToTireFrictionPairs_setup_mut :: (self__pod: *physx_PxVehicleDrivableSurfaceToTireFrictionPairs_Pod, nbTireTypes: u32, nbSurfaceTypes: u32, drivableSurfaceMaterials_pod: **physx_PxMaterial_Pod, drivableSurfaceTypes_pod: *physx_PxVehicleDrivableSurfaceType_Pod) -> void #foreign physx_lib;

PxVehicleDrivableSurfaceToTireFrictionPairs_release_mut :: (self__pod: *physx_PxVehicleDrivableSurfaceToTireFrictionPairs_Pod) -> void #foreign physx_lib;

PxVehicleDrivableSurfaceToTireFrictionPairs_setTypePairFriction_mut :: (self__pod: *physx_PxVehicleDrivableSurfaceToTireFrictionPairs_Pod, surfaceType: u32, tireType: u32, value: float) -> void #foreign physx_lib;

PxVehicleDrivableSurfaceToTireFrictionPairs_getTypePairFriction :: (self__pod: *physx_PxVehicleDrivableSurfaceToTireFrictionPairs_Pod, surfaceType: u32, tireType: u32) -> float #foreign physx_lib;

PxVehicleDrivableSurfaceToTireFrictionPairs_getMaxNbSurfaceTypes :: (self__pod: *physx_PxVehicleDrivableSurfaceToTireFrictionPairs_Pod) -> u32 #foreign physx_lib;

PxVehicleDrivableSurfaceToTireFrictionPairs_getMaxNbTireTypes :: (self__pod: *physx_PxVehicleDrivableSurfaceToTireFrictionPairs_Pod) -> u32 #foreign physx_lib;

PxWheelQueryResult_new :: () -> physx_PxWheelQueryResult_Pod #foreign physx_lib;

PxVehicleWheelConcurrentUpdateData_new :: () -> physx_PxVehicleWheelConcurrentUpdateData_Pod #foreign physx_lib;

PxVehicleConcurrentUpdateData_new :: () -> physx_PxVehicleConcurrentUpdateData_Pod #foreign physx_lib;

phys_PxVehicleSuspensionRaycasts :: (batchQuery_pod: *physx_PxBatchQuery_Pod, nbVehicles: u32, vehicles_pod: **physx_PxVehicleWheels_Pod, nbSceneQueryResults: u32, sceneQueryResults_pod: *physx_PxRaycastQueryResult_Pod, vehiclesToRaycast: *bool) -> void #foreign physx_lib;

// void phys_PxVehicleSuspensionSweeps(physx_PxBatchQuery_Pod* batchQuery_pod, uint32_t nbVehicles, physx_PxVehicleWheels_Pod** vehicles_pod, uint32_t nbSceneQueryResults, physx_PxSweepQueryResult_Pod* sceneQueryResults_pod, uint16_t nbHitsPerQuery, bool const* vehiclesToSweep, float sweepWidthScale, float sweepRadiusScale) {
// physx::PxBatchQuery* batchQuery = reinterpret_cast<physx::PxBatchQuery*>(batchQuery_pod);
// physx::PxVehicleWheels** vehicles = reinterpret_cast<physx::PxVehicleWheels**>(vehicles_pod);
// physx::PxSweepQueryResult* sceneQueryResults = reinterpret_cast<physx::PxSweepQueryResult*>(sceneQueryResults_pod);
// PxVehicleSuspensionSweeps(batchQuery, nbVehicles, vehicles, nbSceneQueryResults, sceneQueryResults, nbHitsPerQuery, vehiclesToSweep, sweepWidthScale, sweepRadiusScale);
// }
phys_PxVehicleModifyWheelContacts :: (vehicle_pod: *physx_PxVehicleWheels_Pod, wheelId: u32, wheelTangentVelocityMultiplier: float, maxImpulse: float, contactModifyPair_pod: *physx_PxContactModifyPair_Pod) -> u32 #foreign physx_lib;

phys_PxVehicleUpdates :: (timestep: float, gravity_pod: *physx_PxVec3_Pod, vehicleDrivableSurfaceToTireFrictionPairs_pod: *physx_PxVehicleDrivableSurfaceToTireFrictionPairs_Pod, nbVehicles: u32, vehicles_pod: **physx_PxVehicleWheels_Pod, vehicleWheelQueryResults_pod: *physx_PxVehicleWheelQueryResult_Pod, vehicleConcurrentUpdates_pod: *physx_PxVehicleConcurrentUpdateData_Pod) -> void #foreign physx_lib;

phys_PxVehiclePostUpdates :: (vehicleConcurrentUpdates_pod: *physx_PxVehicleConcurrentUpdateData_Pod, nbVehicles: u32, vehicles_pod: **physx_PxVehicleWheels_Pod) -> void #foreign physx_lib;

phys_PxVehicleShiftOrigin :: (shift_pod: *physx_PxVec3_Pod, nbVehicles: u32, vehicles_pod: **physx_PxVehicleWheels_Pod) -> void #foreign physx_lib;

// void phys_PxVehicleUpdateSingleVehicleAndStoreTelemetryData(float timestep, physx_PxVec3_Pod const* gravity_pod, physx_PxVehicleDrivableSurfaceToTireFrictionPairs_Pod const* vehicleDrivableSurfaceToTireFrictionPairs_pod, physx_PxVehicleWheels_Pod* focusVehicle_pod, physx_PxVehicleWheelQueryResult_Pod* vehicleWheelQueryResults_pod, physx_PxVehicleTelemetryData_Pod* telemetryData_pod) {
// physx::PxVec3 const& gravity = reinterpret_cast<physx::PxVec3 const&>(*gravity_pod);
// physx::PxVehicleDrivableSurfaceToTireFrictionPairs const& vehicleDrivableSurfaceToTireFrictionPairs = reinterpret_cast<physx::PxVehicleDrivableSurfaceToTireFrictionPairs const&>(*vehicleDrivableSurfaceToTireFrictionPairs_pod);
// physx::PxVehicleWheels* focusVehicle = reinterpret_cast<physx::PxVehicleWheels*>(focusVehicle_pod);
// physx::PxVehicleWheelQueryResult* vehicleWheelQueryResults = reinterpret_cast<physx::PxVehicleWheelQueryResult*>(vehicleWheelQueryResults_pod);
// physx::PxVehicleTelemetryData& telemetryData = reinterpret_cast<physx::PxVehicleTelemetryData&>(*telemetryData_pod);
// PxVehicleUpdateSingleVehicleAndStoreTelemetryData(timestep, gravity, vehicleDrivableSurfaceToTireFrictionPairs, focusVehicle, vehicleWheelQueryResults, telemetryData);
// }
PxVehicleDriveSimDataNW_new :: () -> physx_PxVehicleDriveSimDataNW_Pod #foreign physx_lib;

PxVehicleDriveSimDataNW_getDiffData :: (self__pod: *physx_PxVehicleDriveSimDataNW_Pod) -> *physx_PxVehicleDifferentialNWData_Pod #foreign physx_lib;

PxVehicleDriveSimDataNW_setDiffData_mut :: (self__pod: *physx_PxVehicleDriveSimDataNW_Pod, diff_pod: *physx_PxVehicleDifferentialNWData_Pod) -> void #foreign physx_lib;

PxVehicleDriveSimDataNW_new_1 :: (anonymous_arg0_pod: u32) -> physx_PxVehicleDriveSimDataNW_Pod #foreign physx_lib;

PxVehicleDriveSimDataNW_getBinaryMetaData_mut :: (stream_pod: *physx_PxOutputStream_Pod) -> void #foreign physx_lib;

PxVehicleDriveSimDataNW_delete :: (self__pod: *physx_PxVehicleDriveSimDataNW_Pod) -> void #foreign physx_lib;

PxVehicleDriveNW_allocate_mut :: (nbWheels: u32) -> *physx_PxVehicleDriveNW_Pod #foreign physx_lib;

PxVehicleDriveNW_free_mut :: (self__pod: *physx_PxVehicleDriveNW_Pod) -> void #foreign physx_lib;

PxVehicleDriveNW_setup_mut :: (self__pod: *physx_PxVehicleDriveNW_Pod, physics_pod: *physx_PxPhysics_Pod, vehActor_pod: *physx_PxRigidDynamic_Pod, wheelsData_pod: *physx_PxVehicleWheelsSimData_Pod, driveData_pod: *physx_PxVehicleDriveSimDataNW_Pod, nbWheels: u32) -> void #foreign physx_lib;

PxVehicleDriveNW_create_mut :: (physics_pod: *physx_PxPhysics_Pod, vehActor_pod: *physx_PxRigidDynamic_Pod, wheelsData_pod: *physx_PxVehicleWheelsSimData_Pod, driveData_pod: *physx_PxVehicleDriveSimDataNW_Pod, nbWheels: u32) -> *physx_PxVehicleDriveNW_Pod #foreign physx_lib;

PxVehicleDriveNW_setToRestState_mut :: (self__pod: *physx_PxVehicleDriveNW_Pod) -> void #foreign physx_lib;

PxVehicleDriveNW_new_alloc :: (baseFlags_pod: physx_PxBaseFlags_Pod) -> *physx_PxVehicleDriveNW_Pod #foreign physx_lib;

PxVehicleDriveNW_new_alloc_1 :: () -> *physx_PxVehicleDriveNW_Pod #foreign physx_lib;

PxVehicleDriveNW_createObject_mut :: (address_pod: **u8, context_pod: *physx_PxDeserializationContext_Pod) -> *physx_PxVehicleDriveNW_Pod #foreign physx_lib;

PxVehicleDriveNW_getBinaryMetaData_mut :: (stream_pod: *physx_PxOutputStream_Pod) -> void #foreign physx_lib;

PxVehicleDriveNW_getConcreteTypeName :: (self__pod: *physx_PxVehicleDriveNW_Pod) -> *u8 #foreign physx_lib;

PxVehicleDriveNW_isKindOf :: (self__pod: *physx_PxVehicleDriveNW_Pod, name: *u8) -> bool #foreign physx_lib;

PxVehicleDrive4WRawInputData_new_alloc :: () -> *physx_PxVehicleDrive4WRawInputData_Pod #foreign physx_lib;

PxVehicleDrive4WRawInputData_delete :: (self__pod: *physx_PxVehicleDrive4WRawInputData_Pod) -> void #foreign physx_lib;

PxVehicleDrive4WRawInputData_setDigitalAccel_mut :: (self__pod: *physx_PxVehicleDrive4WRawInputData_Pod, accelKeyPressed: bool) -> void #foreign physx_lib;

PxVehicleDrive4WRawInputData_setDigitalBrake_mut :: (self__pod: *physx_PxVehicleDrive4WRawInputData_Pod, brakeKeyPressed: bool) -> void #foreign physx_lib;

PxVehicleDrive4WRawInputData_setDigitalHandbrake_mut :: (self__pod: *physx_PxVehicleDrive4WRawInputData_Pod, handbrakeKeyPressed: bool) -> void #foreign physx_lib;

PxVehicleDrive4WRawInputData_setDigitalSteerLeft_mut :: (self__pod: *physx_PxVehicleDrive4WRawInputData_Pod, steerLeftKeyPressed: bool) -> void #foreign physx_lib;

PxVehicleDrive4WRawInputData_setDigitalSteerRight_mut :: (self__pod: *physx_PxVehicleDrive4WRawInputData_Pod, steerRightKeyPressed: bool) -> void #foreign physx_lib;

PxVehicleDrive4WRawInputData_getDigitalAccel :: (self__pod: *physx_PxVehicleDrive4WRawInputData_Pod) -> bool #foreign physx_lib;

PxVehicleDrive4WRawInputData_getDigitalBrake :: (self__pod: *physx_PxVehicleDrive4WRawInputData_Pod) -> bool #foreign physx_lib;

PxVehicleDrive4WRawInputData_getDigitalHandbrake :: (self__pod: *physx_PxVehicleDrive4WRawInputData_Pod) -> bool #foreign physx_lib;

PxVehicleDrive4WRawInputData_getDigitalSteerLeft :: (self__pod: *physx_PxVehicleDrive4WRawInputData_Pod) -> bool #foreign physx_lib;

PxVehicleDrive4WRawInputData_getDigitalSteerRight :: (self__pod: *physx_PxVehicleDrive4WRawInputData_Pod) -> bool #foreign physx_lib;

PxVehicleDrive4WRawInputData_setAnalogAccel_mut :: (self__pod: *physx_PxVehicleDrive4WRawInputData_Pod, accel: float) -> void #foreign physx_lib;

PxVehicleDrive4WRawInputData_setAnalogBrake_mut :: (self__pod: *physx_PxVehicleDrive4WRawInputData_Pod, brake: float) -> void #foreign physx_lib;

PxVehicleDrive4WRawInputData_setAnalogHandbrake_mut :: (self__pod: *physx_PxVehicleDrive4WRawInputData_Pod, handbrake: float) -> void #foreign physx_lib;

PxVehicleDrive4WRawInputData_setAnalogSteer_mut :: (self__pod: *physx_PxVehicleDrive4WRawInputData_Pod, steer: float) -> void #foreign physx_lib;

PxVehicleDrive4WRawInputData_getAnalogAccel :: (self__pod: *physx_PxVehicleDrive4WRawInputData_Pod) -> float #foreign physx_lib;

PxVehicleDrive4WRawInputData_getAnalogBrake :: (self__pod: *physx_PxVehicleDrive4WRawInputData_Pod) -> float #foreign physx_lib;

PxVehicleDrive4WRawInputData_getAnalogHandbrake :: (self__pod: *physx_PxVehicleDrive4WRawInputData_Pod) -> float #foreign physx_lib;

PxVehicleDrive4WRawInputData_getAnalogSteer :: (self__pod: *physx_PxVehicleDrive4WRawInputData_Pod) -> float #foreign physx_lib;

PxVehicleDrive4WRawInputData_setGearUp_mut :: (self__pod: *physx_PxVehicleDrive4WRawInputData_Pod, gearUpKeyPressed: bool) -> void #foreign physx_lib;

PxVehicleDrive4WRawInputData_setGearDown_mut :: (self__pod: *physx_PxVehicleDrive4WRawInputData_Pod, gearDownKeyPressed: bool) -> void #foreign physx_lib;

PxVehicleDrive4WRawInputData_getGearUp :: (self__pod: *physx_PxVehicleDrive4WRawInputData_Pod) -> bool #foreign physx_lib;

PxVehicleDrive4WRawInputData_getGearDown :: (self__pod: *physx_PxVehicleDrive4WRawInputData_Pod) -> bool #foreign physx_lib;

phys_PxVehicleDrive4WSmoothDigitalRawInputsAndSetAnalogInputs :: (keySmoothing_pod: *physx_PxVehicleKeySmoothingData_Pod, steerVsForwardSpeedTable_pod: *PxFixedSizeLookupTable_8__Pod, rawInputData_pod: *physx_PxVehicleDrive4WRawInputData_Pod, timestep: float, isVehicleInAir: bool, focusVehicle_pod: *physx_PxVehicleDrive4W_Pod) -> void #foreign physx_lib;

phys_PxVehicleDrive4WSmoothAnalogRawInputsAndSetAnalogInputs :: (padSmoothing_pod: *physx_PxVehiclePadSmoothingData_Pod, steerVsForwardSpeedTable_pod: *PxFixedSizeLookupTable_8__Pod, rawInputData_pod: *physx_PxVehicleDrive4WRawInputData_Pod, timestep: float, isVehicleInAir: bool, focusVehicle_pod: *physx_PxVehicleDrive4W_Pod) -> void #foreign physx_lib;

PxVehicleDriveNWRawInputData_new_alloc :: () -> *physx_PxVehicleDriveNWRawInputData_Pod #foreign physx_lib;

PxVehicleDriveNWRawInputData_delete :: (self__pod: *physx_PxVehicleDriveNWRawInputData_Pod) -> void #foreign physx_lib;

phys_PxVehicleDriveNWSmoothDigitalRawInputsAndSetAnalogInputs :: (keySmoothing_pod: *physx_PxVehicleKeySmoothingData_Pod, steerVsForwardSpeedTable_pod: *PxFixedSizeLookupTable_8__Pod, rawInputData_pod: *physx_PxVehicleDriveNWRawInputData_Pod, timestep: float, isVehicleInAir: bool, focusVehicle_pod: *physx_PxVehicleDriveNW_Pod) -> void #foreign physx_lib;

phys_PxVehicleDriveNWSmoothAnalogRawInputsAndSetAnalogInputs :: (padSmoothing_pod: *physx_PxVehiclePadSmoothingData_Pod, steerVsForwardSpeedTable_pod: *PxFixedSizeLookupTable_8__Pod, rawInputData_pod: *physx_PxVehicleDriveNWRawInputData_Pod, timestep: float, isVehicleInAir: bool, focusVehicle_pod: *physx_PxVehicleDriveNW_Pod) -> void #foreign physx_lib;

PxVehicleDriveTankRawInputData_new_alloc :: (mode_pod: u32) -> *physx_PxVehicleDriveTankRawInputData_Pod #foreign physx_lib;

PxVehicleDriveTankRawInputData_delete :: (self__pod: *physx_PxVehicleDriveTankRawInputData_Pod) -> void #foreign physx_lib;

PxVehicleDriveTankRawInputData_getDriveModel :: (self__pod: *physx_PxVehicleDriveTankRawInputData_Pod) -> u32 #foreign physx_lib;

PxVehicleDriveTankRawInputData_setDigitalAccel_mut :: (self__pod: *physx_PxVehicleDriveTankRawInputData_Pod, b: bool) -> void #foreign physx_lib;

PxVehicleDriveTankRawInputData_setDigitalLeftThrust_mut :: (self__pod: *physx_PxVehicleDriveTankRawInputData_Pod, b: bool) -> void #foreign physx_lib;

PxVehicleDriveTankRawInputData_setDigitalRightThrust_mut :: (self__pod: *physx_PxVehicleDriveTankRawInputData_Pod, b: bool) -> void #foreign physx_lib;

PxVehicleDriveTankRawInputData_setDigitalLeftBrake_mut :: (self__pod: *physx_PxVehicleDriveTankRawInputData_Pod, b: bool) -> void #foreign physx_lib;

PxVehicleDriveTankRawInputData_setDigitalRightBrake_mut :: (self__pod: *physx_PxVehicleDriveTankRawInputData_Pod, b: bool) -> void #foreign physx_lib;

PxVehicleDriveTankRawInputData_getDigitalAccel :: (self__pod: *physx_PxVehicleDriveTankRawInputData_Pod) -> bool #foreign physx_lib;

PxVehicleDriveTankRawInputData_getDigitalLeftThrust :: (self__pod: *physx_PxVehicleDriveTankRawInputData_Pod) -> bool #foreign physx_lib;

PxVehicleDriveTankRawInputData_getDigitalRightThrust :: (self__pod: *physx_PxVehicleDriveTankRawInputData_Pod) -> bool #foreign physx_lib;

PxVehicleDriveTankRawInputData_getDigitalLeftBrake :: (self__pod: *physx_PxVehicleDriveTankRawInputData_Pod) -> bool #foreign physx_lib;

PxVehicleDriveTankRawInputData_getDigitalRightBrake :: (self__pod: *physx_PxVehicleDriveTankRawInputData_Pod) -> bool #foreign physx_lib;

PxVehicleDriveTankRawInputData_setAnalogAccel_mut :: (self__pod: *physx_PxVehicleDriveTankRawInputData_Pod, accel: float) -> void #foreign physx_lib;

PxVehicleDriveTankRawInputData_setAnalogLeftThrust_mut :: (self__pod: *physx_PxVehicleDriveTankRawInputData_Pod, leftThrust: float) -> void #foreign physx_lib;

PxVehicleDriveTankRawInputData_setAnalogRightThrust_mut :: (self__pod: *physx_PxVehicleDriveTankRawInputData_Pod, rightThrust: float) -> void #foreign physx_lib;

PxVehicleDriveTankRawInputData_setAnalogLeftBrake_mut :: (self__pod: *physx_PxVehicleDriveTankRawInputData_Pod, leftBrake: float) -> void #foreign physx_lib;

PxVehicleDriveTankRawInputData_setAnalogRightBrake_mut :: (self__pod: *physx_PxVehicleDriveTankRawInputData_Pod, rightBrake: float) -> void #foreign physx_lib;

PxVehicleDriveTankRawInputData_getAnalogAccel :: (self__pod: *physx_PxVehicleDriveTankRawInputData_Pod) -> float #foreign physx_lib;

PxVehicleDriveTankRawInputData_getAnalogLeftThrust :: (self__pod: *physx_PxVehicleDriveTankRawInputData_Pod) -> float #foreign physx_lib;

PxVehicleDriveTankRawInputData_getAnalogRightThrust :: (self__pod: *physx_PxVehicleDriveTankRawInputData_Pod) -> float #foreign physx_lib;

PxVehicleDriveTankRawInputData_getAnalogLeftBrake :: (self__pod: *physx_PxVehicleDriveTankRawInputData_Pod) -> float #foreign physx_lib;

PxVehicleDriveTankRawInputData_getAnalogRightBrake :: (self__pod: *physx_PxVehicleDriveTankRawInputData_Pod) -> float #foreign physx_lib;

PxVehicleDriveTankRawInputData_setGearUp_mut :: (self__pod: *physx_PxVehicleDriveTankRawInputData_Pod, gearUp: bool) -> void #foreign physx_lib;

PxVehicleDriveTankRawInputData_setGearDown_mut :: (self__pod: *physx_PxVehicleDriveTankRawInputData_Pod, gearDown: bool) -> void #foreign physx_lib;

PxVehicleDriveTankRawInputData_getGearUp :: (self__pod: *physx_PxVehicleDriveTankRawInputData_Pod) -> bool #foreign physx_lib;

PxVehicleDriveTankRawInputData_getGearDown :: (self__pod: *physx_PxVehicleDriveTankRawInputData_Pod) -> bool #foreign physx_lib;

phys_PxVehicleDriveTankSmoothDigitalRawInputsAndSetAnalogInputs :: (keySmoothing_pod: *physx_PxVehicleKeySmoothingData_Pod, rawInputData_pod: *physx_PxVehicleDriveTankRawInputData_Pod, timestep: float, focusVehicle_pod: *physx_PxVehicleDriveTank_Pod) -> void #foreign physx_lib;

phys_PxVehicleDriveTankSmoothAnalogRawInputsAndSetAnalogInputs :: (padSmoothing_pod: *physx_PxVehiclePadSmoothingData_Pod, rawInputData_pod: *physx_PxVehicleDriveTankRawInputData_Pod, timestep: float, focusVehicle_pod: *physx_PxVehicleDriveTank_Pod) -> void #foreign physx_lib;

phys_PxVehicle4WEnable3WTadpoleMode :: (wheelsSimData_pod: *physx_PxVehicleWheelsSimData_Pod, wheelsDynData_pod: *physx_PxVehicleWheelsDynData_Pod, driveSimData_pod: *physx_PxVehicleDriveSimData4W_Pod) -> void #foreign physx_lib;

phys_PxVehicle4WEnable3WDeltaMode :: (wheelsSimData_pod: *physx_PxVehicleWheelsSimData_Pod, wheelsDynData_pod: *physx_PxVehicleWheelsDynData_Pod, driveSimData_pod: *physx_PxVehicleDriveSimData4W_Pod) -> void #foreign physx_lib;

phys_PxVehicleComputeSprungMasses :: (nbSprungMasses: u32, sprungMassCoordinates_pod: *physx_PxVec3_Pod, centreOfMass_pod: *physx_PxVec3_Pod, totalMass: float, gravityDirection: u32, sprungMasses: *float) -> void #foreign physx_lib;

phys_PxVehicleUpdateCMassLocalPose :: (oldCMassLocalPose_pod: *physx_PxTransform_Pod, newCMassLocalPose_pod: *physx_PxTransform_Pod, gravityDirection: u32, vehicle_pod: *physx_PxVehicleWheels_Pod) -> void #foreign physx_lib;

PxVehicleCopyDynamicsMap_new :: () -> physx_PxVehicleCopyDynamicsMap_Pod #foreign physx_lib;

phys_PxVehicleCopyDynamicsData :: (wheelMap_pod: *physx_PxVehicleCopyDynamicsMap_Pod, src_pod: *physx_PxVehicleWheels_Pod, trg_pod: *physx_PxVehicleWheels_Pod) -> void #foreign physx_lib;

PxVehicleGraphChannelDesc_new :: () -> physx_PxVehicleGraphChannelDesc_Pod #foreign physx_lib;

PxVehicleGraph_setup_mut :: (self__pod: *physx_PxVehicleGraph_Pod, desc_pod: *physx_PxVehicleGraphDesc_Pod, graphType_pod: u32) -> void #foreign physx_lib;

PxVehicleGraph_clearRecordedChannelData_mut :: (self__pod: *physx_PxVehicleGraph_Pod) -> void #foreign physx_lib;

PxVehicleGraph_getBackgroundColor :: (self__pod: *physx_PxVehicleGraph_Pod) -> *physx_PxVec3_Pod #foreign physx_lib;

PxVehicleGraph_getBackgroundAlpha :: (self__pod: *physx_PxVehicleGraph_Pod) -> float #foreign physx_lib;

PxVehicleGraph_getBackgroundCoords :: (self__pod: *physx_PxVehicleGraph_Pod, xMin_pod: *float, yMin_pod: *float, xMax_pod: *float, yMax_pod: *float) -> void #foreign physx_lib;

PxVehicleGraph_computeGraphChannel :: (self__pod: *physx_PxVehicleGraph_Pod, channel: u32, xy: *float, colors_pod: *physx_PxVec3_Pod, title: *u8) -> void #foreign physx_lib;

PxVehicleGraph_getLatestValue :: (self__pod: *physx_PxVehicleGraph_Pod, channel: u32) -> float #foreign physx_lib;

PxVehicleTelemetryData_allocate_mut :: (nbWheels: u32) -> *physx_PxVehicleTelemetryData_Pod #foreign physx_lib;

PxVehicleTelemetryData_free_mut :: (self__pod: *physx_PxVehicleTelemetryData_Pod) -> void #foreign physx_lib;

PxVehicleTelemetryData_setup_mut :: (self__pod: *physx_PxVehicleTelemetryData_Pod, graphSizeX: float, graphSizeY: float, engineGraphPosX: float, engineGraphPosY: float, wheelGraphPosX: *float, wheelGraphPosY: *float, backGroundColor_pod: *physx_PxVec3_Pod, lineColorHigh_pod: *physx_PxVec3_Pod, lineColorLow_pod: *physx_PxVec3_Pod) -> void #foreign physx_lib;

PxVehicleTelemetryData_clear_mut :: (self__pod: *physx_PxVehicleTelemetryData_Pod) -> void #foreign physx_lib;

PxVehicleTelemetryData_getEngineGraph :: (self__pod: *physx_PxVehicleTelemetryData_Pod) -> *physx_PxVehicleGraph_Pod #foreign physx_lib;

PxVehicleTelemetryData_getNbWheelGraphs :: (self__pod: *physx_PxVehicleTelemetryData_Pod) -> u32 #foreign physx_lib;

PxVehicleTelemetryData_getWheelGraph :: (self__pod: *physx_PxVehicleTelemetryData_Pod, k: u32) -> *physx_PxVehicleGraph_Pod #foreign physx_lib;

PxVehicleTelemetryData_getTireforceAppPoints :: (self__pod: *physx_PxVehicleTelemetryData_Pod) -> *physx_PxVec3_Pod #foreign physx_lib;

PxVehicleTelemetryData_getSuspforceAppPoints :: (self__pod: *physx_PxVehicleTelemetryData_Pod) -> *physx_PxVec3_Pod #foreign physx_lib;

PxVehicleNoDrive_allocate_mut :: (nbWheels: u32) -> *physx_PxVehicleNoDrive_Pod #foreign physx_lib;

PxVehicleNoDrive_free_mut :: (self__pod: *physx_PxVehicleNoDrive_Pod) -> void #foreign physx_lib;

PxVehicleNoDrive_setup_mut :: (self__pod: *physx_PxVehicleNoDrive_Pod, physics_pod: *physx_PxPhysics_Pod, vehActor_pod: *physx_PxRigidDynamic_Pod, wheelsData_pod: *physx_PxVehicleWheelsSimData_Pod) -> void #foreign physx_lib;

PxVehicleNoDrive_create_mut :: (physics_pod: *physx_PxPhysics_Pod, vehActor_pod: *physx_PxRigidDynamic_Pod, wheelsData_pod: *physx_PxVehicleWheelsSimData_Pod) -> *physx_PxVehicleNoDrive_Pod #foreign physx_lib;

PxVehicleNoDrive_setToRestState_mut :: (self__pod: *physx_PxVehicleNoDrive_Pod) -> void #foreign physx_lib;

PxVehicleNoDrive_setBrakeTorque_mut :: (self__pod: *physx_PxVehicleNoDrive_Pod, id: u32, brakeTorque: float) -> void #foreign physx_lib;

PxVehicleNoDrive_setDriveTorque_mut :: (self__pod: *physx_PxVehicleNoDrive_Pod, id: u32, driveTorque: float) -> void #foreign physx_lib;

PxVehicleNoDrive_setSteerAngle_mut :: (self__pod: *physx_PxVehicleNoDrive_Pod, id: u32, steerAngle: float) -> void #foreign physx_lib;

PxVehicleNoDrive_getBrakeTorque :: (self__pod: *physx_PxVehicleNoDrive_Pod, id: u32) -> float #foreign physx_lib;

PxVehicleNoDrive_getDriveTorque :: (self__pod: *physx_PxVehicleNoDrive_Pod, id: u32) -> float #foreign physx_lib;

PxVehicleNoDrive_getSteerAngle :: (self__pod: *physx_PxVehicleNoDrive_Pod, id: u32) -> float #foreign physx_lib;

PxVehicleNoDrive_new_alloc :: (baseFlags_pod: physx_PxBaseFlags_Pod) -> *physx_PxVehicleNoDrive_Pod #foreign physx_lib;

PxVehicleNoDrive_exportExtraData_mut :: (self__pod: *physx_PxVehicleNoDrive_Pod, anonymous_arg0_pod: *physx_PxSerializationContext_Pod) -> void #foreign physx_lib;

PxVehicleNoDrive_importExtraData_mut :: (self__pod: *physx_PxVehicleNoDrive_Pod, anonymous_arg0_pod: *physx_PxDeserializationContext_Pod) -> void #foreign physx_lib;

PxVehicleNoDrive_createObject_mut :: (address_pod: **u8, context_pod: *physx_PxDeserializationContext_Pod) -> *physx_PxVehicleNoDrive_Pod #foreign physx_lib;

PxVehicleNoDrive_getBinaryMetaData_mut :: (stream_pod: *physx_PxOutputStream_Pod) -> void #foreign physx_lib;

PxVehicleNoDrive_getConcreteTypeName :: (self__pod: *physx_PxVehicleNoDrive_Pod) -> *u8 #foreign physx_lib;

PxVehicleNoDrive_isKindOf :: (self__pod: *physx_PxVehicleNoDrive_Pod, name: *u8) -> bool #foreign physx_lib;

PxVehicleNoDrive_getNbSteerAngle :: (self__pod: *physx_PxVehicleNoDrive_Pod) -> u32 #foreign physx_lib;

PxVehicleNoDrive_getNbDriveTorque :: (self__pod: *physx_PxVehicleNoDrive_Pod) -> u32 #foreign physx_lib;

PxVehicleNoDrive_getNbBrakeTorque :: (self__pod: *physx_PxVehicleNoDrive_Pod) -> u32 #foreign physx_lib;

PxProfilerCallback_zoneStart_mut :: (self__pod: *physx_PxProfilerCallback_Pod, eventName: *u8, detached: bool, contextId: u64) -> *void #foreign physx_lib;

PxProfilerCallback_zoneEnd_mut :: (self__pod: *physx_PxProfilerCallback_Pod, profilerData: *void, eventName: *u8, detached: bool, contextId: u64) -> void #foreign physx_lib;

PxProfileScoped_new_alloc :: (callback_pod: *physx_PxProfilerCallback_Pod, eventName: *u8, detached: bool, contextId: u64) -> *physx_PxProfileScoped_Pod #foreign physx_lib;

PxProfileScoped_delete :: (self__pod: *physx_PxProfileScoped_Pod) -> void #foreign physx_lib;

PxPvd_connect_mut :: (self__pod: *physx_PxPvd_Pod, transport_pod: *physx_PxPvdTransport_Pod, flags_pod: physx_PxPvdInstrumentationFlags_Pod) -> bool #foreign physx_lib;

PxPvd_disconnect_mut :: (self__pod: *physx_PxPvd_Pod) -> void #foreign physx_lib;

PxPvd_isConnected_mut :: (self__pod: *physx_PxPvd_Pod, useCachedStatus: bool) -> bool #foreign physx_lib;

PxPvd_getTransport_mut :: (self__pod: *physx_PxPvd_Pod) -> *physx_PxPvdTransport_Pod #foreign physx_lib;

PxPvd_getInstrumentationFlags_mut :: (self__pod: *physx_PxPvd_Pod) -> physx_PxPvdInstrumentationFlags_Pod #foreign physx_lib;

PxPvd_release_mut :: (self__pod: *physx_PxPvd_Pod) -> void #foreign physx_lib;

phys_PxCreatePvd :: (foundation_pod: *physx_PxFoundation_Pod) -> *physx_PxPvd_Pod #foreign physx_lib;

PxPvdTransport_connect_mut :: (self__pod: *physx_PxPvdTransport_Pod) -> bool #foreign physx_lib;

PxPvdTransport_disconnect_mut :: (self__pod: *physx_PxPvdTransport_Pod) -> void #foreign physx_lib;

PxPvdTransport_isConnected_mut :: (self__pod: *physx_PxPvdTransport_Pod) -> bool #foreign physx_lib;

PxPvdTransport_write_mut :: (self__pod: *physx_PxPvdTransport_Pod, inBytes: *u8, inLength: u32) -> bool #foreign physx_lib;

PxPvdTransport_lock_mut :: (self__pod: *physx_PxPvdTransport_Pod) -> *physx_PxPvdTransport_Pod #foreign physx_lib;

PxPvdTransport_unlock_mut :: (self__pod: *physx_PxPvdTransport_Pod) -> void #foreign physx_lib;

PxPvdTransport_flush_mut :: (self__pod: *physx_PxPvdTransport_Pod) -> void #foreign physx_lib;

PxPvdTransport_getWrittenDataSize_mut :: (self__pod: *physx_PxPvdTransport_Pod) -> u64 #foreign physx_lib;

PxPvdTransport_release_mut :: (self__pod: *physx_PxPvdTransport_Pod) -> void #foreign physx_lib;

phys_PxDefaultPvdSocketTransportCreate :: (host: *u8, port: s32, timeoutInMilliseconds: u32) -> *physx_PxPvdTransport_Pod #foreign physx_lib;

phys_PxDefaultPvdFileTransportCreate :: (name: *u8) -> *physx_PxPvdTransport_Pod #foreign physx_lib;

FilterShaderCallbackInfo :: struct {
    attributes0:       physx.PxFilterObjectAttributes;
    attributes1:       physx.PxFilterObjectAttributes;
    filterData0:       physx.PxFilterData;
    filterData1:       physx.PxFilterData;
    pairFlags:         *physx.PxPairFlags;
    constantBlock:     *void;
    constantBlockSize: physx.PxU32;
}
#run {
    instance: FilterShaderCallbackInfo;
    assert(((cast(*void)(*instance.attributes0)) - cast(*void)(*instance)) == 0, "FilterShaderCallbackInfo.attributes0 has unexpected offset % instead of 0", ((cast(*void)(*instance.attributes0)) - cast(*void)(*instance)));
    assert(size_of(type_of(FilterShaderCallbackInfo.attributes0)) == 4, "FilterShaderCallbackInfo.attributes0 has unexpected size % instead of 4", size_of(type_of(FilterShaderCallbackInfo.attributes0)));
    assert(((cast(*void)(*instance.attributes1)) - cast(*void)(*instance)) == 4, "FilterShaderCallbackInfo.attributes1 has unexpected offset % instead of 4", ((cast(*void)(*instance.attributes1)) - cast(*void)(*instance)));
    assert(size_of(type_of(FilterShaderCallbackInfo.attributes1)) == 4, "FilterShaderCallbackInfo.attributes1 has unexpected size % instead of 4", size_of(type_of(FilterShaderCallbackInfo.attributes1)));
    assert(((cast(*void)(*instance.filterData0)) - cast(*void)(*instance)) == 8, "FilterShaderCallbackInfo.filterData0 has unexpected offset % instead of 8", ((cast(*void)(*instance.filterData0)) - cast(*void)(*instance)));
    assert(size_of(type_of(FilterShaderCallbackInfo.filterData0)) == 16, "FilterShaderCallbackInfo.filterData0 has unexpected size % instead of 16", size_of(type_of(FilterShaderCallbackInfo.filterData0)));
    assert(((cast(*void)(*instance.filterData1)) - cast(*void)(*instance)) == 24, "FilterShaderCallbackInfo.filterData1 has unexpected offset % instead of 24", ((cast(*void)(*instance.filterData1)) - cast(*void)(*instance)));
    assert(size_of(type_of(FilterShaderCallbackInfo.filterData1)) == 16, "FilterShaderCallbackInfo.filterData1 has unexpected size % instead of 16", size_of(type_of(FilterShaderCallbackInfo.filterData1)));
    assert(((cast(*void)(*instance.pairFlags)) - cast(*void)(*instance)) == 40, "FilterShaderCallbackInfo.pairFlags has unexpected offset % instead of 40", ((cast(*void)(*instance.pairFlags)) - cast(*void)(*instance)));
    assert(size_of(type_of(FilterShaderCallbackInfo.pairFlags)) == 8, "FilterShaderCallbackInfo.pairFlags has unexpected size % instead of 8", size_of(type_of(FilterShaderCallbackInfo.pairFlags)));
    assert(((cast(*void)(*instance.constantBlock)) - cast(*void)(*instance)) == 48, "FilterShaderCallbackInfo.constantBlock has unexpected offset % instead of 48", ((cast(*void)(*instance.constantBlock)) - cast(*void)(*instance)));
    assert(size_of(type_of(FilterShaderCallbackInfo.constantBlock)) == 8, "FilterShaderCallbackInfo.constantBlock has unexpected size % instead of 8", size_of(type_of(FilterShaderCallbackInfo.constantBlock)));
    assert(((cast(*void)(*instance.constantBlockSize)) - cast(*void)(*instance)) == 56, "FilterShaderCallbackInfo.constantBlockSize has unexpected offset % instead of 56", ((cast(*void)(*instance.constantBlockSize)) - cast(*void)(*instance)));
    assert(size_of(type_of(FilterShaderCallbackInfo.constantBlockSize)) == 4, "FilterShaderCallbackInfo.constantBlockSize has unexpected size % instead of 4", size_of(type_of(FilterShaderCallbackInfo.constantBlockSize)));
    assert(size_of(FilterShaderCallbackInfo) == 64, "FilterShaderCallbackInfo has size % instead of 64", size_of(FilterShaderCallbackInfo));
}

CollisionCallback :: #type (unknown0: *void, unknown1: *physx.PxContactPairHeader, unknown2: *physx.PxContactPair, unknown3: physx.PxU32) -> void #c_call;
SimulationShaderFilter :: #type (unknown0: *FilterShaderCallbackInfo) -> physx.PxU16 #c_call;

FilterCallbackData :: struct {
    filter:                           SimulationShaderFilter;
    call_default_filter_shader_first: bool;
}
#run {
    instance: FilterCallbackData;
    assert(((cast(*void)(*instance.filter)) - cast(*void)(*instance)) == 0, "FilterCallbackData.filter has unexpected offset % instead of 0", ((cast(*void)(*instance.filter)) - cast(*void)(*instance)));
    assert(size_of(type_of(FilterCallbackData.filter)) == 8, "FilterCallbackData.filter has unexpected size % instead of 8", size_of(type_of(FilterCallbackData.filter)));
    assert(((cast(*void)(*instance.call_default_filter_shader_first)) - cast(*void)(*instance)) == 8, "FilterCallbackData.call_default_filter_shader_first has unexpected offset % instead of 8", ((cast(*void)(*instance.call_default_filter_shader_first)) - cast(*void)(*instance)));
    assert(size_of(type_of(FilterCallbackData.call_default_filter_shader_first)) == 1, "FilterCallbackData.call_default_filter_shader_first has unexpected size % instead of 1", size_of(type_of(FilterCallbackData.call_default_filter_shader_first)));
    assert(size_of(FilterCallbackData) == 16, "FilterCallbackData has size % instead of 16", size_of(FilterCallbackData));
}

FilterShaderTrampoline :: (attributes0: physx.PxFilterObjectAttributes, filterData0: physx.PxFilterData, attributes1: physx.PxFilterObjectAttributes, filterData1: physx.PxFilterData, pairFlags: *physx.PxPairFlags, constantBlock: *void, constantBlockSize: physx.PxU32) -> physx.PxFilterFlags #foreign physx_lib "?FilterShaderTrampoline@@YA?AV?$PxFlags@W4Enum@PxFilterFlag@physx@@G@physx@@IUPxFilterData@2@I0AEAV?$PxFlags@W4Enum@PxPairFlag@physx@@G@2@PEBXI@Z";

TriggerCallback :: #type (unknown0: *void, unknown1: *physx.PxTriggerPair, unknown2: physx.PxU32) -> void #c_call;
ConstraintBreakCallback :: #type (unknown0: *void, unknown1: *physx.PxConstraintInfo, unknown2: physx.PxU32) -> void #c_call;
WakeSleepCallback :: #type (unknown0: *void, unknown1: **physx.PxActor, unknown2: physx.PxU32, unknown3: bool) -> void #c_call;
AdvanceCallback :: #type (unknown0: *void, unknown1: **physx.PxRigidBody, unknown2: *physx.PxTransform, unknown3: physx.PxU32) -> void #c_call;

SimulationEventCallbackInfo :: struct {
    // Callback for collision events.
    collisionCallback:       CollisionCallback = null;
    collisionUserData:       *void = null;

    // Callback for trigger shape events (an object entered or left a trigger shape).
    triggerCallback:         TriggerCallback = null;
    triggerUserData:         *void = null;

    // Callback for when a constraint breaks (such as a joint with a force limit)
    constraintBreakCallback: ConstraintBreakCallback = null;
    constraintBreakUserData: *void = null;

    // Callback for when an object falls asleep or is awoken.
    wakeSleepCallback:       WakeSleepCallback = null;
    wakeSleepUserData:       *void = null;

    // Callback to get the next pose early for objects (if flagged with eENABLE_POSE_INTEGRATION_PREVIEW).
    advanceCallback:         AdvanceCallback = null;
    advanceUserData:         *void = null;
}
#run {
    instance: SimulationEventCallbackInfo;
    assert(((cast(*void)(*instance.collisionCallback)) - cast(*void)(*instance)) == 0, "SimulationEventCallbackInfo.collisionCallback has unexpected offset % instead of 0", ((cast(*void)(*instance.collisionCallback)) - cast(*void)(*instance)));
    assert(size_of(type_of(SimulationEventCallbackInfo.collisionCallback)) == 8, "SimulationEventCallbackInfo.collisionCallback has unexpected size % instead of 8", size_of(type_of(SimulationEventCallbackInfo.collisionCallback)));
    assert(((cast(*void)(*instance.collisionUserData)) - cast(*void)(*instance)) == 8, "SimulationEventCallbackInfo.collisionUserData has unexpected offset % instead of 8", ((cast(*void)(*instance.collisionUserData)) - cast(*void)(*instance)));
    assert(size_of(type_of(SimulationEventCallbackInfo.collisionUserData)) == 8, "SimulationEventCallbackInfo.collisionUserData has unexpected size % instead of 8", size_of(type_of(SimulationEventCallbackInfo.collisionUserData)));
    assert(((cast(*void)(*instance.triggerCallback)) - cast(*void)(*instance)) == 16, "SimulationEventCallbackInfo.triggerCallback has unexpected offset % instead of 16", ((cast(*void)(*instance.triggerCallback)) - cast(*void)(*instance)));
    assert(size_of(type_of(SimulationEventCallbackInfo.triggerCallback)) == 8, "SimulationEventCallbackInfo.triggerCallback has unexpected size % instead of 8", size_of(type_of(SimulationEventCallbackInfo.triggerCallback)));
    assert(((cast(*void)(*instance.triggerUserData)) - cast(*void)(*instance)) == 24, "SimulationEventCallbackInfo.triggerUserData has unexpected offset % instead of 24", ((cast(*void)(*instance.triggerUserData)) - cast(*void)(*instance)));
    assert(size_of(type_of(SimulationEventCallbackInfo.triggerUserData)) == 8, "SimulationEventCallbackInfo.triggerUserData has unexpected size % instead of 8", size_of(type_of(SimulationEventCallbackInfo.triggerUserData)));
    assert(((cast(*void)(*instance.constraintBreakCallback)) - cast(*void)(*instance)) == 32, "SimulationEventCallbackInfo.constraintBreakCallback has unexpected offset % instead of 32", ((cast(*void)(*instance.constraintBreakCallback)) - cast(*void)(*instance)));
    assert(size_of(type_of(SimulationEventCallbackInfo.constraintBreakCallback)) == 8, "SimulationEventCallbackInfo.constraintBreakCallback has unexpected size % instead of 8", size_of(type_of(SimulationEventCallbackInfo.constraintBreakCallback)));
    assert(((cast(*void)(*instance.constraintBreakUserData)) - cast(*void)(*instance)) == 40, "SimulationEventCallbackInfo.constraintBreakUserData has unexpected offset % instead of 40", ((cast(*void)(*instance.constraintBreakUserData)) - cast(*void)(*instance)));
    assert(size_of(type_of(SimulationEventCallbackInfo.constraintBreakUserData)) == 8, "SimulationEventCallbackInfo.constraintBreakUserData has unexpected size % instead of 8", size_of(type_of(SimulationEventCallbackInfo.constraintBreakUserData)));
    assert(((cast(*void)(*instance.wakeSleepCallback)) - cast(*void)(*instance)) == 48, "SimulationEventCallbackInfo.wakeSleepCallback has unexpected offset % instead of 48", ((cast(*void)(*instance.wakeSleepCallback)) - cast(*void)(*instance)));
    assert(size_of(type_of(SimulationEventCallbackInfo.wakeSleepCallback)) == 8, "SimulationEventCallbackInfo.wakeSleepCallback has unexpected size % instead of 8", size_of(type_of(SimulationEventCallbackInfo.wakeSleepCallback)));
    assert(((cast(*void)(*instance.wakeSleepUserData)) - cast(*void)(*instance)) == 56, "SimulationEventCallbackInfo.wakeSleepUserData has unexpected offset % instead of 56", ((cast(*void)(*instance.wakeSleepUserData)) - cast(*void)(*instance)));
    assert(size_of(type_of(SimulationEventCallbackInfo.wakeSleepUserData)) == 8, "SimulationEventCallbackInfo.wakeSleepUserData has unexpected size % instead of 8", size_of(type_of(SimulationEventCallbackInfo.wakeSleepUserData)));
    assert(((cast(*void)(*instance.advanceCallback)) - cast(*void)(*instance)) == 64, "SimulationEventCallbackInfo.advanceCallback has unexpected offset % instead of 64", ((cast(*void)(*instance.advanceCallback)) - cast(*void)(*instance)));
    assert(size_of(type_of(SimulationEventCallbackInfo.advanceCallback)) == 8, "SimulationEventCallbackInfo.advanceCallback has unexpected size % instead of 8", size_of(type_of(SimulationEventCallbackInfo.advanceCallback)));
    assert(((cast(*void)(*instance.advanceUserData)) - cast(*void)(*instance)) == 72, "SimulationEventCallbackInfo.advanceUserData has unexpected offset % instead of 72", ((cast(*void)(*instance.advanceUserData)) - cast(*void)(*instance)));
    assert(size_of(type_of(SimulationEventCallbackInfo.advanceUserData)) == 8, "SimulationEventCallbackInfo.advanceUserData has unexpected size % instead of 8", size_of(type_of(SimulationEventCallbackInfo.advanceUserData)));
    assert(size_of(SimulationEventCallbackInfo) == 80, "SimulationEventCallbackInfo has size % instead of 80", size_of(SimulationEventCallbackInfo));
}

SimulationEventTrampoline :: struct {
    #as using pxsimulationeventcallback: physx.PxSimulationEventCallback;

    Constructor :: (this: *SimulationEventTrampoline, callbacks: *SimulationEventCallbackInfo) -> void #cpp_method #foreign physx_lib "??0SimulationEventTrampoline@@QEAA@PEBUSimulationEventCallbackInfo@@@Z";

    mCallbacks: SimulationEventCallbackInfo;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
    // or need to create a vtable yourself.

    // Collisions
    virtual_onContact :: (this: *SimulationEventTrampoline, pairHeader: *physx.PxContactPairHeader, pairs: *physx.PxContactPair, nbPairs: physx.PxU32) -> void #cpp_method #foreign physx_lib "?onContact@SimulationEventTrampoline@@UEAAXAEBUPxContactPairHeader@physx@@PEBUPxContactPair@3@I@Z";

    // Triggers
    virtual_onTrigger :: (this: *SimulationEventTrampoline, pairs: *physx.PxTriggerPair, count: physx.PxU32) -> void #cpp_method #foreign physx_lib "?onTrigger@SimulationEventTrampoline@@UEAAXPEAUPxTriggerPair@physx@@I@Z";

    // Constraint breaks
    virtual_onConstraintBreak :: (this: *SimulationEventTrampoline, constraints: *physx.PxConstraintInfo, count: physx.PxU32) -> void #cpp_method #foreign physx_lib "?onConstraintBreak@SimulationEventTrampoline@@UEAAXPEAUPxConstraintInfo@physx@@I@Z";

    // Wake/Sleep (combined for convenience)
    virtual_onWake :: (this: *SimulationEventTrampoline, actors: **physx.PxActor, count: physx.PxU32) -> void #cpp_method #foreign physx_lib "?onWake@SimulationEventTrampoline@@UEAAXPEAPEAVPxActor@physx@@I@Z";

    virtual_onSleep :: (this: *SimulationEventTrampoline, actors: **physx.PxActor, count: physx.PxU32) -> void #cpp_method #foreign physx_lib "?onSleep@SimulationEventTrampoline@@UEAAXPEAPEAVPxActor@physx@@I@Z";

    // Advance
    virtual_onAdvance :: (this: *SimulationEventTrampoline, bodyBuffer: **physx.PxRigidBody, poseBuffer: *physx.PxTransform, count: physx.PxU32) -> void #cpp_method #foreign physx_lib "?onAdvance@SimulationEventTrampoline@@UEAAXPEBQEBVPxRigidBody@physx@@PEBVPxTransform@3@I@Z";
}
#run {
    assert(size_of(type_of(SimulationEventTrampoline.pxsimulationeventcallback)) == 8, "SimulationEventTrampoline.pxsimulationeventcallback has unexpected size % instead of 8", size_of(type_of(SimulationEventTrampoline.pxsimulationeventcallback)));
    instance: SimulationEventTrampoline;
    assert(((cast(*void)(*instance.mCallbacks)) - cast(*void)(*instance)) == 8, "SimulationEventTrampoline.mCallbacks has unexpected offset % instead of 8", ((cast(*void)(*instance.mCallbacks)) - cast(*void)(*instance)));
    assert(size_of(type_of(SimulationEventTrampoline.mCallbacks)) == 80, "SimulationEventTrampoline.mCallbacks has unexpected size % instead of 80", size_of(type_of(SimulationEventTrampoline.mCallbacks)));
    assert(size_of(SimulationEventTrampoline) == 88, "SimulationEventTrampoline has size % instead of 88", size_of(SimulationEventTrampoline));
}

RaycastFilterCallback :: struct {
    #as using pxqueryfiltercallback: physx.PxQueryFilterCallback;

    Constructor :: (this: *RaycastFilterCallback, actor: *physx.PxRigidActor) -> void #cpp_method #foreign physx_lib "??0RaycastFilterCallback@@QEAA@PEAVPxRigidActor@physx@@@Z";

    mActor: *physx.PxRigidActor;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
    // or need to create a vtable yourself.

    virtual_preFilter :: (this: *RaycastFilterCallback, unknown0: *physx.PxFilterData, shape: *physx.PxShape, actor: *physx.PxRigidActor, unknown1: *physx.PxHitFlags) -> physx.PxQueryHitType.Enum #cpp_method #foreign physx_lib "?preFilter@RaycastFilterCallback@@UEAA?AW4Enum@PxQueryHitType@physx@@AEBUPxFilterData@4@PEBVPxShape@4@PEBVPxRigidActor@4@AEAV?$PxFlags@W4Enum@PxHitFlag@physx@@G@4@@Z";

    virtual_postFilter :: (this: *RaycastFilterCallback, unknown0: *physx.PxFilterData, unknown1: *physx.PxQueryHit) -> physx.PxQueryHitType.Enum #cpp_method #foreign physx_lib "?postFilter@RaycastFilterCallback@@UEAA?AW4Enum@PxQueryHitType@physx@@AEBUPxFilterData@4@AEBUPxQueryHit@4@@Z";
}
#run {
    assert(size_of(type_of(RaycastFilterCallback.pxqueryfiltercallback)) == 8, "RaycastFilterCallback.pxqueryfiltercallback has unexpected size % instead of 8", size_of(type_of(RaycastFilterCallback.pxqueryfiltercallback)));
    instance: RaycastFilterCallback;
    assert(((cast(*void)(*instance.mActor)) - cast(*void)(*instance)) == 8, "RaycastFilterCallback.mActor has unexpected offset % instead of 8", ((cast(*void)(*instance.mActor)) - cast(*void)(*instance)));
    assert(size_of(type_of(RaycastFilterCallback.mActor)) == 8, "RaycastFilterCallback.mActor has unexpected size % instead of 8", size_of(type_of(RaycastFilterCallback.mActor)));
    assert(size_of(RaycastFilterCallback) == 16, "RaycastFilterCallback has size % instead of 16", size_of(RaycastFilterCallback));
}

RaycastHitCallback :: #type (actor: *physx.PxRigidActor, filterData: *physx.PxFilterData, shape: *physx.PxShape, hitFlags: u32, userData: *void) -> u32 #c_call;

RaycastFilterTrampoline :: struct {
    #as using pxqueryfiltercallback: physx.PxQueryFilterCallback;

    Constructor :: (this: *RaycastFilterTrampoline, callback: RaycastHitCallback, userdata: *void) -> void #cpp_method #foreign physx_lib "??0RaycastFilterTrampoline@@QEAA@P6AIPEBVPxRigidActor@physx@@PEBUPxFilterData@2@PEBVPxShape@2@IPEBX@Z3@Z";

    mCallback: RaycastHitCallback;
    mUserData: *void;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
    // or need to create a vtable yourself.

    virtual_preFilter :: (this: *RaycastFilterTrampoline, filterData: *physx.PxFilterData, shape: *physx.PxShape, actor: *physx.PxRigidActor, hitFlags: *physx.PxHitFlags) -> physx.PxQueryHitType.Enum #cpp_method #foreign physx_lib "?preFilter@RaycastFilterTrampoline@@UEAA?AW4Enum@PxQueryHitType@physx@@AEBUPxFilterData@4@PEBVPxShape@4@PEBVPxRigidActor@4@AEAV?$PxFlags@W4Enum@PxHitFlag@physx@@G@4@@Z";

    virtual_postFilter :: (this: *RaycastFilterTrampoline, unknown0: *physx.PxFilterData, unknown1: *physx.PxQueryHit) -> physx.PxQueryHitType.Enum #cpp_method #foreign physx_lib "?postFilter@RaycastFilterTrampoline@@UEAA?AW4Enum@PxQueryHitType@physx@@AEBUPxFilterData@4@AEBUPxQueryHit@4@@Z";
}
#run {
    assert(size_of(type_of(RaycastFilterTrampoline.pxqueryfiltercallback)) == 8, "RaycastFilterTrampoline.pxqueryfiltercallback has unexpected size % instead of 8", size_of(type_of(RaycastFilterTrampoline.pxqueryfiltercallback)));
    instance: RaycastFilterTrampoline;
    assert(((cast(*void)(*instance.mCallback)) - cast(*void)(*instance)) == 8, "RaycastFilterTrampoline.mCallback has unexpected offset % instead of 8", ((cast(*void)(*instance.mCallback)) - cast(*void)(*instance)));
    assert(size_of(type_of(RaycastFilterTrampoline.mCallback)) == 8, "RaycastFilterTrampoline.mCallback has unexpected size % instead of 8", size_of(type_of(RaycastFilterTrampoline.mCallback)));
    assert(((cast(*void)(*instance.mUserData)) - cast(*void)(*instance)) == 16, "RaycastFilterTrampoline.mUserData has unexpected offset % instead of 16", ((cast(*void)(*instance.mUserData)) - cast(*void)(*instance)));
    assert(size_of(type_of(RaycastFilterTrampoline.mUserData)) == 8, "RaycastFilterTrampoline.mUserData has unexpected size % instead of 8", size_of(type_of(RaycastFilterTrampoline.mUserData)));
    assert(size_of(RaycastFilterTrampoline) == 24, "RaycastFilterTrampoline has size % instead of 24", size_of(RaycastFilterTrampoline));
}

AllocCallback :: #type (size: u64, typeName: *u8, filename: *u8, line: s32, userdata: *void) -> *void #c_call;
DeallocCallback :: #type (ptr: *void, userdata: *void) -> void #c_call;

CustomAllocatorTrampoline :: struct {
    #as using pxallocatorcallback: physx.PxAllocatorCallback;

    Constructor :: (this: *CustomAllocatorTrampoline, allocCb: AllocCallback, deallocCb: DeallocCallback, userdata: *void) -> void #cpp_method #foreign physx_lib "??0CustomAllocatorTrampoline@@QEAA@P6APEAX_KPEBD1HPEAX@ZP6AX22@Z2@Z";

    mAllocCallback:   AllocCallback;
    mDeallocCallback: DeallocCallback;

    mUserData:        *void;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
    // or need to create a vtable yourself.

    virtual_allocate :: (this: *CustomAllocatorTrampoline, size: size_t, typeName: *u8, filename: *u8, line: s32) -> *void #cpp_method #foreign physx_lib "?allocate@CustomAllocatorTrampoline@@UEAAPEAX_KPEBD1H@Z";

    virtual_deallocate :: (this: *CustomAllocatorTrampoline, ptr: *void) -> void #cpp_method #foreign physx_lib "?deallocate@CustomAllocatorTrampoline@@UEAAXPEAX@Z";
}
#run {
    assert(size_of(type_of(CustomAllocatorTrampoline.pxallocatorcallback)) == 8, "CustomAllocatorTrampoline.pxallocatorcallback has unexpected size % instead of 8", size_of(type_of(CustomAllocatorTrampoline.pxallocatorcallback)));
    instance: CustomAllocatorTrampoline;
    assert(((cast(*void)(*instance.mAllocCallback)) - cast(*void)(*instance)) == 8, "CustomAllocatorTrampoline.mAllocCallback has unexpected offset % instead of 8", ((cast(*void)(*instance.mAllocCallback)) - cast(*void)(*instance)));
    assert(size_of(type_of(CustomAllocatorTrampoline.mAllocCallback)) == 8, "CustomAllocatorTrampoline.mAllocCallback has unexpected size % instead of 8", size_of(type_of(CustomAllocatorTrampoline.mAllocCallback)));
    assert(((cast(*void)(*instance.mDeallocCallback)) - cast(*void)(*instance)) == 16, "CustomAllocatorTrampoline.mDeallocCallback has unexpected offset % instead of 16", ((cast(*void)(*instance.mDeallocCallback)) - cast(*void)(*instance)));
    assert(size_of(type_of(CustomAllocatorTrampoline.mDeallocCallback)) == 8, "CustomAllocatorTrampoline.mDeallocCallback has unexpected size % instead of 8", size_of(type_of(CustomAllocatorTrampoline.mDeallocCallback)));
    assert(((cast(*void)(*instance.mUserData)) - cast(*void)(*instance)) == 24, "CustomAllocatorTrampoline.mUserData has unexpected offset % instead of 24", ((cast(*void)(*instance.mUserData)) - cast(*void)(*instance)));
    assert(size_of(type_of(CustomAllocatorTrampoline.mUserData)) == 8, "CustomAllocatorTrampoline.mUserData has unexpected size % instead of 8", size_of(type_of(CustomAllocatorTrampoline.mUserData)));
    assert(size_of(CustomAllocatorTrampoline) == 32, "CustomAllocatorTrampoline has size % instead of 32", size_of(CustomAllocatorTrampoline));
}

ZoneStartCallback :: #type (typeName: *u8, detached: bool, _context: u64, userdata: *void) -> *void #c_call;
ZoneEndCallback :: #type (profilerData: *void, typeName: *u8, detached: bool, _context: u64, userdata: *void) -> void #c_call;

CustomProfilerTrampoline :: struct {
    #as using pxprofilercallback: physx.PxProfilerCallback;

    Constructor :: (this: *CustomProfilerTrampoline, startCb: ZoneStartCallback, endCb: ZoneEndCallback, userdata: *void) -> void #cpp_method #foreign physx_lib "??0CustomProfilerTrampoline@@QEAA@P6APEAXPEBD_N_KPEAX@ZP6AX30123@Z3@Z";

    mStartCallback: ZoneStartCallback;
    mEndCallback:   ZoneEndCallback;

    mUserData:      *void;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
    // or need to create a vtable yourself.

    virtual_zoneStart :: (this: *CustomProfilerTrampoline, eventName: *u8, detached: bool, contextId: u64) -> *void #cpp_method #foreign physx_lib "?zoneStart@CustomProfilerTrampoline@@UEAAPEAXPEBD_N_K@Z";

    virtual_zoneEnd :: (this: *CustomProfilerTrampoline, profilerData: *void, eventName: *u8, detached: bool, contextId: u64) -> void #cpp_method #foreign physx_lib "?zoneEnd@CustomProfilerTrampoline@@UEAAXPEAXPEBD_N_K@Z";
}
#run {
    assert(size_of(type_of(CustomProfilerTrampoline.pxprofilercallback)) == 8, "CustomProfilerTrampoline.pxprofilercallback has unexpected size % instead of 8", size_of(type_of(CustomProfilerTrampoline.pxprofilercallback)));
    instance: CustomProfilerTrampoline;
    assert(((cast(*void)(*instance.mStartCallback)) - cast(*void)(*instance)) == 8, "CustomProfilerTrampoline.mStartCallback has unexpected offset % instead of 8", ((cast(*void)(*instance.mStartCallback)) - cast(*void)(*instance)));
    assert(size_of(type_of(CustomProfilerTrampoline.mStartCallback)) == 8, "CustomProfilerTrampoline.mStartCallback has unexpected size % instead of 8", size_of(type_of(CustomProfilerTrampoline.mStartCallback)));
    assert(((cast(*void)(*instance.mEndCallback)) - cast(*void)(*instance)) == 16, "CustomProfilerTrampoline.mEndCallback has unexpected offset % instead of 16", ((cast(*void)(*instance.mEndCallback)) - cast(*void)(*instance)));
    assert(size_of(type_of(CustomProfilerTrampoline.mEndCallback)) == 8, "CustomProfilerTrampoline.mEndCallback has unexpected size % instead of 8", size_of(type_of(CustomProfilerTrampoline.mEndCallback)));
    assert(((cast(*void)(*instance.mUserData)) - cast(*void)(*instance)) == 24, "CustomProfilerTrampoline.mUserData has unexpected offset % instead of 24", ((cast(*void)(*instance.mUserData)) - cast(*void)(*instance)));
    assert(size_of(type_of(CustomProfilerTrampoline.mUserData)) == 8, "CustomProfilerTrampoline.mUserData has unexpected size % instead of 8", size_of(type_of(CustomProfilerTrampoline.mUserData)));
    assert(size_of(CustomProfilerTrampoline) == 32, "CustomProfilerTrampoline has size % instead of 32", size_of(CustomProfilerTrampoline));
}

ErrorCallback :: #type (code: s32, message: *u8, file: *u8, line: s32, userdata: *void) -> void #c_call;

ErrorTrampoline :: struct {
    #as using pxerrorcallback: physx.PxErrorCallback;

    Constructor :: (this: *ErrorTrampoline, errorCb: ErrorCallback, userdata: *void) -> void #cpp_method #foreign physx_lib "??0ErrorTrampoline@@QEAA@P6AXHPEBD0HPEAX@Z1@Z";

    mErrorCallback: ErrorCallback = null;
    mUserdata:      *void = null;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
    // or need to create a vtable yourself.

    virtual_reportError :: (this: *ErrorTrampoline, code: physx.PxErrorCode.Enum, message: *u8, file: *u8, line: s32) -> void #cpp_method #foreign physx_lib "?reportError@ErrorTrampoline@@UEAAXW4Enum@PxErrorCode@physx@@PEBD1H@Z";
}
#run {
    assert(size_of(type_of(ErrorTrampoline.pxerrorcallback)) == 8, "ErrorTrampoline.pxerrorcallback has unexpected size % instead of 8", size_of(type_of(ErrorTrampoline.pxerrorcallback)));
    instance: ErrorTrampoline;
    assert(((cast(*void)(*instance.mErrorCallback)) - cast(*void)(*instance)) == 8, "ErrorTrampoline.mErrorCallback has unexpected offset % instead of 8", ((cast(*void)(*instance.mErrorCallback)) - cast(*void)(*instance)));
    assert(size_of(type_of(ErrorTrampoline.mErrorCallback)) == 8, "ErrorTrampoline.mErrorCallback has unexpected size % instead of 8", size_of(type_of(ErrorTrampoline.mErrorCallback)));
    assert(((cast(*void)(*instance.mUserdata)) - cast(*void)(*instance)) == 16, "ErrorTrampoline.mUserdata has unexpected offset % instead of 16", ((cast(*void)(*instance.mUserdata)) - cast(*void)(*instance)));
    assert(size_of(type_of(ErrorTrampoline.mUserdata)) == 8, "ErrorTrampoline.mUserdata has unexpected size % instead of 8", size_of(type_of(ErrorTrampoline.mUserdata)));
    assert(size_of(ErrorTrampoline) == 24, "ErrorTrampoline has size % instead of 24", size_of(ErrorTrampoline));
}

AssertHandler :: #type (expr: *u8, file: *u8, line: s32, should_ignore: *bool, userdata: *void) -> void #c_call;

AssertTrampoline :: struct {
    #as using pxasserthandler: physx.PxAssertHandler;

    Constructor :: (this: *AssertTrampoline, onAssert: AssertHandler, userdata: *void) -> void #cpp_method #foreign physx_lib "??0AssertTrampoline@@QEAA@P6AXPEBD0HPEA_NPEAX@Z2@Z";

    mAssertHandler: AssertHandler = null;
    mUserdata:      *void = null;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
    // or need to create a vtable yourself.

    virtual_operator_parens :: (this: *AssertTrampoline, exp: *u8, file: *u8, line: s32, ignore: *bool) -> void #cpp_method #foreign physx_lib "??RAssertTrampoline@@UEAAXPEBD0HAEA_N@Z";
    operator_parens :: (this: AssertTrampoline, exp: *u8, file: *u8, line: s32, ignore: *bool) #no_context {
        operator_parens(*this, exp, file, line, ignore);
    }
}
#run {
    assert(size_of(type_of(AssertTrampoline.pxasserthandler)) == 8, "AssertTrampoline.pxasserthandler has unexpected size % instead of 8", size_of(type_of(AssertTrampoline.pxasserthandler)));
    instance: AssertTrampoline;
    assert(((cast(*void)(*instance.mAssertHandler)) - cast(*void)(*instance)) == 8, "AssertTrampoline.mAssertHandler has unexpected offset % instead of 8", ((cast(*void)(*instance.mAssertHandler)) - cast(*void)(*instance)));
    assert(size_of(type_of(AssertTrampoline.mAssertHandler)) == 8, "AssertTrampoline.mAssertHandler has unexpected size % instead of 8", size_of(type_of(AssertTrampoline.mAssertHandler)));
    assert(((cast(*void)(*instance.mUserdata)) - cast(*void)(*instance)) == 16, "AssertTrampoline.mUserdata has unexpected offset % instead of 16", ((cast(*void)(*instance.mUserdata)) - cast(*void)(*instance)));
    assert(size_of(type_of(AssertTrampoline.mUserdata)) == 8, "AssertTrampoline.mUserdata has unexpected size % instead of 8", size_of(type_of(AssertTrampoline.mUserdata)));
    assert(size_of(AssertTrampoline) == 24, "AssertTrampoline has size % instead of 24", size_of(AssertTrampoline));
}

physx_create_foundation :: () -> *physx.PxFoundation #foreign physx_lib;

physx_create_foundation_with_alloc :: (allocator: *physx.PxAllocatorCallback) -> *physx.PxFoundation #foreign physx_lib;

// fixme[tolsson]: this might be iffy on Windows with DLLs if we have multiple packages
// linking against the raw interface
get_default_allocator :: () -> *physx.PxAllocatorCallback #foreign physx_lib;

// fixme[tolsson]: this might be iffy on Windows with DLLs if we have multiple packages
// linking against the raw interface
get_default_error_callback :: () -> *physx.PxErrorCallback #foreign physx_lib;

physx_create_physics :: (foundation: *physx.PxFoundation, pvd: *physx.PxPvd) -> *physx.PxPhysics #foreign physx_lib;

create_raycast_filter_callback :: (actor_to_ignore: *physx.PxRigidActor) -> *physx.PxQueryFilterCallback #foreign physx_lib;

create_raycast_filter_callback_func :: (callback: RaycastHitCallback, userData: *void) -> *physx.PxQueryFilterCallback #foreign physx_lib;

create_alloc_callback :: (alloc_callback: AllocCallback, dealloc_callback: DeallocCallback, userdata: *void) -> *physx.PxAllocatorCallback #foreign physx_lib;

get_alloc_callback_user_data :: (allocator: *physx.PxAllocatorCallback) -> *void #foreign physx_lib;

create_profiler_callback :: (zone_start_callback: ZoneStartCallback, zone_end_callback: ZoneEndCallback, userdata: *void) -> *physx.PxProfilerCallback #foreign physx_lib;

create_error_callback :: (error_callback: ErrorCallback, userdata: *void) -> *physx.PxErrorCallback #foreign physx_lib;

create_assert_handler :: (on_assert: AssertHandler, userdata: *void) -> *physx.PxAssertHandler #foreign physx_lib;

get_default_simulation_filter_shader :: () -> *void #foreign physx_lib;

create_simulation_event_callbacks :: (callbacks: *SimulationEventCallbackInfo) -> *physx.PxSimulationEventCallback #foreign physx_lib;

get_simulation_event_info :: (callback: *physx.PxSimulationEventCallback) -> *SimulationEventCallbackInfo #foreign physx_lib;

destroy_simulation_event_callbacks :: (callback: *physx.PxSimulationEventCallback) -> void #foreign physx_lib;

enable_custom_filter_shader :: (desc: *physx.PxSceneDesc, filter: SimulationShaderFilter, call_default_filter_shader_first: u32) -> void #foreign physx_lib;

// Not generated, used only for testing and examples!
PxAssertHandler_opCall_mut :: (self__pod: *physx_PxErrorCallback_Pod, expr: *u8, file: *u8, line: s32, ignore: *bool) -> void #foreign physx_lib;

HitAllCallback :: struct {
    #as using pxraycastcallback: physx.PxRaycastCallback;
    vtable: *HitAllCallback_VTable;

    Constructor :: (this: *HitAllCallback, aTouches: *physx.PxRaycastHit, aMaxNbTouches: physx.PxU32) -> void #cpp_method #foreign physx_lib "??0HitAllCallback@@QEAA@PEAUPxRaycastHit@physx@@I@Z";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
    // or need to create a vtable yourself.

    virtual_processTouches :: (this: *HitAllCallback, buffer: *physx.PxRaycastHit, nbHits: physx.PxU32) -> physx.PxAgain #cpp_method #foreign physx_lib "?processTouches@HitAllCallback@@UEAA_NPEBUPxRaycastHit@physx@@I@Z";
}
HitAllCallback_VTable :: struct #type_info_none {
    processTouches: (this: *HitAllCallback, buffer: *physx.PxRaycastHit, nbHits: physx.PxU32) -> physx.PxAgain #cpp_method;
}
HitAllCallback_processTouches :: inline (this: *HitAllCallback, buffer: *physx.PxRaycastHit, nbHits: physx.PxU32) -> physx.PxAgain { return this.vtable.processTouches(this, buffer, nbHits); }

vtable :: (obj: *HitAllCallback) -> *HitAllCallback_VTable { return obj.vtable; }

#run { if true return;
    assert(size_of(type_of(HitAllCallback.pxraycastcallback)) == 96, "HitAllCallback.pxraycastcallback has unexpected size % instead of 96", size_of(type_of(HitAllCallback.pxraycastcallback)));
    assert(size_of(HitAllCallback) == 96, "HitAllCallback has size % instead of 96", size_of(HitAllCallback));
}

make_raycast_callback :: (to_init: *physx.PxRaycastCallback, buffer: *physx.PxRaycastHit, count: physx.PxU32) -> void #foreign physx_lib;

make_shape_flags :: (to_init: *physx.PxShapeFlags, val: physx.PxU8) -> void #foreign physx_lib;

PxPhysics_createShape :: (phys: *physx.PxPhysics, geo: *physx.PxGeometry, materials: **physx.PxMaterial, materialCount: physx.PxU16, isExclusive: bool) -> *physx.PxShape #foreign physx_lib;

make_query_flags :: (to_init: *physx.PxQueryFlags, val: physx.PxU8) -> void #foreign physx_lib;

make_hit_flags :: (to_init: *physx.PxHitFlags, val: physx.PxU16) -> void #foreign physx_lib;

make_query_filter_data :: (to_init: *physx.PxQueryFilterData, query_flags: physx.PxU8, word0: physx.PxU32) -> void #foreign physx_lib;

make_pvd_instrumentation_flag :: (to_init: *physx.PxPvdInstrumentationFlags, val: physx.PxU8) -> void #foreign physx_lib;

PxPvd_connect :: (ths: *physx.PxPvd, transport: *physx.PxPvdTransport) -> bool #foreign physx_lib;

make_mesh_preprocess_flags :: (to_init: *physx.PxMeshPreprocessingFlags, val: physx.PxU32) -> void #foreign physx_lib;

make_geo_flags :: (to_init: *physx.PxMeshGeometryFlags, val: physx.PxU8) -> void #foreign physx_lib;

physx_dummy_main :: () -> s32 #foreign physx_lib "?physx_dummy_main@@YAHXZ";

#scope_file

#import "Basic"; // For assert
#import "Math";
#import "Windows";
physx_lib :: #library,no_dll "win/physx_lib";
